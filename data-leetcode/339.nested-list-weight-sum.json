[
    {
        "title": "Combination Sum",
        "question_content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n&nbsp;\nExample 1:\n\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\nExample 2:\n\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\nExample 3:\n\nInput: candidates = [2], target = 1\nOutput: []\n\n&nbsp;\nConstraints:\n\n\t1 <= candidates.length <= 30\n\t2 <= candidates[i] <= 40\n\tAll elements of candidates are distinct.\n\t1 <= target <= 40",
        "solutions": [
            {
                "id": 1777569,
                "title": "full-explanation-with-state-space-tree-recursion-and-backtracking-well-explained-c",
                "content": "Reading the question we understand that we need every possible unique combination such that sum of the combination is equal to target.\\n\\nFor such questions where we have to find **\"every possible\"** we generally use **backtracking**.\\n\\nLet\\'s understand how can backtracking help us achieve what we want here.\\nBelow is an example with a **state space tree** for better understanding of how backtracking will be used in the solution.\\n\\n#### Example (State Space Tree):\\n\\n![image](https://assets.leetcode.com/users/images/a7b5e2bf-f7c5-4e3a-a040-5cb619027830_1645077072.6875963.jpeg)\\n\\nAs you might have noticed that we are not considering the whole array as possible options at every level, because we want **unique combinations**.\\ne.g. at the node **[2, 2, 3]**, the *possible options* for the next level are only *[3, 5]*. Why?? because if we consider the whole array as possible options, then we we will end up with [2, 2, 3, 2] (with 2 as a possible option), which has already been checked as [2, 2, 2, 3] (see the tree). So to *make the solution unique* we are only considering the *part of the array from current last element to the end element* (like in this example).\\n\\n#### Algorithm:\\n```\\n1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can\\'t achieve the target sum again from this ever. So backtrack from here.\\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\\n\\t\\ti) Now consider all possible options into this combination, one at a time.\\n\\t\\tii) Go check if considering the current option can give us the solution.\\n\\t\\tiii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\\n\\t\\tSo firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\\n\\t\\tWhen this also backtracks remove 3 to try 5, that means [2, 2, 5].\\n\\t\\tNow as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...\\n```\\n\\n#### Code:\\n```cpp\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n***Plz upvote the post if you like the explanation.***\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can\\'t achieve the target sum again from this ever. So backtrack from here.\\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\\n\\t\\ti) Now consider all possible options into this combination, one at a time.\\n\\t\\tii) Go check if considering the current option can give us the solution.\\n\\t\\tiii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\\n\\t\\tSo firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\\n\\t\\tWhen this also backtracks remove 3 to try 5, that means [2, 2, 5].\\n\\t\\tNow as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...\\n```\n```cpp\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777334,
                "title": "c-detailed-explanation-w-tree-diagram-recursion-backtracking-each-step-explained",
                "content": "***Brief note about Question-***\\n* In simple words, we have to *return all possible combination of array whose sum is equal to a particular target.*\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array is given to us as arr[]: [2, 3] and target as 6\\n\\nThen, all possible combinations of array whose sum is equal to 6 is-\\n[[2,2,2] , [3,3]]\\n\\n```\\n___________________\\n***General discussion on how we devlop approach-***\\n* This was a problem where we have to explore all possibility, make each combination and if sum of a combination becomes equal to target sum then we have to store that possible combination in our answer array.\\n\\n* One more thing we have to notice here is that, **for a particular element we have unlimited choice** i.e we can choose a element as many times as we want.\\n* But their is some restiction also on choosing a number.\\n* See for every number in making our target sum, we have two possibility i.e \\n1) **Whether to include that element in making our target sum**.\\n2) **Whether not to include that element in making our target sum**.\\n* We will try and explore each possible combination and if at a point we got our sum as zero then we will say yeah!!, we find a possible combination and include that combination in our answer.\\n\\n* Suppose if at any point our target sum becomes less than zero, then we will return from that point and will not explore further possibility by saying that, ok our target sum becomes negative that means from now no any combination is possible because we have given a non - negative array.\\n* See below tree diagram for more clarity.\\n_______________________\\n***How Tree diagram will work-***\\n* We will make a `op array`, that contains all the possible combinations sum of the array.\\n* We will start from the `index 0` and as we already discussed that for each and every element we have two possibility whether to include this element in making our answer or not, so we will explore all possibilities.\\n* op aray represents which elements this array contains now in making combination sum.\\n* Target represents the left combination sum that we have to make. Intially it is same as the original target that we have to make.\\n* The red cursor below the array, points that on which index we are currently standing.\\n* If at any point our target becomes zero, then we will include that combination in our answer array saying that yes, this is an possible combination and return from there.\\n* If at any point our target becomes less than zero, then we return from there saying that we are never able to make our cbination sum by this combination.\\n* If at any point we cross the size of the array then we will return from there saying that no more element is left to choose.\\n\\n* As we dicussed for every element we have two choices whether to include in our answer or not include in our answer.\\n* So, if we do not a include a element in our answer then without decreasing target sum, we will move to next index. **Why we do not decrese sum?** because we will choose not to include in this element in our combination, hence it does not contribute in making our sum.\\n* But, if we choose a particular element to include in our answer, then we will decrease the target sum but we will not move to next index. **Why we will not move to next index?** because for a specific element *we have unlimited number of choice*, so it may be possible that specific element again contribute in making our sum.\\n* If Image is not cleary visible to you, then for that I have uploaded it on my drive.\\n* **You may visit this link to see Image in good quality.**\\n* LINK :- [TREE DIAGRAM](https://drive.google.com/file/d/1dIVMnBcSlI0D1ZJRXsHR89WD4ZKZIxh2/view?usp=sharing)\\n_________________________\\n\\n![image](https://assets.leetcode.com/users/images/eb6d1bed-c1d3-4252-9d80-b44eb02a6654_1645069516.057088.jpeg)\\n_________________________\\n***Solution - I (using backtracking, Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n```\\n______________________\\n***Solution - II (using Recursion, Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```\\n\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array is given to us as arr[]: [2, 3] and target as 6\\n\\nThen, all possible combinations of array whose sum is equal to 6 is-\\n[[2,2,2] , [3,3]]\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777135,
                "title": "c-easy-to-understand-backtracking",
                "content": "# 39. Combination Sum\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n```\\n1. Sort the vector(non-decreasing).\\n2. First remove all the duplicates from vector.\\n3. Then use recursion and backtracking to solve \\n   the problem.\\n   (A) If at any time sub-problem sum == 0 then \\n       add that vector to the result (vector of \\n       vectors).\\n   (B) Else if sum is negative then ignore that \\n       sub-problem.\\n   (C) Else insert the present index in that \\n       vector to the current vector and call \\n       the function with sum = sum-ar[index] and\\n       index = index, then pop that element from \\n       current index (backtrack) and call the \\n       function with sum = sum and index = index+1\\n```\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n\\n    void Sum(vector<int>& candidates, int target, vector<vector<int> >& res, vector<int>& r, int i)\\n    {\\n        \\n        if(target == 0)\\n        {\\n            // if we get exact answer\\n            res.push_back(r);\\n            return;\\n        }\\n        \\n        while(i <  candidates.size() && target - candidates[i] >= 0)\\n        {\\n            // Till every element in the array starting\\n            // from i which can contribute to the target\\n            r.push_back(candidates[i]);// add them to vector\\n            \\n            // recur for next numbers\\n            Sum(candidates,target - candidates[i],res,r,i);\\n            ++i;\\n            \\n            // Remove number from vector (backtracking)\\n            r.pop_back();\\n        }\\n}\\n    \\n     \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end()); // sort candidates array\\n        \\n        // remove duplicates\\n        candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());\\n        \\n        vector<int> r;\\n        vector<vector<int> > res;\\n        \\n        Sum(candidates,target,res,r,0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n1. Sort the vector(non-decreasing).\\n2. First remove all the duplicates from vector.\\n3. Then use recursion and backtracking to solve \\n   the problem.\\n   (A) If at any time sub-problem sum == 0 then \\n       add that vector to the result (vector of \\n       vectors).\\n   (B) Else if sum is negative then ignore that \\n       sub-problem.\\n   (C) Else insert the present index in that \\n       vector to the current vector and call \\n       the function with sum = sum-ar[index] and\\n       index = index, then pop that element from \\n       current index (backtrack) and call the \\n       function with sum = sum and index = index+1\\n```\n```\\n\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n\\n    void Sum(vector<int>& candidates, int target, vector<vector<int> >& res, vector<int>& r, int i)\\n    {\\n        \\n        if(target == 0)\\n        {\\n            // if we get exact answer\\n            res.push_back(r);\\n            return;\\n        }\\n        \\n        while(i <  candidates.size() && target - candidates[i] >= 0)\\n        {\\n            // Till every element in the array starting\\n            // from i which can contribute to the target\\n            r.push_back(candidates[i]);// add them to vector\\n            \\n            // recur for next numbers\\n            Sum(candidates,target - candidates[i],res,r,i);\\n            ++i;\\n            \\n            // Remove number from vector (backtracking)\\n            r.pop_back();\\n        }\\n}\\n    \\n     \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end()); // sort candidates array\\n        \\n        // remove duplicates\\n        candidates.erase(unique(candidates.begin(),candidates.end()),candidates.end());\\n        \\n        vector<int> r;\\n        vector<vector<int> > res;\\n        \\n        Sum(candidates,target,res,r,0);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16502,
                "title": "a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning",
                "content": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n \\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n \\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "codeTag": "Unknown"
            },
            {
                "id": 16510,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16496,
                "title": "accepted-16ms-c-solution-use-backtracking-easy-understand",
                "content": "Accepted 16ms c++ solution use backtracking for [Combination Sum][1]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum(candidates, target, res, combination, 0);\\n            return res;\\n        }\\n    private:\\n        void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n                combination.push_back(candidates[i]);\\n                combinationSum(candidates, target - candidates[i], res, combination, i);\\n                combination.pop_back();\\n            }\\n        }\\n    };\\n\\nAccepted 12ms c++ solution use backtracking for [Combination Sum II][2]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum2(candidates, target, res, combination, 0);\\n            return res;\\n        }\\n    private:\\n        void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n                if (i == begin || candidates[i] != candidates[i - 1]) {\\n                    combination.push_back(candidates[i]);\\n                    combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                    combination.pop_back();\\n                }\\n        }\\n    };\\n\\nAccepted 0ms c++ solution use backtracking for [Combination Sum III][3]:\\n\\n    class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum3(n, res, combination, 1, k);\\n            return res;\\n        }\\n    private:\\n        void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n            if (!target) {\\n                res.push_back(combination);\\n                return;\\n            }\\n            else if (!need)\\n                return;\\n            for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n                combination.push_back(i);\\n                combinationSum3(target - i, res, combination, i + 1, need - 1);\\n                combination.pop_back();\\n            }\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/problems/combination-sum/\\n  [2]: https://leetcode.com/problems/combination-sum-ii/\\n  [3]: https://leetcode.com/problems/combination-sum-iii/",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n            std::sort(candidates.begin(), candidates.end());\\n            std::vector<std::vector<int> > res;\\n            std::vector<int> combination;\\n            combinationSum(candidates, target, res, combination, 0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 429538,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16509,
                "title": "iterative-java-dp-solution",
                "content": "Hi guys!\\n\\nThe main idea reminds an approach for solving coins/knapsack problem - to store the result for all i < target and create the solution from them. For that for each t from 1 to our target we try every candidate which is less or equal to t in ascending order. For each candidate \"c\" we run through all combinations for target t-c starting with the value greater or equal than c to avoid duplicates and store only ordered combinations. \\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] cands, int t) {\\n            Arrays.sort(cands); // sort candidates to try them in asc order\\n            List<List<List<Integer>>> dp = new ArrayList<>();\\n            for (int i = 1; i <= t; i++) { // run through all targets from 1 to t\\n                List<List<Integer>> newList = new ArrayList(); // combs for curr i\\n                // run through all candidates <= i\\n                for (int j = 0; j < cands.length && cands[j] <= i; j++) {\\n                    // special case when curr target is equal to curr candidate\\n                    if (i == cands[j]) newList.add(Arrays.asList(cands[j]));\\n                    // if current candidate is less than the target use prev results\\n                    else for (List<Integer> l : dp.get(i-cands[j]-1)) {\\n                        if (cands[j] <= l.get(0)) {\\n                            List cl = new ArrayList<>();\\n                            cl.add(cands[j]); cl.addAll(l);\\n                            newList.add(cl);\\n                        }\\n                    }\\n                }\\n                dp.add(newList);\\n            }\\n            return dp.get(t-1);\\n        }\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] cands, int t) {\\n            Arrays.sort(cands); // sort candidates to try them in asc order\\n            List<List<List<Integer>>> dp = new ArrayList<>();\\n            for (int i = 1; i <= t; i++) { // run through all targets from 1 to t\\n                List<List<Integer>> newList = new ArrayList(); // combs for curr i\\n                // run through all candidates <= i\\n                for (int j = 0; j < cands.length && cands[j] <= i; j++) {\\n                    // special case when curr target is equal to curr candidate\\n                    if (i == cands[j]) newList.add(Arrays.asList(cands[j]));\\n                    // if current candidate is less than the target use prev results\\n                    else for (List<Integer> l : dp.get(i-cands[j]-1)) {\\n                        if (cands[j] <= l.get(0)) {\\n                            List cl = new ArrayList<>();\\n                            cl.add(cands[j]); cl.addAll(l);\\n                            newList.add(cl);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 786891,
                "title": "c-two-differnt-aproch-easy-to-understand-with-comment",
                "content": "**Plz upvote my solution if you like it**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n\\t//global values shared between both function\\n    vector<vector<int>>result;\\n    vector<int>current;\\n    int sum;\\n    \\n    void function(vector<int>& candidates,int target,int index)\\n    {\\n        if(sum>target)return ;//base case if sum is greater then target then return \\n        \\n        if(sum==target){\\n            result.push_back(current);//id sum is equal to target then just add current to result\\n        }\\n        for(int i=index;i<candidates.size();i++){\\n            sum+=candidates[i];//and current value to sum\\n            current.push_back(candidates[i]);//and current value to current vector\\n            function(candidates,target,i);//again reccure for same index i\\n            sum-=candidates[i];//back track mean remove value that previously added\\n            current.pop_back();//remove the value that previously added to current \\n        }      \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sum=0; // This sum is global you can see it on the top of code just a clarify if you have any doubt\\n        function(candidates,target,0);//i make result current and sum global to reduce the size of function for simplecity\\n        return result;//This result is also global \\n    }\\n};\\n\\'\\'\\'\\nNow second approch is bit tricky you have to be bit carefull or you can solve this approch using pen and paper \\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>result;\\n    vector<int>current;\\n    \\n    void function(vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            result.push_back(current);\\n            return;\\n        }\\n        \\n        if(index==candidates.size() || target<0)return;\\n        \\n        current.push_back(candidates[index]);\\n        function(candidates,target-candidates[index],index);\\n        current.pop_back();\\n        function(candidates,target,index+1);      \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        function(candidates,target,0);\\n        return result;\\n    }\\n};\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\t//global values shared between both function\\n    vector<vector<int>>result;\\n    vector<int>current;\\n    int sum;\\n    \\n    void function(vector<int>& candidates,int target,int index)\\n    {\\n        if(sum>target)return ;//base case if sum is greater then target then return \\n        \\n        if(sum==target){\\n            result.push_back(current);//id sum is equal to target then just add current to result\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 937255,
                "title": "python-3-dfs-backtracking-two-dp-methods-explanations",
                "content": "### Approach \\\\#1. DFS (Backtracking)\\n- Straight forward backtracking\\n- `cur`: current combination, `cur_sum` current combination sum, `idx` index current at (to avoid repeats)\\n- Time complexity: `O(N^(M/min_cand + 1))`, `N = len(candidates)`, `M = target`, `min_cand = min(candidates)`\\n- Space complexity: `O(M/min_cand)`\\n<iframe src=\"https://leetcode.com/playground/fwFMybYZ/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#2. DP (Slow)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/Qw6fiSbh/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#3. DP (Fast)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/d2qASVHs/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "### Approach \\\\#1. DFS (Backtracking)\\n- Straight forward backtracking\\n- `cur`: current combination, `cur_sum` current combination sum, `idx` index current at (to avoid repeats)\\n- Time complexity: `O(N^(M/min_cand + 1))`, `N = len(candidates)`, `M = target`, `min_cand = min(candidates)`\\n- Space complexity: `O(M/min_cand)`\\n<iframe src=\"https://leetcode.com/playground/fwFMybYZ/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#2. DP (Slow)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/Qw6fiSbh/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n\\n### Approach \\\\#3. DP (Fast)\\n- Read comment for more detail\\n- Time Complexity: `O(M*M*N)`, `N = len(candidates)`, `M = target`\\n- Space Complexity: `O(M*M)`\\n<iframe src=\"https://leetcode.com/playground/d2qASVHs/shared\" frameBorder=\"0\" width=\"850\" height=\"300\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 16521,
                "title": "java-solution-using-recursive",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        \\tArrays.sort(candidates);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            getResult(result, new ArrayList<Integer>(), candidates, target, 0);\\n            \\n            return result;\\n        }\\n        \\n        private void getResult(List<List<Integer>> result, List<Integer> cur, int candidates[], int target, int start){\\n        \\tif(target > 0){\\n        \\t\\tfor(int i = start; i < candidates.length && target >= candidates[i]; i++){\\n        \\t\\t\\tcur.add(candidates[i]);\\n        \\t\\t\\tgetResult(result, cur, candidates, target - candidates[i], i);\\n        \\t\\t\\tcur.remove(cur.size() - 1);\\n        \\t\\t}//for\\n        \\t}//if\\n        \\telse if(target == 0 ){\\n        \\t\\tresult.add(new ArrayList<Integer>(cur));\\n        \\t}//else if\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        \\tArrays.sort(candidates);\\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\\n            getResult(result, new ArrayList<Integer>(), candidates, target, 0);\\n            \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1755084,
                "title": "detailed-time-and-space-complexity-analysis-c-java-backtracking",
                "content": "**Time Complexity** - O(2^k) where k is the sum of target/candidate[i] from i = 0 to size of candidate - 1.\\n**Note-** *the time complexity of pushing cur into res is len_of_cur, so we can say TC - O( len_of_cur\\xD72^k)*\\n**Auxillary Space Complexity** - O(length_of_longest_combination).\\n\\n**Detailed explanation for time and auxillary space complexity** \\n\\n**Note-** *the space complexity i mentioned is the auxillary space complexity i.e. recursive stack space*\\n![image](https://assets.leetcode.com/users/images/72c0a206-7a8a-4109-95be-aea3ad7298e5_1644313045.9214947.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/725c0db0-a479-4412-aa89-6ad7965cde0b_1644409701.0079207.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a11a8b81-ae82-478d-a99a-21c035fb1493_1644409707.9676895.jpeg)\\n\\n\\n\\n**C++ and Java Codes -**\\n<iframe src=\"https://leetcode.com/playground/kgQe9ngW/shared\" frameBorder=\"0\" width=\"1090\" height=\"430\"></iframe>",
                "solutionTags": [
                    "Java",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "**Time Complexity** - O(2^k) where k is the sum of target/candidate[i] from i = 0 to size of candidate - 1.\\n**Note-** *the time complexity of pushing cur into res is len_of_cur, so we can say TC - O( len_of_cur\\xD72^k)*\\n**Auxillary Space Complexity** - O(length_of_longest_combination).\\n\\n**Detailed explanation for time and auxillary space complexity** \\n\\n**Note-** *the space complexity i mentioned is the auxillary space complexity i.e. recursive stack space*\\n![image](https://assets.leetcode.com/users/images/72c0a206-7a8a-4109-95be-aea3ad7298e5_1644313045.9214947.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/725c0db0-a479-4412-aa89-6ad7965cde0b_1644409701.0079207.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a11a8b81-ae82-478d-a99a-21c035fb1493_1644409707.9676895.jpeg)\\n\\n\\n\\n**C++ and Java Codes -**\\n<iframe src=\"https://leetcode.com/playground/kgQe9ngW/shared\" frameBorder=\"0\" width=\"1090\" height=\"430\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 16554,
                "title": "share-my-python-solution-beating-98-17",
                "content": "    class Solution(object):\\n    def combinationSum(self, candidates, target):\\n        result = []\\n        candidates = sorted(candidates)\\n        def dfs(remain, stack):\\n            if remain == 0:\\n                result.append(stack)\\n                return \\n\\n            for item in candidates:\\n                if item > remain: break\\n                if stack and item < stack[-1]: continue\\n                else:\\n                    dfs(remain - item, stack + [item])\\n        \\n        dfs(target, [])\\n        return result",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "    class Solution(object):\\n    def combinationSum(self, candidates, target):\\n        result = []\\n        candidates = sorted(candidates)\\n        def dfs(remain, stack):\\n            if remain == 0:\\n                result.append(stack)\\n                return \\n\\n            for item in candidates:\\n                if item > remain: break\\n                if stack and item < stack[-1]: continue\\n                else:\\n                    dfs(remain - item, stack + [item])\\n        \\n        dfs(target, [])\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 1103237,
                "title": "c-best-and-easy-dp-solution",
                "content": "Similar idea from the problem [coin-change-2](https://leetcode.com/problems/coin-change-2/) .\\nit is simplest and fastest dp solution, we don\\'t need to sort elements \\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n\\t\\t// dp vector to store all possible combinations of the target sum\\n        vector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int &i:nums)\\n        {\\n\\t\\t// Iterating through all the elements from array nums aka candidates\\n            for(int j=i;j<=target;j++)\\n            {\\n\\t\\t\\t// Finding all possible ways to achieve sum j from element i\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n\\t\\t// Finally, returning our ans \\uD83D\\uDE43\\n        return dp[target];\\n    }\\n};\\n```\\nIf you liked this solution please upvote\\uD83D\\uDE4F if you have any query plz comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\\n\\t\\t// dp vector to store all possible combinations of the target sum\\n        vector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int &i:nums)\\n        {\\n\\t\\t// Iterating through all the elements from array nums aka candidates\\n            for(int j=i;j<=target;j++)\\n            {\\n\\t\\t\\t// Finding all possible ways to achieve sum j from element i\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n\\t\\t// Finally, returning our ans \\uD83D\\uDE43\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875097,
                "title": "python-bactracking-solution-explained",
                "content": "This is classical backtracking problem, so let us use `BackTr(target, curr_sol, k)` function, where:\\n\\n1. `target` is target we need to build, if we get some number, we subtract if from target.\\n2. `curr_sol` is current solution built so far.\\n3. `k` is index in our `candidates`: each new number we take should have number more or equal than `k`.\\n\\nSo, no in algorighm we do:\\n1. If `target == 0`, it means we found solution, which is kept in `curr_sol`, so we add it to `self.sol` list of all found solutions.\\n2. If `target` if negative or `k` is more than number of candidates, we need to go back.\\n3. Finally, for each candidate index in `k,...`, we run our function recursively with updated parameters.\\n\\n**Complexity**: TBD\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        def BackTr(target, curr_sol, k):  \\n            if target == 0:\\n                self.sol.append(curr_sol)\\n\\n            if target < 0 or k >= len(candidates):\\n                return\\n\\n            for i in range(k, len(candidates)):\\n                BackTr(target - candidates[i], curr_sol + [candidates[i]], i)\\n        \\n        self.sol = []\\n        BackTr(target, [], 0)   \\n        return self.sol\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        def BackTr(target, curr_sol, k):  \\n            if target == 0:\\n                self.sol.append(curr_sol)\\n\\n            if target < 0 or k >= len(candidates):\\n                return\\n\\n            for i in range(k, len(candidates)):\\n                BackTr(target - candidates[i], curr_sol + [candidates[i]], i)\\n        \\n        self.sol = []\\n        BackTr(target, [], 0)   \\n        return self.sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752444,
                "title": "python-clear-explanation-and-intuition-using-combination-with-backtracking-solution",
                "content": "Here is a my backtracking-based solution. \\nTo fully understand the intuition behind my solution, I will first explaination how we implement combination using backtracking.\\n\\n### Combination\\n\\nTo get all combinations of length 2 from `[1,2,3]`\\n![image](https://assets.leetcode.com/users/images/941d85bd-dab4-4b09-a6d4-5e0e0aca94fc_1595578055.3871193.png)\\n\\n* We dont append the `1` to `[2]` because `[1, 2]` and `[2, 1]` are the same\\n* Same appies to `[3]`\\n\\n### Implementing combinations of sub array with target length\\n```\\nresults = []\\ntarget_length = 2\\narr = [1,2,3]\\n\\ndef combination(i, path):\\n\\n\\t# we have found our answer, lets return. Any code below this statement wont get executed and the recursion stops.\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n\\n\\t# With each iteration of the for loop, we will reduce the number of candidates - [1, 2, 3] , [2, 3] , [3]\\n\\t# This is important to prevent duplicates. \\n\\tfor x in range(i, len(arr)):\\n\\t\\t# lets keep adding to path. \\t\\n\\t\\tpath.append(arr[x])\\n\\n\\t\\t# lets run combination again, if the path is not our target length, it will go to the for loop again.\\n\\t   combination(x, path)\\n\\n\\t   # backtrack, remove my last element, so i can move on .\\n\\t   path.pop()\\n   \\ncombination(0, [])\\n\\nassert combinations == [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]]\\n```\\n\\nNow instead of just finding combinations of a certain length, we replace the termination statement\\n*combination of k length*\\n\\n```\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n```\\n\\nto \\n*combination of target sum*\\n\\n```\\n\\t\\t# termination 1. The sum is the target. stop recursion\\n\\t\\tif sum(path) == target:\\n\\t\\t\\tresults.append(path[:])\\n\\t\\t\\treturn \\n\\n\\t\\t# termination 2 (The sum is greater than the target). stop recursion\\n\\t\\tif sum(path) > target:\\n\\t\\t\\treturn \\n\\n```\\n\\n### Solution to combination sum.\\n\\nTherefore the solution to the problem is:\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        results = []\\n        def helper(i, path):\\n            # endpoint 1 (we found a matching target)\\n            if sum(path) == target:\\n                results.append(path[:])\\n                return \\n\\t\\t\\t\\n\\t\\t\\t# endpoint 2 (The sum is greater than the target)\\n            if sum(path) > target:\\n                return \\n\\t\\t\\t\\n            for x in range(i, len(candidates)):\\n                path.append(candidates[x])\\n                helper(x, path)\\n                path.pop()\\n\\n        helper(0, [])\\n        return results\\n```\\t\\t\\n\\n### What you can do to understand the implementation better.\\n\\n1 . You can try not doing the backtracking step `path.pop()` and see how that affect the results.\\n2. You can print the `path` value in under the for loop.\\n\\n### Conclusion\\n\\nUsing backtracking to solve combinations problem can be easy once you figure out where and how to terminate.\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Combinatorics"
                ],
                "code": "```\\nresults = []\\ntarget_length = 2\\narr = [1,2,3]\\n\\ndef combination(i, path):\\n\\n\\t# we have found our answer, lets return. Any code below this statement wont get executed and the recursion stops.\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n\\n\\t# With each iteration of the for loop, we will reduce the number of candidates - [1, 2, 3] , [2, 3] , [3]\\n\\t# This is important to prevent duplicates. \\n\\tfor x in range(i, len(arr)):\\n\\t\\t# lets keep adding to path. \\t\\n\\t\\tpath.append(arr[x])\\n\\n\\t\\t# lets run combination again, if the path is not our target length, it will go to the for loop again.\\n\\t   combination(x, path)\\n\\n\\t   # backtrack, remove my last element, so i can move on .\\n\\t   path.pop()\\n   \\ncombination(0, [])\\n\\nassert combinations == [[1, 1], [1, 2], [1, 3], [2, 2], [2, 3], [3, 3]]\\n```\n```\\n\\tif len(path) == target_length:\\n\\t\\tresults.append(path[:])\\n\\t\\treturn\\n```\n```\\n\\t\\t# termination 1. The sum is the target. stop recursion\\n\\t\\tif sum(path) == target:\\n\\t\\t\\tresults.append(path[:])\\n\\t\\t\\treturn \\n\\n\\t\\t# termination 2 (The sum is greater than the target). stop recursion\\n\\t\\tif sum(path) > target:\\n\\t\\t\\treturn \\n\\n```\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        results = []\\n        def helper(i, path):\\n            # endpoint 1 (we found a matching target)\\n            if sum(path) == target:\\n                results.append(path[:])\\n                return \\n\\t\\t\\t\\n\\t\\t\\t# endpoint 2 (The sum is greater than the target)\\n            if sum(path) > target:\\n                return \\n\\t\\t\\t\\n            for x in range(i, len(candidates)):\\n                path.append(candidates[x])\\n                helper(x, path)\\n                path.pop()\\n\\n        helper(0, [])\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875365,
                "title": "java-python-backtracking-clean-concise-very-fast-2ms",
                "content": "**Python ~ 32ms**\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()  # sort to terminate early when target < 0\\n        \\n        def backtracking(i, target, path):\\n            if target == 0:\\n                ans.append(path)\\n                return\\n            if i == len(candidates) or target < candidates[i]:\\n                return\\n            backtracking(i, target - candidates[i], path + [candidates[i]]) # Choose ith candidate\\n            backtracking(i + 1, target, path) # Skip ith candidate\\n        \\n        ans = []\\n        backtracking(0, target, [])\\n        return ans\\n```\\n\\n**Java ~ 2ms**\\n```java\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort to terminate early when target < 0\\n        backtracking(0, target, candidates, new LinkedList<>());\\n        return ans;\\n    }\\n    void backtracking(int i, int target, int[] candidates, LinkedList<Integer> path) {\\n        if (target == 0) {\\n            ans.add((List<Integer>) path.clone());\\n            return;\\n        }\\n        if (i == candidates.length || target < candidates[i]) return;\\n        \\n        path.addLast(candidates[i]);\\n        backtracking(i, target - candidates[i], candidates, path); // Choose ith candidate\\n        path.removeLast();\\n        \\n        backtracking(i + 1, target, candidates, path); // Skip ith candidate\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()  # sort to terminate early when target < 0\\n        \\n        def backtracking(i, target, path):\\n            if target == 0:\\n                ans.append(path)\\n                return\\n            if i == len(candidates) or target < candidates[i]:\\n                return\\n            backtracking(i, target - candidates[i], path + [candidates[i]]) # Choose ith candidate\\n            backtracking(i + 1, target, path) # Skip ith candidate\\n        \\n        ans = []\\n        backtracking(0, target, [])\\n        return ans\\n```\n```java\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort to terminate early when target < 0\\n        backtracking(0, target, candidates, new LinkedList<>());\\n        return ans;\\n    }\\n    void backtracking(int i, int target, int[] candidates, LinkedList<Integer> path) {\\n        if (target == 0) {\\n            ans.add((List<Integer>) path.clone());\\n            return;\\n        }\\n        if (i == candidates.length || target < candidates[i]) return;\\n        \\n        path.addLast(candidates[i]);\\n        backtracking(i, target - candidates[i], candidates, path); // Choose ith candidate\\n        path.removeLast();\\n        \\n        backtracking(i + 1, target, candidates, path); // Skip ith candidate\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16530,
                "title": "concise-backtracking-solution",
                "content": "We backtrack from successful searches as well because they are saved at the leafs of recursion tree\\n\\n    class Solution {\\n    public:\\n    \\n        void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n        {\\n            if(target == 0)\\n            {\\n                result.push_back(pSol);\\n                return;\\n            }\\n            \\n            if(next == num.size() || target - num[next] < 0)\\n                return;\\n                \\n            pSol.push_back(num[next]);\\n            search(num, next, pSol, target - num[next], result);\\n            pSol.pop_back();\\n            \\n            search(num, next + 1, pSol, target, result);\\n        }\\n    \\n        \\n        vector<vector<int> > combinationSum(vector<int> &num, int target) \\n        {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            vector<int> pSol;\\n            search(num, 0, pSol, target, result);\\n            return result;    \\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n        {\\n            if(target == 0)\\n            {\\n                result.push_back(pSol);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1778054,
                "title": "python-short-and-clean-solution-explained",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16757,
                "title": "javascript-solution-with-backtracking",
                "content": "```js\\nfunction combinationSum(candidates, target) {\\n  var buffer = [];\\n  var result = [];\\n  search(0, target);\\n  return result;\\n\\n  function search(startIdx, target) {\\n    if (target === 0) return result.push(buffer.slice());\\n    if (target < 0) return;\\n    if (startIdx === candidates.length) return;\\n    buffer.push(candidates[startIdx]);\\n    search(startIdx, target - candidates[startIdx]);\\n    buffer.pop();\\n    search(startIdx + 1, target);\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```js\\nfunction combinationSum(candidates, target) {\\n  var buffer = [];\\n  var result = [];\\n  search(0, target);\\n  return result;\\n\\n  function search(startIdx, target) {\\n    if (target === 0) return result.push(buffer.slice());\\n    if (target < 0) return;\\n    if (startIdx === candidates.length) return;\\n    buffer.push(candidates[startIdx]);\\n    search(startIdx, target - candidates[startIdx]);\\n    buffer.pop();\\n    search(startIdx + 1, target);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351862,
                "title": "solution-swift-combination-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var comb: [Int] = [], uniqs: [[Int]] = []\\n        dfs(&uniqs, &comb, candidates.sorted(), target, 0)\\n        return uniqs\\n    }\\n    \\n    private func dfs(_ uniq: inout [[Int]], _ comb: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int) {\\n        guard t > 0 else { uniq.append(comb); return }\\n        for i in idx..<cands.count where cands[i] <= t {\\n            comb.append(cands[i])\\n            dfs(&uniq, &comb, cands, t - cands[i], i)\\n            comb.removeLast()\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 5 tests, with 0 failures (0 unexpected) in 0.039 (0.041) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\n    /// 7 is a candidate, and 7 = 7.\\n    /// These are the only two combinations.\\n    func test0() {\\n        let value = solution.combinationSum([2,3,6,7], 7)\\n        XCTAssertEqual(value, [[2,2,3],[7]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum([2,3,5], 8)\\n        XCTAssertEqual(value, [[2,2,2,2],[2,3,3],[3,5]])\\n    }\\n    func test2() {\\n        let value = solution.combinationSum([2], 1)\\n        XCTAssertEqual(value, [])\\n    }\\n    func test3() {\\n        let value = solution.combinationSum([1], 1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n    func test4() {\\n        let value = solution.combinationSum([1], 2)\\n        XCTAssertEqual(value, [[1,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var comb: [Int] = [], uniqs: [[Int]] = []\\n        dfs(&uniqs, &comb, candidates.sorted(), target, 0)\\n        return uniqs\\n    }\\n    \\n    private func dfs(_ uniq: inout [[Int]], _ comb: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int) {\\n        guard t > 0 else { uniq.append(comb); return }\\n        for i in idx..<cands.count where cands[i] <= t {\\n            comb.append(cands[i])\\n            dfs(&uniq, &comb, cands, t - cands[i], i)\\n            comb.removeLast()\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\n    /// 7 is a candidate, and 7 = 7.\\n    /// These are the only two combinations.\\n    func test0() {\\n        let value = solution.combinationSum([2,3,6,7], 7)\\n        XCTAssertEqual(value, [[2,2,3],[7]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum([2,3,5], 8)\\n        XCTAssertEqual(value, [[2,2,2,2],[2,3,3],[3,5]])\\n    }\\n    func test2() {\\n        let value = solution.combinationSum([2], 1)\\n        XCTAssertEqual(value, [])\\n    }\\n    func test3() {\\n        let value = solution.combinationSum([1], 1)\\n        XCTAssertEqual(value, [[1]])\\n    }\\n    func test4() {\\n        let value = solution.combinationSum([1], 2)\\n        XCTAssertEqual(value, [[1,1]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16713,
                "title": "a-solution-avoid-using-set",
                "content": "Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one.\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ret = new LinkedList<List<Integer>>();\\n        Arrays.sort(candidates); // sort the candidates\\n        // collect possible candidates from small to large to eliminate duplicates,\\n        recurse(new ArrayList<Integer>(), target, candidates, 0, ret);\\n        return ret;\\n    }\\n    \\n    // the index here means we are allowed to choose candidates from that index\\n    private void recurse(List<Integer> list, int target, int[] candidates, int index, List<List<Integer>> ret) {\\n        if (target == 0) {\\n            ret.add(list);\\n            return;\\n        }\\n        for (int i = index; i < candidates.length; i++) {\\n            int newTarget = target - candidates[i];\\n            if (newTarget >= 0) {\\n                List<Integer> copy = new ArrayList<Integer>(list);\\n                copy.add(candidates[i]);\\n                recurse(copy, newTarget, candidates, i, ret);\\n            } else {\\n                break;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "Sort the candidates and we choose from small to large recursively, every time we add a candidate to our possible sub result, we subtract the target to a new smaller one.\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ret = new LinkedList<List<Integer>>();\\n        Arrays.sort(candidates); // sort the candidates\\n        // collect possible candidates from small to large to eliminate duplicates,\\n        recurse(new ArrayList<Integer>(), target, candidates, 0, ret);\\n        return ret;\\n    }\\n    \\n    // the index here means we are allowed to choose candidates from that index\\n    private void recurse(List<Integer> list, int target, int[] candidates, int index, List<List<Integer>> ret) {\\n        if (target == 0) {\\n            ret.add(list);\\n            return;\\n        }\\n        for (int i = index; i < candidates.length; i++) {\\n            int newTarget = target - candidates[i];\\n            if (newTarget >= 0) {\\n                List<Integer> copy = new ArrayList<Integer>(list);\\n                copy.add(candidates[i]);\\n                recurse(copy, newTarget, candidates, i, ret);\\n            } else {\\n                break;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 662307,
                "title": "javascript-clean-backtracking-solution",
                "content": "```javascript\\nvar combinationSum = function(candidates, target) {\\n    const result = [];\\n    \\n    function permute(arr=[], sum=0, idx=0) {\\n        if(sum > target) return;\\n        if(sum === target) result.push(arr);\\n        \\n        for(let i = idx; i < candidates.length; i++) {\\n            permute([...arr, candidates[i]], sum+candidates[i], i);\\n        }\\n    }\\n    permute()\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```javascript\\nvar combinationSum = function(candidates, target) {\\n    const result = [];\\n    \\n    function permute(arr=[], sum=0, idx=0) {\\n        if(sum > target) return;\\n        if(sum === target) result.push(arr);\\n        \\n        for(let i = idx; i < candidates.length; i++) {\\n            permute([...arr, candidates[i]], sum+candidates[i], i);\\n        }\\n    }\\n    permute()\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1378325,
                "title": "javascript-solution-with-detailed-explanation",
                "content": "This is a question of backtracking and recursion and we got to this conclusion by following points\\n1.The question states we can use same number multiple times so we can think that \\n    it will take use of recursion \\n2.We need to find all possible unique combination of numbers that will result to our target to this should\\tmake us think it will use backtracking too\\n\\nSolution approach\\n1.We will take use of a backtracking recursive function which will take input as index, target and a temperory data structure(in this question stack will be suitable).\\n2.We already initialised the index because we wanna/may use it many times so intialising index outside the loop will be helpful\\n3.Target is our target that we want to achieve\\n4.Temperory data structure will store our combinations i.e numbers that may result to our target\\n5.The loop will start with index and end on our last index as obvious\\n6.We will add the current number to our temp DS and substract it from target\\n7.If our target is still not equal to zero i.e we still have some target to achieve\\n8.So we will keep on calling backtracking function and substraction the number from target to see if its zero or not\\n9.If it becomes zero then we achieved our target and we will push the temp DS values in the result as temp DS was storing the values which together resulted to our target\\n10.If we reached somewhere lower than zero that means our sum became greater than our target so we cannot take that number that made our sum greater than target\\n11.So we will return from their and because we are in a for loop after returning we will add next number of \"candidates array\" to our temperory datastructure and start backtracking recursion again\\n12.Make sure to remove the element from our temp DS because of which our sum became greater than our target\\n\\nIn general we can say this question is alll about selecting and not-selecting an element . We select an element if we haven\\'t reached our target\\nWe remove element from temp DS or don\\'t select an element if we go beyond our target\\n\\n    var combinationSum = function(candidates, target) {\\n        let index = 0\\n        let tempDataStruct = []\\n        let result = []\\n    \\n        function backtracking(index, target, tempDataStruct) {\\n            if(target === 0) {\\n                result.push([...tempDataStruct])\\n                return\\n            }\\n        \\n            if(target < 0) return;\\n        \\n            for(let i=index; i<candidates.length; i++) {\\n                tempDataStruct.push(candidates[i])\\n                backtracking(i, target-candidates[i], tempDataStruct)\\n                tempDataStruct.pop()\\n            }\\n        }\\n        backtracking(index, target, tempDataStruct)\\n        return result;\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "This is a question of backtracking and recursion and we got to this conclusion by following points\\n1.The question states we can use same number multiple times so we can think that \\n    it will take use of recursion \\n2.We need to find all possible unique combination of numbers that will result to our target to this should\\tmake us think it will use backtracking too\\n\\nSolution approach\\n1.We will take use of a backtracking recursive function which will take input as index, target and a temperory data structure(in this question stack will be suitable).\\n2.We already initialised the index because we wanna/may use it many times so intialising index outside the loop will be helpful\\n3.Target is our target that we want to achieve\\n4.Temperory data structure will store our combinations i.e numbers that may result to our target\\n5.The loop will start with index and end on our last index as obvious\\n6.We will add the current number to our temp DS and substract it from target\\n7.If our target is still not equal to zero i.e we still have some target to achieve\\n8.So we will keep on calling backtracking function and substraction the number from target to see if its zero or not\\n9.If it becomes zero then we achieved our target and we will push the temp DS values in the result as temp DS was storing the values which together resulted to our target\\n10.If we reached somewhere lower than zero that means our sum became greater than our target so we cannot take that number that made our sum greater than target\\n11.So we will return from their and because we are in a for loop after returning we will add next number of \"candidates array\" to our temperory datastructure and start backtracking recursion again\\n12.Make sure to remove the element from our temp DS because of which our sum became greater than our target\\n\\nIn general we can say this question is alll about selecting and not-selecting an element . We select an element if we haven\\'t reached our target\\nWe remove element from temp DS or don\\'t select an element if we go beyond our target\\n\\n    var combinationSum = function(candidates, target) {\\n        let index = 0\\n        let tempDataStruct = []\\n        let result = []\\n    \\n        function backtracking(index, target, tempDataStruct) {\\n            if(target === 0) {\\n                result.push([...tempDataStruct])\\n                return\\n            }\\n        \\n            if(target < 0) return;\\n        \\n            for(let i=index; i<candidates.length; i++) {\\n                tempDataStruct.push(candidates[i])\\n                backtracking(i, target-candidates[i], tempDataStruct)\\n                tempDataStruct.pop()\\n            }\\n        }\\n        backtracking(index, target, tempDataStruct)\\n        return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 742449,
                "title": "explanation-of-time-complexity",
                "content": "Ill try and explain the time complexity I know and understand the solution to be. In order to get the time complexity easily of these types of solutions, always consider the recursive tree.\\n\\nLets say we have 4 elements in our list (call it N) and a target = 7 (call it M):\\n\\nnums = [2,3,6,7]\\nAt every single level in our recursion tree we have N choices to decrease target by and then to recurse on.\\n\\nAt the first level target = 7 and we can chose 2,3,6,7.\\n\\n                                7\\n                         5    4    1   0\\n\\nAt the second level of our recursive tree where target=5 we also have 4 choices. Even though some of those choices would lead us\\nto a negative target which isnt valid we can approximate that we still have about 4 choices. So we can state that the number of recursive calls on each level of our recursive tree is 4 (N)\\n\\nSo now we have the number of elements on each level. However how many levels (heigh) will there be worst case?\\n\\nIf you consider a list with only 1s in it we can see the maximum height of our recursive tree is equal to target (M)\\n\\ntarget = 7\\nnums = [1, 1, 1, 1]\\n\\n                         7\\n                        /\\n                       6\\n                      /\\n                     5\\n                    /\\n                   4\\n                  ..\\n                 /\\n                1\\n\\nSo we know the number of elements on each level of our recursive tree (N) and we know the height of our recursive tree (M)\\n\\nTherefore we can say worst case scenario the time complexity is O(len(nums)^target) or O(N^M)\\n\\nO(n^m) time complexity\\n\\nHope this helps.",
                "solutionTags": [],
                "code": "Ill try and explain the time complexity I know and understand the solution to be. In order to get the time complexity easily of these types of solutions, always consider the recursive tree.\\n\\nLets say we have 4 elements in our list (call it N) and a target = 7 (call it M):\\n\\nnums = [2,3,6,7]\\nAt every single level in our recursion tree we have N choices to decrease target by and then to recurse on.\\n\\nAt the first level target = 7 and we can chose 2,3,6,7.\\n\\n                                7\\n                         5    4    1   0\\n\\nAt the second level of our recursive tree where target=5 we also have 4 choices. Even though some of those choices would lead us\\nto a negative target which isnt valid we can approximate that we still have about 4 choices. So we can state that the number of recursive calls on each level of our recursive tree is 4 (N)\\n\\nSo now we have the number of elements on each level. However how many levels (heigh) will there be worst case?\\n\\nIf you consider a list with only 1s in it we can see the maximum height of our recursive tree is equal to target (M)\\n\\ntarget = 7\\nnums = [1, 1, 1, 1]\\n\\n                         7\\n                        /\\n                       6\\n                      /\\n                     5\\n                    /\\n                   4\\n                  ..\\n                 /\\n                1\\n\\nSo we know the number of elements on each level of our recursive tree (N) and we know the height of our recursive tree (M)\\n\\nTherefore we can say worst case scenario the time complexity is O(len(nums)^target) or O(N^M)\\n\\nO(n^m) time complexity\\n\\nHope this helps.",
                "codeTag": "Unknown"
            },
            {
                "id": 16506,
                "title": "8-line-python-solution-dynamic-programming-beats-86-77",
                "content": "    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        dp = [[[]]] + [[] for i in xrange(target)]\\n        for i in xrange(1, target + 1):\\n            for number in candidates:\\n                if number > i: break\\n                for L in dp[i - number]:\\n                    if not L or number >= L[-1]: dp[i] += L + [number],\\n        return dp[target]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        dp = [[[]]] + [[] for i in xrange(target)]\\n        for i in xrange(1, target + 1):\\n            for number in candidates:\\n                if number > i: break\\n                for L in dp[i - number]:\\n                    if not L or number >= L[-1]: dp[i] += L + [number],\\n        return dp[target]",
                "codeTag": "Python3"
            },
            {
                "id": 3685211,
                "title": "beat-100-proper-step-by-step-explanation-simplest-approach",
                "content": "# Intuition\\nThe code follows a backtracking approach to find all combinations that sum up to the given target.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The code follows a backtracking approach to find all combinations that sum up to the given target.\\n2. The `combinationSum` method is the entry point for the backtracking process. It initializes the `ans` list to store the result and the `ls` list to track the current combination.\\n3. The `cum` method performs the backtracking. It takes the current array `c`, the remaining target value, and the starting index as parameters.\\n4. The base case is when the target value becomes zero. In this case, it means that the current combination in `ls` sums up to the target. Therefore, a copy of `ls` is added to the `ans` list as a valid combination.\\n5. The for loop iterates through the elements in the `c` array, starting from the given index `start`.\\n6. Within the loop, if the current element `c[i]` is less than or equal to the remaining target, it is a valid candidate to include in the combination.\\n7. The element `c[i]` is added to the `ls` list, and the `cum` method is recursively called with the updated target (subtracting `c[i]`) and the same starting index `i` to allow reusing the same element in subsequent combinations.\\n8. After the recursive call, the last element is removed from `ls` using `ls.remove(ls.size() - 1)`. This step is crucial for backtracking, as it ensures that the correct elements are considered for the next iteration of the loop.\\n9. The process continues with the next element in the loop until all combinations have been explored.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    ArrayList<Integer> ls = new ArrayList<>();\\n\\n    public List<List<Integer>> combinationSum(int[] c, int target) {\\n        cum(c, target, 0);\\n        return ans;\\n    }\\n\\n    public void cum(int[] c, int target, int start) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ls)); \\n            return;\\n        }\\n\\n        for (int i = start; i < c.length; i++) {\\n            if (c[i] <= target) {\\n                ls.add(c[i]);\\n                cum(c, target - c[i], i); \\n                ls.remove(ls.size() - 1); \\n            }\\n        }\\n    }\\n}\\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/c0566519-3a55-47c3-a7c3-c6ccf4f753f2_1687785256.2860038.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    ArrayList<Integer> ls = new ArrayList<>();\\n\\n    public List<List<Integer>> combinationSum(int[] c, int target) {\\n        cum(c, target, 0);\\n        return ans;\\n    }\\n\\n    public void cum(int[] c, int target, int start) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ls)); \\n            return;\\n        }\\n\\n        for (int i = start; i < c.length; i++) {\\n            if (c[i] <= target) {\\n                ls.add(c[i]);\\n                cum(c, target - c[i], i); \\n                ls.remove(ls.size() - 1); \\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778405,
                "title": "java-simple-approach-with-explanation-runtime-1-ms-100-faster",
                "content": "### Please upvote if you like the solution\\n\\n```\\nclass Solution {\\n    \\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] arr, int target) {\\n            \\n        getTargetCombination(arr, 0, target, new ArrayList<Integer>());\\n        return resultList;\\n    }\\n    \\n    \\n    public void getTargetCombination(int[] arr, int position, int currentTarget, List<Integer> result) {\\n\\n        /**\\n         * Base case\\n         * 1. If currentTarget is reaching to Zero\\n         * 2. Current Position is equal to the length of the Array\\n         */\\n        if (currentTarget == 0) {\\n            resultList.add(new ArrayList<>(result));\\n            return;\\n        }\\n        if (position == arr.length) {\\n            return;\\n        }\\n\\n        /**\\n         * There are two cases\\n         * 1. Pick the current value if the current value (i.e arr[position]) is less than or equal to the currentTarget\\n         *    value then use the same attribute by passing the same position\\n         *\\n         *  2. Not picking up the current element by not reducing the currentTarget value and increasing the position\\n         */\\n        if (arr[position] <= currentTarget) {\\n            result.add(arr[position]);\\n            getTargetCombination(arr, position, currentTarget - arr[position], result);\\n            // removing the last element because post adding of the value the call came back\\n            result.remove(result.size() - 1);\\n        }\\n        // not picked\\n        getTargetCombination(arr, position + 1, currentTarget, result);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] arr, int target) {\\n            \\n        getTargetCombination(arr, 0, target, new ArrayList<Integer>());\\n        return resultList;\\n    }\\n    \\n    \\n    public void getTargetCombination(int[] arr, int position, int currentTarget, List<Integer> result) {\\n\\n        /**\\n         * Base case\\n         * 1. If currentTarget is reaching to Zero\\n         * 2. Current Position is equal to the length of the Array\\n         */\\n        if (currentTarget == 0) {\\n            resultList.add(new ArrayList<>(result));\\n            return;\\n        }\\n        if (position == arr.length) {\\n            return;\\n        }\\n\\n        /**\\n         * There are two cases\\n         * 1. Pick the current value if the current value (i.e arr[position]) is less than or equal to the currentTarget\\n         *    value then use the same attribute by passing the same position\\n         *\\n         *  2. Not picking up the current element by not reducing the currentTarget value and increasing the position\\n         */\\n        if (arr[position] <= currentTarget) {\\n            result.add(arr[position]);\\n            getTargetCombination(arr, position, currentTarget - arr[position], result);\\n            // removing the last element because post adding of the value the call came back\\n            result.remove(result.size() - 1);\\n        }\\n        // not picked\\n        getTargetCombination(arr, position + 1, currentTarget, result);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16656,
                "title": "dynamic-programming-solution",
                "content": "It adapts the DP solution of coin change problem\\n\\n    class Solution {\\n    public:\\n    \\tvector<vector<int> > combinationSum(vector<int> &candidates, int target) {\\n    \\t\\tvector< vector< vector<int> > > combinations(target + 1, vector<vector<int>>());\\n    \\t\\tcombinations[0].push_back(vector<int>());\\n    \\t\\tfor (auto& score : candidates)\\n    \\t\\t\\tfor (int j = score; j <= target; j++)\\n    \\t\\t\\t\\tif (combinations[j - score].size() > 0)\\t{\\n    \\t\\t\\t\\t\\tauto tmp = combinations[j - score];\\n    \\t\\t\\t\\t\\tfor (auto& s : tmp)\\n    \\t\\t\\t\\t\\t\\ts.push_back(score);\\n    \\t\\t\\t\\t\\tcombinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end());\\n    \\t\\t\\t\\t}\\n    \\t\\tauto ret = combinations[target];\\n    \\t\\tfor (int i = 0; i < ret.size(); i++)\\n    \\t\\t\\tsort(ret[i].begin(), ret[i].end());\\n    \\t\\treturn ret;\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvector<vector<int> > combinationSum(vector<int> &candidates, int target) {\\n    \\t\\tvector< vector< vector<int> > > combinations(target + 1, vector<vector<int>>());\\n    \\t\\tcombinations[0].push_back(vector<int>());\\n    \\t\\tfor (auto& score : candidates)\\n    \\t\\t\\tfor (int j = score; j <= target; j++)\\n    \\t\\t\\t\\tif (combinations[j - score].size() > 0)\\t{\\n    \\t\\t\\t\\t\\tauto tmp = combinations[j - score];\\n    \\t\\t\\t\\t\\tfor (auto& s : tmp)\\n    \\t\\t\\t\\t\\t\\ts.push_back(score);\\n    \\t\\t\\t\\t\\tcombinations[j].insert(combinations[j].end(), tmp.begin(), tmp.end());\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 307982,
                "title": "heavily-commented-javascript-backtracking-solution",
                "content": "Here\\'s my heavily commented version, as I didn\\'t see many of those around yet.\\nI left the console.log in there, to help with getting the order of the execution.\\nRemove it for better performance.\\n\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n        console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else if (t < 0) {\\n            console.log(\\'Dead path. Will our code actually ever get here?\\');\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                find(t - candidates[i], [...p, candidates[i]], i)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 // further, because of the 2nd check of the while loop condition.\\n                i++;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n        console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else if (t < 0) {\\n            console.log(\\'Dead path. Will our code actually ever get here?\\');\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                find(t - candidates[i], [...p, candidates[i]], i)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 // further, because of the 2nd check of the while loop condition.\\n                i++;\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815714,
                "title": "dfs-recursion-solution-with-illustration-to-understand-the-process",
                "content": "I\\'m using candidates[2,3,5] and target 8 as example. \\nIt\\'s pretty clear with the chart below how the function dfs is called recursively and how duplications like [3,5], [5,3] is avoided.\\nSome solutions sorted the candidates first, and some also have a if statement on if target <0. Both are not necessary.\\nAlso, I acutally found that sort the candidates may increase the number of operations. You can draw a similar chart with [5,3,2]. It has fewer operations. See codes following the chart below.\\n![image](https://assets.leetcode.com/users/images/600da56f-c155-40b7-bb44-186257125966_1598579025.1168523.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        self.dfs(candidates, target,[],res)\\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            self.dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "I\\'m using candidates[2,3,5] and target 8 as example. \\nIt\\'s pretty clear with the chart below how the function dfs is called recursively and how duplications like [3,5], [5,3] is avoided.\\nSome solutions sorted the candidates first, and some also have a if statement on if target <0. Both are not necessary.\\nAlso, I acutally found that sort the candidates may increase the number of operations. You can draw a similar chart with [5,3,2]. It has fewer operations. See codes following the chart below.\\n![image](https://assets.leetcode.com/users/images/600da56f-c155-40b7-bb44-186257125966_1598579025.1168523.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        self.dfs(candidates, target,[],res)\\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            self.dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 16669,
                "title": "c-backtracking-implementation",
                "content": "C# backtracking implementation\\n\\n        public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n        {\\n            List<IList<int>> result = new List<IList<int>>();\\n            List<int> combination = new List<int>();\\n            Array.Sort(candidates);\\n            CombinationSum(result, candidates, combination, target, 0);\\n            return result;\\n        }\\n\\n        private void CombinationSum(IList<IList<int>> result, int[] candidates, IList<int> combination, int target, int start)\\n        {\\n            if (target == 0)\\n            {\\n                result.Add(new List<int>(combination));\\n                return;\\n            }\\n\\n            for (int i = start; i != candidates.Length && target >= candidates[i]; ++i)\\n            {\\n                combination.Add(candidates[i]);\\n                CombinationSum(result, candidates, combination, target - candidates[i], i);\\n                combination.Remove(combination.Last());\\n            }\\n        }",
                "solutionTags": [],
                "code": "C# backtracking implementation\\n\\n        public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n        {\\n            List<IList<int>> result = new List<IList<int>>();\\n            List<int> combination = new List<int>();\\n            Array.Sort(candidates);\\n            CombinationSum(result, candidates, combination, target, 0);\\n            return result;\\n        }\\n\\n        private void CombinationSum(IList<IList<int>> result, int[] candidates, IList<int> combination, int target, int start)\\n        {\\n            if (target == 0)\\n            {\\n                result.Add(new List<int>(combination));\\n                return;\\n            }\\n\\n            for (int i = start; i != candidates.Length && target >= candidates[i]; ++i)\\n            {\\n                combination.Add(candidates[i]);\\n                CombinationSum(result, candidates, combination, target - candidates[i], i);\\n                combination.Remove(combination.Last());\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3237600,
                "title": "c-beats-100-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    void solve(int target,vector<int> &candidates,vector<vector<int>> &ans,int index)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            if(target-candidates[i]>=0)\\n               solve(target-candidates[i],candidates,ans,i);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        solve(target,candidates,ans,0);\\n        return ans;\\n    }\\n};\\n\\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/a9a3382a-a1b3-4c13-a59c-e5e41a1ca8fe_1677523515.9827046.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> temp;\\n    void solve(int target,vector<int> &candidates,vector<vector<int>> &ans,int index)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return ;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            if(target-candidates[i]>=0)\\n               solve(target-candidates[i],candidates,ans,i);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        solve(target,candidates,ans,0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920513,
                "title": "python",
                "content": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```\\n```",
                "solutionTags": [],
                "code": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1546400,
                "title": "java-backtracking-w-early-exit-detailed-time-complexity-explanation-added",
                "content": "**Backtracking - No Early Exit optimization**\\n```\\n/**\\n * Since this question allows same number to be used unlimited times, candidates\\n * array cannot have zero and negative numbers. As it will lead to infinite\\n * number of combinations. For example: candidates = [-1, 0, 1] and target = 1.\\n * This case will result in infinite solutions if same number can be used\\n * multiple times.\\n *\\n * Time Complexity:\\n * This problem can be converted to Combination Sum II. For example, candidates = [2,3,5,6] and target = 12.\\n * Then we can create an array = [2,2,2,2,2,2, 3,3,3,3, 5,5, 6,6].\\n * Now from this array we can use each number only once in the combination.\\n * Therefore total number of elements in this array N\\' equal to floor(T/n1) + floor(T/n2) + ... + floor(T/nN)\\n *\\n * 1. The length of the potential combinations can vary from 1 to k where k = T/M.\\n * 2. Total number of combinations of size k is C(N\\',k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N\\',1) + 2*C(N\\',2) + ... + k*C(N\\',k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N\\', i)).\\n * If k = N\\', then above time complexity becomes O(N\\' * 2^(N\\'-1))\\n *\\n * Space Complexity: O(T/M) -> This is used by recursion stack and temp list.\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                continue;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Backtracking - With Early Exit optimization**\\n```java\\n/**\\n * In this solution we are sorting the input array, which allows us to early\\n * exit from the recursion if the current number is greater than the remaining\\n * target.\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * the time and space required for the sorting.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n        // Only benefit of sorting is that we can break early in the recursion if the\\n        // current number is greater than the remaining target.\\n        Arrays.sort(candidates);\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/1546439/Java-or-Backtracking-optimized-for-duplicate-candidates-(Detailed-TC-explanation-added))\\n- [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/1546449/Java-or-Optimized-Backtracking-w-Detailed-Time-Complexity-explanation)\\n- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/discuss/1546467/Java-or-TC:-O(N*T)-or-SC:-O(T)-or-DP-(BottomUp-and-TopDown)-w-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * Since this question allows same number to be used unlimited times, candidates\\n * array cannot have zero and negative numbers. As it will lead to infinite\\n * number of combinations. For example: candidates = [-1, 0, 1] and target = 1.\\n * This case will result in infinite solutions if same number can be used\\n * multiple times.\\n *\\n * Time Complexity:\\n * This problem can be converted to Combination Sum II. For example, candidates = [2,3,5,6] and target = 12.\\n * Then we can create an array = [2,2,2,2,2,2, 3,3,3,3, 5,5, 6,6].\\n * Now from this array we can use each number only once in the combination.\\n * Therefore total number of elements in this array N\\' equal to floor(T/n1) + floor(T/n2) + ... + floor(T/nN)\\n *\\n * 1. The length of the potential combinations can vary from 1 to k where k = T/M.\\n * 2. Total number of combinations of size k is C(N\\',k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N\\',1) + 2*C(N\\',2) + ... + k*C(N\\',k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N\\', i)).\\n * If k = N\\', then above time complexity becomes O(N\\' * 2^(N\\'-1))\\n *\\n * Space Complexity: O(T/M) -> This is used by recursion stack and temp list.\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                continue;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * In this solution we are sorting the input array, which allows us to early\\n * exit from the recursion if the current number is greater than the remaining\\n * target.\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * the time and space required for the sorting.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0 || target <= 0) {\\n            return result;\\n        }\\n        // Only benefit of sorting is that we can break early in the recursion if the\\n        // current number is greater than the remaining target.\\n        Arrays.sort(candidates);\\n        combinationSumHelper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSumHelper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSumHelper(candidates, i, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254479,
                "title": "20ms-cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target, int fm = 0) {\\n        if (target == 0){\\n            return {{}};\\n        }\\n        vector<vector<int>> res;\\n        for (int i = fm; i < candidates.size(); i++){\\n            if (target < candidates[i])\\n                continue;\\n\\n            for (vector<int> &b : combinationSum(candidates, target - candidates[i], i)){\\n                b.push_back(candidates[i]);\\n                res.push_back(b);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target, int fm = 0) {\\n        if (target == 0){\\n            return {{}};\\n        }\\n        vector<vector<int>> res;\\n        for (int i = fm; i < candidates.size(); i++){\\n            if (target < candidates[i])\\n                continue;\\n\\n            for (vector<int> &b : combinationSum(candidates, target - candidates[i], i)){\\n                b.push_back(candidates[i]);\\n                res.push_back(b);\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16724,
                "title": "java-solution-backtracking",
                "content": "    public class Solution {\\n     \\n    \\tprivate List<List<Integer>> solution;\\n    \\n    \\tprivate List<Integer> curSolution;\\n    \\n    \\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\t\\tsolution = new ArrayList<List<Integer>>();\\n    \\t\\tcurSolution = new ArrayList<Integer>();\\n    \\t\\tArrays.sort(candidates);\\n    \\t\\tbackTrack(candidates, target, 0); \\n    \\t\\treturn solution;\\n    \\t}\\n    \\n    \\tprivate void backTrack(int[] candidates, int target, int lastIdx) {\\n    \\t\\tif (target == 0) {\\n    \\t\\t\\tsolution.add(new ArrayList<>(curSolution));\\n    \\t\\t}\\n    \\t\\telse if (target < 0) {\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\telse {\\n    \\t\\t\\tint i = lastIdx;\\n    \\t\\t\\twhile (i < candidates.length) {\\n    \\t\\t\\t\\tint candidate = candidates[i];\\n    \\t\\t\\t\\tcurSolution.add(candidate);\\n    \\t\\t\\t\\tbackTrack(candidates, target - candidate, i);\\n    \\t\\t\\t\\tcurSolution.remove(curSolution.size() - 1);\\n    \\t\\t\\t\\twhile (i < candidates.length && candidates[i] == candidate) {\\n    \\t\\t\\t\\t\\ti++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n     \\n    \\tprivate List<List<Integer>> solution;\\n    \\n    \\tprivate List<Integer> curSolution;\\n    \\n    \\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\t\\tsolution = new ArrayList<List<Integer>>();\\n    \\t\\tcurSolution = new ArrayList<Integer>();\\n    \\t\\tArrays.sort(candidates);\\n    \\t\\tbackTrack(candidates, target, 0); \\n    \\t\\treturn solution;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 16559,
                "title": "non-recursive-java-solution",
                "content": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        int i=0, size = candidates.length, sum=0;\\n        Stack<Integer> combi = new Stack<>(), indices = new Stack<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        while (i < size) {\\n        \\tif (sum + candidates[i]>= target) {\\n        \\t\\tif (sum + candidates[i] == target) {\\n        \\t\\t\\tcombi.push(candidates[i]);\\n        \\t\\t\\tresult.add(new ArrayList<>(combi));\\n        \\t\\t\\tcombi.pop();\\n        \\t\\t}\\n        \\t\\t// indices stack and combination stack should have the same size all the time\\n        \\t\\tif (!indices.empty()){\\n        \\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\ti = indices.pop();\\n        \\t\\t\\twhile (i == size-1 && !indices.empty()) {\\n        \\t\\t\\t\\ti = indices.pop();\\n        \\t\\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\t\\t\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t} else {\\n        \\t\\tcombi.push(candidates[i]);\\n        \\t\\tsum +=candidates[i];\\n        \\t\\tindices.push(i);\\n        \\t}\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Stack"
                ],
                "code": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        int i=0, size = candidates.length, sum=0;\\n        Stack<Integer> combi = new Stack<>(), indices = new Stack<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        while (i < size) {\\n        \\tif (sum + candidates[i]>= target) {\\n        \\t\\tif (sum + candidates[i] == target) {\\n        \\t\\t\\tcombi.push(candidates[i]);\\n        \\t\\t\\tresult.add(new ArrayList<>(combi));\\n        \\t\\t\\tcombi.pop();\\n        \\t\\t}\\n        \\t\\t// indices stack and combination stack should have the same size all the time\\n        \\t\\tif (!indices.empty()){\\n        \\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\ti = indices.pop();\\n        \\t\\t\\twhile (i == size-1 && !indices.empty()) {\\n        \\t\\t\\t\\ti = indices.pop();\\n        \\t\\t\\t\\tsum -= combi.pop();\\n        \\t\\t\\t\\t\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t} else {\\n        \\t\\tcombi.push(candidates[i]);\\n        \\t\\tsum +=candidates[i];\\n        \\t\\tindices.push(i);\\n        \\t}\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1960396,
                "title": "java-98-fast-backtracking-and-recursion-full-explanation-with-comments",
                "content": "```\\n// Intuition behind this solution is thinking that \"CAN WE TAKE THE ELEMENT\" or \"NOT TAKING IT\" .\\n// By the above logic we can draw recursion tree\\n\\n/* \\n\\nNOTE : we can take any element any number of times in Combination sum 1\\nEX : [2,3,6,7] target = 7\\nans : [ [2,2,3] , [7] ]\\nSuppose calling function : funct(index,target,List<Integer> ds)\\nLeft tree : we are taking the element \\nRight tree : we are not\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2           3        6        7\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \\t  /   \\\\\\n                                       [0,5,{2}]  [i+1,7,{}]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /     \\\\\\n\\t\\t\\t\\t\\t    [0,3,{2,2}]    [i+1,5,{2}]\\n\\t\\t\\t\\t\\t\\t/     \\\\ \\n\\t\\t\\t [0,1,{2,2,2}]      [i+1,3,{2,2}]\\n\\t             /  \\\\                /   \\\\ \\n         Here  t = 0\\t    [1,0,{2,2,3}] = This is one of our answers\\n\\t\\t\\nLike that recursion tree will run and stops when i becomes arr.length and you can also stop at t becomes zero because then it will not be possible to take that element\\t\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] a, int t) {\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        List<Integer> ls = new ArrayList<>();  // our inside list to store different combinations\\n        int index = 0; // starting from index 0\\n        combSum(index,ans,a,t,ls); // recursive function\\n        return ans;\\n    }\\n    static void combSum(int i,List<List<Integer>>ans,int a[],int t,List<Integer> ds) {\\n        // Base condition\\n\\t\\tif(i == a.length) {\\n            if(t == 0) {\\n                ans.add(new ArrayList<>(ds)); // ArrayList constructor constructs a list of specified collection . in our case it is List<Integer> ds\\n            }\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// Check if the element at index is smaller than the target or not\\n        if(a[i] <= t) {\\n            ds.add(a[i]);\\n            combSum(i,ans,a,t-a[i],ds); // calls for same index and decreasing target by a[i]\\n            ds.remove(ds.size()-1); // during backtracking we will remove the added element in ds\\n        }\\n        combSum(i+1,ans,a,t,ds); // call for next index\\n    }\\n}\\n\\n/* Its time complexity will be : 2^target * k  ( k = putting ds in ans in base case )\\n\\nNOTE:  We are taking 2^target not 2^n because if we were allowed to take element only once(i.e in combination sum2) we can have n times pick/non-pick choices thats why its time complexity will be ( 2^n *k ) but here we are having a  choice to take one element multiple times . \\n\\nfor example : number = 2 , target = 10 we can pick/non-pick element 2 till t times \\nand if we distribute 2^t for n elements we can say on an average its time complexity will be 2^t\\n\\nSpace Complexity will be : ( k * x ) ( k = average length and x combinations ) ( Its totally dependent upon given conditions) */\\n\\n// Upvote if you like the explanation \\uD83D\\uDC4D\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Intuition behind this solution is thinking that \"CAN WE TAKE THE ELEMENT\" or \"NOT TAKING IT\" .\\n// By the above logic we can draw recursion tree\\n\\n/* \\n\\nNOTE : we can take any element any number of times in Combination sum 1\\nEX : [2,3,6,7] target = 7\\nans : [ [2,2,3] , [7] ]\\nSuppose calling function : funct(index,target,List<Integer> ds)\\nLeft tree : we are taking the element \\nRight tree : we are not\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2           3        6        7\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     \\t  /   \\\\\\n                                       [0,5,{2}]  [i+1,7,{}]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /     \\\\\\n\\t\\t\\t\\t\\t    [0,3,{2,2}]    [i+1,5,{2}]\\n\\t\\t\\t\\t\\t\\t/     \\\\ \\n\\t\\t\\t [0,1,{2,2,2}]      [i+1,3,{2,2}]\\n\\t             /  \\\\                /   \\\\ \\n         Here  t = 0\\t    [1,0,{2,2,3}] = This is one of our answers\\n\\t\\t\\nLike that recursion tree will run and stops when i becomes arr.length and you can also stop at t becomes zero because then it will not be possible to take that element\\t\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] a, int t) {\\n        List<List<Integer>> ans = new ArrayList<>(); // ans list\\n        List<Integer> ls = new ArrayList<>();  // our inside list to store different combinations\\n        int index = 0; // starting from index 0\\n        combSum(index,ans,a,t,ls); // recursive function\\n        return ans;\\n    }\\n    static void combSum(int i,List<List<Integer>>ans,int a[],int t,List<Integer> ds) {\\n        // Base condition\\n\\t\\tif(i == a.length) {\\n            if(t == 0) {\\n                ans.add(new ArrayList<>(ds)); // ArrayList constructor constructs a list of specified collection . in our case it is List<Integer> ds\\n            }\\n            return;\\n        }\\n\\t\\t\\n\\t\\t// Check if the element at index is smaller than the target or not\\n        if(a[i] <= t) {\\n            ds.add(a[i]);\\n            combSum(i,ans,a,t-a[i],ds); // calls for same index and decreasing target by a[i]\\n            ds.remove(ds.size()-1); // during backtracking we will remove the added element in ds\\n        }\\n        combSum(i+1,ans,a,t,ds); // call for next index\\n    }\\n}\\n\\n/* Its time complexity will be : 2^target * k  ( k = putting ds in ans in base case )\\n\\nNOTE:  We are taking 2^target not 2^n because if we were allowed to take element only once(i.e in combination sum2) we can have n times pick/non-pick choices thats why its time complexity will be ( 2^n *k ) but here we are having a  choice to take one element multiple times . \\n\\nfor example : number = 2 , target = 10 we can pick/non-pick element 2 till t times \\nand if we distribute 2^t for n elements we can say on an average its time complexity will be 2^t\\n\\nSpace Complexity will be : ( k * x ) ( k = average length and x combinations ) ( Its totally dependent upon given conditions) */\\n\\n// Upvote if you like the explanation \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177891,
                "title": "java-100-fastest-solution",
                "content": "```\\nclass Solution {\\n    \\n     void findAllways(int[] candidates,List<List<Integer>> finalList,ArrayList<Integer> list,int i,int target){\\n        if(target == 0)\\n            finalList.add(new ArrayList<Integer>(list));\\n        else{\\n            for(int j=i;j<candidates.length;j++)\\n            {\\n                if(candidates[j]<=target){\\n                list.add(candidates[j]);\\n                findAllways(candidates,finalList,list,j,target-candidates[j]);\\n                list.remove(list.size()-1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\n        List<List<Integer>> finalList = new ArrayList<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        findAllways(candidates,finalList,list,0,target);\\n        \\n        return finalList;\\n    }\\n    \\n}\\n``\\nPlease upvotes if find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n     void findAllways(int[] candidates,List<List<Integer>> finalList,ArrayList<Integer> list,int i,int target){\\n        if(target == 0)\\n            finalList.add(new ArrayList<Integer>(list));\\n        else{\\n            for(int j=i;j<candidates.length;j++)\\n            {\\n                if(candidates[j]<=target){\\n                list.add(candidates[j]);\\n                findAllways(candidates,finalList,list,j,target-candidates[j]);\\n                list.remove(list.size()-1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 371715,
                "title": "python-dynamic-programming-beats-99",
                "content": "I\\'m sharing both my recursive and dynamic programming solutions. The DP approach is about three times faster.\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # return self.combinationSumRecurisve(candidates, target, [])\\n        return self.combinationSumDP(candidates, target)\\n    \\n    def combinationSumDP(self, candidates, target):\\n        dp = {}\\n        dp[0] = [[]]\\n        candidates.sort()\\n        for c in candidates:\\n            for t in range(c, target + 1):\\n                if (t-c) in dp:\\n                    if t not in dp:\\n                        dp[t] = []\\n                    for comb_t_m_c in dp[t-c]:\\n                        dp[t].append(comb_t_m_c + [c])\\n        return dp[target] if target in dp else []\\n        \\n    \\n    def combinationSumRecurisve(self, candidates, target, curr_nums):\\n        if target == 0:\\n            return [curr_nums]\\n        \\n        if len(candidates) == 0 or target <= 0:\\n            return []\\n        \\n        c = candidates[0]\\n        sol = self.combinationSumRecurisve(candidates[1:], target, curr_nums)\\n        sol.extend(self.combinationSumRecurisve(candidates, target - c, curr_nums + [c]))\\n        return sol\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # return self.combinationSumRecurisve(candidates, target, [])\\n        return self.combinationSumDP(candidates, target)\\n    \\n    def combinationSumDP(self, candidates, target):\\n        dp = {}\\n        dp[0] = [[]]\\n        candidates.sort()\\n        for c in candidates:\\n            for t in range(c, target + 1):\\n                if (t-c) in dp:\\n                    if t not in dp:\\n                        dp[t] = []\\n                    for comb_t_m_c in dp[t-c]:\\n                        dp[t].append(comb_t_m_c + [c])\\n        return dp[target] if target in dp else []\\n        \\n    \\n    def combinationSumRecurisve(self, candidates, target, curr_nums):\\n        if target == 0:\\n            return [curr_nums]\\n        \\n        if len(candidates) == 0 or target <= 0:\\n            return []\\n        \\n        c = candidates[0]\\n        sol = self.combinationSumRecurisve(candidates[1:], target, curr_nums)\\n        sol.extend(self.combinationSumRecurisve(candidates, target - c, curr_nums + [c]))\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16735,
                "title": "share-my-15-line-dfs-java-code",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            Arrays.sort(candidates);\\n            dfs(ans, new ArrayList<Integer>(), candidates, target, 0);\\n            return ans;\\n        }\\n        \\n        private void dfs(List<List<Integer>> ans, List<Integer> list, int[] cand, int remain, int from) {\\n            if (remain < 0) { return; }\\n            if (remain == 0) { ans.add(new ArrayList<Integer>(list)); return; }\\n            for (int i=from; i<cand.length; ++i) {  //cand[] sorted; from is the starting point of picking elements at this level\\n                list.add(cand[i]);\\n                dfs(ans, list, cand, remain-cand[i], i);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            Arrays.sort(candidates);\\n            dfs(ans, new ArrayList<Integer>(), candidates, target, 0);\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 16814,
                "title": "simple-and-fast-dfs-solution-python-ac-98ms",
                "content": "    class Solution:\\n    # @param candidates, a list of integers\\n    # @param target, integer\\n    # @return a list of lists of integers\\n    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        stack = [(0, 0, [])]\\n        result = []\\n        while stack:\\n            total, start, res = stack.pop()\\n            if total == target:\\n                result.append(res)\\n            for n in range(start, len(candidates)):\\n                t = total + candidates[n]\\n                if t > target:\\n                    break\\n                stack.append((t, n, res + [candidates[n]]))\\n        return result\\n\\nJAVA\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        Stack<ArrayList<Integer>> stack = new Stack<ArrayList<Integer>>();\\n        Stack<Integer> sum = new Stack<Integer>();\\n        Stack<Integer> start = new Stack<Integer>();\\n        stack.push(new ArrayList<Integer>());\\n        sum.push(0);\\n        start.push(0);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        while (!stack.isEmpty()) {\\n            List<Integer> res = stack.pop();\\n            int total = sum.pop();\\n            int begin = start.pop();\\n            if (total == target)\\n                result.add(res);\\n            else {\\n                for (int i = begin; i < candidates.length; i++) {\\n                    int t = total + candidates[i];\\n                    if (t > target)\\n                        break;\\n                    ArrayList<Integer> r = new ArrayList<Integer>(res);\\n                    r.add(candidates[i]);\\n                    stack.push(r);\\n                    sum.push(t);\\n                    start.push(i);\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param candidates, a list of integers\\n    # @param target, integer\\n    # @return a list of lists of integers\\n    def combinationSum(self, candidates, target):\\n        candidates.sort()\\n        stack = [(0, 0, [])]\\n        result = []\\n        while stack:\\n            total, start, res = stack.pop()\\n            if total == target:\\n                result.append(res)\\n            for n in range(start, len(candidates)):\\n                t = total + candidates[n]\\n                if t > target:\\n                    break\\n                stack.append((t, n, res + [candidates[n]]))\\n        return result\\n\\nJAVA\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        Stack<ArrayList<Integer>> stack = new Stack<ArrayList<Integer>>();\\n        Stack<Integer> sum = new Stack<Integer>();\\n        Stack<Integer> start = new Stack<Integer>();\\n        stack.push(new ArrayList<Integer>());\\n        sum.push(0);\\n        start.push(0);\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        while (!stack.isEmpty()) {\\n            List<Integer> res = stack.pop();\\n            int total = sum.pop();\\n            int begin = start.pop();\\n            if (total == target)\\n                result.add(res);\\n            else {\\n                for (int i = begin; i < candidates.length; i++) {\\n                    int t = total + candidates[i];\\n                    if (t > target)\\n                        break;\\n                    ArrayList<Integer> r = new ArrayList<Integer>(res);\\n                    r.add(candidates[i]);\\n                    stack.push(r);\\n                    sum.push(t);\\n                    start.push(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3696459,
                "title": "backtraking-4-connected-problems",
                "content": "# 1.combination sum\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def dfs(candidates,target,path,res):\\n            if target==0:\\n                res.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n        dfs(candidates,target,[],res)\\n        return res\\n```\\n# 2.combination sum II\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\\n# 3. permutation\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```\\n# 4. Restore IP Address\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:\\n                ans.append(temp[:-1])\\n                return\\n            if k==4 or len(s)==0:\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s):\\n                    break\\n                if int(s[:i+1])>255:\\n                    continue\\n                if i!=0 and s[0]==\"0\":\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  \\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```\\n# please upvote me it would encourage me alot\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def dfs(candidates,target,path,res):\\n            if target==0:\\n                res.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                dfs(candidates[i:],target-candidates[i],path+[candidates[i]],res)\\n        dfs(candidates,target,[],res)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        def back(nums,ans,temp):\\n            if len(nums)==0:\\n                ans.append(temp)\\n                return \\n            for i in range(len(nums)):\\n                back(nums[:i]+nums[i+1:],ans,temp+[nums[i]])\\n        ans=[]\\n        back(nums,ans,[])\\n        return ans\\n```\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        ans,k=[],0\\n        def back(s,ans,k,temp=\\'\\'):\\n            if k==4 and len(s)==0:\\n                ans.append(temp[:-1])\\n                return\\n            if k==4 or len(s)==0:\\n                return \\n            for i in range(3):\\n                if k>4 or i+1>len(s):\\n                    break\\n                if int(s[:i+1])>255:\\n                    continue\\n                if i!=0 and s[0]==\"0\":\\n                    continue\\n                back(s[i+1:],ans,k+1,temp+s[:i+1]+\\'.\\')  \\n            return ans\\n        return back(s,ans,k,\\'\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090390,
                "title": "very-easy-c-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply do recursion and generate all the possible combinations to check if that combination result in target if not backtrack.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe ca use backtracking like the same way we generate all the sub sets of array here the thing is we have to check if the sum of that subset result in target or not . And also we should check repeatedly for the same element also so not call for i+1 instead i.\\n# Complexity\\n- Time complexity:$$O(n*2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,int rem,vector<int>&temp){\\n        if(rem<0)return;\\n        if(rem==0)ans.push_back(temp);\\n\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i,rem-arr[i],temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int>temp;\\n        backtrack(candidates,0,target,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,int rem,vector<int>&temp){\\n        if(rem<0)return;\\n        if(rem==0)ans.push_back(temp);\\n\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i,rem-arr[i],temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int>temp;\\n        backtrack(candidates,0,target,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060713,
                "title": "c-faster-than-100-00-super-clear-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t\\tvector<int>cur_path;\\n\\t\\t\\tlen = candidates.size();\\n\\t\\t\\tdfs ( candidates, target, cur_path, 0 );\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\n\\tprivate:\\n\\t\\tvector<vector<int>> ans;\\n\\t\\tint len;\\n\\t\\t\\n\\t\\tvoid dfs ( vector<int> &candidates, int target, vector<int> &cur_path, int start )\\n\\t\\t{\\n\\t\\t\\tif ( target < 0 ) return;\\n\\t\\t\\tif ( target == 0 )\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(cur_path);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor ( ; start < len; ++start )\\n\\t\\t\\t{\\n\\t\\t\\t\\tcur_path.push_back( candidates[start] );\\n\\t\\t\\t\\tdfs ( candidates, target - candidates[start], cur_path, start );\\n\\t\\t\\t\\tcur_path.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t\\tvector<int>cur_path;\\n\\t\\t\\tlen = candidates.size();\\n\\t\\t\\tdfs ( candidates, target, cur_path, 0 );\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 632799,
                "title": "three-python-solutions-dp-bfs-backtrack-with-explanation-time-beats-88",
                "content": "### DP\\nConstruct a 1d table for recording combinations in a bottom-up manner. Time O(mn) where m denotes the number of candidates and n is the target.\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tcache = [[] for _ in range(target + 1)]\\n\\tcache[0] = [[]]\\n\\tfor c in candidates:\\n\\t\\tfor i in range(target + 1):\\n\\t\\t\\tif i >= c:\\n\\t\\t\\t\\tfor temp_ans in cache[i - c]:\\n\\t\\t\\t\\t\\tcache[i].append(temp_ans + [c])\\n\\treturn cache[-1]\\n```\\n###  BFS\\nBasic idea is similar to [279. Perfect Squares](https://leetcode.com/problems/perfect-squares/)\\nFor each element pop from the queue, and for each possible candidates, minus it from the current target. If the result equals zeros then we get a solution; if the result is greater than zero then we keep push it into the queue; if the result is smaller than zero than we just stop proceeding there.\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# BFS\\n\\tfrom collections import deque\\n\\tqueue = deque() # [cur_target, cur_ans]\\n\\tqueue.append((target, [], 0))\\n\\tans = []\\n\\twhile queue:\\n\\t\\tcur_target, cur_ans, cand_idx = queue.popleft()\\n\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\tnew_target = cur_target - candidates[i]\\n\\t\\t\\tif new_target == 0:\\n\\t\\t\\t\\tans.append(cur_ans + [candidates[i]])\\n\\t\\t\\telif new_target > 0:\\n\\t\\t\\t\\tqueue.append((cur_target - candidates[i], cur_ans + [candidates[i]], i))\\n\\treturn ans\\n```\\n### Backtrack\\nThe idea is very similar to [77. Combinations](https://leetcode.com/problems/combinations/) but we need to record and pass `cur_sum`, and the base case is to check if `cur_sum` is equal to or larger than `target`. Time beats ~62%.\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tdef combination_sum(cur_ans, cur_sum, cand_idx):\\n\\t\\t\\tif cur_sum >= target:\\n\\t\\t\\t\\tif cur_sum == target:\\n\\t\\t\\t\\t\\tans.append(cur_ans)\\n\\t\\t\\t\\treturn\\n\\t\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\t\\tcombination_sum(cur_ans + [candidates[i]], cur_sum + candidates[i], i)\\n\\tans = []\\n\\tcombination_sum([], 0, 0)\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tcache = [[] for _ in range(target + 1)]\\n\\tcache[0] = [[]]\\n\\tfor c in candidates:\\n\\t\\tfor i in range(target + 1):\\n\\t\\t\\tif i >= c:\\n\\t\\t\\t\\tfor temp_ans in cache[i - c]:\\n\\t\\t\\t\\t\\tcache[i].append(temp_ans + [c])\\n\\treturn cache[-1]\\n```\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# BFS\\n\\tfrom collections import deque\\n\\tqueue = deque() # [cur_target, cur_ans]\\n\\tqueue.append((target, [], 0))\\n\\tans = []\\n\\twhile queue:\\n\\t\\tcur_target, cur_ans, cand_idx = queue.popleft()\\n\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\tnew_target = cur_target - candidates[i]\\n\\t\\t\\tif new_target == 0:\\n\\t\\t\\t\\tans.append(cur_ans + [candidates[i]])\\n\\t\\t\\telif new_target > 0:\\n\\t\\t\\t\\tqueue.append((cur_target - candidates[i], cur_ans + [candidates[i]], i))\\n\\treturn ans\\n```\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tdef combination_sum(cur_ans, cur_sum, cand_idx):\\n\\t\\t\\tif cur_sum >= target:\\n\\t\\t\\t\\tif cur_sum == target:\\n\\t\\t\\t\\t\\tans.append(cur_ans)\\n\\t\\t\\t\\treturn\\n\\t\\t\\tfor i in range(cand_idx, len(candidates)):\\n\\t\\t\\t\\tcombination_sum(cur_ans + [candidates[i]], cur_sum + candidates[i], i)\\n\\tans = []\\n\\tcombination_sum([], 0, 0)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 162348,
                "title": "backtracking-with-explanations",
                "content": ">Base case: target == 0\\n\\n>Recursive case: target > 0\\nwe try nums[i] as a candidate of current combination and decrease target by nums[i] (only if target >= candidates[i])\\n\\n>`curRes` printed for the example` candidates = [2,3,6,7], target = 7`\\n```\\n[2]\\n[2, 2]\\n[2, 2, 2]\\n[2, 2, 3]\\n[2, 3]\\n[3]\\n[3, 3]\\n[6]\\n[7]\\n```\\n****\\n```\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        if (candidates == null || candidates.length == 0)\\n            return new ArrayList<>();\\n        \\n        List<List<Integer>> allRes = new ArrayList<>();\\n        combinationSumAfter(candidates, target, new ArrayList<>(), allRes, 0);\\n        return allRes;\\n    }\\n    \\n    private void combinationSumAfter(int[] candidates, int target, List<Integer> curRes, List<List<Integer>> allRes, int start) {\\n        if (target == 0) {\\n            // Base case.\\n            allRes.add(new ArrayList<>(curRes));\\n            return;\\n        }\\n        // Recursive case.\\n        for (int i = start; i < candidates.length; i++) {\\n            if (target - candidates[i] < 0) continue;\\n            curRes.add(candidates[i]);\\n            // System.out.println(curRes);\\n            combinationSumAfter(candidates, target - candidates[i], curRes, allRes, i);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n[2]\\n[2, 2]\\n[2, 2, 2]\\n[2, 2, 3]\\n[2, 3]\\n[3]\\n[3, 3]\\n[6]\\n[7]\\n```\n```\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        if (candidates == null || candidates.length == 0)\\n            return new ArrayList<>();\\n        \\n        List<List<Integer>> allRes = new ArrayList<>();\\n        combinationSumAfter(candidates, target, new ArrayList<>(), allRes, 0);\\n        return allRes;\\n    }\\n    \\n    private void combinationSumAfter(int[] candidates, int target, List<Integer> curRes, List<List<Integer>> allRes, int start) {\\n        if (target == 0) {\\n            // Base case.\\n            allRes.add(new ArrayList<>(curRes));\\n            return;\\n        }\\n        // Recursive case.\\n        for (int i = start; i < candidates.length; i++) {\\n            if (target - candidates[i] < 0) continue;\\n            curRes.add(candidates[i]);\\n            // System.out.println(curRes);\\n            combinationSumAfter(candidates, target - candidates[i], curRes, allRes, i);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3363912,
                "title": "backtracking-with-python3-well-explantation-easy-clear",
                "content": "# Intuition:\\nThe problem requires finding all possible combinations of elements from a given list of integers such that their sum is equal to a target value. The approach is to use backtracking to generate all possible combinations and keep track of the valid ones.\\n\\n# Approach:\\nThe given code defines a class Solution and a function combinationSum that takes a list of integers and a target value as input and returns a list of lists containing all valid combinations of integers that add up to the target value.\\n\\nThe approach used is recursive backtracking. The backtracking function takes two arguments, curr which represents the current combination and i which represents the index of the next element to be added to the combination.\\n\\nInitially, the current combination is empty and the index i is set to zero. Then, for each index j starting from i, the backtracking function is called recursively with the updated combination curr+[can[j]] and the index j. This ensures that all possible combinations are explored.\\n\\nThe function also checks if the current combination sum equals the target value and adds it to the result list if it is valid.\\n\\n# Complexity:\\n# Time complexity: \\nThe time complexity of the backtracking function is O(2^n), where n is the length of the input list can. This is because there are 2^n possible combinations of elements from the input list. Therefore, the time complexity of the entire function is O(2^n) as well.\\n\\n# Space complexity: \\nThe space complexity of the backtracking function is O(n) as the maximum number of elements that can be stored in the current combination at any point is n. The space complexity of the entire function is also O(2^n) as there can be at most 2^n valid combinations.\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum(self, can: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def backtracking(curr: List[int],i:int):\\n            s=sum(curr)\\n            if s==target:\\n                res.append(curr)\\n            elif s<target:\\n                for j in range(i,len(can)):\\n                    backtracking(curr+[can[j]],j)\\n        backtracking([],0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, can: List[int], target: int) -> List[List[int]]:\\n        res=[]\\n        def backtracking(curr: List[int],i:int):\\n            s=sum(curr)\\n            if s==target:\\n                res.append(curr)\\n            elif s<target:\\n                for j in range(i,len(can)):\\n                    backtracking(curr+[can[j]],j)\\n        backtracking([],0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905794,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n^m), where n is the length of candidates and m is the target value.\\n    //   - space: O(m), where m is the target value.\\n    \\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n        \\n        backtrack(remain: target, comb: &comb, start: 0, candidates: candidates, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(remain: Int, comb: inout [Int], start: Int, candidates: [Int], ans: inout [[Int]]) {\\n        guard remain >= 0 else { return }\\n        guard remain != 0 else { ans.append(comb); return }\\n\\n        for i in start..<candidates.count {\\n            comb.append(candidates[i])\\n            backtrack(remain: remain - candidates[i], comb: &comb, start: i, candidates: candidates, ans: &ans)\\n            comb.removeLast()\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n^m), where n is the length of candidates and m is the target value.\\n    //   - space: O(m), where m is the target value.\\n    \\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var ans = [[Int]]()\\n        var comb = [Int]()\\n        \\n        backtrack(remain: target, comb: &comb, start: 0, candidates: candidates, ans: &ans)\\n        return ans\\n    }\\n\\n\\n    private func backtrack(remain: Int, comb: inout [Int], start: Int, candidates: [Int], ans: inout [[Int]]) {\\n        guard remain >= 0 else { return }\\n        guard remain != 0 else { ans.append(comb); return }\\n\\n        for i in start..<candidates.count {\\n            comb.append(candidates[i])\\n            backtrack(remain: remain - candidates[i], comb: &comb, start: i, candidates: candidates, ans: &ans)\\n            comb.removeLast()\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595577,
                "title": "my-solution",
                "content": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```",
                "solutionTags": [],
                "code": "```\\ndef comboSum(target,candidates):\\n    \\'\\'\\'\\n    1. No duplicates\\n    2. Same number can be repeated\\n    3. Same combo is not repeated\\n\\n    \\'\\'\\'\\n\\n    result = []\\n\\n    def helper(start,sum_so_far,subset,level=0):\\n        space= \\' \\'*level\\n        print(f\\'{space} {subset}\\')\\n        if sum_so_far == target:\\n            result.append(subset[::])\\n            return\\n        if sum_so_far > target:\\n            return\\n\\n        for i in range(start,len(candidates)):\\n            num = candidates[i]\\n            subset.append(num)\\n            sum_so_far +=num\\n            level+=1\\n            helper(i,sum_so_far,subset,level)\\n            level-=1\\n            sum_so_far -=num\\n            subset.pop()\\n\\n    helper(0,0,[])\\n    return result\\n\\nif __name__ == \"__main__\":\\n    candidates = [1,2,3]\\n    target = 3\\n    print(comboSum(target,candidates))\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1560722,
                "title": "java-easy-solution-100-faster-recursion-and-backtracking",
                "content": "## Combination Sum\\n\\n![image](https://assets.leetcode.com/users/images/a0d936b8-ff90-48d7-9233-1235eaadf933_1636105505.476083.png)\\n\\n\\nThere are similar questions like 2sum, 3sum, 4sum in which we were required to find a given number of elements from array whose sum is equal to target element, but in this problem we are required to find all the possible subarray or sublists.\\nThe approach for this problem is similar to other problems on finding [subsets](https://leetcode.com/problems/subsets-ii/) and [permutation](https://leetcode.com/problems/permutations/).\\n\\n**Code**\\n\\n```java\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tcombinationUtil(list, new ArrayList<>(), candidates, 0, target);\\n\\treturn list;\\n}\\n\\npublic void combinationUtil(List<List<Integer>> list, List<Integer> temp, int[] candidates, int start, int target) {\\n\\t// base case\\n\\tif(target == 0) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t// recursion step\\n\\tfor(int i = start; i < candidates.length; i++) {\\n\\t\\tif(target < candidates[i]) continue;\\n\\n\\t\\ttemp.add(candidates[i]);\\n\\t\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```\\n\\n**Explanation**\\nSo we were required to find all the sub lists in which sum of elements equal to target given and each element can be taken any number of times. \\nLet\\'s understand recursive step first\\n\\n```java\\nfor(int i = start; i < candidates.length; i++) {\\n\\tif(target < candidates[i]) continue;\\n\\n\\ttemp.add(candidates[i]);\\n\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\ttemp.remove(temp.size() - 1);\\n}\\n```\\n\\nHere I am starting from `0th index` and if the element is greater than or equal to the target then only I add that to my `temp` list otherwise `continue`, after adding to `temp` list make further call on to subarray starting from same `i` because it is given that same element can be taken as many times, so we have to consider the same element and check weather it makes a pair not.\\nThen after solving for `i` remove last element of temp and increment `i` to check for pair starting from next element. Do not forget to initialise `i` to `start` because we don\\'t want to start again from the `0th index` as that will give us duplicates.\\n\\n\\n![image](https://assets.leetcode.com/users/images/92604850-3aa5-402c-a76d-ada2b9581bfa_1636106847.534792.png)\\n\\nHope it helps\\nDo upvote\\nThanks\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\tList<List<Integer>> list = new ArrayList<>();\\n\\tcombinationUtil(list, new ArrayList<>(), candidates, 0, target);\\n\\treturn list;\\n}\\n\\npublic void combinationUtil(List<List<Integer>> list, List<Integer> temp, int[] candidates, int start, int target) {\\n\\t// base case\\n\\tif(target == 0) {\\n\\t\\tlist.add(new ArrayList<>(temp));\\n\\t\\treturn;\\n\\t}\\n\\n\\t// recursion step\\n\\tfor(int i = start; i < candidates.length; i++) {\\n\\t\\tif(target < candidates[i]) continue;\\n\\n\\t\\ttemp.add(candidates[i]);\\n\\t\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\t}\\n}\\n```\n```java\\nfor(int i = start; i < candidates.length; i++) {\\n\\tif(target < candidates[i]) continue;\\n\\n\\ttemp.add(candidates[i]);\\n\\tcombinationUtil(list, temp, candidates, i, target - candidates[i]);\\n\\ttemp.remove(temp.size() - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382280,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "```\\n   vector<vector<int>> ans;\\n    void solve(vector<int>& candidates, int target,int i,int sum,vector<int> temp)\\n    {\\n        \\n        if(target==sum )\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(sum>target || i>=candidates.size())\\n            return;\\n        temp.push_back(candidates[i]);\\n        solve(candidates,target,i,sum+candidates[i],temp);\\n        temp.pop_back();\\n        solve(candidates,target,i+1,sum,temp);\\n      \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        vector<int> temp;\\n        solve(candidates,target,0,0,temp);\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n   vector<vector<int>> ans;\\n    void solve(vector<int>& candidates, int target,int i,int sum,vector<int> temp)\\n    {\\n        \\n        if(target==sum )\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(sum>target || i>=candidates.size())\\n            return;\\n        temp.push_back(candidates[i]);\\n        solve(candidates,target,i,sum+candidates[i],temp);\\n        temp.pop_back();\\n        solve(candidates,target,i+1,sum,temp);\\n      \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        vector<int> temp;\\n        solve(candidates,target,0,0,temp);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616872,
                "title": "intuitive-javascript-solution-with-backtracking",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n  const output = [];\\n   //The goal is to use backtracking to find all combinations.\\n  const findCombination = (remain, path, start) => {\\n    if (remain < 0) {\\n      return;\\n    }\\n    if (remain === 0) {\\n      output.push([...path]);\\n      return;\\n    }\\n    for (let i = start; i < candidates.length; i++) {\\n      // create a new path array to run the subroutine. It\\'s\\n      // cleaner than pushing and then reseting the array in \\n      // javascript.\\n      findCombination(remain - candidates[i], [...path, candidates[i]], i);    \\n    }\\n  }\\n  findCombination(target, [], 0);\\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n  const output = [];\\n   //The goal is to use backtracking to find all combinations.\\n  const findCombination = (remain, path, start) => {\\n    if (remain < 0) {\\n      return;\\n    }\\n    if (remain === 0) {\\n      output.push([...path]);\\n      return;\\n    }\\n    for (let i = start; i < candidates.length; i++) {\\n      // create a new path array to run the subroutine. It\\'s\\n      // cleaner than pushing and then reseting the array in \\n      // javascript.\\n      findCombination(remain - candidates[i], [...path, candidates[i]], i);    \\n    }\\n  }\\n  findCombination(target, [], 0);\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389405,
                "title": "combination-1-method-for-6-problems-39-40-77-78-90-216",
                "content": "# Main Idea\\nAfter finishing all these problem, I found that the answers of the leetcode GOD, @caikehe, all use similar approach. So I challenge myself to try out DFS. I think DFS is more easy to understand.\\n\\nThe DFS function\\'s structure can mostly break down into\\n1. Check if it is the path we are looking for, if true, append it to the output.\\n2. Explore (loop through) all the possible next node and call its DFS and we may need to add some kind of constraints in the DFS to fullfill the requirement. For example, limit the possible next node in the next DFS, so we can only select in ascending order.\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```python\\nclass Solution(object):\\n    def combinationSum(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    num = candidates[i]\\n                    dfs(i, target-num, path+[num])\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\nThe key is to pick up number by ascending order, so we will not have duplicates.\\nIn order to do that, we use `min_i`, `min_i` means that we can only select index that is larger than `min_i`\\n\"\"\"\\n```\\n\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\\n```python\\nclass Solution(object):\\n    def combinationSum2(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    if i>min_i and candidates[i]==candidates[i-1]: continue #[2]\\n                    num = candidates[i]\\n                    dfs(i+1, target-num, path+[num]) #[1]\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\n1.\\nIn this problem, we can only select each number once.\\nThat is why we pass `i+1` to the `dfs()`.\\n\\n2.\\nAnother thing is preventing duplicates.\\nFor example, `[1,2,2,2,3]`\\nWe may end up using the first 2, the second 2, the third 2 to make 3 `[2, 3]`.\\nSo when we are looping all the possible candidates\\nWe need to `continue` if it is the not the first one in all the same element.\\nBecuase the first element is going to cover all the possibilities in its own `dfs()`.\\n\"\"\"\\n```\\n\\n[77. Combinations](https://leetcode.com/problems/combinations/)\\n```python\\nclass Solution(object):\\n    def combine(self, N, K):\\n        def dfs(min_num, path):\\n            if len(path)==K:\\n                opt.append(path)\\n                return\\n            else:\\n                for num in xrange(min_num, N+1):\\n                    dfs(num+1, path+[num])\\n        opt = []\\n        dfs(1, [])\\n        return opt\\n```\\n\\n# [90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```python\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        nums.sort()\\n\\n        def dfs(nums, path):\\n            opt.append(path)\\n            if len(nums)==0: return\\n            for i, num in enumerate(nums):\\n                if i>0 and nums[i]==nums[i-1]: continue #[0]\\n                dfs(path+[num], nums[i+1:])\\n        opt = []\\n        dfs([], nums)\\n        return opt\\n\"\"\"\\nSince there is duplicate in the `nums`, if the `num` is the same as the previous, we need to skip it.\\nBecause in the previous DFS, the out come has include the existance of current node.\\n\"\"\"\\n```\\n\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)\\n```python\\nclass Solution(object):\\n    def combinationSum3(self, K, N):\\n        def dfs(min_num, path):\\n            if len(path)==K and sum(path)==N:\\n                opt.append(path)\\n            for num in xrange(min_num, 10):\\n                dfs(path+[num], num+1)\\n        opt = []\\n        dfs([], 1)\\n        return opt\\n```\\n\\n# Big O\\nThe big O of these question are complicated and hard to analize. But according to some resource, all the combination problems are derived to be `O(2^N)`, N is the number of element. (`let s = target / min(nums[i])  T = C(s,1) + C(s, 2) + ... + C(s, s) = 2^s`) You can think of this answer as for each element it got two choices, to be chosen or not to be chosen.\\n\\nThe Space complexity is also `O(2^N)`, because we use recusive DFS. If we convert above to be iterative DFS, it may reduce to `O(N)`.\\n\\n# More Resources\\nCheck out my GitHub, https://github.com/wuduhren/leetcode-python for other topics.  \\nI really take time tried to make the best solution or explaination. Because I wanted to help others like me.  \\nIf you like my answer, a **star** on [GitHub](https://github.com/wuduhren/leetcode-python) means a lot to me.",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def combinationSum(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    num = candidates[i]\\n                    dfs(i, target-num, path+[num])\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\nThe key is to pick up number by ascending order, so we will not have duplicates.\\nIn order to do that, we use `min_i`, `min_i` means that we can only select index that is larger than `min_i`\\n\"\"\"\\n```\n```python\\nclass Solution(object):\\n    def combinationSum2(self, candidates, T):\\n        def dfs(min_i, target, path):\\n            if target<0:\\n                return\\n            elif target==0:\\n                opt.append(path)\\n            else:\\n                for i in xrange(min_i, len(candidates)):\\n                    if i>min_i and candidates[i]==candidates[i-1]: continue #[2]\\n                    num = candidates[i]\\n                    dfs(i+1, target-num, path+[num]) #[1]\\n        opt = []\\n        candidates.sort()\\n        dfs(0, T, [])\\n        return opt\\n\"\"\"\\n1.\\nIn this problem, we can only select each number once.\\nThat is why we pass `i+1` to the `dfs()`.\\n\\n2.\\nAnother thing is preventing duplicates.\\nFor example, `[1,2,2,2,3]`\\nWe may end up using the first 2, the second 2, the third 2 to make 3 `[2, 3]`.\\nSo when we are looping all the possible candidates\\nWe need to `continue` if it is the not the first one in all the same element.\\nBecuase the first element is going to cover all the possibilities in its own `dfs()`.\\n\"\"\"\\n```\n```python\\nclass Solution(object):\\n    def combine(self, N, K):\\n        def dfs(min_num, path):\\n            if len(path)==K:\\n                opt.append(path)\\n                return\\n            else:\\n                for num in xrange(min_num, N+1):\\n                    dfs(num+1, path+[num])\\n        opt = []\\n        dfs(1, [])\\n        return opt\\n```\n```python\\nclass Solution(object):\\n    def subsetsWithDup(self, nums):\\n        nums.sort()\\n\\n        def dfs(nums, path):\\n            opt.append(path)\\n            if len(nums)==0: return\\n            for i, num in enumerate(nums):\\n                if i>0 and nums[i]==nums[i-1]: continue #[0]\\n                dfs(path+[num], nums[i+1:])\\n        opt = []\\n        dfs([], nums)\\n        return opt\\n\"\"\"\\nSince there is duplicate in the `nums`, if the `num` is the same as the previous, we need to skip it.\\nBecause in the previous DFS, the out come has include the existance of current node.\\n\"\"\"\\n```\n```python\\nclass Solution(object):\\n    def combinationSum3(self, K, N):\\n        def dfs(min_num, path):\\n            if len(path)==K and sum(path)==N:\\n                opt.append(path)\\n            for num in xrange(min_num, 10):\\n                dfs(path+[num], num+1)\\n        opt = []\\n        dfs([], 1)\\n        return opt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16754,
                "title": "simple-java-solution",
                "content": "\\n    List<List<Integer>> res = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        helper(candidates, 0, target, new ArrayList<Integer>());\\n        return res;\\n    }\\n    \\n    private void helper(int[] can, int start, int target,List<Integer> each) {\\n        for (int i = start; i < can.length; i++) {\\n            List<Integer> temp = new ArrayList<>(each);\\n            if (can[i] == target) {\\n                temp.add(can[i]);\\n                res.add(temp);\\n                break;\\n            } else if (can[i] < target) {\\n                temp.add(can[i]);\\n                helper(can, i, target - can[i], new ArrayList<>(temp));\\n            } else {break;}\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    List<List<Integer>> res = new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        helper(candidates, 0, target, new ArrayList<Integer>());\\n        return res;\\n    }\\n    \\n    private void helper(int[] can, int start, int target,List<Integer> each) {\\n        for (int i = start; i < can.length; i++) {\\n            List<Integer> temp = new ArrayList<>(each);\\n            if (can[i] == target) {\\n                temp.add(can[i]);\\n                res.add(temp);\\n                break;\\n            } else if (can[i] < target) {\\n                temp.add(can[i]);\\n                helper(can, i, target - can[i], new ArrayList<>(temp));\\n            } else {break;}\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2378220,
                "title": "simple-java-solution-with-full-explanation-easy-to-understand-recursion-tree-drawn",
                "content": "```\\nPlease  \\uD83D\\uDD3C this.solution if(you understood == true)\\n```\\n\\nFirstly if we need to make anytype of choices we can use recursion like to pick the element or to not pick it :\\n\\n##### Recursive Function Call will take arguements :\\n\\n1. `index = 0`\\n2. array(candidates in this case)\\n3. target\\n4. ans `List<<List>>`\\n5. empty `List<>` \\n\\nhere like in case : [2,3,6,7] when target = 7 \\n\\n**Function Call will look Like this** : `combinationsFinder(index,arr,target,list<list<>>,list<>)`\\n\\n***Steps I took to solve:***\\n\\n1. Start from 0 index element i.e 2\\n\\n2. Now we have 2 choices either pick it or leave it (all about recursion)\\n\\n3. Like if we pick it then target will become 5 as 2 is already taken hence (target = target - candidates[i]) and then we will not increase the index as an element can be taken multiple times. We will add this to an ArrayList or Vector as per language pref. after function got called we will remove that element from the list.\\n\\n4. Second choice: if we not pick it target will remain as it is and index will increment by 1 (index = index+1). We will pass the list as it is (empty as no element added). Note: we are not picking element only if it greater than target. \\n\\n5. and lastly for the base condition (no more recursion call) if the target becomes 0 when our index reaches length of array we will add empty arrayList else return\\n\\n\\n**Recursion Tree HandDrawn (ps dont mind my drawing) :**\\n\\n![image](https://assets.leetcode.com/users/images/b152d9f9-f6ef-428b-afd5-28707474c205_1659611996.5682747.png)\\n\\n**Hope You Understood and If you all liked the explanation please upvote this Post** \\uD83D\\uDE0A\\n\\n***My Java Code is \\uD83D\\uDC47\\uD83C\\uDF55***\\n```\\n// Best Approach : Combinations - Recursion - PickNotPick\\n// Time Complexity : O(2^n*k)  -> k : length of arraylist\\n// Space Complexity : O(k)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        combinationsFinder(candidates,0,target,new ArrayList<>(),ans);\\n        \\n        return ans;\\n    }\\n    \\n    static void combinationsFinder(int[] arr,int idx,int target,List<Integer> list,List<List<Integer>> ans){\\n        \\n        if(idx == arr.length){\\n            if(target==0) ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        if(arr[idx]<=target){\\n            list.add(arr[idx]);\\n            combinationsFinder(arr,idx,target - arr[idx],list,ans);\\n            list.remove(list.size() - 1);\\n        }\\n        combinationsFinder(arr,idx+1,target,list,ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nPlease  \\uD83D\\uDD3C this.solution if(you understood == true)\\n```\n```\\n// Best Approach : Combinations - Recursion - PickNotPick\\n// Time Complexity : O(2^n*k)  -> k : length of arraylist\\n// Space Complexity : O(k)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        combinationsFinder(candidates,0,target,new ArrayList<>(),ans);\\n        \\n        return ans;\\n    }\\n    \\n    static void combinationsFinder(int[] arr,int idx,int target,List<Integer> list,List<List<Integer>> ans){\\n        \\n        if(idx == arr.length){\\n            if(target==0) ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        if(arr[idx]<=target){\\n            list.add(arr[idx]);\\n            combinationsFinder(arr,idx,target - arr[idx],list,ans);\\n            list.remove(list.size() - 1);\\n        }\\n        combinationsFinder(arr,idx+1,target,list,ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918913,
                "title": "easy-c-solution-using-recursion-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We can take an element multiple times and add them to get the target value.\\n- We\\u2019re using the help function where the base case is if the index reaches the last of our candidates array & the target became 0 then we\\u2019ll push temp to ans vector.\\n- Now there could be 2 possible cases:\\n    1. We\\u2019ll include the current element to our temp variable:\\n        - Check the current index value if it\\u2019s less than target then we can push it to temp and consider this as a part of our ans vector. Reduce the value from target.\\n        - after that we\\u2019ll pop the element from temp, as when it return from this call means that value didn\\u2019t give us expected ans.\\n    2. We won\\u2019t include the current element and move to the next element.\\n- **Time complexity:** O(2^k), where k is the sum of target/candidate[i] from i = 0 to size of candidate - 1.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        help(0, candidates, target, ans, temp);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& candidates, int target, vector<vector<int>> &ans, vector<int> &temp){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n            \\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            help(index, candidates, target-candidates[index], ans, temp);\\n            temp.pop_back();\\n        }\\n        help(index+1, candidates, target, ans, temp);\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        help(0, candidates, target, ans, temp);\\n        return ans;\\n    }\\n    \\n    void help(int index, vector<int>& candidates, int target, vector<vector<int>> &ans, vector<int> &temp){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n            \\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            help(index, candidates, target-candidates[index], ans, temp);\\n            temp.pop_back();\\n        }\\n        help(index+1, candidates, target, ans, temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875295,
                "title": "javascript-typescript-dfs-solution-w-detailed-comments",
                "content": "**javascript:**\\n```\\nfunction combinationSum(candidates, target) {\\n    // result of all combinations that sum to target\\n    var res = [];\\n\\t\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path, sum, last) {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (var i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\t\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort(function (a, b) {\\n        return a - b;\\n    });\\n\\t\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\t\\n    return res;\\n}\\n```\\n\\n**typescript:**\\n```\\nfunction combinationSum(candidates: number[], target: number): number[][] {\\n    // result of all combinations that sum to target\\n    const res: number[][] = [];\\n\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path: number[], sum: number, last: number): void {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (let i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort((a, b) => a - b);\\n\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction combinationSum(candidates, target) {\\n    // result of all combinations that sum to target\\n    var res = [];\\n\\t\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path, sum, last) {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (var i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\t\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort(function (a, b) {\\n        return a - b;\\n    });\\n\\t\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\t\\n    return res;\\n}\\n```\n```\\nfunction combinationSum(candidates: number[], target: number): number[][] {\\n    // result of all combinations that sum to target\\n    const res: number[][] = [];\\n\\n    /**\\n     * helper dfs method to generate all paths that sum to target\\n     * @param path current dfs path of numbers\\n     * @param sum current sum of numbers\\n     * @param last last index drawn\\n     */\\n    function dfs(path: number[], sum: number, last: number): void {\\n        // check if we\\'ve reached target sum (this is valid combo)\\n        if (sum === target) {\\n            // push to res and return to break\\n            res.push(path);\\n            return;\\n        }\\n\\n        // iterate thru children (candidates in this case)\\n        // except, we start at last candidate drawn, to avoid duplicates\\n        for (let i = last; i < candidates.length; i++) {\\n            // check to see if adding this candidate can contribute to sum\\n            // don\\'t do anything if it exceeds (it won\\'t be valid)\\n            if (sum + candidates[i] <= target) {\\n                // note, it\\'s important we spread path (make a copy of it)\\n                // so that all calls in recursion tree aren\\'t modifying same array\\n                dfs([...path, candidates[i]], sum + candidates[i], i);\\n            }\\n        }\\n    }\\n\\n    // sort candidates ascending. the reason why we do this is because, in our dfs,\\n    // when we\\'re going through candidates, and a number is too big for target (exceeds)\\n    // we don\\'t want to continue to the next number, it will only be bigger\\n    candidates.sort((a, b) => a - b);\\n\\n    // start dfs (initial empty path, because none visited yet, so sum also 0)\\n    dfs([], 0, 0);\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16550,
                "title": "swift-solution-backtracking",
                "content": "```\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var result = [[Int]]()\\n        var candidate = [Int]()\\n        \\n        backtracking(&result, &candidate, candidates.sorted(), target, 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[Int]], _ candidate: inout [Int], _ candidates: [Int], _ remain: Int, _ start: Int) {\\n        if remain < 0 {\\n            return\\n        } else if remain == 0 {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<candidates.count {\\n                candidate.append(candidates[i])\\n                backtracking(&result, &candidate, candidates, remain - candidates[i], i)\\n                candidate.removeLast()\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func combinationSum(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var result = [[Int]]()\\n        var candidate = [Int]()\\n        \\n        backtracking(&result, &candidate, candidates.sorted(), target, 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[Int]], _ candidate: inout [Int], _ candidates: [Int], _ remain: Int, _ start: Int) {\\n        if remain < 0 {\\n            return\\n        } else if remain == 0 {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<candidates.count {\\n                candidate.append(candidates[i])\\n                backtracking(&result, &candidate, candidates, remain - candidates[i], i)\\n                candidate.removeLast()\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16719,
                "title": "16-lines-concise-and-easy-understand-c-solution-backtracking",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, tmp, candidates, target, 0);\\n            return res;\\n        }\\n        void backtracking(vector<vector<int>>& res, vector<int>& tmp, vector<int>& candidates, int target, int index){\\n            if(target < 0) return;\\n            if(target == 0) {\\n                res.push_back(tmp);\\n                return;\\n            }\\n            for(int i = index; i < candidates.size(); i++){\\n                tmp.push_back(candidates[i]);\\n                backtracking(res, tmp, candidates, target - candidates[i], i);\\n                tmp.pop_back();\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, tmp, candidates, target, 0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 16761,
                "title": "c-backtracking-solution",
                "content": "        \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> nums;\\n        sort(candidates.begin(), candidates.end());\\n        dfs(candidates, target, 0, nums, res);\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& candidates, int target, int index, vector<int>& nums, vector<vector<int>>& res) {\\n        if (target < 0)\\n            return;\\n        if (target == 0) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        for (int i=index; i<candidates.size(); i++) {\\n            nums.push_back(candidates[i]);\\n            dfs(candidates, target-candidates[i], i, nums, res);\\n            nums.pop_back();\\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "        \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> nums;\\n        sort(candidates.begin(), candidates.end());\\n        dfs(candidates, target, 0, nums, res);\\n        return res;\\n    }\\n    \\n    void dfs(vector<int>& candidates, int target, int index, vector<int>& nums, vector<vector<int>>& res) {\\n        if (target < 0)\\n            return;\\n        if (target == 0) {\\n            res.push_back(nums);\\n            return;\\n        }\\n        for (int i=index; i<candidates.size(); i++) {\\n            nums.push_back(candidates[i]);\\n            dfs(candidates, target-candidates[i], i, nums, res);\\n            nums.pop_back();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3534868,
                "title": "c-easy-to-understand",
                "content": "### Intuition:\\nThe problem requires us to find all unique combinations of numbers from the given candidates list that add up to the target value. We can start by considering each candidate as a possible choice at each step and recursively explore all possible paths until the target is reached or exceeded.\\n\\n\\n### Approach:\\n1. Create a vector to store all the unique combinations that add up to the target value. \\n2. Create a vector to store the current combination being explored.\\n3. Define a recursive helper function that takes in the candidates list, target value, start index, current combination, and the answer vector as parameters.\\n4. If the target value is reached, add the current combination to the answer vector and return.\\n5. If the target value is exceeded, return.\\n6. For each candidate starting from the start index, add it to the current combination and recursively call the helper function with the updated target value and start index.\\n7. After returning from the recursive call, remove the last added candidate from the current combination to explore other possibilities.\\n8. Return the answer vector.\\n \\n### Complexity:\\n- Time Complexity: The time complexity of the algorithm is O(N^target), where N is the length of the candidates list and target is the target value. This is because, in the worst-case scenario, we may have to explore all possible combinations of length target. \\n- Space Complexity: The space complexity of the algorithm is O(target) because of the recursive call stack. The space required to store the answer vector and the current combination is negligible compared to the stack space.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(candidates, target, 0, curr, ans);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target, int start, vector<int>& curr, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(target < 0){\\n            return;\\n        }\\n        for(int i=start; i<candidates.size(); i++){\\n            curr.push_back(candidates[i]);\\n            helper(candidates, target-candidates[i], i, curr, ans);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n\\n```\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(candidates, target, 0, curr, ans);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target, int start, vector<int>& curr, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(target < 0){\\n            return;\\n        }\\n        for(int i=start; i<candidates.size(); i++){\\n            curr.push_back(candidates[i]);\\n            helper(candidates, target-candidates[i], i, curr, ans);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211354,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all the given integers, and T is the target value. Thus the time complexity is exponential and this is expected because the algorithm is recursive backtracking.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(T/M), where T is the target value and M is the minimal element among all other candidates.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum(candidates, target-candidates[index], output, temp, index);\\n            temp.pop_back();\\n        }\\n        combinationSum(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                temp.push_back(candidates[i]);\\n                combinationSum(candidates, target-candidates[i], output, temp, i);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum(candidates, target-candidates[index], output, temp, index);\\n            temp.pop_back();\\n        }\\n        combinationSum(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^(M/T + 1)), where N is the number of candidates, M is the smallest candidate among all\\n    the given integers, and T is the target value. Thus the time complexity is exponential and this is expected\\n    because the algorithm is recursive backtracking.\\n\\n    Space Complexity : O(T/M), where T is the target value and M is the minimal element among all other\\n    candidates.\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                temp.push_back(candidates[i]);\\n                combinationSum(candidates, target-candidates[i], output, temp, i);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083701,
                "title": "94-javascript-fast-very-easy-to-understand-solution",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/kO95ZxxDpwI\\n\\n# Code\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let res = []\\n    let temp = []\\n    let iterate = (index,sum)=>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push([...temp])\\n            return;\\n        }\\n        for(let i =index; i<candidates.length;i++){\\n            if(candidates[i]>target)continue\\n            temp.push(candidates[i])\\n            iterate(i, sum+candidates[i])\\n            temp.pop()\\n        }\\n    }\\n    iterate(0,0)\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    let res = []\\n    let temp = []\\n    let iterate = (index,sum)=>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push([...temp])\\n            return;\\n        }\\n        for(let i =index; i<candidates.length;i++){\\n            if(candidates[i]>target)continue\\n            temp.push(candidates[i])\\n            iterate(i, sum+candidates[i])\\n            temp.pop()\\n        }\\n    }\\n    iterate(0,0)\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777024,
                "title": "java-dp",
                "content": "I solved this problem too many times with backtracking, lets solve it using DP (knapsack)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>>[] dp = new List[target + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(new ArrayList<>());\\n          \\n        for (int c : candidates) {\\n            for (int i = c; i <= target; i++) {\\n                if (dp[i - c] != null) {\\n                    if (dp[i] == null)\\n                        dp[i] = new ArrayList<>();\\n                                    \\n                    for (List<Integer> list : dp[i - c]) {\\n                        List<Integer> copy = new ArrayList<>(list);\\n                        copy.add(c);\\n                        \\n                        dp[i].add(copy);\\n                    }\\n                }\\n            }            \\n        } \\n        \\n        return dp[target] == null ? new ArrayList<>() : dp[target];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>>[] dp = new List[target + 1];\\n        dp[0] = new ArrayList<>();\\n        dp[0].add(new ArrayList<>());\\n          \\n        for (int c : candidates) {\\n            for (int i = c; i <= target; i++) {\\n                if (dp[i - c] != null) {\\n                    if (dp[i] == null)\\n                        dp[i] = new ArrayList<>();\\n                                    \\n                    for (List<Integer> list : dp[i - c]) {\\n                        List<Integer> copy = new ArrayList<>(list);\\n                        copy.add(c);\\n                        \\n                        dp[i].add(copy);\\n                    }\\n                }\\n            }            \\n        } \\n        \\n        return dp[target] == null ? new ArrayList<>() : dp[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777011,
                "title": "java-recursion-4ms-daily-challenge-2-17-22",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        helper(candidates, target, 0, new ArrayList<Integer>());\\n        return res;\\n    }\\n    List<List<Integer>> res = new ArrayList<>();\\n    private void helper(int[] cands, int target, int stIdx, List<Integer> curList) {\\n        if (target == 0) res.add(curList);\\n        \\n        for (int i = stIdx; i < cands.length; i++) {\\n            if (cands[i] <= target) {\\n                List<Integer> list = new ArrayList<>(curList);\\n                list.add(cands[i]);\\n                helper(cands, target - cands[i], i, list);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        helper(candidates, target, 0, new ArrayList<Integer>());\\n        return res;\\n    }\\n    List<List<Integer>> res = new ArrayList<>();\\n    private void helper(int[] cands, int target, int stIdx, List<Integer> curList) {\\n        if (target == 0) res.add(curList);\\n        \\n        for (int i = stIdx; i < cands.length; i++) {\\n            if (cands[i] <= target) {\\n                List<Integer> list = new ArrayList<>(curList);\\n                list.add(cands[i]);\\n                helper(cands, target - cands[i], i, list);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874929,
                "title": "c-straightforward-backtracking-unbounded-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> combinations;\\n        vector<int> current;\\n        backtrack(candidates, target, 0, current, combinations);\\n        return combinations;\\n    }\\n    \\nprivate:\\n    void backtrack(vector<int>& candidates, int target, int index, vector<int>& current, vector<vector<int>>& combinations) {\\n        if (target == 0) {\\n            combinations.push_back(current);\\n            return;\\n        }\\n        if (target < 0 || index >= candidates.size()) return;\\n        current.push_back(candidates[index]);\\n        backtrack(candidates, target - current.back(), index, current, combinations);\\n        current.pop_back();\\n        backtrack(candidates, target, index + 1, current, combinations);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> combinations;\\n        vector<int> current;\\n        backtrack(candidates, target, 0, current, combinations);\\n        return combinations;\\n    }\\n    \\nprivate:\\n    void backtrack(vector<int>& candidates, int target, int index, vector<int>& current, vector<vector<int>>& combinations) {\\n        if (target == 0) {\\n            combinations.push_back(current);\\n            return;\\n        }\\n        if (target < 0 || index >= candidates.size()) return;\\n        current.push_back(candidates[index]);\\n        backtrack(candidates, target - current.back(), index, current, combinations);\\n        current.pop_back();\\n        backtrack(candidates, target, index + 1, current, combinations);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491067,
                "title": "python-simple-and-concise-clean-code",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        \\n        ret = []\\n        \\n        def fn(nums, tmp):\\n            if sum(tmp) > target:\\n                return False\\n            elif sum(tmp) == target:\\n                ret.append(tmp)\\n                return True\\n            else:   # sum(tmp) < target\\n                for i in range(len(nums)):\\n                    fn(nums[i:],tmp+[nums[i]])\\n        \\n        fn(candidates,[])\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        \\n        ret = []\\n        \\n        def fn(nums, tmp):\\n            if sum(tmp) > target:\\n                return False\\n            elif sum(tmp) == target:\\n                ret.append(tmp)\\n                return True\\n            else:   # sum(tmp) < target\\n                for i in range(len(nums)):\\n                    fn(nums[i:],tmp+[nums[i]])\\n        \\n        fn(candidates,[])\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 237525,
                "title": "python-simple-bactracking-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        ans = []\\n        def helper(candidates, target, t):\\n            if not target:\\n                ans.append(t)\\n                return\\n            for i, num in enumerate(candidates):\\n                if target >= num:\\n                    helper(candidates[i:], target - num, t + [num])\\n                else: break\\n        helper(candidates, target, [])\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        ans = []\\n        def helper(candidates, target, t):\\n            if not target:\\n                ans.append(t)\\n                return\\n            for i, num in enumerate(candidates):\\n                if target >= num:\\n                    helper(candidates[i:], target - num, t + [num])\\n                else: break\\n        helper(candidates, target, [])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16657,
                "title": "my-easy-understanding-dp-solution-c",
                "content": "Hi, here is my dp solution.  The idea is pretty similar with the dp solution of subset. :)\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;\\n        int size = candidates.size();\\n        if (size == 0) return result;\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<vector<int>>> dp(target + 1, vector<vector<int>>());\\n        dp[0].push_back(vector<int>());\\n        \\n        for (int i = 1; i <= target; ++i) {\\n            for (int j = 0; j < size && candidates[j] <= i; ++j) {\\n                for (int k = 0; k < dp[i - candidates[j]].size(); ++k) {\\n                    vector<int> temp = dp[i - candidates[j]][k];\\n                    if (temp.size() && (temp[temp.size() - 1] > candidates[j])) continue;\\n                    temp.push_back(candidates[j]);\\n                    dp[i].push_back(temp);\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "Hi, here is my dp solution.  The idea is pretty similar with the dp solution of subset. :)\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;\\n        int size = candidates.size();\\n        if (size == 0) return result;\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<vector<int>>> dp(target + 1, vector<vector<int>>());\\n        dp[0].push_back(vector<int>());\\n        \\n        for (int i = 1; i <= target; ++i) {\\n            for (int j = 0; j < size && candidates[j] <= i; ++j) {\\n                for (int k = 0; k < dp[i - candidates[j]].size(); ++k) {\\n                    vector<int> temp = dp[i - candidates[j]][k];\\n                    if (temp.size() && (temp[temp.size() - 1] > candidates[j])) continue;\\n                    temp.push_back(candidates[j]);\\n                    dp[i].push_back(temp);\\n                }\\n            }\\n        }\\n        return dp[target];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16758,
                "title": "javascript-solution",
                "content": "    function combinationSum(candidates, target) {\\n      candidates.sort((a, b) => a - b);\\n    \\n      var length = candidates.length;\\n      var res = [];\\n      search(0, [], target);\\n      return res;\\n    \\n      function search(idx, prefix, target) {\\n        if (target === 0) res.push(prefix.slice());\\n        if (idx === length) return;\\n        if (target <= 0) return;\\n    \\n        prefix.push(candidates[idx]);\\n        search(idx, prefix, target - candidates[idx]);\\n        prefix.pop();\\n        search(idx + 1, prefix, target);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function combinationSum(candidates, target) {\\n      candidates.sort((a, b) => a - b);\\n    \\n      var length = candidates.length;\\n      var res = [];\\n      search(0, [], target);\\n      return res;\\n    \\n      function search(idx, prefix, target) {\\n        if (target === 0) res.push(prefix.slice());\\n        if (idx === length) return;\\n        if (target <= 0) return;\\n    \\n        prefix.push(candidates[idx]);\\n        search(idx, prefix, target - candidates[idx]);\\n        prefix.pop();\\n        search(idx + 1, prefix, target);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 16829,
                "title": "a-recursive-yet-efficient-java-solution-with-explanation",
                "content": "The problem is a bit like N-queen problem, which is to say that we just need to enumerate all the possible solution recursively to get the final result. \\n\\nFirst of all, we need to sort the array, to ensure the combination to be unique and also the numbers in the combination to be listed in a non-descending order. \\n\\nThen, we define a recursive function with the signature as:  \\n\\n    combinationSum(int [] candidates, LinkedList vector, int start, int target)\\n\\nwhere `\\u201ccandidates\\u201d` is the list that we could take numbers from, `\\u201cvector\\u201d` is the list of combination that we have accumulated so far, `\\u201cstart\\u201d` is the starting point at which we could take numbers from forwards (no backwards), and `\\u201ctarget\\u201d` is the rest sum that we need to achieve.  \\n\\nAs a recursive function, the bottom cases for the combinationSum() are: \\n\\n1). The value of the `\\u201cstart\\u201d element` is equal to the `\\u201ctarget\\u201d`, we then find a combination, so just add the `\\u201cstart\\u201d element` to the `\\u201cvector\\u201d` and output the result. \\n\\n2). The value of the `\\u201cstart\\u201d element` is greater than the `\\u201ctarget\\u201d`, then it is impossible to find the combination onwards, because the `\\u201ccandidates\\u201d` list is sorted and all the following elements would be greater than the `\\u201ctarget\\u201d` as well. \\n\\n*Given the above recursive function, we could solve the problem by calling the function for each candidate starting from the start point. \\nFor each candidates, we first try to add the candidate into the `\\u201cvector\\u201d`, and then again starting from this candidate, we call the `combinationSum()` function to obtain the result for the new `\\u201ctarget\\u201d` afterwards.* \\n \\nHere is the code. \\n\\n\\n\\tprivate List<List<Integer>> res = new LinkedList<List<Integer>>();\\n\\t\\n\\tprivate void combinationSum(int [] candidates, LinkedList<Integer> vec,\\n\\t\\t\\t\\t\\t\\t\\t\\tint start, int target){\\n\\t\\t\\n\\t\\tfor(int i=start; i<candidates.length; ++i){\\n\\t\\t\\tif(candidates[i] < target){\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\n\\t\\t\\t\\t// Try a new combination, one could repeat itself again, so start from \"i\", instead of \"i+1\" \\n\\t\\t\\t\\tcombinationSum(candidates, newVec, i, target-candidates[i]);\\t\\t\\t\\t\\n\\t\\t\\t}else if(candidates[i] == target){\\n\\n\\t\\t\\t\\t// Found a combination\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\t\\t\\t\\tres.add(newVec);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// candidates[i] > target, no need to continue\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\tArrays.sort(candidates);\\n    \\tLinkedList<Integer> vec = new LinkedList<Integer>();\\n    \\tthis.combinationSum(candidates, vec, 0, target);\\n    \\treturn res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "The problem is a bit like N-queen problem, which is to say that we just need to enumerate all the possible solution recursively to get the final result. \\n\\nFirst of all, we need to sort the array, to ensure the combination to be unique and also the numbers in the combination to be listed in a non-descending order. \\n\\nThen, we define a recursive function with the signature as:  \\n\\n    combinationSum(int [] candidates, LinkedList vector, int start, int target)\\n\\nwhere `\\u201ccandidates\\u201d` is the list that we could take numbers from, `\\u201cvector\\u201d` is the list of combination that we have accumulated so far, `\\u201cstart\\u201d` is the starting point at which we could take numbers from forwards (no backwards), and `\\u201ctarget\\u201d` is the rest sum that we need to achieve.  \\n\\nAs a recursive function, the bottom cases for the combinationSum() are: \\n\\n1). The value of the `\\u201cstart\\u201d element` is equal to the `\\u201ctarget\\u201d`, we then find a combination, so just add the `\\u201cstart\\u201d element` to the `\\u201cvector\\u201d` and output the result. \\n\\n2). The value of the `\\u201cstart\\u201d element` is greater than the `\\u201ctarget\\u201d`, then it is impossible to find the combination onwards, because the `\\u201ccandidates\\u201d` list is sorted and all the following elements would be greater than the `\\u201ctarget\\u201d` as well. \\n\\n*Given the above recursive function, we could solve the problem by calling the function for each candidate starting from the start point. \\nFor each candidates, we first try to add the candidate into the `\\u201cvector\\u201d`, and then again starting from this candidate, we call the `combinationSum()` function to obtain the result for the new `\\u201ctarget\\u201d` afterwards.* \\n \\nHere is the code. \\n\\n\\n\\tprivate List<List<Integer>> res = new LinkedList<List<Integer>>();\\n\\t\\n\\tprivate void combinationSum(int [] candidates, LinkedList<Integer> vec,\\n\\t\\t\\t\\t\\t\\t\\t\\tint start, int target){\\n\\t\\t\\n\\t\\tfor(int i=start; i<candidates.length; ++i){\\n\\t\\t\\tif(candidates[i] < target){\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\n\\t\\t\\t\\t// Try a new combination, one could repeat itself again, so start from \"i\", instead of \"i+1\" \\n\\t\\t\\t\\tcombinationSum(candidates, newVec, i, target-candidates[i]);\\t\\t\\t\\t\\n\\t\\t\\t}else if(candidates[i] == target){\\n\\n\\t\\t\\t\\t// Found a combination\\n\\t\\t\\t\\tLinkedList<Integer> newVec = new LinkedList<Integer>();\\n\\t\\t\\t\\tnewVec.addAll(vec);\\n\\t\\t\\t\\tnewVec.add(candidates[i]);\\n\\t\\t\\t\\tres.add(newVec);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t// candidates[i] > target, no need to continue\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n    \\tArrays.sort(candidates);\\n    \\tLinkedList<Integer> vec = new LinkedList<Integer>();\\n    \\tthis.combinationSum(candidates, vec, 0, target);\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16825,
                "title": "recursive-java-solution",
                "content": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort the array, so the result could be increasing order\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        for(int i = 0; i < candidates.length; i++){\\n            // target smaller than current number, jump the current and rest of numbers\\n            if(target < candidates[i]) continue;\\n\\n            // if target is equal to the current number,add it to a new list and add that list to result          \\n            else if(target == candidates[i]){\\n                List<Integer> set = new ArrayList<Integer>();\\n                set.add(candidates[i]);\\n                result.add(set);\\n            }\\n\\n            // if the target is smaller the current number,call this function again\\n            else{\\n                // use modified array which not includes those numbers that before i to eliminate the duplicates\\n                int[] array = Arrays.copyOfRange(candidates,i,candidates.length);\\n\\n                // call this function. pass the new target and modified array.\\n                List<List<Integer>> temp = combinationSum(array, target - candidates[i]);\\n\\n                // for each list in the return list, add current number in the front of list, then add it to result\\n                // attention that if return list is null, this enhanced for loop will not perform. \\n                for(List<Integer> list:temp){\\n                    list.add(0,candidates[i]);\\n                    result.add(list);\\n                } \\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\nThey key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.",
                "solutionTags": [],
                "code": "    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        Arrays.sort(candidates); // sort the array, so the result could be increasing order\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        \\n        for(int i = 0; i < candidates.length; i++){\\n            // target smaller than current number, jump the current and rest of numbers\\n            if(target < candidates[i]) continue;\\n\\n            // if target is equal to the current number,add it to a new list and add that list to result          \\n            else if(target == candidates[i]){\\n                List<Integer> set = new ArrayList<Integer>();\\n                set.add(candidates[i]);\\n                result.add(set);\\n            }\\n\\n            // if the target is smaller the current number,call this function again\\n            else{\\n                // use modified array which not includes those numbers that before i to eliminate the duplicates\\n                int[] array = Arrays.copyOfRange(candidates,i,candidates.length);\\n\\n                // call this function. pass the new target and modified array.\\n                List<List<Integer>> temp = combinationSum(array, target - candidates[i]);\\n\\n                // for each list in the return list, add current number in the front of list, then add it to result\\n                // attention that if return list is null, this enhanced for loop will not perform. \\n                for(List<Integer> list:temp){\\n                    list.add(0,candidates[i]);\\n                    result.add(list);\\n                } \\n            }\\n        }\\n        \\n        return result;\\n    }\\n\\nThey key point is passing new target and modified array. Pass the modified array to make sure no duplicates set. If the new target could not find a match number, the return list will be null, thus this null list will not be added to the result list.",
                "codeTag": "Unknown"
            },
            {
                "id": 2774330,
                "title": "combinations-sum-1-java-solution-easy-recursive-approach",
                "content": "//Using Subset Pattern To Generate Combinations i.e. Include or Not Include\\n//but this time the change is made when we include the element ,we are not going to increase our index\\n//instead of increasing index we have given that we can use one element as many time as we want that\\'s why we are \\n//not going to increment index\\n\\n\\n![image](https://assets.leetcode.com/users/images/fd71fb68-bc08-4678-806c-66163da7721e_1667491488.5400312.jpeg)\\n\\n//Three Base cases\\n1. if(sum==target)  --> add subset ans into final ans arraylist\\n2. if(sum>target) --> return\\n3. if(index > arr.length) --> return\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(0,candidates,target,0,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\nT.C :- O(2^target  *  k)  // k is the average length/size of subset \\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(0,candidates,target,0,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\nT.C :- O(2^target  *  k)  // k is the average length/size of subset \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717214,
                "title": "easy-backtracking-solution-with-explanation-and-complexity-analysis",
                "content": "## General Algorithm \\nThe comination sum problems are those typical problems which can be solve with basic understanding of `backtracking` and `recursion`.\\nThese problems generally require 2 recursive calls which are as follows -\\n- you take `i th indexed` number form array and perform some operation (in this case, adding it to current-sum and inserting it in the list)\\n- you don\\'t take that number and performing operations that counter the operations in 1st recursive call (in this case, subtracting the number from current-sum and removing it from the list)\\n\\nIn this problem\\'s case, you take ith indexed number and add it to `current-sum` followed by inserting it in the `probable-ans lis`t. Now, if taking that number doesn\\'t work then anyways you subtract that number from `current sum` to bring it to it normal state and remove that number from `probable-ans-list`.\\n\\n**Base-case scenarios :**\\n- if `i` is greater that size of array; i.e. , all the elements of the array are visited.\\n- if `current-sum` is greater that target sum; because anyways, there is no point in finding sum with other numbers if current sum exceeds the target\\n\\n## Solution\\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> wrapper = new ArrayList<>();\\n        helper(wrapper, candidates, candidates.length, target, 0, 0, new ArrayList<>());\\n        return wrapper;\\n    }\\n    \\n    private void helper(List<List<Integer>> wrapper, int[] arr, int n, int target, int currSum, int i, List<Integer> probableAnsList) {\\n        if (i >= n) { \\n\\t\\t// Base-case 1\\n            if (currSum == target)\\n                wrapper.add(new ArrayList<>(probableAnsList)); \\n\\t\\t\\t\\t/* cloning arraylist (adding new Arraylist) because java references same object here which we are in future going to mutate and if the cloned list is not added then mutated changes will be seen here as well. */\\n            return;\\n        }\\n        if (currSum > target) // base-case 2\\n            return;\\n        \\n\\t\\t// Including the i-th indexed number\\n        currSum += arr[i];\\n        probableAnsList.add(arr[i]);\\n        helper(wrapper, arr, n, target, currSum, i, probableAnsList);\\n\\t\\t\\n\\t\\t// excluding the i-th indexed number\\n        currSum -= arr[i];\\n        probableAnsList.remove(probableAnsList.size() - 1);\\n        helper(wrapper, arr, n, target, currSum, i + 1, probableAnsList);\\n        \\n        return;\\n    }\\n    \\n}\\n```\\n\\n## Complexity analysis\\n\\n- Time Complexity = **O(2 ^ target) * k**\\n\\t- Reason: \\n\\t\\t- `2 ^ target` because at each step we are making 2 recursive calls. \\n\\t\\tFor ex. if arr[] = {1,2,3} and target is 3; then one of the ansers will be [1,1,1] and for \"every 1\" we are either taking it or ignorig it.\\n\\t\\t- `* k` because once we get target == currSum, we are inserting the elements of `probableAnsList` in `wrapper` which is `O(size of probableAnsList)`\\n\\n- Space Complexity = O(number of elements in wrapper)\\n\\n\\uD83C\\uDF1F`Upvote` if you liked this solution \\uD83C\\uDF1F",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> wrapper = new ArrayList<>();\\n        helper(wrapper, candidates, candidates.length, target, 0, 0, new ArrayList<>());\\n        return wrapper;\\n    }\\n    \\n    private void helper(List<List<Integer>> wrapper, int[] arr, int n, int target, int currSum, int i, List<Integer> probableAnsList) {\\n        if (i >= n) { \\n\\t\\t// Base-case 1\\n            if (currSum == target)\\n                wrapper.add(new ArrayList<>(probableAnsList)); \\n\\t\\t\\t\\t/* cloning arraylist (adding new Arraylist) because java references same object here which we are in future going to mutate and if the cloned list is not added then mutated changes will be seen here as well. */\\n            return;\\n        }\\n        if (currSum > target) // base-case 2\\n            return;\\n        \\n\\t\\t// Including the i-th indexed number\\n        currSum += arr[i];\\n        probableAnsList.add(arr[i]);\\n        helper(wrapper, arr, n, target, currSum, i, probableAnsList);\\n\\t\\t\\n\\t\\t// excluding the i-th indexed number\\n        currSum -= arr[i];\\n        probableAnsList.remove(probableAnsList.size() - 1);\\n        helper(wrapper, arr, n, target, currSum, i + 1, probableAnsList);\\n        \\n        return;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370502,
                "title": "python-recursion-detailed-explanation",
                "content": "1. Take two empty array to hold the result.\\n2.  `ds` stack for picking and removing element while moving along recursion. \\n3.  `res` to store final result and return. \\n4.  Call a recursive function starting with index 0. \\n5.  For each call, we have two option, either to pick the element (if it is less than the **current target** value) or to not pick (greater than current target value). \\n6.  By Current target, I mean if we have picked up the previous element, our target becomes  `target - element at current index i` else our `target` remains the same. \\n7.  If we pick the element, the current index `i` will be incremented by 1 else it will remain same.\\n8.  Similarly if we have processed the recursive call where we see that the element we picked is wrong, for example, if we picked 3 two\\'s `[2, 2, 2]` in stack then while returning back to its parent call, we should remove the element which is not required. \\n9.  The base case for the recursion will be when we have reached to the last index of the array and if we found the current target is `0`, it means we have found one possible combination. \\n10.  Recursively call above steps and wohooo, we have reached the solution. \\n\\n\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def combination(i, target, ds, res):\\n            if i == len(candidates):\\n                if target == 0 and ds not in res:\\n                    res.append(ds.copy())\\n                return\\n            if candidates[i] <= target:\\n                ds.append(candidates[i])\\n                combination(i, target - candidates[i], ds, res)\\n                ds.pop()\\n            combination(i + 1, target, ds, res)\\n            return res\\n        return combination(0, target, ds = [], res = [])\\n```\\n\\n**Note** - I have used `ds.copy()` to avoid overwriting of array due to reference. You can refer to Python Deep Copy and Shallow Copy concept for more info\\n\\nIf you like the explanation and solution, don\\'t hesitate to upvote. Cheers !!",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def combination(i, target, ds, res):\\n            if i == len(candidates):\\n                if target == 0 and ds not in res:\\n                    res.append(ds.copy())\\n                return\\n            if candidates[i] <= target:\\n                ds.append(candidates[i])\\n                combination(i, target - candidates[i], ds, res)\\n                ds.pop()\\n            combination(i + 1, target, ds, res)\\n            return res\\n        return combination(0, target, ds = [], res = [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276784,
                "title": "python-backtracking-with-full-working-explanation",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:  # Time: O(2^len(Tree)) and Space: O(n)\\n        res = []\\n\\n        def dfs(i, cur, total):\\n            if total == target:  # when the conditions are met we will copy a copy of current list into the result list\\n                res.append(cur.copy())\\n                return\\n            \\n            if i >= len(candidates) or total > target: \\n                return\\n            \\n            cur.append(candidates[i])  # x=1 we choose to include the current index\\n            dfs(i, cur, total + candidates[i])\\n            cur.pop()  # x=0 we choose to ignore the current index\\n            dfs(i + 1, cur, total)\\n\\n        dfs(0, [], 0)\\n\\t\\t\\n        return res\\n```\\nFor example,\\nLet **candidates = [2, 3, 5]** & **target = 8**\\n1. res = [ ]\\n* def dfs(0, [], 0):\\nif 0 == 8 = False\\nif 0 >= 3 or 0 > 8 = False or False = False\\ncur = [2] --> \\n* dfs(0, [2], 0 + 2):\\nif 2 == 8 = False -> if 0 >= 3 or 2 > 8 = False or False = False\\ncur = [2, 2] --> \\n* dfs(0, [2, 2], 2 + 2):\\nif 4 == 8 = False -> if 0 >= 3 or 4 > 8 = False or False = False\\ncur = [2, 2, 2] --> \\n* dfs(0, [2, 2, 2], 4 + 2):\\nif 6 == 8 = False -> if 0 >= 3 or 6 > 8 = False or False = False\\ncur = [2, 2, 2, 2] --> \\n* dfs(0, [2, 2, 2, 2], 6 + 2):\\nif 8 == 8 = True: res = [ [2, 2, 2, 2] ] --> return\\n--> dfs(1, [2, 2, 2, 2], 6) -> cur = [2, 2, 2] --> \\n* dfs(1, [2, 2, 2], 6):\\nif 6 == 8 = False -> if 1 >= 3 or 6 > 8 = False or False = False\\ncur = [2, 2, 2, 3] --> \\n* dfs(1, [2, 2, 2, 3], 9):\\nif 9 == 8 = False -> if 1 >= 3 or 9 > 8 = False or True = True: return\\n--> dfs(1, [2, 2, 2, 3], 9) -> cur = [2, 2, 2] --> \\n* dfs(2, [2, 2, 2], 6):\\nif 6 == 8 = False -> if 2 >= 3 or 6 > 8 = False or False = False\\ncur = [2, 2, 2, 5] --> \\n* dfs(2, [2, 2, 2, 5], 11):\\nif 11 == 8 = False -> if 2 >= 3 or 11 > 8 = False or True = True: return\\n--> dfs(2, [2, 2, 2, 3], 9) -> cur = [2, 2, 2] --> \\n* dfs(3, [2, 2, 2], 6) ->\\nif 6 == 8 = False -> if 3 >= 3 or 6 > 8 = True or False = True: return\\n--> dfs(3, [2, 2, 2], 6) -> dfs(2, [2, 2, 2], 6) -> dfs(1, [2, 2, 2], 6) -> dfs(0, [2, 2, 2], 6) -> cur = [2, 2]\\n* dfs(1, [2, 2], 4) ->\\nif 4 == 8 = False -> if 1 >= 3 or 4 > 8 = False or False = False\\ncur = [2, 2, 3] --> \\n* dfs(1, [2, 2, 3], 7):\\nif 7 == 8 = False -> if 1 >= 3 or 7 > 8 = False or False = False\\ncur = [2, 2, 3, 3] --> \\n* dfs(1, [2, 2, 3, 3], 10):\\nif 10 == 8 = False -> if 1 >= 3 or 10 > 8 = False or True = True: return \\n--> dfs(1, [2, 2, 3, 3], 10) --> cur = [2, 3, 3] -->\\n* dfs(2, [2, 2, 3], 7):\\nif 7 == 8 = False -> if 2 >= 3 or 7 > 8 = False or False = False\\ncur = [2, 2, 3, 5] --> \\n* dfs(2, [2, 2, 3, 5], 12):\\nif 12 == 8 = False -> if 2 >= 3 or 12 > 8 = False or True = True: return \\n--> dfs(1, [2, 2, 3, 5], 12) --> cur = [2, 3, 3] -->\\n* dfs(3, [2, 2, 3], 7):\\nif 7 == 8 = False -> if 3 >= 3 or 7 > 8 = True or False = True: return \\n--> dfs(3, [2, 2, 3], 7) -> dfs(2, [2, 2, 3], 7) -> cur = [2, 2]\\n* dfs(2, [2, 2], 4):\\nif 4 == 8 = False -> if 2 >= 3 or 4 > 8 = False or False = False\\ncur = [2, 2, 5] --> \\n* dfs(2, [2, 2, 5], 9):\\nif 9 == 8 = False -> if 2 >= 3 or 9 > 8 = True or False = True: return\\n--> dfs(2, [2, 2, 5], 9) -> cur = [2, 2]\\n* dfs(3, [2, 2], 4):\\nif 4 == 8 = False -> if 3 >= 3 or 4 > 8 = True or False = True: return\\n--> dfs(2, [2, 2], 4) -> dfs(1, [2, 2], 4) -> dfs(0, [2, 2], 4) -> cur = [2] -->\\n* dfs(1, [2], 2):\\nif 2 == 8 = False -> if 1 >= 3 or 2 > 8 = False or False = False\\ncur = [2, 3] --> \\n* dfs(1, [2, 3], 5):\\nif 5 == 8 = False -> if 1 >= 3 or 5 > 8 = False or False = False\\ncur = [2, 3, 3] --> \\n* dfs(1, [2, 3, 3], 8):\\nif 8 == 8 = True: res = [ [2, 3, 3] ] --> return\\n--> dfs(1, [2, 3, 3], 6) -> cur = [2, 3] --> \\n* dfs(2, [2, 3], 5):\\nif 5 == 8 = False -> if 2 >= 3 or 5 > 8 = False or False = False\\ncur = [2, 3, 5] --> \\n* dfs(2, [2, 3, 5], 10):\\nif 10 == 8 = False -> if 2 >= 3 or 10 > 8 = False or True = True: return \\n--> dfs(2, [2, 3, 5], 10) -> cur = [2, 3] --> \\n* dfs(3, [2, 3], 5):\\nif 5 == 8 = False -> if 3 >= 3 or 5 > 8 = True or False = True: return \\n--> dfs(2, [2, 3], 5) -> dfs(1, [2, 3], 5) -> cur = [2] --> \\n* dfs(2, [2], 2):\\nif 2 == 8 = False -> if 2 >= 3 or 2 > 8 = False or False = False\\ncur = [2, 5] --> \\n* dfs(2, [2, 5], 7):\\nif 7 == 8 = False -> if 2 >= 3 or 7 > 8 = False or False = False\\ncur = [2, 5, 5] --> \\n* dfs(2, [2, 5, 5], 12):\\nif 12 == 8 = False -> if 2 >= 3 or 12 > 8 = False or True = True: return \\n--> dfs(2, [2, 5, 5], 12) -> cur = [2, [2, 5], 7)\\n* dfs(3, [2, 5], 7):\\nif 7 == 8 = False -> if 3 >= 3 or 7 > 8 = True or False = True: return \\n--> dfs(2, [2, 5], 7) -> cur = [2]\\n* dfs(3, [2], 2):\\nif 2 == 8 = False -> if 3 >= 3 or 2 > 8 = True or False = True: return \\n--> dfs(2, [2], 5) -> dfs(1, [2], 5) -> dfs(0, [2], 5) -> cur [ ]\\n3. Similarly, continue with the 3 branch and 5 branch.\\n4. Return the result list.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:  # Time: O(2^len(Tree)) and Space: O(n)\\n        res = []\\n\\n        def dfs(i, cur, total):\\n            if total == target:  # when the conditions are met we will copy a copy of current list into the result list\\n                res.append(cur.copy())\\n                return\\n            \\n            if i >= len(candidates) or total > target: \\n                return\\n            \\n            cur.append(candidates[i])  # x=1 we choose to include the current index\\n            dfs(i, cur, total + candidates[i])\\n            cur.pop()  # x=0 we choose to ignore the current index\\n            dfs(i + 1, cur, total)\\n\\n        dfs(0, [], 0)\\n\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875252,
                "title": "combination-sum-c-backtracking-with-short-explanation",
                "content": "Apply backtracking. Add an element to the vector if it keeps the sum less than or equal to target. \\n\\nIf it any point our sum is equal to target, push this vector to our answer vector, else backtrack.\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>& ans, vector<int>& v, vector<int>& candidates, int target, int curr)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0) return;\\n        for(int i=curr;i<candidates.size();i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                v.push_back(candidates[i]);\\n                solve(ans,v,candidates,target-candidates[i],i);\\n                v.pop_back();\\n            }\\n            else break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(candidates.begin(),candidates.end());\\n        solve(ans,v,candidates,target,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>& ans, vector<int>& v, vector<int>& candidates, int target, int curr)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0) return;\\n        for(int i=curr;i<candidates.size();i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                v.push_back(candidates[i]);\\n                solve(ans,v,candidates,target-candidates[i],i);\\n                v.pop_back();\\n            }\\n            else break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        sort(candidates.begin(),candidates.end());\\n        solve(ans,v,candidates,target,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843289,
                "title": "c-simple-and-easy-solution-with-backtracking-concept",
                "content": "Simple backtracking concept , if any problems please let me know in comment section.\\n\\nPoint to observe -> Recursion is used inside the loop(iteration).\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& candidates, int target,int index,vector<int> &v,vector<vector<int> > &ans){\\n        if(target<0)\\n            return;\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=index;i<candidates.size();i++){\\n            v.push_back(candidates[i]);\\n            solve(candidates,target-candidates[i],i,v,ans);\\n            v.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> >ans;\\n        vector<int> v;\\n        int index=0;\\n        solve(candidates,target,index,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>& candidates, int target,int index,vector<int> &v,vector<vector<int> > &ans){\\n        if(target<0)\\n            return;\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=index;i<candidates.size();i++){\\n            v.push_back(candidates[i]);\\n            solve(candidates,target-candidates[i],i,v,ans);\\n            v.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> >ans;\\n        vector<int> v;\\n        int index=0;\\n        solve(candidates,target,index,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763691,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> v;\\n        vector<int> u;\\n         helper(candidates, target,0,v,u);\\n        return v;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target,int i,vector<vector<int>>& result, vector<int>& current)\\n    {\\n        if(target==0){\\n            result.push_back(current);\\n            return ;\\n        }\\n        if(i==candidates.size() || target<0)\\n            return;\\n        \\n        current.push_back(candidates[i]);\\n        helper(candidates,target-candidates[i],i,result,current);\\n        current.pop_back();\\n        helper(candidates,target,i+1,result,current);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> v;\\n        vector<int> u;\\n         helper(candidates, target,0,v,u);\\n        return v;\\n    }\\n    \\n    void helper(vector<int>& candidates, int target,int i,vector<vector<int>>& result, vector<int>& current)\\n    {\\n        if(target==0){\\n            result.push_back(current);\\n            return ;\\n        }\\n        if(i==candidates.size() || target<0)\\n            return;\\n        \\n        current.push_back(candidates[i]);\\n        helper(candidates,target-candidates[i],i,result,current);\\n        current.pop_back();\\n        helper(candidates,target,i+1,result,current);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344320,
                "title": "python-easy-to-understand-solution-96-faster",
                "content": "\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        \\n        def backtrack ( currSum, currList, mainList ):\\n            \\n\\n            for i in range( len(mainList) ):\\n                \\n                # If we have found the target value then we don\\'t have to iterate in the loop any further\\n                # Optimization #2: Any sum we get after this will always be greater than or equal to the current sum. ( Since we initially sorted the list in Optimization #1  )\\n                if currSum + mainList[i] == target:\\n                    # Add the answer to the list\\n                    solution.append( currList + [mainList[i]] )\\n                    return\\n                \\n                # Since the current sum is already greater than target, no point iterating further. ( Optimization #2 )\\n                if currSum + mainList[i] > target:\\n                    return\\n                \\n                # current sum is still less than target, backtrack\\n                else:\\n                    # currSum = current sum from function parameter + current element\\n                    # currList = current list from function parameter + list(current element)\\n                    # mainList = mainList [ i ... len(candidates) ] ( slicing to avoid duplicates ) \\n                    backtrack( currSum + mainList[i], currList + [ mainList[i] ], mainList[i:] )\\n            \\n        \\n\\t\\t\\n        solution = []\\n        \\n\\t\\t# Call the backtrack function\\n\\t\\t\\t# Optimization #1: sorting the list \\n\\t\\tbacktrack( 0, [], sorted( candidates ) )\\n        \\n        return solution\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        \\n        def backtrack ( currSum, currList, mainList ):\\n            \\n\\n            for i in range( len(mainList) ):\\n                \\n                # If we have found the target value then we don\\'t have to iterate in the loop any further\\n                # Optimization #2: Any sum we get after this will always be greater than or equal to the current sum. ( Since we initially sorted the list in Optimization #1  )\\n                if currSum + mainList[i] == target:\\n                    # Add the answer to the list\\n                    solution.append( currList + [mainList[i]] )\\n                    return\\n                \\n                # Since the current sum is already greater than target, no point iterating further. ( Optimization #2 )\\n                if currSum + mainList[i] > target:\\n                    return\\n                \\n                # current sum is still less than target, backtrack\\n                else:\\n                    # currSum = current sum from function parameter + current element\\n                    # currList = current list from function parameter + list(current element)\\n                    # mainList = mainList [ i ... len(candidates) ] ( slicing to avoid duplicates ) \\n                    backtrack( currSum + mainList[i], currList + [ mainList[i] ], mainList[i:] )\\n            \\n        \\n\\t\\t\\n        solution = []\\n        \\n\\t\\t# Call the backtrack function\\n\\t\\t\\t# Optimization #1: sorting the list \\n\\t\\tbacktrack( 0, [], sorted( candidates ) )\\n        \\n        return solution\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310038,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 203331,
                "title": "ruby-backtracking-with-diagram",
                "content": "```ruby\\n# @param {Integer[]} candidates\\n# @param {Integer} target\\n# @return {Integer[][]}\\ndef combination_sum(candidates, target)\\n    return [] if !candidates || candidates.empty?\\n    bt(candidates, target)\\nend\\n\\ndef bt(candidates, target, idx = 0, path = [], result = [], total = 0)\\n    if total == target\\n        result.push(path)\\n        return\\n    end\\n\\n    idx.upto(candidates.size - 1) do |i|\\n        next if total + candidates[i] > target\\n        bt(candidates, target, i, path + [candidates[i]], result, total + candidates[i])\\n    end\\n\\n    result\\nend\\n\\n# 39. Combination Sum\\n# https://leetcode.com/problems/combination-sum/description/\\n\\n# Similar problem listed in articles\\n# https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\n# https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c++-solution-use-backtracking-easy-understand.\\n\\n# Points to remember\\n# 1. No duplicates combinations in result               (So we should consider each unique combination only once)\\n# 2. Combination can contain a number any no. of times  (This means combination with repitition)\\n# 3. All numbers are +ve                                (Allows for pruning totals > target)\\n\\n# Approach 1: Backtracking\\n\\n# Example: candidates = [2,3,6,7], target = 7\\n# dfs call with idx: 0 path: [] result: [] total: 0\\n# check with next candidate and prune i: 0 | candidate: 2\\n#     dfs call with idx: 0 path: [2] result: [] total: 2\\n#     check with next candidate and prune i: 0 | candidate: 2\\n#         dfs call with idx: 0 path: [2, 2] result: [] total: 4\\n#         check with next candidate and prune i: 0 | candidate: 2\\n#             dfs call with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#             check with next candidate and prune i: 0 | candidate: 2\\n#             check with next candidate and prune i: 1 | candidate: 3\\n#             check with next candidate and prune i: 2 | candidate: 6\\n#             check with next candidate and prune i: 3 | candidate: 7\\n#             dfs retrn with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#             dfs call with idx: 1 path: [2, 2, 3] result: [] total: 7\\n#             dfs retrn with idx: 1 path: [2, 2, 3] result: [[2, 2, 3]] total: 7\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 0 path: [2, 2] result: [[2, 2, 3]] total: 4\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 0 path: [2] result: [[2, 2, 3]] total: 2\\n# check with next candidate and prune i: 1 | candidate: 3\\n#     dfs call with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n# check with next candidate and prune i: 2 | candidate: 6\\n#     dfs call with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n# check with next candidate and prune i: 3 | candidate: 7\\n#     dfs call with idx: 3 path: [7] result: [[2, 2, 3]] total: 7\\n#     dfs retrn with idx: 3 path: [7] result: [[2, 2, 3], [7]] total: 7\\n# dfs retrn with idx: 0 path: [] result: [[2, 2, 3], [7]] total: 0\\n# Refer to the diagram for recursion tree\\n```\\n![image](https://assets.leetcode.com/users/vkommi2/image_1544343701.png)\\n",
                "solutionTags": [],
                "code": "```ruby\\n# @param {Integer[]} candidates\\n# @param {Integer} target\\n# @return {Integer[][]}\\ndef combination_sum(candidates, target)\\n    return [] if !candidates || candidates.empty?\\n    bt(candidates, target)\\nend\\n\\ndef bt(candidates, target, idx = 0, path = [], result = [], total = 0)\\n    if total == target\\n        result.push(path)\\n        return\\n    end\\n\\n    idx.upto(candidates.size - 1) do |i|\\n        next if total + candidates[i] > target\\n        bt(candidates, target, i, path + [candidates[i]], result, total + candidates[i])\\n    end\\n\\n    result\\nend\\n\\n# 39. Combination Sum\\n# https://leetcode.com/problems/combination-sum/description/\\n\\n# Similar problem listed in articles\\n# https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning)\\n# https://leetcode.com/problems/combination-sum/discuss/16496/Accepted-16ms-c++-solution-use-backtracking-easy-understand.\\n\\n# Points to remember\\n# 1. No duplicates combinations in result               (So we should consider each unique combination only once)\\n# 2. Combination can contain a number any no. of times  (This means combination with repitition)\\n# 3. All numbers are +ve                                (Allows for pruning totals > target)\\n\\n# Approach 1: Backtracking\\n\\n# Example: candidates = [2,3,6,7], target = 7\\n# dfs call with idx: 0 path: [] result: [] total: 0\\n# check with next candidate and prune i: 0 | candidate: 2\\n#     dfs call with idx: 0 path: [2] result: [] total: 2\\n#     check with next candidate and prune i: 0 | candidate: 2\\n#         dfs call with idx: 0 path: [2, 2] result: [] total: 4\\n#         check with next candidate and prune i: 0 | candidate: 2\\n#             dfs call with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#             check with next candidate and prune i: 0 | candidate: 2\\n#             check with next candidate and prune i: 1 | candidate: 3\\n#             check with next candidate and prune i: 2 | candidate: 6\\n#             check with next candidate and prune i: 3 | candidate: 7\\n#             dfs retrn with idx: 0 path: [2, 2, 2] result: [] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#             dfs call with idx: 1 path: [2, 2, 3] result: [] total: 7\\n#             dfs retrn with idx: 1 path: [2, 2, 3] result: [[2, 2, 3]] total: 7\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 0 path: [2, 2] result: [[2, 2, 3]] total: 4\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [2, 3] result: [[2, 2, 3]] total: 5\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 0 path: [2] result: [[2, 2, 3]] total: 2\\n# check with next candidate and prune i: 1 | candidate: 3\\n#     dfs call with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n#     check with next candidate and prune i: 1 | candidate: 3\\n#         dfs call with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#         check with next candidate and prune i: 1 | candidate: 3\\n#         check with next candidate and prune i: 2 | candidate: 6\\n#         check with next candidate and prune i: 3 | candidate: 7\\n#         dfs retrn with idx: 1 path: [3, 3] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 1 path: [3] result: [[2, 2, 3]] total: 3\\n# check with next candidate and prune i: 2 | candidate: 6\\n#     dfs call with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n#     check with next candidate and prune i: 2 | candidate: 6\\n#     check with next candidate and prune i: 3 | candidate: 7\\n#     dfs retrn with idx: 2 path: [6] result: [[2, 2, 3]] total: 6\\n# check with next candidate and prune i: 3 | candidate: 7\\n#     dfs call with idx: 3 path: [7] result: [[2, 2, 3]] total: 7\\n#     dfs retrn with idx: 3 path: [7] result: [[2, 2, 3], [7]] total: 7\\n# dfs retrn with idx: 0 path: [] result: [[2, 2, 3], [7]] total: 0\\n# Refer to the diagram for recursion tree\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 16504,
                "title": "easy-to-understand-96-performance-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            return combinationSum(candidates, target, 0);\\n        }\\n        \\n        public List<List<Integer>> combinationSum(int[] candidates, int target, int start) {\\n            \\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            Arrays.sort(candidates);\\n            for (int i = start; i < candidates.length; i++) {\\n                if (candidates[i] <target) {\\n                    for (List<Integer> ar : combinationSum(candidates, target - candidates[i], i)) {\\n                        ar.add(0, candidates[i]);\\n                        res.add(ar);\\n                    }\\n                } else if (candidates[i] == target) {\\n                    List<Integer> lst = new ArrayList<>();\\n                    lst.add(candidates[i]);\\n                    res.add(lst);\\n                } else\\n                    break;\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n            return combinationSum(candidates, target, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3521721,
                "title": "detailed-explanation-with-recursion-tree-backtracking-c-tc-o-k-2-t-sc-o-k-x",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every element we come across in the given array, we are faced with the choice of either picking it to subtract from the target, or not picking it. \\n\\nUsing this fact, we can traverse the given array and make recursive calls to the function for each element in the array, reducing the target by the value picked till either the index is equal to size of the array or the value of target reaches less than or equal to zero.\\n\\nIf target value reaches zero, it means that the combination of elements picked will add up to the target and is a valid solution.\\n\\n**NOTE:** Since this problem allows us to pick multiple instances of the same element, we will pass the current index of the array (instead of the next one) when recursively calling the function as we can choose to pick it again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPass 0, `target`, `candidates`, `temp` and `sol` to the function `genUniqueCombos` that will generate unique combinations of the numbers adding up to the target. The parameters passed represent the current index, target to be attained, given array, array holding possible combination and array holding all possible combinations respectively.\\n\\nIf the index we are currently at is less than or equal to the target, we can think about adding it to (one of possible) solution. Push it into `temp` and recursively call the function, only this time with target reduced by the element added.\\n\\nOnce function call is returned, remove the element added to `temp`.\\n\\nIf index we are currently at is greater than the target, we cannot add it to the solution. Simply recursively call the function with the next index.\\n\\nWe can set the base case as the current index becoming equal to the size of the array, or the target becoming less than or equal to zero. If the target is equal to zero, we can surely say that it is one of the possible solutions and can push it into `sol`.\\n\\n**PS:** Recursion tree for `candidates` = [1, 2, 3] and `target` = 3.\\n\\n![WhatsApp Image 2023-05-14 at 8.23.53 AM.jpeg](https://assets.leetcode.com/users/images/2c69be16-4196-4f42-9865-c93fbb4c1fb7_1684032984.0102649.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: $$O(k*2^t)$$, where k is the number of possible solutions and t is the target to be attained.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k*x)$$, where k is number of possible solutions and x is the size of the longest solution.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void genUniqueCombos(int idx, int target, vector<int>& candidates, vector<int>& temp, vector<vector<int>>& sol){\\n        if(idx==candidates.size()||target<=0){\\n            if(!target) sol.push_back(temp);\\n            return;\\n        }\\n\\n        if(candidates[idx]<=target){\\n            temp.push_back(candidates[idx]);\\n            genUniqueCombos(idx, target-candidates[idx], candidates, temp, sol);\\n            temp.pop_back();\\n        }\\n        genUniqueCombos(idx+1, target, candidates, temp, sol);\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        genUniqueCombos(0, target, candidates, temp, sol);\\n        return sol;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void genUniqueCombos(int idx, int target, vector<int>& candidates, vector<int>& temp, vector<vector<int>>& sol){\\n        if(idx==candidates.size()||target<=0){\\n            if(!target) sol.push_back(temp);\\n            return;\\n        }\\n\\n        if(candidates[idx]<=target){\\n            temp.push_back(candidates[idx]);\\n            genUniqueCombos(idx, target-candidates[idx], candidates, temp, sol);\\n            temp.pop_back();\\n        }\\n        genUniqueCombos(idx+1, target, candidates, temp, sol);\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        genUniqueCombos(0, target, candidates, temp, sol);\\n        return sol;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629817,
                "title": "java-solution-easy-approach",
                "content": "```\\n\\n```****JAVA Solution Easy Approach****\\npublic List<List<Integer>> combinationSum(int[] candidates, int target)\\n{\\n        List<List<Integer>> al = new ArrayList<>();\\n\\t\\t//taking an List of List which will traverse via Call by reference through recursion\\n        Combo(candidates, target, \"\", target, al);           // passing list of List in recursion logic\\n        return al;                                                             // returning the list after Recursion ends\\n    }\\nstatic void Combo(int a[], int N, String ans, int max, List<List<Integer>> al)\\n    {\\n        if(N==0) //base Condition when our targets equals to 0\\n        {\\n            ArrayList<Integer> cl = new ArrayList<>();\\n            StringTokenizer st = new StringTokenizer(ans.trim()); // Breaking the string ans into integers and adding them into list,( a new List will be created for each case when base condition get hit)\\n            int n = st.countTokens();\\n            for(int j=0 ; j<=n-1; j++)\\n            {\\n                cl.add(Integer.parseInt(st.nextToken()));\\n            }\\n            al.add(cl); //adding our list to--> list of list\\n        }\\n        else\\n        {\\n            for(int i=0; i<a.length; i++)\\n            {\\n                if(N-a[i]>=0&& a[i]<=max) //taking max variable for stoping the duplication of answer \\n                {\\n                Combo(a, N-a[i], ans+a[i]+\" \", a[i], al); // passing max as last a[i] which we included in our ans\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777309,
                "title": "python-3-dfs-recursion-solution-and-explanation",
                "content": "\\n# \\uD83C\\uDF1F[Python 3] DFS Recursion Solution and Explanation\\n\\n## 1\\uFE0F\\u20E3 Main Idea:\\n* Step 1. Sort candidates\\n* Step 2. Recurssive call our helper function\\n\\n### Helper Function\\n* We take currentList as one of our function\\'s input because every time we try to add in a new number from candidates\\n* Once we append in new number, we recurssive call helper function and this time make our target = target - num which we picked\\n* Also we use startIdx to prevent counting duplicated outputs\\n\\n## Complexity Analysis\\n* Time: O(N^T/M) : Let N be length of candidates, T be target value, M be minimum value along candidates \\n* Space: O(N^T/M : Let N be length of candidates, T be target value, M be minimum value along candidates\\n\\n> Because every time we may at worst expand N-way tree from certain point. But how do we know the tree\\'s **height**?\\n> For example: We have a smallest value 1, and target value 100. So at worst we will have a maximum height which is [1,1,1,...,1] total **100** length. So we can consider **T/M**\\n\\n## Code\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res = []\\n        self.calHelper([], 0, candidates, target, res)\\n        return res\\n        \\n    def calHelper(self, currentList, startIdx, candidates, target, res):\\n        # Once target == 0 means we found a vaild list\\n        if target == 0:\\n            res.append(currentList)\\n            return\\n        \\n        # Start from startIdx means we can use duplicate nums\\n        for i in range(startIdx, len(candidates)):\\n            num = candidates[i]\\n            if num <= target:\\n                self.calHelper(currentList + [num], i, candidates, target - num, res)\\n            # Since candidates are sorted, if we cant find a vaild num <= target we break\\n            else:\\n                break\\n```\\n\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res = []\\n        self.calHelper([], 0, candidates, target, res)\\n        return res\\n        \\n    def calHelper(self, currentList, startIdx, candidates, target, res):\\n        # Once target == 0 means we found a vaild list\\n        if target == 0:\\n            res.append(currentList)\\n            return\\n        \\n        # Start from startIdx means we can use duplicate nums\\n        for i in range(startIdx, len(candidates)):\\n            num = candidates[i]\\n            if num <= target:\\n                self.calHelper(currentList + [num], i, candidates, target - num, res)\\n            # Since candidates are sorted, if we cant find a vaild num <= target we break\\n            else:\\n                break\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777073,
                "title": "c-clean-easy-backtracking",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid findcombination(int ind,int target,vector<int> &arr,vector<vector<int>>&ans,vector<int>&ds){\\n\\t\\t\\tif(ind==arr.size()){\\n\\t\\t\\t\\tif(target==0){\\n\\t\\t\\t\\t\\tans.push_back(ds);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(arr[ind]<=target){\\n\\t\\t\\t\\tds.push_back(arr[ind]);\\n\\t\\t\\t\\tfindcombination(ind,target-arr[ind],arr,ans,ds);\\n\\t\\t\\t\\tds.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tfindcombination(ind+1,target,arr,ans,ds);\\n\\t\\t}\\n\\t\\tvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t\\tvector<vector<int>>ans;\\n\\t\\t\\tvector<int>ds;\\n\\t\\t\\tfindcombination(0,target,candidates,ans,ds);\\n\\t\\t\\treturn ans; \\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid findcombination(int ind,int target,vector<int> &arr,vector<vector<int>>&ans,vector<int>&ds){\\n\\t\\t\\tif(ind==arr.size()){\\n\\t\\t\\t\\tif(target==0){\\n\\t\\t\\t\\t\\tans.push_back(ds);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1777025,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\n```\\nfunc combinationSum(candidates []int, target int) [][]int {\\n\\tvar ans [][]int\\n\\n\\tif len(candidates) == 0 {\\n\\t\\treturn ans\\n\\t}\\n\\n\\tbt(&ans, make([]int, 0), candidates, 0, target)\\n\\n\\treturn ans\\n}\\n\\nfunc bt(ans *[][]int, tmp, nums []int, idx, tgt int) {\\n\\tif tgt < 0 || idx > len(nums) {\\n\\t\\treturn\\n\\t}\\n\\n\\tif tgt == 0 {\\n\\t\\tcpyTmp := make([]int, len(tmp))\\n\\t\\tcopy(cpyTmp, tmp)\\n\\t\\t*ans = append(*ans, cpyTmp)\\n\\t}\\n\\n\\tfor i := idx; i < len(nums); i++ {\\n\\t\\ttmp = append(tmp, nums[i])\\n\\t\\tbt(ans, tmp, nums, i, tgt-nums[i])\\n\\t\\ttmp = tmp[:len(tmp)-1]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc combinationSum(candidates []int, target int) [][]int {\\n\\tvar ans [][]int\\n\\n\\tif len(candidates) == 0 {\\n\\t\\treturn ans\\n\\t}\\n\\n\\tbt(&ans, make([]int, 0), candidates, 0, target)\\n\\n\\treturn ans\\n}\\n\\nfunc bt(ans *[][]int, tmp, nums []int, idx, tgt int) {\\n\\tif tgt < 0 || idx > len(nums) {\\n\\t\\treturn\\n\\t}\\n\\n\\tif tgt == 0 {\\n\\t\\tcpyTmp := make([]int, len(tmp))\\n\\t\\tcopy(cpyTmp, tmp)\\n\\t\\t*ans = append(*ans, cpyTmp)\\n\\t}\\n\\n\\tfor i := idx; i < len(nums); i++ {\\n\\t\\ttmp = append(tmp, nums[i])\\n\\t\\tbt(ans, tmp, nums, i, tgt-nums[i])\\n\\t\\ttmp = tmp[:len(tmp)-1]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1594104,
                "title": "easy-java-solution-backtracking-for-beginners",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target){\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        combinationSumhelper(0,candidates,target,ans, new ArrayList<Integer>());\\n\\n        return ans ;\\n    }\\n\\n    // similar concept of taking and not taking\\n    public void  combinationSumhelper( int index ,int[] candidates, int target, List<List<Integer>> ans , List<Integer> insideList){\\n        if (index == candidates.length){\\n            if (target == 0){\\n                List<Integer> newInside = new ArrayList<>(insideList);\\n                ans.add(newInside);\\n            }\\n\\n            return;\\n        }\\n\\n        if (candidates[index] <= target){\\n            insideList.add(candidates[index]);\\n            // Taking the element\\n            combinationSumhelper(index,candidates,target-candidates[index],ans,insideList);\\n            // Backtracking\\n            insideList.remove(insideList.size() - 1);\\n        }\\n        // not taking the element\\n        combinationSumhelper(index+1,candidates,target,ans,insideList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target){\\n\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        combinationSumhelper(0,candidates,target,ans, new ArrayList<Integer>());\\n\\n        return ans ;\\n    }\\n\\n    // similar concept of taking and not taking\\n    public void  combinationSumhelper( int index ,int[] candidates, int target, List<List<Integer>> ans , List<Integer> insideList){\\n        if (index == candidates.length){\\n            if (target == 0){\\n                List<Integer> newInside = new ArrayList<>(insideList);\\n                ans.add(newInside);\\n            }\\n\\n            return;\\n        }\\n\\n        if (candidates[index] <= target){\\n            insideList.add(candidates[index]);\\n            // Taking the element\\n            combinationSumhelper(index,candidates,target-candidates[index],ans,insideList);\\n            // Backtracking\\n            insideList.remove(insideList.size() - 1);\\n        }\\n        // not taking the element\\n        combinationSumhelper(index+1,candidates,target,ans,insideList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189310,
                "title": "java-bactracking-beats-99-in-both-time-and-memory-2ms-t-c-o-n-t-s-c-o-t",
                "content": "\\n\\t// O(N^T) O(T)\\n\\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tArrays.sort(candidates);\\n\\t\\tcombinationSumRecHelper(candidates, 0, target, 0, ans, temp, candidates.length);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(N^T) O(T)\\n\\tpublic void combinationSumRecHelper(int[] candidates, int idx, int target, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int len) {\\n\\n\\t\\tif (curr == target) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (curr > target || idx == len)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (curr + candidates[idx] > target)\\n\\t\\t\\treturn;\\n\\n\\t\\ttemp.add(candidates[idx]);\\n\\t\\tcombinationSumRecHelper(candidates, idx, target, curr + candidates[idx], ans, temp, len);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\n\\t\\tcombinationSumRecHelper(candidates, idx + 1, target, curr, ans, temp, len);\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// O(N^T) O(T)\\n\\tpublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tArrays.sort(candidates);\\n\\t\\tcombinationSumRecHelper(candidates, 0, target, 0, ans, temp, candidates.length);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(N^T) O(T)\\n\\tpublic void combinationSumRecHelper(int[] candidates, int idx, int target, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int len) {\\n\\n\\t\\tif (curr == target) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (curr > target || idx == len)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (curr + candidates[idx] > target)\\n\\t\\t\\treturn;\\n\\n\\t\\ttemp.add(candidates[idx]);\\n\\t\\tcombinationSumRecHelper(candidates, idx, target, curr + candidates[idx], ans, temp, len);\\n\\t\\ttemp.remove(temp.size() - 1);\\n\\n\\t\\tcombinationSumRecHelper(candidates, idx + 1, target, curr, ans, temp, len);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 875304,
                "title": "java-combination-sum-recursion-100-fast-well-explained",
                "content": "This solution asks you to create a combination of the integers given IN ANY WAY to get sum as target. Also, the provided integers are unique. \\nWe undertake recusion since there are multiple possibilities for any integer. Any integer can be part of the list of numbers which add to target, or not be part of it, or be present multiple times.\\n\\n```\\nclass Solution {\\n    private List<List<Integer>> result;\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        result = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        recursiveHelper(candidates, target, new ArrayList<Integer>(), 0); \\n        return result;\\n    }\\n    \\n    private void recursiveHelper(int[] candidates, int target, List<Integer> list, int currIdx){\\n        if(target<0)\\n            return;\\n        \\n        for(int i=currIdx;i<candidates.length;i++){\\n            if(candidates[i]==target){\\n                 List<Integer> l = new ArrayList<>(list);\\n                 l.add(candidates[i]);\\n                 result.add(l);\\n                return;\\n            }\\n            if(candidates[i]>target)\\n                return;\\n            list.add(candidates[i]);\\n            recursiveHelper(candidates, target-candidates[i], list, i);\\n            list.remove(list.size()-1);\\n        }\\n        \\n    }\\n}\\n```\\n\\n\\n1. We need to find a combination of integers which sums to target. oR condition such that SUM- Target == 0. If such a list of numbers is present, that we add in the result set.\\n2. Now how and which number to add?\\n**Pruning 1**\\nWe\\'ll start by adding small numbers to the list (which sums up to target) and then large numbers. Hence we sort the list first. So if the target is not achievable by adding even the smallest number to the list, then it is useless to recurse and add large numebers, hence if **any candidate[i] > target, we stop the current recursion.**\\n\\n**Pruning 2**\\nAlso, while adding numbers we ensure when we add a large number, we do not add small number i.e. we avoid combination like [2,2,3] , [2,3,2], and [3,2,2] by only adding large number after small number. **So IN LOOP we start by index of the number added last time.**\\n\\n**Pruning 3**\\nWe always subtract number added to list from target. So if target is zero, we have a solution list to be added to result set.\\nIf target == any number, we add the number to list and stop our recursion here. No need to add another function call stack, saves memory and time.\\n\\n**BackTrack**\\nAfter adding an element to the list and calling recursion. We need to backtrack our step by removing the recently added element. Since here in JAVA list is passed by reference, we need to do that here. You could always pass a new list but that would be memory consuming since not always the newly created list will create a solution. Thus we only duplicate the list when we have the solution.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private List<List<Integer>> result;\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        result = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        recursiveHelper(candidates, target, new ArrayList<Integer>(), 0); \\n        return result;\\n    }\\n    \\n    private void recursiveHelper(int[] candidates, int target, List<Integer> list, int currIdx){\\n        if(target<0)\\n            return;\\n        \\n        for(int i=currIdx;i<candidates.length;i++){\\n            if(candidates[i]==target){\\n                 List<Integer> l = new ArrayList<>(list);\\n                 l.add(candidates[i]);\\n                 result.add(l);\\n                return;\\n            }\\n            if(candidates[i]>target)\\n                return;\\n            list.add(candidates[i]);\\n            recursiveHelper(candidates, target-candidates[i], list, i);\\n            list.remove(list.size()-1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831159,
                "title": "java-easy-solution",
                "content": "**Please upvote if helpfull!**\\n```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\n        helper(candidates, target, 0, 0, new ArrayList<>());\\n\\n        return resultList;\\n\\n    }\\n\\n    private void helper(int[] candidates, int target, int index, int sum, List<Integer> list) {\\n\\n        if (sum > target) return;\\n\\n        if (sum == target) {\\n\\n            resultList.add(new ArrayList(list));\\n        }\\n\\n        for (int i = index; i < candidates.length; i++) {\\n            \\n            list.add(candidates[i]);\\n            helper(candidates, target, i , sum + candidates[i], list);\\n            list.remove(list.size() - 1);\\n\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> resultList = new ArrayList<>();\\n    \\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n\\n\\n        helper(candidates, target, 0, 0, new ArrayList<>());\\n\\n        return resultList;\\n\\n    }\\n\\n    private void helper(int[] candidates, int target, int index, int sum, List<Integer> list) {\\n\\n        if (sum > target) return;\\n\\n        if (sum == target) {\\n\\n            resultList.add(new ArrayList(list));\\n        }\\n\\n        for (int i = index; i < candidates.length; i++) {\\n            \\n            list.add(candidates[i]);\\n            helper(candidates, target, i , sum + candidates[i], list);\\n            list.remove(list.size() - 1);\\n\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708264,
                "title": "c-combinations-i-ii-and-iii",
                "content": "**Combinations I :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations II :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations III :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539779,
                "title": "java-2ms-solution-using-recursion-99-56",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Stack<Integer> comb = new Stack<>();\\n        find(candidates, target, comb, 0, result);\\n        return result;\\n    }\\n    private void find(int[] candidates, int target, Stack<Integer> comb, int k, List<List<Integer>> result) {\\n        for (int i = k; i < candidates.length; i++) {\\n            if (candidates[i] == target) {\\n                comb.push(candidates[i]);\\n                result.add(new ArrayList<>(comb));\\n                comb.pop();\\n            } else if (candidates[i] < target) {\\n                comb.push(candidates[i]);\\n                find(candidates, target - candidates[i], comb, i, result);\\n                comb.pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        Stack<Integer> comb = new Stack<>();\\n        find(candidates, target, comb, 0, result);\\n        return result;\\n    }\\n    private void find(int[] candidates, int target, Stack<Integer> comb, int k, List<List<Integer>> result) {\\n        for (int i = k; i < candidates.length; i++) {\\n            if (candidates[i] == target) {\\n                comb.push(candidates[i]);\\n                result.add(new ArrayList<>(comb));\\n                comb.pop();\\n            } else if (candidates[i] < target) {\\n                comb.push(candidates[i]);\\n                find(candidates, target - candidates[i], comb, i, result);\\n                comb.pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485551,
                "title": "simple-java-recursion-solution",
                "content": "class Solution \\n{\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        Arrays.sort(candidates);\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        List<Integer> list=new ArrayList<>();\\n        \\n        helper(candidates,0,target,0,result,list);\\n        \\n        return result;\\n        \\n    }\\n    \\n    void helper(int candidates[],int start,int target,int sum,List<List<Integer>> result,List<Integer> list)\\n    {\\n        if(sum>target)\\n            return;\\n        \\n        if(sum==target)\\n        {\\n            result.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        for(int i=start;i<candidates.length;i++)\\n        {\\n            list.add(candidates[i]);\\n            helper(candidates,i,target,sum+candidates[i],result,list);\\n            list.remove(list.size()-1);\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        Arrays.sort(candidates);\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        List<Integer> list=new ArrayList<>();\\n        \\n        helper(candidates,0,target,0,result,list);\\n        \\n        return result;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 459477,
                "title": "python-5-lines-dp-solution",
                "content": "We can simply use the approach for solving Coin Change II [#518](https://leetcode.com/problems/coin-change-2).\\nIt only takes 5 lines without sorting at first.\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[[]]] + [[] for _ in range(target)]\\n        for candidate in candidates:\\n            for i in range(candidate, target + 1):\\n                dp[i] += [sublist + [candidate] for sublist in dp[i - candidate]]\\n        return dp[target]\\n```\\nTime complexity O(length of candidates * target)\\nSpace complexity O(target^3)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[[]]] + [[] for _ in range(target)]\\n        for candidate in candidates:\\n            for i in range(candidate, target + 1):\\n                dp[i] += [sublist + [candidate] for sublist in dp[i - candidate]]\\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255454,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        mem=collections.defaultdict(list)\\n        for i in range(target+1):\\n            for candidate in candidates:\\n                if candidate>i:\\n                    continue\\n                elif candidate==i:\\n                    mem[i].append([candidate])\\n                elif candidate<i:\\n                    tmp=mem[i-candidate]\\n                    for tmplist in tmp:\\n                        pair=[candidate]+tmplist\\n                        if sorted(pair) not in mem[i]:\\n                            mem[i].append(sorted(pair))\\n        return mem[target]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        mem=collections.defaultdict(list)\\n        for i in range(target+1):\\n            for candidate in candidates:\\n                if candidate>i:\\n                    continue\\n                elif candidate==i:\\n                    mem[i].append([candidate])\\n                elif candidate<i:\\n                    tmp=mem[i-candidate]\\n                    for tmplist in tmp:\\n                        pair=[candidate]+tmplist\\n                        if sorted(pair) not in mem[i]:\\n                            mem[i].append(sorted(pair))\\n        return mem[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219346,
                "title": "python-easy-and-clean-iterative-backtracking",
                "content": "```python\\n def combinationSum(self, candidates, target):\\n\\tanswer = []\\n\\tstack = [([], 0, 0)]\\n\\twhile stack:\\n\\t\\tchosen, currSum, currIndex = stack.pop()\\n\\t\\tif currSum == target:\\n\\t\\t\\tanswer.append(chosen)\\n\\t\\t\\tcontinue\\n\\t\\tfor i in range(currIndex, len(candidates)):\\n\\t\\t\\tcandidate = candidates[i]\\n\\t\\t\\tif currSum + candidate > target:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tstack.append((chosen + [candidate], currSum + candidate, i))\\n\\treturn answer\\n```\\nNothing special here, just a simple and easy to read iterative approach to backtracking with a stack. The key here is that we only consider candidates from `currIndex` and onwards as we want to break the symmetry between the pair, leaving us with unique combinations.",
                "solutionTags": [],
                "code": "```python\\n def combinationSum(self, candidates, target):\\n\\tanswer = []\\n\\tstack = [([], 0, 0)]\\n\\twhile stack:\\n\\t\\tchosen, currSum, currIndex = stack.pop()\\n\\t\\tif currSum == target:\\n\\t\\t\\tanswer.append(chosen)\\n\\t\\t\\tcontinue\\n\\t\\tfor i in range(currIndex, len(candidates)):\\n\\t\\t\\tcandidate = candidates[i]\\n\\t\\t\\tif currSum + candidate > target:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tstack.append((chosen + [candidate], currSum + candidate, i))\\n\\treturn answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 16616,
                "title": "very-elegant-python-code-using-recursive-yield-iterator",
                "content": "    def combSum(A, x):\\n        if A == [] or x < A[0]:\\n            return\\n        elif x == A[0]:\\n            yield [x]\\n        else:\\n            for comb in combSum(A, x - A[0]):\\n                yield [A[0]] + comb\\n            for comb in combSum(A[1:], x):\\n                yield comb\\n    \\n    class Solution:\\n        def combinationSum(self, A, x):\\n            return list(combSum(sorted(set(A)), x))",
                "solutionTags": [],
                "code": "    def combSum(A, x):\\n        if A == [] or x < A[0]:\\n            return\\n        elif x == A[0]:\\n            yield [x]\\n        else:\\n            for comb in combSum(A, x - A[0]):\\n                yield [A[0]] + comb\\n            for comb in combSum(A[1:], x):\\n                yield comb\\n    \\n    class Solution:\\n        def combinationSum(self, A, x):\\n            return list(combSum(sorted(set(A)), x))",
                "codeTag": "Java"
            },
            {
                "id": 3597098,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$Exponential$$\\n\\n- Space complexity:\\n$$Exponential$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            if (sum == target)\\n                ans.push_back(temp);\\n            return;\\n        }\\n        if ((sum + candidates[idx]) <= target) {\\n            sum += candidates[idx];\\n            temp.push_back(candidates[idx]);\\n            helper(idx, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[idx];\\n            temp.pop_back();\\n        }\\n        helper(idx+1, candidates, n, sum, target, temp, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            if (sum == target)\\n                ans.push_back(temp);\\n            return;\\n        }\\n        if ((sum + candidates[idx]) <= target) {\\n            sum += candidates[idx];\\n            temp.push_back(candidates[idx]);\\n            helper(idx, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[idx];\\n            temp.pop_back();\\n        }\\n        helper(idx+1, candidates, n, sum, target, temp, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473884,
                "title": "c-recursive-backtracking-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n      if(ind==arr.size()){\\n        if(target==0){\\n          ans.push_back(ds);\\n        }\\n        return;\\n      }\\n      if(arr[ind]<=target){\\n        ds.push_back(arr[ind]);\\n        findCombination(ind,target-arr[ind],arr,ans,ds);\\n        ds.pop_back();\\n      }\\n      findCombination(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n      if(ind==arr.size()){\\n        if(target==0){\\n          ans.push_back(ds);\\n        }\\n        return;\\n      }\\n      if(arr[ind]<=target){\\n        ds.push_back(arr[ind]);\\n        findCombination(ind,target-arr[ind],arr,ans,ds);\\n        ds.pop_back();\\n      }\\n      findCombination(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774204,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760114,
                "title": "java-easy-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> ans=new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] arr, int sum) {\\n        Arrays.sort(arr);\\n        helper(arr,sum,0,new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(int [] arr,int sum,int ind,List<Integer> temp){\\n        if(ind==arr.length){\\n            return;\\n        }\\n        \\n        if(arr[ind]==sum){\\n            ArrayList<Integer> temp2=new ArrayList<>();\\n            temp2.addAll(temp);\\n            temp2.add(arr[ind]);\\n            ans.add(temp2);\\n            return;\\n        }\\n        if(arr[ind]>sum){\\n            return;\\n        }\\n        \\n        helper(arr,sum,ind+1,temp);\\n        \\n        ArrayList<Integer> temp2=new ArrayList<>();\\n        temp2.addAll(temp);\\n        temp2.add(arr[ind]);\\n        helper(arr,sum-arr[ind],ind,temp2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans=new ArrayList<>();\\n    public List<List<Integer>> combinationSum(int[] arr, int sum) {\\n        Arrays.sort(arr);\\n        helper(arr,sum,0,new ArrayList<>());\\n        return ans;\\n    }\\n    public void helper(int [] arr,int sum,int ind,List<Integer> temp){\\n        if(ind==arr.length){\\n            return;\\n        }\\n        \\n        if(arr[ind]==sum){\\n            ArrayList<Integer> temp2=new ArrayList<>();\\n            temp2.addAll(temp);\\n            temp2.add(arr[ind]);\\n            ans.add(temp2);\\n            return;\\n        }\\n        if(arr[ind]>sum){\\n            return;\\n        }\\n        \\n        helper(arr,sum,ind+1,temp);\\n        \\n        ArrayList<Integer> temp2=new ArrayList<>();\\n        temp2.addAll(temp);\\n        temp2.add(arr[ind]);\\n        helper(arr,sum-arr[ind],ind,temp2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969565,
                "title": "very-fast-98-c-dfs-solution",
                "content": "```\\n    public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> current = new();\\n\\n        void Dfs(int index, int total)\\n        {\\n            if (total == target)\\n            {\\n                results.Add(current.ToArray());\\n                return;\\n            }\\n\\n            if (index >= candidates.Length || total > target)\\n            {\\n                return;\\n            }\\n\\n            current.Push(candidates[index]);\\n            Dfs(index, total + candidates[index]);\\n            current.Pop();\\n            Dfs(index + 1, total);\\n        }\\n\\n        Dfs(0, 0);\\n        return results;\\n    }\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n    public IList<IList<int>> CombinationSum(int[] candidates, int target)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> current = new();\\n\\n        void Dfs(int index, int total)\\n        {\\n            if (total == target)\\n            {\\n                results.Add(current.ToArray());\\n                return;\\n            }\\n\\n            if (index >= candidates.Length || total > target)\\n            {\\n                return;\\n            }\\n\\n            current.Push(candidates[index]);\\n            Dfs(index, total + candidates[index]);\\n            current.Pop();\\n            Dfs(index + 1, total);\\n        }\\n\\n        Dfs(0, 0);\\n        return results;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1777361,
                "title": "recursive-solution-with-diagram",
                "content": "**DO upvote if you understand**\\n![image](https://assets.leetcode.com/users/images/270da9e8-b2c0-4f9f-9a63-24ba4c32722c_1645073544.489124.png)\\n\\n```\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>>answer;\\n\\n        vector<int>currentAns;\\n\\n        solve(candidates , target , 0 , currentAns , answer);\\n    \\treturn answer;\\n    }\\n\\n    void solve(vector<int>& candidates, int target , int idx ,\\n    \\tvector<int>&currentAns , vector<vector<int>>&answer) {\\n\\n\\n    \\t//Base case \\n    \\tif( target == 0 ) {\\n    \\t\\t//if target is zero we have found the combination\\n    \\t\\tanswer.push_back(currentAns);\\n    \\t\\treturn;\\n    \\t}\\n    \\tif(idx >= candidates.size()) return;\\n    \\tint currentVal = candidates[idx];\\n    \\t\\n    \\t//pick the element\\n        //if current element is less or equal to target then do the combination\\n    \\tif(target >= currentVal) {\\n    \\t\\tcurrentAns.push_back(currentVal);\\n    \\t\\tsolve(candidates , target-currentVal , idx , currentAns ,answer);\\n    \\t\\t //make sure u remove the element while recursion is over\\n    \\t\\tcurrentAns.pop_back();\\n    \\t}\\n    \\t\\n    \\t//not pick up element\\n    \\tsolve(candidates , target , idx+1 , currentAns , answer);\\n\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>>answer;\\n\\n        vector<int>currentAns;\\n\\n        solve(candidates , target , 0 , currentAns , answer);\\n    \\treturn answer;\\n    }\\n\\n    void solve(vector<int>& candidates, int target , int idx ,\\n    \\tvector<int>&currentAns , vector<vector<int>>&answer) {\\n\\n\\n    \\t//Base case \\n    \\tif( target == 0 ) {\\n    \\t\\t//if target is zero we have found the combination\\n    \\t\\tanswer.push_back(currentAns);\\n    \\t\\treturn;\\n    \\t}\\n    \\tif(idx >= candidates.size()) return;\\n    \\tint currentVal = candidates[idx];\\n    \\t\\n    \\t//pick the element\\n        //if current element is less or equal to target then do the combination\\n    \\tif(target >= currentVal) {\\n    \\t\\tcurrentAns.push_back(currentVal);\\n    \\t\\tsolve(candidates , target-currentVal , idx , currentAns ,answer);\\n    \\t\\t //make sure u remove the element while recursion is over\\n    \\t\\tcurrentAns.pop_back();\\n    \\t}\\n    \\t\\n    \\t//not pick up element\\n    \\tsolve(candidates , target , idx+1 , currentAns , answer);\\n\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777034,
                "title": "c-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&C,vector<int>&A,vector<vector<int>>&res,int target,int sum,int start)\\n    {\\n        if(sum == target)\\n        {\\n            res.push_back(A);\\n            return;\\n        }\\n        \\n        for(int i = start; i < C.size(); i++)\\n        {\\n            if(sum + C[i] <= target)\\n            {\\n                A.push_back(C[i]);\\n                sum += C[i];\\n                solve(C,A,res,target,sum,i);\\n                A.pop_back();\\n                sum -= C[i];\\n            }\\n        }\\n            \\n    }\\n    vector<vector<int>> combinationSum(vector<int>&C, int target) {\\n        vector<vector<int>>res;\\n        vector<int>A;\\n        solve(C,A,res,target,0,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>&C,vector<int>&A,vector<vector<int>>&res,int target,int sum,int start)\\n    {\\n        if(sum == target)\\n        {\\n            res.push_back(A);\\n            return;\\n        }\\n        \\n        for(int i = start; i < C.size(); i++)\\n        {\\n            if(sum + C[i] <= target)\\n            {\\n                A.push_back(C[i]);\\n                sum += C[i];\\n                solve(C,A,res,target,sum,i);\\n                A.pop_back();\\n                sum -= C[i];\\n            }\\n        }\\n            \\n    }\\n    vector<vector<int>> combinationSum(vector<int>&C, int target) {\\n        vector<vector<int>>res;\\n        vector<int>A;\\n        solve(C,A,res,target,0,0);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634720,
                "title": "0ms-c-solution-backtracking-solution",
                "content": "*Please find the image below:*\\n![image](https://assets.leetcode.com/users/images/ade65dba-4375-492d-82b1-e31a6b377c14_1639865523.526272.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void combinationSumHelper(int indx, vector<int>& arr, int target,vector<vector<int>>& result,  vector<int>& comb )\\n    {\\n        if(indx >=arr.size())\\n        {\\n            return;\\n        }\\n        \\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        \\n        if(arr[indx]<=target)\\n        {\\n        comb.push_back(arr[indx]);\\n        combinationSumHelper(indx,arr,target-arr[indx],result,comb);\\n        comb.pop_back();\\n        \\n        }\\n   \\n       combinationSumHelper(indx+1,arr,target,result,comb);\\n        \\n        \\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        combinationSumHelper(0,candidates,target,result,comb);\\n        return result;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combinationSumHelper(int indx, vector<int>& arr, int target,vector<vector<int>>& result,  vector<int>& comb )\\n    {\\n        if(indx >=arr.size())\\n        {\\n            return;\\n        }\\n        \\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        \\n        if(arr[indx]<=target)\\n        {\\n        comb.push_back(arr[indx]);\\n        combinationSumHelper(indx,arr,target-arr[indx],result,comb);\\n        comb.pop_back();\\n        \\n        }\\n   \\n       combinationSumHelper(indx+1,arr,target,result,comb);\\n        \\n        \\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        combinationSumHelper(0,candidates,target,result,comb);\\n        return result;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626467,
                "title": "c-0ms-100-faster-3-approachs-comparison-explained",
                "content": "**Please upvote if you like the solution and any improvements or suggestion are welcomed in the comments.**\\n## Approach 1: Dynamic Programming\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\tvector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int i:candidates)\\n        {\\n            for(int j=i;j<=target;j++)\\n            {\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        return dp[target];\\n\\t}\\n};\\n```\\n\\n## Approach 2: Sorting, Backtracking and DFS\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t//sorting not needed but used for pruning\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n\\t\\t//removing not possible elements\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    //Function used to calculate the next possible combination until end of the possible candidates\\n    void findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return;\\n        if(sum==0)res.push_back(comb);\\n        for(int i=start;i<n;i++){\\n            comb.push_back(candidates[i]);\\n            findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n    }\\n};\\n```\\n**Example-**\\nInput: **candidates = [2,3,6,7,8,9], target = 7**\\nOutput: **[[2,2,3],[7]]**\\n***Explanation:***\\nPruning- **possible candidates** =**[2,3,6,7]**\\nThe checking goes like-\\n[2]      => (7-2>0) => add 2\\n[2,2]     => (7-4>0)  => add 2\\n[2,2,2]  => (7-6>0)  => add 2 \\n[2,2,2,2]  => (7-8<0)  => remove 2, add 3\\n[2,2,2,3]  => (7-9<0)  => remove 3, add 6\\n[2,2,2,6]  => (7-12<0)  => remove 6, add 7\\n[2,2,2,7]  => (7-13<0)  => remove 7, remove2, add 3\\n**[2,2,3]  => (7-7==0)  => add to result** , remove 3 ,add 6\\n[2,2,6]  => (7-10<0)  => remove 6 ,add 7\\n[2,2,7]  => (7-11<0)  => remove 7 ,remove 2, add 3\\n[2,3]=> (7-5>0)=>add 3\\n[2,3,3] => (7-8<0)  => remove 3 ,add 6\\n[2,3,6] => (7-11<0)  => remove 6 ,add 7\\n[2,3,7] =>(7-12<0) =>remove 7, remove 3, add 6\\n[2,6] => (7-8<0) =>remove 6 , add 7\\n[2,7] =>(7-9<0) =>remove 7, remove 2, add 3\\n[3]=> (7-3>0) => add 3\\n[3,3] => (7-6>0) => add 3\\n[3,3,3] => (7-9<0)  => remove 3 ,add 6\\n[3,3,6] => (7-12<0)  => remove 6 ,add 7\\n[3,3,7] =>(7-13<0) =>remove 7, remove 3, add 6\\n[3,6]  => (7-9<0)  => remove 6 ,add 7\\n[3,7] =>  (7-10<0)  => remove 7 ,remove 3, add 6 \\n[6] =>(7-6>0) =>add 7\\n[6,7] =>(7-13<0) => remove 7 ,remove 6, add 7\\n**[7] => (7==7) =>add to result**\\nIn this way, we get the result as **[[2,2,3],[7]]**\\n\\n## Approach 3:: Optimizing DFS calls\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    \\n    bool findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return false;\\n        if(sum==0){res.push_back(comb);return true;}\\n        bool tryNext=true;\\n        for(int i=start;tryNext&&i<n;i++){\\n            comb.push_back(candidates[i]);\\n            tryNext=findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Example-**\\nInput: **candidates = [2,3,6,7,8,9], target = 7**\\nOutput: **[[2,2,3],[7]]**\\n***Explanation:***\\nPruning- **possible candidates** =**[2,3,6,7]**\\nThe checking goes like-\\n**tryNext=true**\\n[2]      => (7-2>0) => add 2\\n**tryNext=true**\\n[2,2]     => (7-4>0)  => add 2\\n**tryNext=true**\\n[2,2,2]  => (7-6>0)  => add 2 \\n**tryNext=true**\\n[2,2,2,2]  => **(7-8<0)  =>  tryNext=false**, remove 2,\\nremove2, add 3\\n**tryNext=true**\\n**[2,2,3]  => (7-7==0)  => add to result** , remove 3 ,add 6\\n**tryNext=true**\\n[2,2,6]  => **(7-10<0)  =>  tryNext=false** , remove 6\\nremove 2, add 3\\n**tryNext=true**\\n[2,3]=> (7-5>0)=>add 3\\n**tryNext=true**\\n[2,3,3] => **(7-8<0)  =>  tryNext=false** , remove 3,\\nremove 3, add 6\\n[2,6] => **(7-8<0) => tryNext=false** , remove 6 ,\\nremove 2, add 3\\n[3]=> (7-3>0) => add 3\\n**tryNext=true**\\n[3,3] => (7-6>0) => add 3\\n**tryNext=true**\\n[3,3,3] => **(7-9<0)  =>  tryNext=false** , remove 3 \\nremove 3, add 6\\n**tryNext=true**\\n[3,6]  => **(7-9<0)  =>  tryNext=false** , remove 6 \\nremove 3, add 6 \\n**tryNext=true**\\n[6] =>(7-6>0) =>add 7\\n**tryNext=true**\\n[6,7] =>**(7-13<0) =>  tryNext=false** , remove 7 ,remove 6, add 7\\n**tryNext=true**\\n**[7] => (7==7) =>add to result**\\nIn this way, we get the result as **[[2,2,3],[7]]**\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Combination Sum.\\nMemory Usage: 10.7 MB, less than 97.01% of C++ online submissions for Combination Sum.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\tvector <vector <vector <int>>> dp(target+1);\\n        dp[0]={{}};\\n        for(int i:candidates)\\n        {\\n            for(int j=i;j<=target;j++)\\n            {\\n                for(auto v:dp[j-i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        return dp[target];\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n\\t\\t//sorting not needed but used for pruning\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n\\t\\t//removing not possible elements\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    //Function used to calculate the next possible combination until end of the possible candidates\\n    void findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return;\\n        if(sum==0)res.push_back(comb);\\n        for(int i=start;i<n;i++){\\n            comb.push_back(candidates[i]);\\n            findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(begin(candidates),end(candidates));\\n        int n=candidates.size();\\n        while(n&&(candidates[n-1]>target)){n--;}\\n        int sum=target;\\n        vector<vector<int>> result;\\n        vector<int> comb;\\n        findNextComboSum(candidates,result,comb,n,sum,0);\\n        return result;\\n    }\\n    \\n    bool findNextComboSum(vector<int>& candidates,vector<vector<int>>& res,\\n                         vector<int>& comb,int& n,int sum,int start){\\n        if(sum<0)return false;\\n        if(sum==0){res.push_back(comb);return true;}\\n        bool tryNext=true;\\n        for(int i=start;tryNext&&i<n;i++){\\n            comb.push_back(candidates[i]);\\n            tryNext=findNextComboSum(candidates,res,comb,n,sum-candidates[i],i);\\n            comb.pop_back();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561049,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        helper(candidates, list, new ArrayList<>(), target, 0);\\n        return list;\\n    }\\n    private void helper(int[] candidates, List<List<Integer>> list , List<Integer> tmp, int target, int i){\\n        if(target < 0)  return;\\n        else if(target == 0)    list.add(new ArrayList<>(tmp));\\n        else{\\n            while(i<candidates.length){\\n                tmp.add(candidates[i]);\\n                helper(candidates, list, tmp, target - candidates[i], i++);\\n                tmp.remove(tmp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        helper(candidates, list, new ArrayList<>(), target, 0);\\n        return list;\\n    }\\n    private void helper(int[] candidates, List<List<Integer>> list , List<Integer> tmp, int target, int i){\\n        if(target < 0)  return;\\n        else if(target == 0)    list.add(new ArrayList<>(tmp));\\n        else{\\n            while(i<candidates.length){\\n                tmp.add(candidates[i]);\\n                helper(candidates, list, tmp, target - candidates[i], i++);\\n                tmp.remove(tmp.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427935,
                "title": "c-with-explanation-simple-and-easy-to-understand-for-na-ve-like-me",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void help(vector<int>& cand,vector<vector<int>> &vec,vector<int> &v,int target,int n){\\n\\t//base case\\n        if(target==0){\\n            vec.push_back(v);\\n                return;\\n        }\\n        if(n==0){\\n            return;\\n        }\\n\\t//choice diagram \\n        if(cand[n-1]<=target){\\n            v.push_back(cand[n-1]);\\n            help(cand,vec,v,target-cand[n-1],n);\\n            v.pop_back();\\n        }\\n        help(cand,vec,v,target,n-1);\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& cand, int target) {\\n        vector<vector<int>> vec;\\n        vector<int> v;\\n        help(cand,vec,v,target,cand.size());\\n        return vec;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<int>& cand,vector<vector<int>> &vec,vector<int> &v,int target,int n){\\n\\t//base case\\n        if(target==0){\\n            vec.push_back(v);\\n                return;\\n        }\\n        if(n==0){\\n            return;\\n        }\\n\\t//choice diagram \\n        if(cand[n-1]<=target){\\n            v.push_back(cand[n-1]);\\n            help(cand,vec,v,target-cand[n-1],n);\\n            v.pop_back();\\n        }\\n        help(cand,vec,v,target,n-1);\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& cand, int target) {\\n        vector<vector<int>> vec;\\n        vector<int> v;\\n        help(cand,vec,v,target,cand.size());\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278005,
                "title": "python-dfs-sort",
                "content": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        candidates.sort()\\n        def DFS(arr,sm,target,j):\\n            if sm==target:\\n                if arr not in ans:\\n                    ans.append(arr)\\n                return\\n            for i in range(j,len(candidates)):\\n                if sm+candidates[i]>target:\\n                    return\\n                DFS(arr+[candidates[i]],sm+candidates[i],target,i)\\n        DFS([],0,target,0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        candidates.sort()\\n        def DFS(arr,sm,target,j):\\n            if sm==target:\\n                if arr not in ans:\\n                    ans.append(arr)\\n                return\\n            for i in range(j,len(candidates)):\\n                if sm+candidates[i]>target:\\n                    return\\n                DFS(arr+[candidates[i]],sm+candidates[i],target,i)\\n        DFS([],0,target,0)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1234096,
                "title": "c-backtracking-with-explanation-easy-to-understand",
                "content": "The idea of my solution is simple. I will backtrack with vector result, vector current, int target, int current_sum (sum of this backtrack turn), int prev (to save index of candidates that we have already use in last backtrack). \\n1) I check if current_sum is larger than target or not. If yes I will immediatedly stop backtrack because if we continue to backtrack we only add a postive number to make current_sum larger.\\n2) If current_sum==target, I will push vector current to result then return\\n3) If we are step 3, it means that or current_sum still smaller than target and need to increase. Now we loop from previous index to last index of candidate (I do not loop from 1 because I will make the same vector. For example, if I already have 1, 2 and in backtrack with 2 if we loop from 1 we wiil have 2, 1 and it not valid), then we add the element we loop through to vector current and backtrack with vector current and current_sum + the element we just added.\\n\\nIf my solution is helpful, give me an upvote. Thank you for reading.\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<vector<int>> &result, vector<int> current, int target, int current_sum, vector<int> candidates, int previous){\\n        if(current_sum>target){\\n            return;\\n        }\\n        if(current_sum==target){\\n            result.push_back(current);\\n        }\\n        \\n        for(int i=previous; i<candidates.size(); i++){\\n            current.push_back(candidates[i]);\\n            backtrack(result, current, target, current_sum+candidates[i], candidates, i);\\n            current.pop_back();\\n        }\\n    }\\n        \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;\\n        vector<int> current;\\n        backtrack(result, current, target, 0, candidates, 0);\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    void backtrack(vector<vector<int>> &result, vector<int> current, int target, int current_sum, vector<int> candidates, int previous){\\n        if(current_sum>target){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1188545,
                "title": "top-down-using-memoization-solution-better-time-complexity-than-backtracking",
                "content": "The idea is that you memoize the generated combinations for each target, and bubble that up to the caller. The caller will then add the candidate that generated those lists to each of them. \\n\\nOf course we will have to dedupe at the end, because resuing solutions will generate duplicates. \\n\\nI am not so sure of the time complexity, but I beleive it would be this:\\n\\nO(N^2 * M) with N being the target and M being the length of array. We then have the sorting for deduping. So that would be O(MlogM)\\nThe result is O(M(logM * N^2)). Seems to be a better time complexity than backtracking.  \\n\\n```\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        # For memoization\\n        self.memo = {}\\n        \\n        def get_combo(candidates, target):\\n            \\n            if target < 0:\\n                return\\n\\n            if target == 0:\\n                # Return a list of list so we can add candidates to it\\n                return [[]]\\n            \\n            # Use memoization\\n            if target in self.memo:\\n                return self.memo[target]\\n            \\n            final_list = []\\n            for candidate in candidates:\\n                result = get_combo(candidates, target - candidate)\\n                if result:\\n                    for alist in result:\\n                        # deep copy\\n                        alist = list(alist)\\n                        # add candidate to each list returned\\n                        alist.append(candidate)\\n                        # add new list to final list\\n                        final_list.append(alist)\\n\\n            self.memo[target] = final_list             \\n            return final_list\\n        \\n        results = []\\n        \\n        # Dedupe\\n        aset = set()\\n        for alist in get_combo(candidates, target):\\n            alist = sorted(alist)\\n            if tuple(alist) not in aset:\\n                aset.add(tuple(alist))\\n                results.append(alist)\\n                \\n        return results\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        # For memoization\\n        self.memo = {}\\n        \\n        def get_combo(candidates, target):\\n            \\n            if target < 0:\\n                return\\n\\n            if target == 0:\\n                # Return a list of list so we can add candidates to it\\n                return [[]]\\n            \\n            # Use memoization\\n            if target in self.memo:\\n                return self.memo[target]\\n            \\n            final_list = []\\n            for candidate in candidates:\\n                result = get_combo(candidates, target - candidate)\\n                if result:\\n                    for alist in result:\\n                        # deep copy\\n                        alist = list(alist)\\n                        # add candidate to each list returned\\n                        alist.append(candidate)\\n                        # add new list to final list\\n                        final_list.append(alist)\\n\\n            self.memo[target] = final_list             \\n            return final_list\\n        \\n        results = []\\n        \\n        # Dedupe\\n        aset = set()\\n        for alist in get_combo(candidates, target):\\n            alist = sorted(alist)\\n            if tuple(alist) not in aset:\\n                aset.add(tuple(alist))\\n                results.append(alist)\\n                \\n        return results\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1151613,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(target, path, start):\\n            if target == 0: res.append(path)\\n            else:\\n                for i in range(start, len(candidates)):\\n                    if target - candidates[i] >= 0:\\n                        backtrack(target - candidates[i], path + [candidates[i]], i)\\n        \\n        res = []\\n        backtrack(target, [], 0)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(target, path, start):\\n            if target == 0: res.append(path)\\n            else:\\n                for i in range(start, len(candidates)):\\n                    if target - candidates[i] >= 0:\\n                        backtrack(target - candidates[i], path + [candidates[i]], i)\\n        \\n        res = []\\n        backtrack(target, [], 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935010,
                "title": "well-commented-javascript-backtracking-solution-beats-99-81-o-n-t-m-time-space",
                "content": "**Explanation for the time/space complexity (taken directly from Solutions tab) below the code**\\n\\n```\\nvar combinationSum = function(candidates, target) {\\n  const combos = [];\\n  // Pass in the given args, plus combos, a currCombo array, and an index\\n  combinationSumHelper(candidates, target, combos, [], 0);\\n  return combos;\\n};\\n\\nvar combinationSumHelper = function(candidates, target, combos, currCombo, index) {\\n  // Since we subtract from target on each recursive call, we know that\\n  // the base case is when target === 0 (a valid combo)\\n  if (target === 0) combos.push([...currCombo]);\\n\\n  for (let i = index; i < candidates.length; i++) {\\n\\t// Just check to make sure the current number fits into target\\n    if (candidates[i] <= target) {\\n\\t  // Try to use the number by pushing to currCombo\\n      currCombo.push(candidates[i]);\\n\\t  // Recurse and subtract this number from target (now the next recursion will use the remainder)\\n\\t  // and pass in i as the index because we can use this number multiple times\\n      combinationSumHelper(candidates, target - candidates[i], combos, currCombo, i);\\n\\t  // Un-use the number so in the next iteration, you will use the next number\\n      currCombo.pop();\\n    }\\n  }\\n}\\n```\\n\\n**Copied directly from Solutions tab; explanation for time/space complexity (Space has the same reason as Time since Recursion stack reflects it):**\\n\\nLet N be the number of candidates, T be the target value, and M be the minimal value among the candidates.\\n\\n... the execution of the backtracking is unfolded as a DFS traversal in a n-ary tree. The total number of steps during the backtracking would be the number of nodes in the tree.\\n\\nAt each node, it takes a constant time to process, except the leaf nodes which could take a linear time to make a copy of combination. So we can say that the time complexity is linear to the number of nodes of the execution tree.\\n\\nHere we provide a loose upper bound on the number of nodes.\\n\\n* First of all, the fan-out of each node would be bounded to N, i.e. the total number of candidates.\\n\\n* The maximal depth of the tree, would be T/M, where we keep on adding the smallest element to the combination.\\n\\n* As we know, the maximal number of nodes in N-ary tree of T/M height would be N ^ ((T/M) +1)\\n\\nNote that, the actual number of nodes in the execution tree would be much smaller than the upper bound, since the fan-out of the nodes are decreasing level by level.",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar combinationSum = function(candidates, target) {\\n  const combos = [];\\n  // Pass in the given args, plus combos, a currCombo array, and an index\\n  combinationSumHelper(candidates, target, combos, [], 0);\\n  return combos;\\n};\\n\\nvar combinationSumHelper = function(candidates, target, combos, currCombo, index) {\\n  // Since we subtract from target on each recursive call, we know that\\n  // the base case is when target === 0 (a valid combo)\\n  if (target === 0) combos.push([...currCombo]);\\n\\n  for (let i = index; i < candidates.length; i++) {\\n\\t// Just check to make sure the current number fits into target\\n    if (candidates[i] <= target) {\\n\\t  // Try to use the number by pushing to currCombo\\n      currCombo.push(candidates[i]);\\n\\t  // Recurse and subtract this number from target (now the next recursion will use the remainder)\\n\\t  // and pass in i as the index because we can use this number multiple times\\n      combinationSumHelper(candidates, target - candidates[i], combos, currCombo, i);\\n\\t  // Un-use the number so in the next iteration, you will use the next number\\n      currCombo.pop();\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 875305,
                "title": "pyhton-simple-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=qs1-iEla-5M)\\nhttps://www.youtube.com/watch?v=qs1-iEla-5M\\n```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        self.res = []\\n        self.candidates = candidates\\n        self.backtrack([], 0, target)\\n        return self.res\\n    \\n    def backtrack(self, path, indx, target):\\n        \\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            self.res.append(path)\\n            return \\n        \\n        for x in range(indx, len(self.candidates)):\\n            self.backtrack(path+[self.candidates[x]], x, target - self.candidates[x])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        self.res = []\\n        self.candidates = candidates\\n        self.backtrack([], 0, target)\\n        return self.res\\n    \\n    def backtrack(self, path, indx, target):\\n        \\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            self.res.append(path)\\n            return \\n        \\n        for x in range(indx, len(self.candidates)):\\n            self.backtrack(path+[self.candidates[x]], x, target - self.candidates[x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874860,
                "title": "java-clean-code-backtracking-technique",
                "content": "```\\nclass Solution {\\n\\t\\n\\tprivate void combinationSumUtil (int[] candidates, int target, int index, List<Integer> temp, List<List<Integer>> res) {\\n\\t\\t\\n\\t\\tif (target == 0) {\\n\\t\\t\\tres.add (new ArrayList <>(temp));\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (; index < candidates.length && target > 0; index++) {\\n\\t\\t\\ttemp.add (candidates[index]);\\n\\t\\t\\tcombinationSumUtil (candidates, target - candidates[index], index, temp, res);\\n\\t\\t\\ttemp.remove (temp.size () - 1);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic List<List<Integer>> combinationSum (int[] candidates, int target) {\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList <>();\\n\\t\\tcombinationSumUtil (candidates, target, 0, new ArrayList<Integer> (), res);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tprivate void combinationSumUtil (int[] candidates, int target, int index, List<Integer> temp, List<List<Integer>> res) {\\n\\t\\t\\n\\t\\tif (target == 0) {\\n\\t\\t\\tres.add (new ArrayList <>(temp));\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (; index < candidates.length && target > 0; index++) {\\n\\t\\t\\ttemp.add (candidates[index]);\\n\\t\\t\\tcombinationSumUtil (candidates, target - candidates[index], index, temp, res);\\n\\t\\t\\ttemp.remove (temp.size () - 1);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic List<List<Integer>> combinationSum (int[] candidates, int target) {\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList <>();\\n\\t\\tcombinationSumUtil (candidates, target, 0, new ArrayList<Integer> (), res);\\n\\t\\t\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845243,
                "title": "python-recursive-solution-faster-than-92-13-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        res = []\\n        candidates.sort()\\n        def helper(target, index, sub_list):\\n            if target == 0:\\n                res.append(sub_list)\\n            if target < 0 or index >= len(candidates):\\n                return\\n            for i in range(index, len(candidates)):\\n                #optimization\\n                if target < candidates[i]:\\n                    break\\n                helper(target-candidates[i], i, sub_list+[candidates[i]])\\n        helper(target, 0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates:\\n            return []\\n        res = []\\n        candidates.sort()\\n        def helper(target, index, sub_list):\\n            if target == 0:\\n                res.append(sub_list)\\n            if target < 0 or index >= len(candidates):\\n                return\\n            for i in range(index, len(candidates)):\\n                #optimization\\n                if target < candidates[i]:\\n                    break\\n                helper(target-candidates[i], i, sub_list+[candidates[i]])\\n        helper(target, 0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762703,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643296,
                "title": "simple-recursion-python",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.answer=set()   # Set - To get rid of duplicates\\n        self.candidates=[]  \\n    def helper(self,target_,ans_=[]):\\n        if target_ < 0 : return\\n        elif target_ == 0 : \\n            self.answer.add(tuple(sorted(ans_))) # Sets can store only tuples not lists \\n            return          # Sorting it to make it distinguishable\\n        else:\\n            for i in self.candidates:\\n                self.helper(target_-i,ans_+[i])\\n    def combinationSum(self, candidates, target) -> List[List[int]]:\\n        self.candidates = candidates # Making it a data member caus\\' it never changes and \\n        self.helper(target)          #     no need to pass it for every recursion call\\n        return list(self.answer)\\n```\\n![image](https://assets.leetcode.com/users/ssvvbb6/image_1590044625.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.answer=set()   # Set - To get rid of duplicates\\n        self.candidates=[]  \\n    def helper(self,target_,ans_=[]):\\n        if target_ < 0 : return\\n        elif target_ == 0 : \\n            self.answer.add(tuple(sorted(ans_))) # Sets can store only tuples not lists \\n            return          # Sorting it to make it distinguishable\\n        else:\\n            for i in self.candidates:\\n                self.helper(target_-i,ans_+[i])\\n    def combinationSum(self, candidates, target) -> List[List[int]]:\\n        self.candidates = candidates # Making it a data member caus\\' it never changes and \\n        self.helper(target)          #     no need to pass it for every recursion call\\n        return list(self.answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 521349,
                "title": "commented-python3-7-solution-faster-than-71-49-100-less-memory",
                "content": "unlike what I saw others post, i am not recalculating the sum every step, rather running the same solution for the remaining sum.\\nHope it helps!\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # if the target is reached - return \\n        if target == 0:\\n            return []\\n        \\n        # quit if we went out of bounds\\n        if target < 0:\\n            return None\\n        out = []\\n        \\n        # two cases here:\\n        # if a candidate is the target add to solutions \\n        # since everything after will be beyond the sum\\n        # if < target : get combinations on target-cur_candidate,\\n        # then merge each solution with the cur_candidate\\n\\n        for i in range(len(candidates)):\\n            candidate = candidates[i]\\n            if candidate == target:\\n                out.append([candidate])\\n\\n            if candidate < target:\\n                solutions = self.combinationSum(candidates[i:], target-candidate)\\n                for solution in solutions:\\n                    if solution is not None:\\n                        out.append([candidate, *solution])\\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # if the target is reached - return \\n        if target == 0:\\n            return []\\n        \\n        # quit if we went out of bounds\\n        if target < 0:\\n            return None\\n        out = []\\n        \\n        # two cases here:\\n        # if a candidate is the target add to solutions \\n        # since everything after will be beyond the sum\\n        # if < target : get combinations on target-cur_candidate,\\n        # then merge each solution with the cur_candidate\\n\\n        for i in range(len(candidates)):\\n            candidate = candidates[i]\\n            if candidate == target:\\n                out.append([candidate])\\n\\n            if candidate < target:\\n                solutions = self.combinationSum(candidates[i:], target-candidate)\\n                for solution in solutions:\\n                    if solution is not None:\\n                        out.append([candidate, *solution])\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519968,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> finalResult;\\n    vector<int> result;\\npublic:\\n    void combinationSumUtil(const vector<int>& candidates, int target, int size)\\n    {\\n        if(target == 0)\\n        {\\n            finalResult.push_back(result);\\n            return;\\n        }\\n        if(target<0) return;\\n        if(size<=0 && target>=1) return;\\n        result.push_back(candidates[size-1]);\\n        combinationSumUtil(candidates, target-candidates[size-1], size);\\n        result.pop_back();\\n        combinationSumUtil(candidates, target, size-1);\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        combinationSumUtil(candidates,target,candidates.size());\\n        return finalResult;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    vector<vector<int>> finalResult;\\n    vector<int> result;\\npublic:\\n    void combinationSumUtil(const vector<int>& candidates, int target, int size)\\n    {\\n        if(target == 0)\\n        {\\n            finalResult.push_back(result);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 499983,
                "title": "easy-to-understand-c-solution-backtracking",
                "content": "Runtime: 8 ms, faster than 97.96% of C++ online submissions for Combination Sum.\\nMemory Usage: 9.6 MB, less than 63.89% of C++ online submissions for Combination Sum.\\n```\\nclass Solution {\\n    vector<vector<int>> res;\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(candidates, target, 0, temp, 0);\\n        \\n        return res;\\n    }\\n    \\n    void solve(vector<int>& candidates, int target, int currSum, vector<int>& temp, int pos)\\n    {\\n        if(currSum > target)\\n            return;\\n        if(currSum == target)\\n        {\\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=pos; i<candidates.size(); i++)\\n        {\\n            currSum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            solve(candidates, target, currSum, temp, i);\\n            currSum -= candidates[i];\\n            temp.pop_back();\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    vector<vector<int>> res;\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        \\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(candidates, target, 0, temp, 0);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 403209,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n\\n    def combinationSum(self, candidates: [int], target: int) -> [[int]]:\\n        answer = []\\n\\n        universe = [([], 0)]\\n        for n in candidates:\\n            for (ls, v) in universe:\\n                if v + n == target:\\n                    answer.append(ls + [n])\\n                elif v + n < target:\\n                    universe.append((ls + [n], v + n))\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n\\n    def combinationSum(self, candidates: [int], target: int) -> [[int]]:\\n        answer = []\\n\\n        universe = [([], 0)]\\n        for n in candidates:\\n            for (ls, v) in universe:\\n                if v + n == target:\\n                    answer.append(ls + [n])\\n                elif v + n < target:\\n                    universe.append((ls + [n], v + n))\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340436,
                "title": "a-6-line-python-dp-solution-with-explanation",
                "content": "Intuition: This is very similar to the classic Knapsack problem (how many ways can you add these numbers to get target), except we also have to keep track of the combinations.\\n\\nConsider the example\\n\\n```[2,3,5]```, with target 8. To reach 8, our last step must be adding 2, 3, or 5. So we take all the combinations that add up to 6, 5, or 3 respectively, and add the remaining number rin the last step. To eliminate duplicates, we iterate over the candidates first. (This guarantees that each new combination we\\'re adding is distinct.)\\n\\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0] = [[]]\\n        for candidate in candidates:\\n            for i in range(candidate, len(dp)): \\n                dp[i].extend(comb + [candidate] for comb in dp[i - candidate])\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```[2,3,5]```\n```\\ndef combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0] = [[]]\\n        for candidate in candidates:\\n            for i in range(candidate, len(dp)): \\n                dp[i].extend(comb + [candidate] for comb in dp[i - candidate])\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 324671,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n\\tlet total = []\\n\\tfunction dfs (index, sum, result) {\\n\\t\\tif (sum === target) {\\n\\t\\t\\ttotal.push([...result])\\n\\t\\t}\\n\\t\\tif (sum > target) {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfor (let i = index; i < candidates.length; i++) {\\n\\t\\t\\tresult.push(candidates[i])\\n\\t\\t\\tdfs(i, sum + candidates[i], result)\\n\\t\\t\\tresult.pop()\\n\\t\\t}\\n\\t}\\n\\tdfs(0, 0, [])\\n\\treturn total\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n\\tlet total = []\\n\\tfunction dfs (index, sum, result) {\\n\\t\\tif (sum === target) {\\n\\t\\t\\ttotal.push([...result])\\n\\t\\t}\\n\\t\\tif (sum > target) {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tfor (let i = index; i < candidates.length; i++) {\\n\\t\\t\\tresult.push(candidates[i])\\n\\t\\t\\tdfs(i, sum + candidates[i], result)\\n\\t\\t\\tresult.pop()\\n\\t\\t}\\n\\t}\\n\\tdfs(0, 0, [])\\n\\treturn total\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16608,
                "title": "backtracking-top-down-dp-bottom-up-dp-solutions-in-java",
                "content": "**Solution 1: Backtracking**\\n```\\nList<List<Integer>> combSum_BK(int[] a, int target) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    backtrack(a, target, result, new ArrayList<>(), 0);\\n    return result;\\n}\\n\\nvoid backtrack(int[] a, int target, List<List<Integer>> result, List<Integer> path, int start) {\\n    if (target == 0) {\\n        result.add(new ArrayList<>(path));\\n        return;\\n    }\\n    for (int i = start; i < a.length; i++) {\\n        if (target - a[i] < 0) continue;\\n        path.add(a[i]);\\n        backtrack(a, target - a[i], result, path, i);\\n        path.remove(path.size() - 1);\\n    }\\n}\\n```\\n\\n**Solution 2: Top-Down DP**\\n```\\nList<List<Integer>> combSum_DP_TopDown(int[] a, int target) {\\n    List<List<List<Integer>>> dp = new ArrayList<>(target);\\n    Arrays.sort(a);\\n    for (int i = 0; i <= target; i++) dp.add(null);\\n    return subProblem(a, target, dp);\\n}\\n\\nList<List<Integer>> subProblem(int[] a, int target, List<List<List<Integer>>> dp) {\\n    if (dp.get(target) != null) return dp.get(target);  // Already calculated. Reuse.\\n    List<List<Integer>> current = new ArrayList<>();    // Not yet calculated.\\n    for (int candidate : a) {\\n        if (target - candidate < 0) break;      // Subproblem doesn't exist.\\n        if (target - candidate == 0) {          // Subproblem is candidate itself.\\n            List<Integer> single = new ArrayList<>(Arrays.asList(candidate));\\n            current.add(single);\\n            continue;\\n        }\\n        List<List<Integer>> old = subProblem(a, target - candidate, dp); //check Subproblem\\n        for (List<Integer> path : old) {            // Add candidate to all results.\\n            if (candidate > path.get(0)) continue;\\n            List<Integer> new_path = new ArrayList<>();        \\n            new_path.add(candidate);\\n            new_path.addAll(path);\\n            current.add(new_path);\\n        }\\n    }\\n    dp.set(target, current);    // Current problem results memoized.\\n    return dp.get(target);\\n}\\n```\\n\\n**Solution 3: Bottom-Up DP**\\n```\\nList<List<Integer>> comb_DP_BottomUp(int[] a, int target) {\\n    Arrays.sort(a);\\n    List<List<List<Integer>>> dp = new ArrayList<>();\\n    for (int i = 1; i <= target; i++) {\\n        List<List<Integer>> current = new ArrayList<>();\\n        for (int candidate : a) {\\n            int sub = i - candidate;    \\n            if (sub < 0) break;         // subproblem doesn't exist.\\n            if (sub == 0) {             // subproblem is candidate itself. \\n                current.add(Arrays.asList(candidate));              \\n                continue;\\n            }\\n            for (List<Integer> path : dp.get(sub - 1)) {    // subproblem is reused.\\n                if (candidate > path.get(0)) continue;\\n                List<Integer> new_path = new ArrayList<>();\\n                new_path.add(candidate);\\n                new_path.addAll(path);\\n                current.add(new_path);\\n            }\\n        }\\n        dp.add(current);\\n    }\\n    return dp.get(target - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nList<List<Integer>> combSum_BK(int[] a, int target) {\\n    List<List<Integer>> result = new ArrayList<>();\\n    backtrack(a, target, result, new ArrayList<>(), 0);\\n    return result;\\n}\\n\\nvoid backtrack(int[] a, int target, List<List<Integer>> result, List<Integer> path, int start) {\\n    if (target == 0) {\\n        result.add(new ArrayList<>(path));\\n        return;\\n    }\\n    for (int i = start; i < a.length; i++) {\\n        if (target - a[i] < 0) continue;\\n        path.add(a[i]);\\n        backtrack(a, target - a[i], result, path, i);\\n        path.remove(path.size() - 1);\\n    }\\n}\\n```\n```\\nList<List<Integer>> combSum_DP_TopDown(int[] a, int target) {\\n    List<List<List<Integer>>> dp = new ArrayList<>(target);\\n    Arrays.sort(a);\\n    for (int i = 0; i <= target; i++) dp.add(null);\\n    return subProblem(a, target, dp);\\n}\\n\\nList<List<Integer>> subProblem(int[] a, int target, List<List<List<Integer>>> dp) {\\n    if (dp.get(target) != null) return dp.get(target);  // Already calculated. Reuse.\\n    List<List<Integer>> current = new ArrayList<>();    // Not yet calculated.\\n    for (int candidate : a) {\\n        if (target - candidate < 0) break;      // Subproblem doesn't exist.\\n        if (target - candidate == 0) {          // Subproblem is candidate itself.\\n            List<Integer> single = new ArrayList<>(Arrays.asList(candidate));\\n            current.add(single);\\n            continue;\\n        }\\n        List<List<Integer>> old = subProblem(a, target - candidate, dp); //check Subproblem\\n        for (List<Integer> path : old) {            // Add candidate to all results.\\n            if (candidate > path.get(0)) continue;\\n            List<Integer> new_path = new ArrayList<>();        \\n            new_path.add(candidate);\\n            new_path.addAll(path);\\n            current.add(new_path);\\n        }\\n    }\\n    dp.set(target, current);    // Current problem results memoized.\\n    return dp.get(target);\\n}\\n```\n```\\nList<List<Integer>> comb_DP_BottomUp(int[] a, int target) {\\n    Arrays.sort(a);\\n    List<List<List<Integer>>> dp = new ArrayList<>();\\n    for (int i = 1; i <= target; i++) {\\n        List<List<Integer>> current = new ArrayList<>();\\n        for (int candidate : a) {\\n            int sub = i - candidate;    \\n            if (sub < 0) break;         // subproblem doesn't exist.\\n            if (sub == 0) {             // subproblem is candidate itself. \\n                current.add(Arrays.asList(candidate));              \\n                continue;\\n            }\\n            for (List<Integer> path : dp.get(sub - 1)) {    // subproblem is reused.\\n                if (candidate > path.get(0)) continue;\\n                List<Integer> new_path = new ArrayList<>();\\n                new_path.add(candidate);\\n                new_path.addAll(path);\\n                current.add(new_path);\\n            }\\n        }\\n        dp.add(current);\\n    }\\n    return dp.get(target - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16658,
                "title": "4-problems-1-solution-java-solutions-for-combinations-combination-sum1-combination-sum2-combination-sum3",
                "content": "**Combinations**\\n\\n```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum1**\\n\\n\\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum2**\\n\\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\\n\\n**CombinationSum3**\\n\\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Combinatorics"
                ],
                "code": "```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16666,
                "title": "almost-same-solution-for-two-problems-combination-sum-and-combination-sum-ii-c-code-with-comments-fast",
                "content": "**Combination Sum** \\n\\ncode is explained as comments.\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                   // if current element is bigger than the assigned target, there is \\n                   //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                   //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                   // keep searching for new elements with start as i since here duplicates are allowed\\n                elementSum(candidates,res,elements,target-candidates[i],i);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n**Combination Sum II**\\n\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                 // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                 // we always want to count the first element in this recursive step even if it is the same \\n                 // as one before. To avoid overcounting, we just ignore the duplicates\\n                 // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                  // if current element is bigger than the assigned target, there is \\n                  //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                  //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                  // keep searching for new element with start as i + 1 because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n\\nThank you",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "**Combination Sum** \\n\\ncode is explained as comments.\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                   // if current element is bigger than the assigned target, there is \\n                   //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                   //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                   // keep searching for new elements with start as i since here duplicates are allowed\\n                elementSum(candidates,res,elements,target-candidates[i],i);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n**Combination Sum II**\\n\\n\\n    void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start){\\n                 // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                 // we always want to count the first element in this recursive step even if it is the same \\n                 // as one before. To avoid overcounting, we just ignore the duplicates\\n                 // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                  // if current element is bigger than the assigned target, there is \\n                  //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                  //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                  // keep searching for new element with start as i + 1 because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }\\n        \\n\\nThank you",
                "codeTag": "Unknown"
            },
            {
                "id": 3919161,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    void solve(int ind, vector<int>&candidates, int &target, int sum, vector<vector<int>>&result , vector<int>&ans) \\n    {\\n        if(ind == candidates.size())\\n        {\\n            // if(sum == target)\\n            // {\\n            //     result.push_back(ans);\\n            // }\\n            return;\\n        }\\n\\n        if(sum >= target)\\n        {\\n            if(sum == target)\\n            {\\n                result.push_back(ans);\\n            }\\n            return;\\n        }\\n            ans.push_back(candidates[ind]);\\n            sum = sum + candidates[ind];\\n            solve(ind, candidates, target, sum, result, ans);\\n\\n            ans.pop_back();\\n            sum -= candidates[ind];\\n            solve(ind+1, candidates, target, sum, result, ans);\\n         \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) \\n    {\\n        vector<vector<int>>result;\\n        vector<int>ans;\\n        solve(0, candidates, target, 0, result, ans);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void solve(int ind, vector<int>&candidates, int &target, int sum, vector<vector<int>>&result , vector<int>&ans) \\n    {\\n        if(ind == candidates.size())\\n        {\\n            // if(sum == target)\\n            // {\\n            //     result.push_back(ans);\\n            // }\\n            return;\\n        }\\n\\n        if(sum >= target)\\n        {\\n            if(sum == target)\\n            {\\n                result.push_back(ans);\\n            }\\n            return;\\n        }\\n            ans.push_back(candidates[ind]);\\n            sum = sum + candidates[ind];\\n            solve(ind, candidates, target, sum, result, ans);\\n\\n            ans.pop_back();\\n            sum -= candidates[ind];\\n            solve(ind+1, candidates, target, sum, result, ans);\\n         \\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) \\n    {\\n        vector<vector<int>>result;\\n        vector<int>ans;\\n        solve(0, candidates, target, 0, result, ans);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631074,
                "title": "most-optimized-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j,n,k-v[j],v,tmp,ans);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& v, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = v.size();\\n        solve(0,n,target,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j,n,k-v[j],v,tmp,ans);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& v, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> tmp;\\n        int n = v.size();\\n        solve(0,n,target,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193246,
                "title": "simple-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        self.ans = []                                   # for adding all the answers\\n        def traverse(candid, arr,sm):                   # arr : an array that contains the accused combination; sm : is the sum of all elements of arr \\n            if sm == target: self.ans.append(arr)       # If sum is equal to target then you know it, I know it, what to do\\n            if sm >= target: return                     # If sum is greater than target then no need to move further.\\n            for i in range(len(candid)):                # we will traverse each element from the array.\\n                traverse(candid[i:], arr + [candid[i]], sm+candid[i])   #most important, splice the array including the current index, splicing in order to handle the duplicates.\\n        traverse(candidates,[], 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184895,
                "title": "all-in-one-iterative-vs-recursive-tree-diagram-detailed-explained-meme",
                "content": "![backtea.jpeg](https://assets.leetcode.com/users/images/8643339f-f6fa-43ec-91c4-47f8007c230d_1676377995.5688634.jpeg)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs you might have noticed that we are not considering the whole array as possible options at every level, because we want unique combinations.\\ne.g. at the node [2, 2, 3], the possible options for the next level are only [3, 5]. Why?? because if we consider the whole array as possible options, then we we will end up with [2, 2, 3, 2] (with 2 as a possible option), which has already been checked as [2, 2, 2, 3] (see the tree). So to make the solution unique we are only considering the part of the array from current last element to the end element (like in this example).\\n1. If the sum of the current combination is greater than target, then even if we move forward with this combination, the sum will only increase, so there is no fun to moving further with such a combination as we can never achieve the target sum from this. So backtrack from this.\\n2. If the sum of the current combination is equal to the target, then we have a solution, so store this combination in the answers. Now moving forward with this combnation also will only increase the sum and we can\\'t achieve the target sum again from this ever. So backtrack from here.\\n3. if we are here then that means the sum of the combination is still less that the target sum, and we have a scope of finding a combination whose sum can be equal to the target.\\n\\t\\ti) Now consider all possible options into this combination, one at a time.\\n\\t\\tii) Go check if considering the current option can give us the solution.\\n\\t\\tiii) Now when this option backtracks to this place again, now remove this option and try another option. e.g. at [2, 2, _ ] we have 3 options to fill the 3rd place i.e. [2, 3, 5].\\n\\t\\tSo firstly we will go on with [2, 2, 2]. Then when this backtracks to this place again, remove the last 2 and try the next option which is 3 that means [2, 2, 3].\\n\\t\\tWhen this also backtracks remove 3 to try 5, that means [2, 2, 5].\\n\\t\\tNow as all the options are exhausted for [2, 2, _ ], now backtrack to its previous state which is [2, 2], and so on...\\n\\n![disc.jpeg](https://assets.leetcode.com/users/images/6d68f170-7995-4c8e-9548-933a3412e358_1676378568.4791667.jpeg)\\n\\n\\nHow Tree diagram will work-\\n\\nWe will make a op array, that contains all the possible combinations sum of the array.\\n\\nWe will start from the index 0 and as we already discussed that for each and every element we have two possibility whether to include this element in making our answer or not, so we will explore all possibilities.\\n\\nop aray represents which elements this array contains now in making combination sum.\\n\\nTarget represents the left combination sum that we have to make. Intially it is same as the original target that we have to make.\\n\\nThe red cursor below the array, points that on which index we are currently standing.\\n\\nIf at any point our target becomes zero, then we will include that combination in our answer array saying that yes, this is an possible combination and return from there.\\n\\nIf at any point our target becomes less than zero, then we return from there saying that we are never able to make our cbination sum by this combination.\\n\\nIf at any point we cross the size of the array then we will return from there saying that no more element is left to choose.\\n\\nAs we dicussed for every element we have two choices whether to include in our answer or not include in our answer.\\n\\nSo, if we do not a include a element in our answer then without decreasing target sum, we will move to next index. Why we do not decrese sum? because we will choose not to include in this element in our combination, hence it does not contribute in making our sum.\\n\\nBut, if we choose a particular element to include in our answer, then we will decrease the target sum but we will not move to next index. Why we will not move to next index? because for a specific element we have unlimited number of choice, so it may be possible that specific element again contribute in making our sum.\\n\\nIf Image is not cleary visible to you, then for that I have uploaded it on my drive.\\n\\nYou may visit this link to see Image in good quality.\\n\\n# Code\\n```1_c++_recursive []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n``` \\n```PYTHON_ITERATIVE []\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```\\n```c++_recursive []\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```\\n```java_iterative []\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\n  private void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curSum>target) return;\\n        if(curSum==target){\\n            ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        for(int j=curInd;j<A.length;j++){\\n            subList.add(A[j]);\\n            dfs(ans,subList,A,target,j,curSum+A[j]);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n```\\n```c++ []\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n```\\n```java_recur []\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\nprivate void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curInd==A.length){\\n            if(target==curSum) ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        if((curSum+A[curInd])<=target){\\n            subList.add(A[curInd]);\\n            dfs(ans,subList,A,target,curInd,curSum+A[curInd]);\\n            subList.remove(subList.size()-1);\\n        }\\n        dfs(ans,subList,A,target,curInd+1,curSum);\\n    }\\n```\\n# PYTHON\\n\\n```Combinations []\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\\n```Permutations_I []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\\n```Permutations_II []\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n```Subsets_1 []\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n```Subsets_II []\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n```Comb_Sum []\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n```Comb_sum_II []\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```\\n# java \\n\\n```subset []\\nSubsets : https://leetcode.com/problems/subsets/\\n\\npublic List<List<Integer>> subsets(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n}\\n```\\n```subset2 []\\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n} \\n```\\n```perm []\\nPermutations : https://leetcode.com/problems/permutations/\\n\\npublic List<List<Integer>> permute(int[] nums) {\\n   List<List<Integer>> list = new ArrayList<>();\\n   // Arrays.sort(nums); // not necessary\\n   backtrack(list, new ArrayList<>(), nums);\\n   return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n   if(tempList.size() == nums.length){\\n      list.add(new ArrayList<>(tempList));\\n   } else{\\n      for(int i = 0; i < nums.length; i++){ \\n         if(tempList.contains(nums[i])) continue; // element already exists, skip\\n         tempList.add(nums[i]);\\n         backtrack(list, tempList, nums);\\n         tempList.remove(tempList.size() - 1);\\n      }\\n   }\\n} \\n```\\n```permu2 []\\nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n    if(tempList.size() == nums.length){\\n        list.add(new ArrayList<>(tempList));\\n    } else{\\n        for(int i = 0; i < nums.length; i++){\\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n            used[i] = true; \\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, used);\\n            used[i] = false; \\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n```combSum []\\nCombination Sum : https://leetcode.com/problems/combination-sum/\\n\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n```com_sum2 []\\nCombination Sum II (can\\'t reuse same element) : https://leetcode.com/problems/combination-sum-ii/\\n\\npublic List<List<Integer>> combinationSum2(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n    \\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n            tempList.remove(tempList.size() - 1); \\n        }\\n    }\\n} \\n```\\n```palin_part []\\nPalindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/\\npublic List<List<String>> partition(String s) {\\n   List<List<String>> list = new ArrayList<>();\\n   backtrack(list, new ArrayList<>(), s, 0);\\n   return list;\\n}\\n\\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n   if(start == s.length())\\n      list.add(new ArrayList<>(tempList));\\n   else{\\n      for(int i = start; i < s.length(); i++){\\n         if(isPalindrome(s, start, i)){\\n            tempList.add(s.substring(start, i + 1));\\n            backtrack(list, tempList, s, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n         }\\n      }\\n   }\\n}\\n\\npublic boolean isPalindrome(String s, int low, int high){\\n   while(low < high)\\n      if(s.charAt(low++) != s.charAt(high--)) return false;\\n   return true;\\n} \\n```\\n\\n# c++ \\n```comsum1 []\\nAccepted 16ms c++ solution use backtracking for Combination Sum:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n            combination.push_back(candidates[i]);\\n            combinationSum(candidates, target - candidates[i], res, combination, i);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\\n```comsum2 []\\nAccepted 12ms c++ solution use backtracking for Combination Sum II:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum2(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n            if (i == begin || candidates[i] != candidates[i - 1]) {\\n                combination.push_back(candidates[i]);\\n                combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                combination.pop_back();\\n            }\\n    }\\n};\\n```\\n```comSum2 []\\nAccepted 0ms c++ solution use backtracking for Combination Sum III:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum3(n, res, combination, 1, k);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        else if (!need)\\n            return;\\n        for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n            combination.push_back(i);\\n            combinationSum3(target - i, res, combination, i + 1, need - 1);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity:o(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![mem2.png](https://assets.leetcode.com/users/images/8b0c18c6-2e7d-4ef3-a11b-1ff369dc24f2_1676378307.5784204.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```1_c++_recursive []\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // 2 D vector to store our answer\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target)\\n    {\\n        // if our target becomes zero at any point, then yess!! we wil find a possible combination\\n        if(target == 0) \\n        {\\n            ans.push_back(temp); // include that combination in our answer\\n            return; // and then return, we are now not gonna explore more possiblity\\n        }\\n        \\n        // if at any point target becomes less than zero, then simply return, saying that no it is notpossible to our target combination sum\\n        if(target < 0)\\n            return;\\n        \\n        // if index crosses the last index, we will return saying that no more element is left to choosee\\n        if(i == arr.size())\\n            return;\\n        \\n        // As we dicussed for every element we have two choices whether to include in our answer or not include in our answer. \\n\\t\\t//so now, we are doing that\\n        \\n        // we are not taking the ith element,\\n        // so without decreasing sum we will move to next index because it will not contribute in making our sum\\n        solve(i + 1, arr, temp, target);\\n        \\n        // we are taking the ith element and not moving onto the next element because it may be possible that this element again contribute in making our sum.\\n        // but we decrease our target sum as we are consediring that this will help us in making our target sum\\n        \\n        temp.push_back(arr[i]); // including ith element\\n        solve(i, arr, temp, target - arr[i]); // decreasing sum,and call again function\\n        temp.pop_back(); // backtrack\\n        \\n    }\\n    vector<vector<int>> combinationSum(vector<int>& arr, int target) {\\n        ans.clear(); // clear global array, make to sure that no garbage value is present in it\\n        \\n        vector<int> temp; // temporary vector that tries all possible combination\\n        \\n        solve(0, arr, temp, target); // calling function, and see we start from index zero\\n        \\n        return ans; // finally return the answer array\\n    }\\n};\\n```\n```PYTHON_ITERATIVE []\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        ret = []\\n        self.dfs(candidates, target, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, path, ret):\\n        if target < 0:\\n            return \\n        if target == 0:\\n            ret.append(path)\\n            return \\n        for i in range(len(nums)):\\n            self.dfs(nums[i:], target-nums[i], path+[nums[i]], ret)\\n```\n```c++_recursive []\\nclass Solution {\\npublic:\\n    // for the sake of convience, not to include again and again in my function call, I declare target here\\n    int target;\\n    \\n    vector<vector<int>> ans; // 2-D vector to store our answer\\n    \\n    void solve(vector<int>& arr, int i, int sum, vector<int> op)\\n    {\\n        // if i crosses the array size, we will return saying that no more possibilty is left to choose\\n        \\n        if(i >= arr.size()) \\n        {\\n            return;\\n        }\\n        \\n        // if value at ith index + sum becomes equal to target, then we will store it in our answer array, saying that yes it is a possible combination\\n        if(arr[i] + sum == target)\\n        {\\n            op.push_back(arr[i]);\\n            ans.push_back(op);\\n            return;\\n        }\\n        \\n        // if value at ith index + sum is less than target, then we have two choices i.e whether to include this value in our possible combiation array or not include that,\\n        if(arr[i] + sum < target)\\n        {\\n            // we make two output vector, one for calling function at same index and anthor for calling function frm next index. Because for every element we have unlimited choices, that it will contribute in making our sum any number of times.\\n            vector<int> op1 = op;\\n            vector<int> op2 = op;\\n            \\n            op2.push_back(arr[i]);\\n            solve(arr, i, sum + arr[i], op2);\\n            solve(arr, i + 1, sum, op1);\\n        }\\n        else\\n        {\\n            solve(arr, i + 1, sum, op); // call for the next index\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& arr, int required_target) {\\n        ans.clear(); //clear global array, make to sure that no garbage value is present in it\\n        \\n        target = required_target; // give target what he wants \\n        vector<int> op; // op array to try all possible combination\\n        sort(arr.begin(),arr.end()); // sort the array in ascending order\\n        solve(arr, 0, 0, op); // call function\\n        \\n        return ans; // return the final answer array\\n    }\\n};\\n```\n```java_iterative []\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\n  private void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curSum>target) return;\\n        if(curSum==target){\\n            ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        for(int j=curInd;j<A.length;j++){\\n            subList.add(A[j]);\\n            dfs(ans,subList,A,target,j,curSum+A[j]);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n```\n```c++ []\\nclass Solution {\\n    void combination(vector<int>& candidates, int target, vector<int> currComb, int currSum, int currIndex, vector<vector<int>>& ans){\\n        if(currSum>target) return; //backtrack\\n        if(currSum==target){\\n            ans.push_back(currComb); //store the solution and backtrack\\n            return;\\n        }\\n        \\n        for(int i=currIndex; i<candidates.size(); i++){ //try all possible options for the next level\\n            currComb.push_back(candidates[i]); //put 1 option into the combination\\n            currSum+=candidates[i];\\n            combination(candidates, target, currComb, currSum, i, ans); //try with this combination, whether it gives a solution or not.\\n            currComb.pop_back(); //when this option backtrack to here, remove this and go on to the next option.\\n            currSum-=candidates[i];\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> currComb;\\n        combination(candidates, target, currComb, 0, 0, ans);\\n        return ans;\\n    }\\n};\\n```\n```java_recur []\\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        dfs(answer,new ArrayList<Integer>(), candidates,target,0,0);\\n        return answer;\\n    }\\nprivate void dfs(List<List<Integer>> ans,List<Integer> subList,int A[],int target,int curInd,int curSum){\\n        if(curInd==A.length){\\n            if(target==curSum) ans.add(new ArrayList<>(subList));\\n            return;\\n        }\\n        if((curSum+A[curInd])<=target){\\n            subList.add(A[curInd]);\\n            dfs(ans,subList,A,target,curInd,curSum+A[curInd]);\\n            subList.remove(subList.size()-1);\\n        }\\n        dfs(ans,subList,A,target,curInd+1,curSum);\\n    }\\n```\n```Combinations []\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```Permutations_I []\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```Permutations_II []\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```Subsets_1 []\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```Subsets_II []\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```Comb_Sum []\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```Comb_sum_II []\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```\n```subset []\\nSubsets : https://leetcode.com/problems/subsets/\\n\\npublic List<List<Integer>> subsets(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n}\\n```\n```subset2 []\\nSubsets II (contains duplicates) : https://leetcode.com/problems/subsets-ii/\\n\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n    list.add(new ArrayList<>(tempList));\\n    for(int i = start; i < nums.length; i++){\\n        if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n        tempList.add(nums[i]);\\n        backtrack(list, tempList, nums, i + 1);\\n        tempList.remove(tempList.size() - 1);\\n    }\\n} \\n```\n```perm []\\nPermutations : https://leetcode.com/problems/permutations/\\n\\npublic List<List<Integer>> permute(int[] nums) {\\n   List<List<Integer>> list = new ArrayList<>();\\n   // Arrays.sort(nums); // not necessary\\n   backtrack(list, new ArrayList<>(), nums);\\n   return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n   if(tempList.size() == nums.length){\\n      list.add(new ArrayList<>(tempList));\\n   } else{\\n      for(int i = 0; i < nums.length; i++){ \\n         if(tempList.contains(nums[i])) continue; // element already exists, skip\\n         tempList.add(nums[i]);\\n         backtrack(list, tempList, nums);\\n         tempList.remove(tempList.size() - 1);\\n      }\\n   }\\n} \\n```\n```permu2 []\\nPermutations II (contains duplicates) : https://leetcode.com/problems/permutations-ii/\\n\\npublic List<List<Integer>> permuteUnique(int[] nums) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n    if(tempList.size() == nums.length){\\n        list.add(new ArrayList<>(tempList));\\n    } else{\\n        for(int i = 0; i < nums.length; i++){\\n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n            used[i] = true; \\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, used);\\n            used[i] = false; \\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```combSum []\\nCombination Sum : https://leetcode.com/problems/combination-sum/\\n\\npublic List<List<Integer>> combinationSum(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{ \\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```com_sum2 []\\nCombination Sum II (can\\'t reuse same element) : https://leetcode.com/problems/combination-sum-ii/\\n\\npublic List<List<Integer>> combinationSum2(int[] nums, int target) {\\n    List<List<Integer>> list = new ArrayList<>();\\n    Arrays.sort(nums);\\n    backtrack(list, new ArrayList<>(), nums, target, 0);\\n    return list;\\n    \\n}\\n\\nprivate void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n    if(remain < 0) return;\\n    else if(remain == 0) list.add(new ArrayList<>(tempList));\\n    else{\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n            tempList.remove(tempList.size() - 1); \\n        }\\n    }\\n} \\n```\n```palin_part []\\nPalindrome Partitioning : https://leetcode.com/problems/palindrome-partitioning/\\npublic List<List<String>> partition(String s) {\\n   List<List<String>> list = new ArrayList<>();\\n   backtrack(list, new ArrayList<>(), s, 0);\\n   return list;\\n}\\n\\npublic void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n   if(start == s.length())\\n      list.add(new ArrayList<>(tempList));\\n   else{\\n      for(int i = start; i < s.length(); i++){\\n         if(isPalindrome(s, start, i)){\\n            tempList.add(s.substring(start, i + 1));\\n            backtrack(list, tempList, s, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n         }\\n      }\\n   }\\n}\\n\\npublic boolean isPalindrome(String s, int low, int high){\\n   while(low < high)\\n      if(s.charAt(low++) != s.charAt(high--)) return false;\\n   return true;\\n} \\n```\n```comsum1 []\\nAccepted 16ms c++ solution use backtracking for Combination Sum:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i) {\\n            combination.push_back(candidates[i]);\\n            combinationSum(candidates, target - candidates[i], res, combination, i);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```\n```comsum2 []\\nAccepted 12ms c++ solution use backtracking for Combination Sum II:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum2(std::vector<int> &candidates, int target) {\\n        std::sort(candidates.begin(), candidates.end());\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum2(candidates, target, res, combination, 0);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum2(std::vector<int> &candidates, int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        for (int i = begin; i != candidates.size() && target >= candidates[i]; ++i)\\n            if (i == begin || candidates[i] != candidates[i - 1]) {\\n                combination.push_back(candidates[i]);\\n                combinationSum2(candidates, target - candidates[i], res, combination, i + 1);\\n                combination.pop_back();\\n            }\\n    }\\n};\\n```\n```comSum2 []\\nAccepted 0ms c++ solution use backtracking for Combination Sum III:\\n\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int> > combinationSum3(int k, int n) {\\n        std::vector<std::vector<int> > res;\\n        std::vector<int> combination;\\n        combinationSum3(n, res, combination, 1, k);\\n        return res;\\n    }\\nprivate:\\n    void combinationSum3(int target, std::vector<std::vector<int> > &res, std::vector<int> &combination, int begin, int need) {\\n        if (!target) {\\n            res.push_back(combination);\\n            return;\\n        }\\n        else if (!need)\\n            return;\\n        for (int i = begin; i != 10 && target >= i * need + need * (need - 1) / 2; ++i) {\\n            combination.push_back(i);\\n            combinationSum3(target - i, res, combination, i + 1, need - 1);\\n            combination.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515817,
                "title": "combination-sum-python-faster-than-98-recursive-approach",
                "content": "```\\n# There are two possibities of making a combination, i.e., to take an element or to not take an element.\\n\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        final = []\\n        def get_combinations(ind, target, arr, result):\\n            if ind == len(arr):\\n                if target == 0:\\n                    final.append(result[:])\\n                return\\n            if arr[ind] <= target:\\n                result.append(arr[ind])\\n                get_combinations(ind, target-arr[ind], arr, result)  # to take the element\\n                result.pop()\\n            get_combinations(ind+1, target, arr, result)  # to not take the element\\n        get_combinations(0, target, candidates, [])\\n        return final\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# There are two possibities of making a combination, i.e., to take an element or to not take an element.\\n\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        final = []\\n        def get_combinations(ind, target, arr, result):\\n            if ind == len(arr):\\n                if target == 0:\\n                    final.append(result[:])\\n                return\\n            if arr[ind] <= target:\\n                result.append(arr[ind])\\n                get_combinations(ind, target-arr[ind], arr, result)  # to take the element\\n                result.pop()\\n            get_combinations(ind+1, target, arr, result)  # to not take the element\\n        get_combinations(0, target, candidates, [])\\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382056,
                "title": "python-faster-than-92-easy-solution",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        path = []\\n        answer = []\\n        def dp(idx, total):\\n            if total == target:\\n                answer.append(path[:])\\n                return\\n            if total > target:\\n                return\\n            \\n            for i in range(idx, len(candidates)):\\n                path.append(candidates[i])\\n                dp(i, total + candidates[i])\\n                path.pop()\\n        \\n        dp(0, 0)\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        path = []\\n        answer = []\\n        def dp(idx, total):\\n            if total == target:\\n                answer.append(path[:])\\n                return\\n            if total > target:\\n                return\\n            \\n            for i in range(idx, len(candidates)):\\n                path.append(candidates[i])\\n                dp(i, total + candidates[i])\\n                path.pop()\\n        \\n        dp(0, 0)\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378912,
                "title": "easy-c-detailed-explanation",
                "content": "For this a prior knowledge of recursion and backtracking is required thats it \\n\\n1st Click why recursion --- Since we need to know every kind of combination and also cant possible with regular                                               for and while loop \\n\\n2nd click ---- either include || either we not include it in our data structure approach that get in mind\\n\\nIn this method we just reduce the target till it become equal to 0 by taking each and every possible case of including or not including the combination \\n\\nthinking of approach is difficult but understanding it is much more easier \\n\\n\\nclass Solution {\\n    \\npublic:\\n     void FindCombination( int i , int target , vector<int>&arr , vector<int>&ds , vector<vector<int>>&ans)\\n     {\\n         if(i==arr.size())\\n         {\\n              if(target==0)\\n             {\\n                   ans.push_back(ds) ; \\n             }  \\n             return ; \\n         }      \\n         if(target >= arr[i])\\n         {\\n               ds.push_back(arr[i]) ; \\n              FindCombination(i , target-arr[i] , arr , ds , ans) ; \\n\\t\\t\\t  ds.pop_back() ; // here we are not increasing index so that same element \\n         }                     // pop_back() used for all not including conditions\\n\\t\\t     FindCombination(i+1,target,arr,ds,ans) ; \\n     }\\n   \\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>>ans ; \\n        vector<int>ds ;  // here we simply declare everything we required  \\n        FindCombination(0,target,candidates,ds,ans) ;  // pass it to our recursive function \\n        return ans ; \\n    }\\n};\\n\\nenjoy learning || enjoy leet code \\n\\nif everything is clear make sure to give a up vote",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\npublic:\\n     void FindCombination( int i , int target , vector<int>&arr , vector<int>&ds , vector<vector<int>>&ans)\\n     {\\n         if(i==arr.size())\\n         {\\n              if(target==0)\\n             {\\n                   ans.push_back(ds) ; \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1777617,
                "title": "js-using-recurison",
                "content": "```\\n\\nconst combinationSum = function(candidates, target) {\\n    const len = candidates.length;\\n    const result = [];\\n    \\n    const recursiveFxn = (sum, idx, arr) => {\\n        if(idx >= len) {\\n            return;\\n        }\\n        if(sum < 0) {\\n            return;\\n        }\\n        if(sum === 0) {\\n            result.push([...arr]);\\n        }\\n        for(let i = idx; i < len; i++) {\\n            arr.push(candidates[i]);\\n            recursiveFxn(sum-candidates[i], i, arr);\\n            arr.pop(candidates[i]);\\n        }\\n        \\n    };\\n\\n    recursiveFxn(target, 0, []);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst combinationSum = function(candidates, target) {\\n    const len = candidates.length;\\n    const result = [];\\n    \\n    const recursiveFxn = (sum, idx, arr) => {\\n        if(idx >= len) {\\n            return;\\n        }\\n        if(sum < 0) {\\n            return;\\n        }\\n        if(sum === 0) {\\n            result.push([...arr]);\\n        }\\n        for(let i = idx; i < len; i++) {\\n            arr.push(candidates[i]);\\n            recursiveFxn(sum-candidates[i], i, arr);\\n            arr.pop(candidates[i]);\\n        }\\n        \\n    };\\n\\n    recursiveFxn(target, 0, []);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777476,
                "title": "python3-easy-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        def dfs(i,arr,total):\\n            if total==target:\\n                ans.append(arr.copy())\\n                return\\n            if i>=len(candidates) or total>target:\\n                return\\n            \\n            arr.append(candidates[i])\\n            dfs(i, arr, total+candidates[i])\\n            arr.pop()\\n            dfs(i+1, arr, total)\\n        dfs(0,[],0)\\n        return ans\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans=[]\\n        def dfs(i,arr,total):\\n            if total==target:\\n                ans.append(arr.copy())\\n                return\\n            if i>=len(candidates) or total>target:\\n                return\\n            \\n            arr.append(candidates[i])\\n            dfs(i, arr, total+candidates[i])\\n            arr.pop()\\n            dfs(i+1, arr, total)\\n        dfs(0,[],0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777439,
                "title": "javascript-intutive-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(arr, target) {\\n    let result = []\\n    \\n    findCombination();\\n    return result\\n    \\n    function findCombination(start = 0, sum =0, ans = []){\\n        if(sum > target) return;\\n        if(sum === target){\\n            result.push(ans.slice());\\n        }\\n        \\n        for(let i=start; i<arr.length; i++){\\n            findCombination(i, sum + arr[i], [...ans, arr[i]]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(arr, target) {\\n    let result = []\\n    \\n    findCombination();\\n    return result\\n    \\n    function findCombination(start = 0, sum =0, ans = []){\\n        if(sum > target) return;\\n        if(sum === target){\\n            result.push(ans.slice());\\n        }\\n        \\n        for(let i=start; i<arr.length; i++){\\n            findCombination(i, sum + arr[i], [...ans, arr[i]]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640643,
                "title": "easy-fast-simple-98-92-76-ms-41-1-mb",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    const resArr = []\\n    \\n    const dfs = (i = 0, sum = 0, currentArr = []) => {\\n        if (sum > target) return\\n        if (sum === target) {\\n            resArr.push([...currentArr])\\n            return\\n        }\\n        for (let j = i; j < candidates.length; j++) {\\n            currentArr.push(candidates[j])\\n            dfs(j, sum + candidates[j], currentArr)\\n            currentArr.pop()\\n        }\\n    }\\n    \\n    dfs()\\n    return resArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function(candidates, target) {\\n    const resArr = []\\n    \\n    const dfs = (i = 0, sum = 0, currentArr = []) => {\\n        if (sum > target) return\\n        if (sum === target) {\\n            resArr.push([...currentArr])\\n            return\\n        }\\n        for (let j = i; j < candidates.length; j++) {\\n            currentArr.push(candidates[j])\\n            dfs(j, sum + candidates[j], currentArr)\\n            currentArr.pop()\\n        }\\n    }\\n    \\n    dfs()\\n    return resArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1606874,
                "title": "python-recursion-faster-than-97-9-with-comments-explanation",
                "content": "Pretty simple recusion here.  \\nFirst we verify that the list is sorted smallest to largest (problem didn\\'t specify), then we call into the recursive funciton which starts at the largest number and work backwards.\\n\\nIf the current value matches the target, we add it to the list of combinations on its own.\\n If value > target, or  target - value < smallest candidate, we skip this value.\\n For all other values, pass a slice of the candidate list up to and including the current index back into the recursive function with a new target of target-value.\\n  Then append the current value to all of those sub combinations and pass them back up.\\n\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # Edge Case\\n        if not candidates:\\n            return []\\n        \\n        # Define recursive function\\n        def rc(nums: list[int], target: int) -> list[list[int]]:\\n            nonlocal low_num\\n            combos = []\\n            for i in range(len(nums)-1, -1, -1):\\n                cur_val = nums[i]\\n                if cur_val == target:\\n                    combos.append([target])\\n                elif cur_val + low_num > target:\\n                     # Don\\'t waste time processing sub_combos for a number too large to be in any\\n                    continue\\n                else:\\n                    # Pass the list including current value into function to get all combos for sub-target.\\n                    sub_combos = rc(nums[:i+1], target - cur_val)\\n                    # Now add the current value to all of those combinations.\\n                    for sub in sub_combos:\\n                        sub.append(cur_val)\\n                        combos.append(sub)\\n            return combos\\n\\n        candidates.sort()   # The problem didn\\'t specify that candidates would be ordered.\\n        low_num = candidates[0]    # Used in rc to stop processing values that won\\'t be in any subgroup\\n        return rc(candidates, target)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6a2c3cd2-9879-4bbe-b588-8bbc7a3ce0a5_1638402728.3166742.png)\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # Edge Case\\n        if not candidates:\\n            return []\\n        \\n        # Define recursive function\\n        def rc(nums: list[int], target: int) -> list[list[int]]:\\n            nonlocal low_num\\n            combos = []\\n            for i in range(len(nums)-1, -1, -1):\\n                cur_val = nums[i]\\n                if cur_val == target:\\n                    combos.append([target])\\n                elif cur_val + low_num > target:\\n                     # Don\\'t waste time processing sub_combos for a number too large to be in any\\n                    continue\\n                else:\\n                    # Pass the list including current value into function to get all combos for sub-target.\\n                    sub_combos = rc(nums[:i+1], target - cur_val)\\n                    # Now add the current value to all of those combinations.\\n                    for sub in sub_combos:\\n                        sub.append(cur_val)\\n                        combos.append(sub)\\n            return combos\\n\\n        candidates.sort()   # The problem didn\\'t specify that candidates would be ordered.\\n        low_num = candidates[0]    # Used in rc to stop processing values that won\\'t be in any subgroup\\n        return rc(candidates, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573007,
                "title": "python-using-optimized-decision-tree",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        result = []\\n        def dfs(i, cur, total):\\n            if total == target:\\n                result.append(cur.copy())\\n                return\\n            if i >= len(candidates) or total > target: return\\n            cur.append(candidates[i])\\n            dfs(i, cur, total+candidates[i])\\n            cur.pop()\\n            dfs(i+1, cur, total)\\n            \\n        dfs(0, [], 0)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        result = []\\n        def dfs(i, cur, total):\\n            if total == target:\\n                result.append(cur.copy())\\n                return\\n            if i >= len(candidates) or total > target: return\\n            cur.append(candidates[i])\\n            dfs(i, cur, total+candidates[i])\\n            cur.pop()\\n            dfs(i+1, cur, total)\\n            \\n        dfs(0, [], 0)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435980,
                "title": "javascript-dfs-151ms",
                "content": "Did 40 https://leetcode.com/problems/combination-sum-ii/discuss/1435950/javascript-dfs-128ms first, small change\\n```\\nlet can, n;\\nconst combinationSum = (a, target) => {\\n    a.sort((x, y) => x - y);\\n    let res = [];\\n    can = a, n = a.length;\\n    dfs(target, 0, res, []);\\n    return res;\\n};\\n\\nconst dfs = (sum, start, res, path) => {\\n    if (sum == 0) return res.push([...path]);\\n    for (let i = start; i < n; i++) {\\n        if (can[i] > sum) return;\\n        path.push(can[i]);\\n        dfs(sum - can[i], i, res, path); // allow select the same number, change i + 1 to i \\n        path.pop();\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nlet can, n;\\nconst combinationSum = (a, target) => {\\n    a.sort((x, y) => x - y);\\n    let res = [];\\n    can = a, n = a.length;\\n    dfs(target, 0, res, []);\\n    return res;\\n};\\n\\nconst dfs = (sum, start, res, path) => {\\n    if (sum == 0) return res.push([...path]);\\n    for (let i = start; i < n; i++) {\\n        if (can[i] > sum) return;\\n        path.push(can[i]);\\n        dfs(sum - can[i], i, res, path); // allow select the same number, change i + 1 to i \\n        path.pop();\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374609,
                "title": "java-backtracking-3ms",
                "content": "```\\nclass Solution \\n{\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> curr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack( res , curr , 0 ,target,candidates,0);    \\n        return res;\\n    }\\n    public void backtrack( List<List<Integer>> res , List<Integer> curr , int sum ,int target,int[] candidates,int index)\\n    {\\n        if( sum == target )\\n        {\\n            if( !res.contains(curr) )\\n            {\\n                res.add(new ArrayList(curr));    \\n            }\\n            return;\\n        }\\n        for( int i = index ; i < candidates.length ; i++ )\\n        {\\n            if( sum + candidates[i] > target )\\n            {\\n                return;\\n            }\\n            curr.add( candidates[i] );\\n            sum = sum + candidates[i];\\n            backtrack( res , curr , sum , target , candidates ,i);  \\n            //adding index so it does\\'nt start from index 0 if current index is 1-n cauze that possiblity will have\\n            // already been covered when index was 0\\n\\t\\t\\t/*\\n\\t\\t\\teg [2,2,3] has been covered when index was at 0\\n\\t\\t\\tso we need not traverse to index 0 to get [3,2,2] because it\\'s already stored in res.\\n\\t\\t\\t*/\\n            curr.remove( curr.size() - 1 );\\n            sum = sum - candidates[i];\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) \\n    {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> curr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack( res , curr , 0 ,target,candidates,0);    \\n        return res;\\n    }\\n    public void backtrack( List<List<Integer>> res , List<Integer> curr , int sum ,int target,int[] candidates,int index)\\n    {\\n        if( sum == target )\\n        {\\n            if( !res.contains(curr) )\\n            {\\n                res.add(new ArrayList(curr));    \\n            }\\n            return;\\n        }\\n        for( int i = index ; i < candidates.length ; i++ )\\n        {\\n            if( sum + candidates[i] > target )\\n            {\\n                return;\\n            }\\n            curr.add( candidates[i] );\\n            sum = sum + candidates[i];\\n            backtrack( res , curr , sum , target , candidates ,i);  \\n            //adding index so it does\\'nt start from index 0 if current index is 1-n cauze that possiblity will have\\n            // already been covered when index was 0\\n\\t\\t\\t/*\\n\\t\\t\\teg [2,2,3] has been covered when index was at 0\\n\\t\\t\\tso we need not traverse to index 0 to get [3,2,2] because it\\'s already stored in res.\\n\\t\\t\\t*/\\n            curr.remove( curr.size() - 1 );\\n            sum = sum - candidates[i];\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283302,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(candidates,0,target,result,new ArrayList());\\n        return result;\\n    }\\n    public void recur(int[] c,int start,int target,List<List<Integer>> result,List<Integer> list)\\n    {\\n        if(target<0)\\n            return;\\n        if(target==0)\\n            result.add(new ArrayList(list));\\n        for(int i=start;i<c.length;i++)\\n        {\\n            list.add(c[i]);\\n            recur(c,i,target-c[i],result,list);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(candidates,0,target,result,new ArrayList());\\n        return result;\\n    }\\n    public void recur(int[] c,int start,int target,List<List<Integer>> result,List<Integer> list)\\n    {\\n        if(target<0)\\n            return;\\n        if(target==0)\\n            result.add(new ArrayList(list));\\n        for(int i=start;i<c.length;i++)\\n        {\\n            list.add(c[i]);\\n            recur(c,i,target-c[i],result,list);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204196,
                "title": "lessons-learned",
                "content": "**Related problems**: All try to teach recursion + loop combo\\n* https://leetcode.com/problems/permutations/ : **(Basics)** on every recursion, iteration starts from 0th index \\n* https://leetcode.com/problems/permutations-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern \\n* https://leetcode.com/problems/combinations/ : **(Basics)** on every recursion, iteration starts from next index (ie, adjacent index to parent recursion iteration index) \\n* https://leetcode.com/problems/combination-sum/ : **(Basics)** sorting helps to prune\\n* https://leetcode.com/problems/combination-sum-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern and Sort+skip adjacent duplicate elements pattern\\n* https://leetcode.com/problems/restore-ip-addresses/ : **(Advanced)** includes special char \\'.\\', StringBuilder, number conversion, number validity check, looped deletion\\n* https://leetcode.com/problems/24-game/ : **(Advanced)** \\n* If you have done the above problems, no need to do: https://leetcode.com/problems/combination-sum-iii/, https://leetcode.com/problems/subsets/, https://leetcode.com/problems/subsets-ii/, https://leetcode.com/problems/letter-combinations-of-a-phone-number/ . These are very similar to the above ones and you won\\'t gain much from these.\\n\\n**Code**:\\n```\\n// My first code\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Better: if you sort the candidates first, then you can skip computing next elements (might be a million next elements) by exiting early from the for loop as soon as you see a candidate that is bigger than the remaining target. Similar technique (not sorting always) can be applied in various backtracking problems to prune the recursive tree.\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length && sum + nums[i] <= target; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Best: Nothing much. Just removed the redundant variable for \\'sum\\' and used \\'target\\' alone. Could use this little trick for various sum problems (already found in tree problems)\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length && target - nums[i] >= 0; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// My first code\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Better: if you sort the candidates first, then you can skip computing next elements (might be a million next elements) by exiting early from the for loop as soon as you see a candidate that is bigger than the remaining target. Similar technique (not sorting always) can be applied in various backtracking problems to prune the recursive tree.\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int sum, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (sum == target) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (sum > target) return;\\n        \\n        for (int i = start; i < nums.length && sum + nums[i] <= target; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target, sum + nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Best: Nothing much. Just removed the redundant variable for \\'sum\\' and used \\'target\\' alone. Could use this little trick for various sum problems (already found in tree problems)\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length && target - nums[i] >= 0; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141751,
                "title": "python3-no-sorting",
                "content": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        def backtracking(output,start,res):\\n            if res == target:\\n                ans.append(list(output))\\n                return\\n            \\n            for i in range(start,len(candidates)):\\n                if res<=target:\\n                    output.append(candidates[i])\\n                    backtracking(output,i,res+candidates[i])\\n                    output.pop()\\n\\n        \\n        backtracking([],0,0)  \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        def backtracking(output,start,res):\\n            if res == target:\\n                ans.append(list(output))\\n                return\\n            \\n            for i in range(start,len(candidates)):\\n                if res<=target:\\n                    output.append(candidates[i])\\n                    backtracking(output,i,res+candidates[i])\\n                    output.pop()\\n\\n        \\n        backtracking([],0,0)  \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121660,
                "title": "share-my-c-recursive-solution-easy-and-clean-code",
                "content": "### **Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> tmp;\\n        helper(candidates, target, 0, res, tmp);\\n        return res;\\n    }\\n    void helper(vector<int>& candidates, int target, int start, vector<vector<int>>& res, vector<int>& tmp){\\n        for (int i = start; i < candidates.size(); ++i){\\n            int diff = target - candidates[i];\\n            if (diff == 0){\\n                tmp.push_back(candidates[i]);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            else if (diff > 0){\\n                tmp.push_back(candidates[i]);\\n                helper(candidates, diff, i, res, tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\n### **Performance**\\n- Runtime: 8 ms, faster than 78.42%\\n- Memory Usage: 10.8 MB, less than 91.65%",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> tmp;\\n        helper(candidates, target, 0, res, tmp);\\n        return res;\\n    }\\n    void helper(vector<int>& candidates, int target, int start, vector<vector<int>>& res, vector<int>& tmp){\\n        for (int i = start; i < candidates.size(); ++i){\\n            int diff = target - candidates[i];\\n            if (diff == 0){\\n                tmp.push_back(candidates[i]);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            else if (diff > 0){\\n                tmp.push_back(candidates[i]);\\n                helper(candidates, diff, i, res, tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564870,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568512,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1565727,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1566902,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1569455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567175,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568222,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568863,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567176,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1564870,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568512,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1565727,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1566902,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1569455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567175,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568222,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568863,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1567176,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1568455,
                "content": [
                    {
                        "username": "giacomo",
                        "content": "In order to express a correct asymptotic time complexity in Big-Oh notation for the average case for the Combination Sum problem, we would need to make arguments on how the average set of candidates looks like and how it relates to the target.\\n\\nOf course, this is not easy to do. If you have ever looked at analysis for sorting algorithms, you know that it is not easy (and the input for sorting algorithms is just a set of numbers, here we also have a target).\\n\\nHowever, if asked to discuss the time complexity, what would you do?\\n\\nWould you take a particular case and pretend that that is the average case, without providing any proof?\\n\\nIf you are in front of two solutions for this problem, how would you decide which one has the lowest time complexity?"
                    },
                    {
                        "username": "Jsn667",
                        "content": "**The idea is that if the array is sorted and you subtract (target - candidates[i] ) and you get a negative result, then every number in front of candidates[i] will give you a negative result so you can just skip those numbers.**\\n\\n**Also, it is not possible to receive duplicate answers with this method because there are no duplicates in the input and each number is only given the choice of subtracting themselves or any number in front. For example, in [2, 3, 6, 7] tar = 7, the value 2 has the choice between picking itself or any number in front of it, which is why [2, 2, 3] is an answer but, the value 3 will never be able to choose 2 so the result [3, 2, 2] is not possible (hopefully I explained it clearly).**\\n\\n![image](https://assets.leetcode.com/users/images/5c439987-250b-4f89-ae36-8d7428f25b68_1611079433.9667132.png)\\n\\n"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "yeah its pretty clear thanks\\n"
                    },
                    {
                        "username": "Koh_e_Nauman",
                        "content": "good explination <3.i like that!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "bailey8",
                        "content": "I\\'m confused on trying to calculate the time complexity. Some posts say `O(2^n)`. Some say `O(m^n)` where `m` is the target and `n` is length of array. Another post says `O(l^k)` -  where `l` is the length of the array, `k` is the length of the longest possible combination (namely `target / minInArray`). I do not understand why this is the case using the backtracking approach. Could anyone give a detailed explination and analysis on the time and space complexity? Thanks!"
                    },
                    {
                        "username": "sajalhsn13",
                        "content": "to me it is O(2^K)\\nwhere K is the target and N is the input array size.\\nso, everytime I have 2 choices and I might have to make decision at-most K times."
                    },
                    {
                        "username": "jyim3",
                        "content": "It can\\'t be O(2^n) because at each subproblem the number of choices scales on the length of candidates.  O(m^n) is a fairly loose bound where you are not even implement backtracking, instead you are enumerating all possible combinations - see point 1 of https://leetcode.com/problems/coin-change/solutions/127438/coin-change/comments/1009544.  The standard backtracking dfs implementation should follow a O(n^m) time complexity - best way to think about it is that at each subproblem you have n choices.  O(l^k) is a tighter analysis than O(n^m)."
                    },
                    {
                        "username": "henryzhou7",
                        "content": "If there exists negative value in the candidates, what could be the condition for checking the terminating case? \\n\\nThanks"
                    },
                    {
                        "username": "kabusecha",
                        "content": "negative values will break the question since there will be an infinite number of combinations if a negative number can be negated by any combination of positive numbers."
                    },
                    {
                        "username": "upadhyaypriyanshu24",
                        "content": "[@magbene](/magbene) It would work but that would not be the most efficient way I presume?"
                    },
                    {
                        "username": "magbene",
                        "content": "Would sorting the array first and then checking the same condition `currSum > target` would work?"
                    },
                    {
                        "username": "ratchapongt",
                        "content": "Array length is A\\nTarget is integer, eg 5. Hence B = 5.\\n\\nAfter much discussion the interviewer said that the time complexity is (Worst case) B ^ A.\\n\\nIn my opinion, how can the actual target number be part of time complexity? Does it make sense to say when target = 5, the time complexity is 5 ^ A ?\\nI use backtracking. What is your option?"
                    },
                    {
                        "username": "saitamapunch",
                        "content": "Couldn\\u2019t all the backtracking solutions posted be optimized with memoization. Suppose the numbers were `1,2,3,4,5...` and the target was `11`. The resulting combinations will have some sort of combinations that add up to 5, plus the numbers that sum up to remaining 6. (e.g. `1+4`, 2+3`, `5`), The backtracking solution recomputes the different combinations that make up the remaining 6.  \\n\\nI have not seen any backtracking solutions posted to include memoization. So I just want to see if my idea is correct."
                    },
                    {
                        "username": "zenfred",
                        "content": "Yes you can use memoization for this, but I doubt if there would be real improvement of runtime. The reason is, the subsolutions are not integer values but arrays, which means you need _O(n)_ time simply to fetch them, which is the same with the time you need to reconstruct a subsolution from scratch."
                    },
                    {
                        "username": "kubagros",
                        "content": "Memoization will be an optimization only if the subproblems that solve the bigger problem are overlapping - for example you could cache f(x) if the structure would look as follows:\\nf(b) = f(d) + >>f(x)\\nf(c) = f(e) + >>f(x)<<\\nf(a) = f(b) + f(c) = f(d) + >>f(x)<< + f(e) + >>f(x)<< = f(d) + f(e) + >>2f(x)<<\\n\\nFor the current problem, the solution for bigger target can be build out of a smaller target solution (given candidates are the same), but there is no repetition* that could be cached (in other words, there is no solution that we could reuse more than once) if our goal is to achieve a result just for a single target. The problem has more or less the following structure:\\nf(a) = >>f(b)<< + f(x1)\\nf(b) = >>f(c)<<  + f(x2)\\nf(c) = >>f(d)<<  + f(x3)\\n\\n\\n*notice the difference between  reoccurrence is not a repetition\\ni.e.:\\nreocurrence e.g.:\\nf(3) = f(2)\\nf(2)= f(1)\\nf(1) = f(0)\\nf(0) = const\\n\\nrepetition e.g.:\\nf(3) = f(1) + ...\\nf(2) = f(1) + ...\\nf(1) = f(0) + ...\\nf(0) = const\\n\\n\\nIf the task was slightly different and they asked us to return a solution for more targets given the same set of candidates for each target, then caching would help, because as you\\'ve noticed, while computing result for a bigger target, you might need to compute a solution for a smaller target, so in case you started with bigger one, it\\'s likely you already have a solution for smaller one cached."
                    },
                    {
                        "username": "aumo",
                        "content": "code it up fam"
                    },
                    {
                        "username": "neetika",
                        "content": "how do you convert the recursive soln to this problem to a dp one and how do you calculate the time complexity intuitively (without having to solve recurrence relation)?"
                    },
                    {
                        "username": "xiaochenchen",
                        "content": "I was reading the [solution][1] provided here:\\n\\nHow would you calculate the time complexity of this problem? \\n\\nAs the solution will allow duplications in the entry itself.\\n\\n\\n  [1]: http://discuss.leetcode.com/questions/61/combination-sum/62"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I\\'m stuck because of that too."
                    },
                    {
                        "username": "buhsnahdus",
                        "content": "EDIT : A new condition restricting the input is added to the problem statement which makes this discussion not valid anymore. NEVERMIND!!!\\n\\nThe given constraints for this problem are too big to pass and thus it should have lower constraints.\\nThe testcase with \\ncandidates = `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]`\\n\\t\\t\\t target = `500` \\n\\t\\t\\tfits well in the given constraints but I could not find any solution that could pass this testcase efficiently in the time or memory limits. Moreover, similar testcases are not in the system tests for this problem and I even tried running this testcase with some of the fastest solutions submitted by others but all that I tried failed with TLE or MLE.\\n\\t\\t\\t"
                    },
                    {
                        "username": "ds_09",
                        "content": "2 <= candidates[i] <= 40, you have included 1 in the candidate array."
                    }
                ]
            },
            {
                "id": 1872909,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1737630,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1572487,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1568861,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1568862,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1877541,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1568860,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1957710,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1845108,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1575383,
                "content": [
                    {
                        "username": "gandalfTheGray",
                        "content": "The problem with this kind of questions is that you always expect there to be an efficient solution"
                    },
                    {
                        "username": "cleverprogrammer77",
                        "content": "class Solution {\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds){\n        if(ind == arr.length){\n            if(target == 0){\n                ans.add(new ArrayList<>(ds));\n            }\n            return;\n        }\n        if(arr[ind] <= target) {\n            ds.add(arr[ind]);\n            findCombinations(ind, arr, target - arr[ind], ans, ds);\n            ds.remove(ds.size() - 1);\n        }\n        findCombinations(ind + 1, arr, target, ans, ds);\n    }\n\n\n\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        findCombinations(0, candidates, target, ans, new ArrayList<>());\n        return ans;\n    }\n} `your inline code...your inline code...`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ShreckYe",
                        "content": "This problem is actually identical to solving linear Diophantine equations with non-negative coefficients. I wonder whether there is any mathematical optimization that can be applied to this problem?"
                    },
                    {
                        "username": "morrischen2008",
                        "content": "Let's suppose that all elements in the candidate array are distinct and the array size is n (since duplicate elements makes the analysis of time complexity harder). I think the time complexity is \\n\\n    C(n,1) + C(n,2) + ... + C(n,n) = 2^n - C(n,0) = O(2^n)\\n\\nwhere C(n,1) means number of combinations taking 1 out of n items. But I also see posts (outside leetcode) saying the time complexity is O(n!), which I have no idea how to get this. \\n\\nWhich one is correct? Thanks!"
                    },
                    {
                        "username": "likunjk",
                        "content": "I test this case.\\n\\n    candidates = {1,1}  target = 1\\n\\nmy algorithm return `{{1}, {1}}`, But it can still be Accepted."
                    },
                    {
                        "username": "apoorvgunjanpathak",
                        "content": "It is mentioned that the given array is having DISTINCT values."
                    },
                    {
                        "username": "yakeenasabha",
                        "content": "this medium?\\nman this was f_ing hard."
                    },
                    {
                        "username": "superplane",
                        "content": "It seems that the test cases don't consider the duplication in candidates. For example, candidates=[2,2,3,6,7] and target=7, then the expected answer from Leetcode is [[2,2,3],[2,2,3],[2,2,3],[7]]. \\n\\nOf course, since elements can be used repeatedly, we can argue that no duplicates exist in the candidate array. But it's better to make it more clearly."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "Has anyone experienced issues of test cases \"leaking over\" or \"interfering\" with other test cases? For example, when I run the first test case (candidates =\\n[2,3,6,7]; target = 7), it passes successfully with the output being [[2,2,3],[7]].\\n\\nHowever, when I run the 2nd test case (candidates =[2,3,5]; target = 8), it doesn\\'t pass. The output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]]. Strangely, I noticed that [2,2,3] and[7] are not only wrong because they don\\'t sum up to target =8, but they are the output arrays of the previous test case.\\n\\nLikelwise, when I run the 3rd test case (candidates=[2], target=1), my output [[2,2,3],[7],[2,2,2,2],[2,3,3],[3,5]], which is exactly the same as the last test case\\'s output. This is even stranger bc how can a [2] and target=1 produce 5 different combos with numbers containing 3,5,7 which aren\\'t even in candidates = []?\\n\\nI wrote my code in Python:\\n```\\nimport copy\\n# runtime: O(2^target) b/c worst case is when candidates[] has at least \\'1\\'. For example, candidates = [1,2,3,4,5,6,7] and target = 7. Visual down below\\nclass Solution(object):\\n    result = []\\n    def dfs(self, index, cur_list, total_sum, candidates, target):\\n        if total_sum == target:\\n            self.result.append(copy.copy(cur_list))\\n            return\\n        if total_sum > target or index >= len(candidates):\\n            return\\n        cur_list.append(candidates[index])\\n        self.dfs(index, cur_list, total_sum + candidates[index], candidates, target)\\n        cur_list.pop()\\n        self.dfs(index + 1, cur_list, total_sum, candidates, target)\\n\\n    def combinationSum(self, candidates, target):\\n        self.dfs(0, [], 0, candidates, target)\\n        return self.result\\n```\\nAny thoughts?"
                    },
                    {
                        "username": "cagils",
                        "content": "PSEUDO CODE basic backtracking solution tip:\\n```\\nCURRENT = []\\nRESULT = []\\n    function DFS (i, sum) {\\n        if (sum == target) <<Push a copy of CURRENT into RESULT>>\\n        else if (sum < target) {\\n            for ( j is from i to len(candidates) ) {\\n                <<Push candidates[j] into CURRENT>>\\n                DFS(j, sum + candidates[j])\\n                <<Pop one from CURRENT>>\\n            }\\n        }\\n        return RESULT\\n    }\\n    return DFS(0, 0)\\n}\\n```"
                    },
                    {
                        "username": "psionl0",
                        "content": "Thanks for this tip. It helped me to deal with lists that are just permutations of one another."
                    },
                    {
                        "username": "TheAkkirana",
                        "content": "https://leetcode.com/problems/combination-sum-iv/discuss/1261618/Combination-Sum-I-II-III-IV-or-C++-with-same-approach"
                    }
                ]
            },
            {
                "id": 1572719,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1572280,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1571096,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1568859,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 2050310,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 2027858,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1910929,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1878594,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1863942,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1856096,
                "content": [
                    {
                        "username": "justyy",
                        "content": "It is quite similar to the coin change problem:\\nhttps://leetcode.com/problems/coin-change/\\nexcept that this one needs to find all solutions, and that problem requires just the minimal number of choices.\\nbut the problem statement can be exactly the same.\\nbacktracking, implemented in Recursion,  [See here](https://helloacm.com/using-backtracking-algorithm-to-find-the-combination-integer-sum/) if you can\\'t figure it out. the hint is that you can sort the numbers and always choose from the current maximum.\\n\\n"
                    },
                    {
                        "username": "mangoslicer",
                        "content": "I\\'m thinking that the time complexity has to be greater than the time complexity to generate all subsequences of the array (2^n)."
                    },
                    {
                        "username": "tryHarder",
                        "content": "in the case of\\n[2,3,6,7,2]\\n7\\n\\nthe test result is\\n[[2,2,3],[2,2,3],[2,2,3],[7]]\\n\\nDuplicates show up in the answer\\n\\nThe right answer would be [[2,2,3],[7]]"
                    },
                    {
                        "username": "yfcheng",
                        "content": "I think this problem is missing one test case like this:\\ncandidates [1,1], and target 1.  \\n\\nThe reason being that although the number can be used multiple times, the question is still asking for unique solution sets.  Currently, the expected solution for the above mentioned test case is [[1],[1]], which is obviously incorrect."
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": "I have one doubt can anyone help me to sort it,and the doubt is why we have to data.pop_back() operation it can done directly in tree but why not here\\n\\nvoid comb(vector<int>& arr,int index,int target,vector<int>data)\\n    {\\n        if(index==arr.size())\\n        {\\n            if(target==0)\\n            {\\n               ans.push_back(data);\\n            }\\n\\n            return;\\n        }\\n        if(arr[index]<=target)\\n        {\\n            data.push_back(arr[index]);\\n            comb(arr,index,target-arr[index],data);\\n            data.pop_back();\\n        }\\n        comb(arr,index+1,target,data);\\n    }"
                    },
                    {
                        "username": "ashuranjan003",
                        "content": "Can someone explain me why below line is written in problem statement?\\n\\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "is the candidates sorted?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "yes"
                    },
                    {
                        "username": "shahansha001",
                        "content": "class Solution {\\npublic:\\n vector<vector<int>> ans;\\n\\n void helper(vector<int>& C,int i,int target,vector<int>& sol)\\n {\\n        if(target==0)\\n        {\\n            ans.push_back(sol);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n\\n        //target is not 0,we dont have element to pick\\n        if(C.size()==i)\\n        return;\\n\\n        //skip i element\\n        helper(C,i+1,target,sol); \\n        sol.push_back(C[i]);\\n        //pick the i the element\\n        helper(C,i,target-C[i],sol);\\n        sol.pop_back();\\n\\n }\\n        \\nvector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n      vector<int> sol;\\n        helper(candidates,0,target,sol);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "stella06",
                        "content": "it\\'s is similar to one of variation of coin change problem."
                    },
                    {
                        "username": "burhanNoori",
                        "content": "Here in the question it is not mentioned that the given array candidates is sorted and it is assumed."
                    }
                ]
            },
            {
                "id": 1853675,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1838875,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1816295,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1812483,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1810863,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1792169,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1757991,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1752613,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1742004,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1735237,
                "content": [
                    {
                        "username": "circletech",
                        "content": "I got an error in the expect answer\\nfor candidates = [8,7,4,3] target = 11\\n\\nthey expect  [[8,3],[7,4],[4,4,3]]\\n3 occures once in the first and last slice. am I missing sth \\uD83E\\uDD14 ?\\n\\n"
                    },
                    {
                        "username": "nitnatnok",
                        "content": "This problem makes sense only if candidates numbers are limited to positive integers.\\nSolution assumes this fact, but problem description doesn\\'t state it."
                    },
                    {
                        "username": "karan3773",
                        "content": "is the combinationsum vector sorted"
                    },
                    {
                        "username": "airj23",
                        "content": "My solution:\\nclass Solution(object):\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        #target bag\\n        #candidate item\\n        dp = [[[]]] + [[]] * target\\n        for c in candidates:\\n            for j in range(1, target + 1):\\n                if j >= c:\\n                    dp[j] = dp[j] + list(map(lambda x: x + [c], dp[j-c])) \\n        return dp[target]\\n\\npython is so good for psudo-code!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Gaurav_Agg12",
                        "content": "who is here after striver\\'s solution"
                    },
                    {
                        "username": "yashmimani3107",
                        "content": " case 1 : base condition if(ind== arr.size()){\\n            if(target==0){\\n                ans.push_back(ds); \\n            }\\n            return;\\n        }         \\n100% better TC @\\ncase 2 : base condition if(ind== arr.size()&&(target==0)){\\n                ans.push_back(ds); \\n            return;\\n        }      \\nruntime error in this case why ??"
                    },
                    {
                        "username": "kuznetsov_alv",
                        "content": "Have anyone faced such a problem:\\n`Line 19: Char 16: error CS0266: Cannot implicitly convert type \\'System.Collections.Generic.List<System.Collections.Generic.List<int>>\\' to \\'System.Collections.Generic.IList<System.Collections.Generic.IList<int>>\\'. An explicit conversion exists (are you missing a cast?) (in __Driver__.cs)`\\n\\nIt happens even if the method is totally empty. I don\\'t understand what\\'s going on here."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "schapaga",
                        "content": "I was looking to a solution ([link](https://leetcode.com/problems/combination-sum/solutions/16502/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning/?orderBy=most_votes)) and had a question. \\n\\n\\nFor combination sum I, why is this line important?\\ntempList.remove(tempList.size() - 1);\\nWhy are we removing the last element form the tempList array everytime?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Having found all the combination sums that include the ith element, it is now time to find the combination sums that don\\'t include the ith element."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1734199,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1731903,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1728166,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1718488,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1709648,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1698847,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1679753,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1674057,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1671311,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            },
            {
                "id": 1648678,
                "content": [
                    {
                        "username": "samuelmayna",
                        "content": "Can someone tell me where I am going wrong. \\nI don\\'t know why I am getting duplicates in the results\\nmy code:\\n ` \\nclass Solution(object):\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        result=[]\\n        size=len(candidates)\\n        def dfs(permutations,remainder,index):\\n            if remainder==0:\\n                result.append(list(permutations))\\n                return\\n            for i in range(index,size):\\n                val= candidates[i]\\n                if(remainder- val>=0):\\n                   permutations.append(val)\\n                   dfs(permutations, remainder-val,index)\\n                   permutations.pop()\\n        dfs([],target,0)\\n        return result[leetcode](https://leetcode.com) @\\n.`\\noutput:\\n `[[2,2,3],[2,3,2],[3,2,2],[7]]`\\n"
                    },
                    {
                        "username": "kgaurav8026",
                        "content": "  void findcomb(int i, int n, vector<int> &ds, vector<vector<int>> &ans, vector<int>  &candidates, int target){\\n        \\n        if( target <= 0 ){\\n            if(target == 0){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(candidates[i]);\\n        target = target - candidates[i];\\n        findcomb(i, n, ds, ans, candidates, target);\\n        ds.pop_back();\\n        target = target + candidates[i];\\n        findcomb(i+1, n, ds, ans, candidates, target);\\n        \\n        \\n          }\\n\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n     vector<int> ds;\\n     vector<vector<int>> ans;\\n     int n = candidates.size();\\n     findcomb(0, n, ds, ans, candidates, target);\\n     return ans;\\n    }\\nWhy this is giving runtime error??"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "may be this line target <= 0\nWe have to compare index!!\nnot target\n"
                    },
                    {
                        "username": "sandeepcsa98",
                        "content": "Recursion with pick and not pick intution is best"
                    },
                    {
                        "username": "Abhishek_290",
                        "content": "The combination sum problem problem can solve without backtracking if yes then tell me the approch "
                    },
                    {
                        "username": "AmbreMandar1812",
                        "content": "When I declare\\nList<Integer> ans = new ArrayList<>();\\nand try to add the the above list to the ArrayList Result\\n<List<List<Integer>> Result = new ArrayList<>();\\na blank ans list is inserted to result even though the list  ans is filled with elements...Why so??...\\nPlease Help"
                    },
                    {
                        "username": "yashpatel21102001",
                        "content": "class Solution {\\n    void method(int ind, int target, vector<int>& arr, vector<vector<int>>& ans,vector<int>& ds){\\n        //base condtions\\n        if(ind == arr.size()){\\n            if(target == 0 ){\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n\\n        //pick the elements\\n        if(arr[ind] <= target){\\n            ds.push_back(arr[ind]);\\n            method(ind,target-arr[ind],arr,ans,ds);\\n            //when method will back here last condition would be failed \\n            //so pop out last one\\n            ds.pop_back();\\n        }\\n\\n        //not pick the elemetn\\n        method(ind+1,target,arr,ans,ds);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        //initialize the ans vector to store answers\\n        vector<vector<int>> ans;\\n\\n        //intialize the ds vector to store individual ans\\n        vector<int> ds;\\n\\n        //make the call to recursive function\\n        method(0,target,candidates,ans,ds);\\n\\n        return ans;\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "subham20042001",
                        "content": "Without Backtracking \\n\\nclass Solution {\\n  public:\\n    \\n    vector<vector<int> > ans;\\n\\nvoid func(vector<int> &A,int sum,vector<int> temp , int B,int index)\\n{\\n    if(sum==B)\\n    {\\n        ans.push_back(temp);\\n        return ;\\n    }\\n    \\n    if(index==A.size())\\n    return ;\\n   \\n    func(A,sum,temp,B,index+1);\\n   \\n    \\n    while(sum<=B)\\n    {\\n        sum+=A[index];\\n        temp.push_back(A[index]);\\n        func(A,sum,temp,B,index+1);\\n       \\n    }\\n    \\n   \\n    \\n    \\n}\\n    \\n    vector<vector<int> > combinationSum(vector<int> &A, int B) {\\n        sort(A.begin(),A.end());\\n        A.erase(unique(A.begin(), A.end()), A.end());\\n       \\n       func(A,0,{},B,0);\\n     \\n     sort(ans.begin(),ans.end());\\n      return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashupadhyay266",
                        "content": "\n       class Solution:\n        def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n            def check(candidates,result,stack,target,sum_val,i):\n                if i==len(candidates):\n                    return \n                if sum_val==target:\n                    result.append(stack)\n                    return \n                elif sum_val>target:\n                    return \n                else:\n                    check(candidates,result,stack+[candidates[i]],target,sum_val+candidates[i],i)\n                    check(candidates,result,stack,target,sum_val,i+1)\n                return result\n\n\n            result=[]\n            stack=[]\n            sum_val=0\n            i=0\n            return check(candidates,result,stack,target,sum_val,i)\n\n''\n\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-combination-sum-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/combination-sum-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Break",
        "question_content": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;,&quot;code&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.\nNote that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 169383,
                "title": "solved-the-time-complexity-of-the-brute-force-method-should-be-o-2-n-and-prove-it-below",
                "content": "First I paste my code here which is equivalent to the code in the \"Solution\" tab:\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        // put all words into a hashset\\n        Set<String> set = new HashSet<>(wordDict);\\n        return wb(s, set);\\n    }\\n    private boolean wb(String s, Set<String> set) {\\n        int len = s.length();\\n        if (len == 0) {\\n            return true;\\n        }\\n        for (int i = 1; i <= len; ++i) {\\n            if (set.contains(s.substring(0, i)) && wb(s.substring(i), set)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nThe time complexity depends on how many nodes the recursion tree has. In the worst case, the recursion tree has the most nodes, which means the program should not return in the middle and it should try as many possibilities as possible. So the branches and depth of the tree are as many as possible. For the worst case, for example, we take `s = \"abcd\"` and `wordDict = [\"a\", \"b\", \"c\", \"bc\", \"ab\", \"abc\"]`, the recursion tree is shown below:\\n<img src=\"https://s3-lc-upload.s3.amazonaws.com/users/r0cky2h/image_1536728871.png\" width=\"500\">\\nFrom the code `if (set.contains(s.substring(0, i)) && wb(s.substring(i), set)) { }`, we can see that only if the wordDict contains the prefix, the recursion function can go down to the next level. So on the figure above, string on the edge means the wordDict contains that string. All the gray node with empty string cannot be reached because if the program reaches one such node, the program will return, which lead to some nodes right to it will not be reached. So the conclusion is for a string with length 4, the recursion tree has 8 nodes (all black nodes), and 8 is 2^(4-1). So to generalize this, for a string with length n, the recursion tree wil have 2^(n-1) nodes, i.e., the time complexity is O(2^n). I will prove this generalization below using mathmatical induction:\\n<img src=\"https://s3-lc-upload.s3.amazonaws.com/users/r0cky2h/image_1536729678.png\" width=\"500\">\\nExplanation: the value of a node is the string length. We calculate the number of nodes in the recursion tree for string length=1, 2, ...., n respectively. \\n\\nFor example, when string length=4, the second layer of the recursion tree has three nodes where the string length is 3, 2 and 1 respectively. And the number of subtree rooted at these three nodes have been calculated when we do the mathmatical induction.\\n\\nSo time complexity is O(2^n).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        // put all words into a hashset\\n        Set<String> set = new HashSet<>(wordDict);\\n        return wb(s, set);\\n    }\\n    private boolean wb(String s, Set<String> set) {\\n        int len = s.length();\\n        if (len == 0) {\\n            return true;\\n        }\\n        for (int i = 1; i <= len; ++i) {\\n            if (set.contains(s.substring(0, i)) && wb(s.substring(i), set)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43790,
                "title": "java-implementation-using-dp-in-two-ways",
                "content": "    public class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            \\n            boolean[] f = new boolean[s.length() + 1];\\n            \\n            f[0] = true;\\n            \\n            \\n            /* First DP\\n            for(int i = 1; i <= s.length(); i++){\\n                for(String str: dict){\\n                    if(str.length() <= i){\\n                        if(f[i - str.length()]){\\n                            if(s.substring(i-str.length(), i).equals(str)){\\n                                f[i] = true;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n            }*/\\n            \\n            //Second DP\\n            for(int i=1; i <= s.length(); i++){\\n                for(int j=0; j < i; j++){\\n                    if(f[j] && dict.contains(s.substring(j, i))){\\n                        f[i] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            return f[s.length()];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            \\n            boolean[] f = new boolean[s.length() + 1];\\n            \\n            f[0] = true;\\n            \\n            \\n            /* First DP\\n            for(int i = 1; i <= s.length(); i++){\\n                for(String str: dict){\\n                    if(str.length() <= i){\\n                        if(f[i - str.length()]){\\n                            if(s.substring(i-str.length(), i).equals(str)){\\n                                f[i] = true;\\n                                break;\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 43814,
                "title": "c-dynamic-programming-simple-and-fast-solution-4ms-with-optimization",
                "content": "We use a boolean vector dp[]. dp[***i***] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position ***i*** back and only substring and do dictionary look up in case the preceding position ***j*** with *dp[**j**] == true* is found.\\n\\n    bool wordBreak(string s, unordered_set<string> &dict) {\\n            if(dict.size()==0) return false;\\n            \\n            vector<bool> dp(s.size()+1,false);\\n            dp[0]=true;\\n            \\n            for(int i=1;i<=s.size();i++)\\n            {\\n                for(int j=i-1;j>=0;j--)\\n                {\\n                    if(dp[j])\\n                    {\\n                        string word = s.substr(j,i-j);\\n                        if(dict.find(word)!= dict.end())\\n                        {\\n                            dp[i]=true;\\n                            break; //next i\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return dp[s.size()];\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "We use a boolean vector dp[]. dp[***i***] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position ***i*** back and only substring and do dictionary look up in case the preceding position ***j*** with *dp[**j**] == true* is found.\\n\\n    bool wordBreak(string s, unordered_set<string> &dict) {\\n            if(dict.size()==0) return false;\\n            \\n            vector<bool> dp(s.size()+1,false);\\n            dp[0]=true;\\n            \\n            for(int i=1;i<=s.size();i++)\\n            {\\n                for(int j=i-1;j>=0;j--)\\n                {\\n                    if(dp[j])\\n                    {\\n                        string word = s.substr(j,i-j);\\n                        if(dict.find(word)!= dict.end())\\n                        {\\n                            dp[i]=true;\\n                            break; //next i\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            return dp[s.size()];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3171265,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  bool wordBreak(string s, vector<string>& wordDict) {\\n    const int n = s.length();\\n    const int maxLength = getMaxLength(wordDict);\\n    const unordered_set<string> wordSet{begin(wordDict), end(wordDict)};\\n    vector<int> dp(n + 1);\\n    dp[0] = true;\\n\\n    for (int i = 1; i <= n; ++i)\\n      for (int j = i - 1; j >= 0; --j) {\\n        if (i - j > maxLength)\\n          break;\\n        if (dp[j] && wordSet.count(s.substr(j, i - j))) {\\n          dp[i] = true;\\n          break;\\n        }\\n      }\\n\\n    return dp[n];\\n  }\\n\\n private:\\n  int getMaxLength(const vector<string>& wordDict) {\\n    return max_element(begin(wordDict), end(wordDict),\\n                       [](const auto& a, const auto& b) {\\n                         return a.length() < b.length();\\n                       })\\n        ->length();\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        def construct(current,wordDict, memo={}):\\n            if current in memo:\\n                return memo[current]\\n\\n            if not current:\\n                return True\\n\\n            for word in wordDict:\\n                if current.startswith(word):\\n                    new_current = current[len(word):]\\n                    if construct(new_current,wordDict,memo):\\n                        memo[current] = True\\n                        return True\\n\\n            memo[current] = False\\n            return False\\n\\n        return construct(s,wordDict)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return recWay1(s, wordDict);\\n    }\\n\\n    boolean recWay2(String s, List<String> wordDict) {\\n        Boolean[] memo = new Boolean[s.length() + 1];\\n        return wordBreak2(s, new HashSet<>(wordDict), 0, memo);\\n    }\\n\\n    boolean wordBreak2(String s, Set<String> wordDict, int k, Boolean[] memo) {\\n        int n = s.length();\\n        if (k == n) return true;\\n\\n        if (memo[k] != null) return memo[k];\\n\\n        for (int i=k + 1; i<=n; i++) {\\n            String word = s.substring(k, i);\\n            if (wordDict.contains(word) && wordBreak2(s, wordDict, i, memo)) {\\n                return memo[k] = true;\\n            }\\n        }\\n\\n        return memo[k] = false;\\n    }\\n\\n    boolean recWay1(String s, List<String> wordDict) {\\n        Boolean[] memo = new Boolean[s.length() + 1];\\n        return wordBreak(s, wordDict, 0, memo);\\n    }\\n    \\n    boolean wordBreak(String s, List<String> wordDict, int k, Boolean[] memo) {\\n        if (k == s.length()) {\\n            return true;\\n        }\\n        \\n        if (memo[k] != null) {\\n            return memo[k];\\n        }\\n        \\n        for (int i=0; i<wordDict.size(); i++) {\\n            String word = wordDict.get(i);\\n            if (s.startsWith(word, k)) {\\n                if(wordBreak(s, wordDict, k + word.length(), memo)) return memo[k] = true;\\n            }\\n        }\\n                   \\n        return memo[k] = false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  bool wordBreak(string s, vector<string>& wordDict) {\\n    const int n = s.length();\\n    const int maxLength = getMaxLength(wordDict);\\n    const unordered_set<string> wordSet{begin(wordDict), end(wordDict)};\\n    vector<int> dp(n + 1);\\n    dp[0] = true;\\n\\n    for (int i = 1; i <= n; ++i)\\n      for (int j = i - 1; j >= 0; --j) {\\n        if (i - j > maxLength)\\n          break;\\n        if (dp[j] && wordSet.count(s.substr(j, i - j))) {\\n          dp[i] = true;\\n          break;\\n        }\\n      }\\n\\n    return dp[n];\\n  }\\n\\n private:\\n  int getMaxLength(const vector<string>& wordDict) {\\n    return max_element(begin(wordDict), end(wordDict),\\n                       [](const auto& a, const auto& b) {\\n                         return a.length() < b.length();\\n                       })\\n        ->length();\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        def construct(current,wordDict, memo={}):\\n            if current in memo:\\n                return memo[current]\\n\\n            if not current:\\n                return True\\n\\n            for word in wordDict:\\n                if current.startswith(word):\\n                    new_current = current[len(word):]\\n                    if construct(new_current,wordDict,memo):\\n                        memo[current] = True\\n                        return True\\n\\n            memo[current] = False\\n            return False\\n\\n        return construct(s,wordDict)\\n```\n```Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return recWay1(s, wordDict);\\n    }\\n\\n    boolean recWay2(String s, List<String> wordDict) {\\n        Boolean[] memo = new Boolean[s.length() + 1];\\n        return wordBreak2(s, new HashSet<>(wordDict), 0, memo);\\n    }\\n\\n    boolean wordBreak2(String s, Set<String> wordDict, int k, Boolean[] memo) {\\n        int n = s.length();\\n        if (k == n) return true;\\n\\n        if (memo[k] != null) return memo[k];\\n\\n        for (int i=k + 1; i<=n; i++) {\\n            String word = s.substring(k, i);\\n            if (wordDict.contains(word) && wordBreak2(s, wordDict, i, memo)) {\\n                return memo[k] = true;\\n            }\\n        }\\n\\n        return memo[k] = false;\\n    }\\n\\n    boolean recWay1(String s, List<String> wordDict) {\\n        Boolean[] memo = new Boolean[s.length() + 1];\\n        return wordBreak(s, wordDict, 0, memo);\\n    }\\n    \\n    boolean wordBreak(String s, List<String> wordDict, int k, Boolean[] memo) {\\n        if (k == s.length()) {\\n            return true;\\n        }\\n        \\n        if (memo[k] != null) {\\n            return memo[k];\\n        }\\n        \\n        for (int i=0; i<wordDict.size(); i++) {\\n            String word = wordDict.get(i);\\n            if (s.startsWith(word, k)) {\\n                if(wordBreak(s, wordDict, k + word.length(), memo)) return memo[k] = true;\\n            }\\n        }\\n                   \\n        return memo[k] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43808,
                "title": "simple-dp-solution-in-python-with-description",
                "content": "The idea is the following:\\n\\n- d is an array that contains booleans\\n\\n- d[i] is True if there is a word in the dictionary that *ends* at ith index of s AND d is also True at the beginning of the word\\n\\n\\nExample:\\n\\n- s = \"leetcode\"\\n\\n- words = [\"leet\", \"code\"]\\n\\n- d[3] is True because there is \"leet\" in the dictionary that ends at 3rd index of \"leetcode\"\\n\\n- d[7] is True because there is \"code\" in the dictionary that ends at the 7th index of \"leetcode\" AND d[3] is True\\n\\nThe result is the last index of d.\\n\\n    def word_break(s, words):\\n     \\td = [False] * len(s)    \\n     \\tfor i in range(len(s)):\\n     \\t\\tfor w in words:\\n     \\t\\t\\tif w == s[i-len(w)+1:i+1] and (d[i-len(w)] or i-len(w) == -1):\\n     \\t\\t\\t\\td[i] = True\\n     \\treturn d[-1]",
                "solutionTags": [],
                "code": "The idea is the following:\\n\\n- d is an array that contains booleans\\n\\n- d[i] is True if there is a word in the dictionary that *ends* at ith index of s AND d is also True at the beginning of the word\\n\\n\\nExample:\\n\\n- s = \"leetcode\"\\n\\n- words = [\"leet\", \"code\"]\\n\\n- d[3] is True because there is \"leet\" in the dictionary that ends at 3rd index of \"leetcode\"\\n\\n- d[7] is True because there is \"code\" in the dictionary that ends at the 7th index of \"leetcode\" AND d[3] is True\\n\\nThe result is the last index of d.\\n\\n    def word_break(s, words):\\n     \\td = [False] * len(s)    \\n     \\tfor i in range(len(s)):\\n     \\t\\tfor w in words:\\n     \\t\\t\\tif w == s[i-len(w)+1:i+1] and (d[i-len(w)] or i-len(w) == -1):\\n     \\t\\t\\t\\td[i] = True\\n     \\treturn d[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 43788,
                "title": "4-lines-in-python",
                "content": "`ok[i]` tells whether `s[:i]` can be built.\\n\\n    def wordBreak(self, s, words):\\n        ok = [True]\\n        for i in range(1, len(s)+1):\\n            ok += any(ok[j] and s[j:i] in words for j in range(i)),\\n        return ok[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "`ok[i]` tells whether `s[:i]` can be built.\\n\\n    def wordBreak(self, s, words):\\n        ok = [True]\\n        for i in range(1, len(s)+1):\\n            ok += any(ok[j] and s[j:i] in words for j in range(i)),\\n        return ok[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1455100,
                "title": "python-3-solutions-top-down-dp-bottom-up-dp-then-optimised-with-trie-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: DFS with Memoization + HashSet**\\n- Let `dp(i)` return True if `s[i..n-1]` can be segmented into a space-separated sequence of one or more dictionary words.\\n- Then `dp(0)` is our result.\\n```python\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        wordSet = set(wordDict)\\n\\n        @lru_cache(None)\\n        def dp(start):\\n            if start == n:  # Found a valid way to break words\\n                return True\\n\\n            for end in range(start + 1, n + 1):  # O(N^2)\\n                word = s[start:end]  # O(N)\\n                if word in wordSet and dp(end):\\n                    return True\\n            return False\\n\\n        return dp(0)\\n```\\n**Complexity**\\n- Time: `O(N^3 + M)`, where `N <= 300` is length of string `s`, where `M <= 1000` is length of `wordDict`.\\n  There are total `N` dp states, they are `dp[0], dp[1],.., dp[n]`, each dp state needs a loop `O(N^2)` to calculate the result.\\n  Plus the time to build `wordSet` from `wordDict`, which is `O(M)`\\n  So total complexity is: `O(N * N^2 + M)` = `O(N^3 + M)`.\\n- Space: `O(N + M)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP (Updated: Add this solution)**\\n- Just convert from Top down DP to Bottom up DP.\\n```python\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        \\n        dp = [False] * (n+1)\\n        dp[n] = True\\n        for i in range(n-1, -1, -1):\\n            for j in range(i+1, n+1):\\n                if dp[j] and s[i:j] in wordSet:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[0]\\n```\\n**Complexity**\\n- Time: `O(N^3 + M)`, where `N <= 300` is length of string `s`, where `M <= 1000` is length of `wordDict`.\\n- Space: `O(N + M)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: DFS with Memoization + Optimized with Trie**\\n- We can optimize to this part `s[i:j] in wordSet` to `O(1)` by building the Trie structure to store all words in our trie.\\n- Then when we iterate characters at index `j`, we update the `cur` trie node which represents the string `s[i:j]` in our trie words.\\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.child = defaultdict(TrieNode)\\n    \\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            cur = cur.child[c]\\n        cur.isWord = True\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        root = TrieNode()\\n        for word in wordDict:\\n            root.addWord(word)\\n            \\n        n = len(s)\\n        dp = [False] * (n+1)\\n        dp[n] = True\\n        \\n        for i in range(n-1, -1, -1):\\n            cur = root\\n            for j in range(i+1, n+1):\\n                c = s[j-1]\\n                if c not in cur.child: break  # s[i:j] not exist in our trie\\n                cur = cur.child[c]\\n                if cur.isWord and dp[j]:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[0]\\n```\\n**Complexity**\\n- Time: `O(N^2 + T)`, where `N <= 300` is length of string `s`, `T <= 20000` is total characters in `wordDict` for building Trie Structure.\\n   Building DP costs `O(N^2)`.\\n   Plus the time to build the Trie, which is `O(T)`.\\n   So total complexity is: `O(N * N + T)` = `O(N^2 + T)`.\\n- Space: `O(N + T)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        wordSet = set(wordDict)\\n\\n        @lru_cache(None)\\n        def dp(start):\\n            if start == n:  # Found a valid way to break words\\n                return True\\n\\n            for end in range(start + 1, n + 1):  # O(N^2)\\n                word = s[start:end]  # O(N)\\n                if word in wordSet and dp(end):\\n                    return True\\n            return False\\n\\n        return dp(0)\\n```\n```python\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        \\n        dp = [False] * (n+1)\\n        dp[n] = True\\n        for i in range(n-1, -1, -1):\\n            for j in range(i+1, n+1):\\n                if dp[j] and s[i:j] in wordSet:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[0]\\n```\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.isWord = False\\n        self.child = defaultdict(TrieNode)\\n    \\n    def addWord(self, word):\\n        cur = self\\n        for c in word:\\n            cur = cur.child[c]\\n        cur.isWord = True\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        root = TrieNode()\\n        for word in wordDict:\\n            root.addWord(word)\\n            \\n        n = len(s)\\n        dp = [False] * (n+1)\\n        dp[n] = True\\n        \\n        for i in range(n-1, -1, -1):\\n            cur = root\\n            for j in range(i+1, n+1):\\n                c = s[j-1]\\n                if c not in cur.child: break  # s[i:j] not exist in our trie\\n                cur = cur.child[c]\\n                if cur.isWord and dp[j]:\\n                    dp[i] = True\\n                    break\\n        \\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43797,
                "title": "a-solution-using-bfs",
                "content": "People have posted elegant solutions using DP. The solution I post below using BFS is no better than those. Just to share some new thoughts.\\n\\nWe can use a graph to represent the possible solutions. The vertices of the graph are simply the positions of the first characters of the words and each edge actually represents a word. For example, the input string is \"nightmare\", there are two ways to break it, \"night mare\" and \"nightmare\". The graph would be\\n\\n0-->5-->9\\n\\n|__ __ _^\\n\\nThe question is simply to check if there is a path from 0 to 9. The most efficient way is traversing the graph using BFS with the help of a queue and a hash set. The hash set is used to keep track of the visited nodes to avoid repeating the same work. \\n\\nFor this problem, the time complexity is O(n^2) and space complexity is O(n), the same with DP. This idea can be used to solve the problem word break II. We can simple construct the graph using BFS, save it into a map and then find all the paths using DFS. \\n\\n    bool wordBreak(string s, unordered_set<string> &dict) {\\n        // BFS\\n        queue<int> BFS;\\n        unordered_set<int> visited;\\n        \\n        BFS.push(0);\\n        while(BFS.size() > 0)\\n        {\\n            int start = BFS.front();\\n            BFS.pop();\\n            if(visited.find(start) == visited.end())\\n            {\\n                visited.insert(start);\\n                for(int j=start; j<s.size(); j++)\\n                {\\n                    string word(s, start, j-start+1);\\n                    if(dict.find(word) != dict.end())\\n                    {\\n                        BFS.push(j+1);\\n                        if(j+1 == s.size())\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "People have posted elegant solutions using DP. The solution I post below using BFS is no better than those. Just to share some new thoughts.\\n\\nWe can use a graph to represent the possible solutions. The vertices of the graph are simply the positions of the first characters of the words and each edge actually represents a word. For example, the input string is \"nightmare\", there are two ways to break it, \"night mare\" and \"nightmare\". The graph would be\\n\\n0-->5-->9\\n\\n|__ __ _^\\n\\nThe question is simply to check if there is a path from 0 to 9. The most efficient way is traversing the graph using BFS with the help of a queue and a hash set. The hash set is used to keep track of the visited nodes to avoid repeating the same work. \\n\\nFor this problem, the time complexity is O(n^2) and space complexity is O(n), the same with DP. This idea can be used to solve the problem word break II. We can simple construct the graph using BFS, save it into a map and then find all the paths using DFS. \\n\\n    bool wordBreak(string s, unordered_set<string> &dict) {\\n        // BFS\\n        queue<int> BFS;\\n        unordered_set<int> visited;\\n        \\n        BFS.push(0);\\n        while(BFS.size() > 0)\\n        {\\n            int start = BFS.front();\\n            BFS.pop();\\n            if(visited.find(start) == visited.end())\\n            {\\n                visited.insert(start);\\n                for(int j=start; j<s.size(); j++)\\n                {\\n                    string word(s, start, j-start+1);\\n                    if(dict.find(word) != dict.end())\\n                    {\\n                        BFS.push(j+1);\\n                        if(j+1 == s.size())\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43886,
                "title": "evolve-from-brute-force-to-optimal-a-review-of-all-solutions",
                "content": "1. Recursion, Average O(2^n)\\nT(n) = T(n-1)+T(n-2)+...+T(1) \\n=> T(n+1) = T(n)+T(n-1)+T(n-2)+...+T(1)\\n=>T(n+1) = 2T(n)\\n* c++\\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        return canBrk(0,s,wordDict);    \\n    }\\n    bool canBrk(int start, string& s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if(start == n) return 1;\\n        string sub;\\n        for(int i = start; i<n; i++) if(wordDict.count(sub+=s[i]) && canBrk(i+1,s,wordDict)) return 1;\\n        return 0;\\n    }\\n```\\n* java is more expensive due to use of substring\\n```\\n\\tpublic boolean wordBreak(String s, List<String> wordDict) {    \\n        return wordBreak(0,s,new HashSet(wordDict));   \\n    }\\n    private boolean wordBreak(int p, String s, Set<String> dict){\\n        int n=s.length();\\n        if(p==n) {\\n            return true;\\n        }\\n        for(int i=p+1;i<=n;i++) {\\n            if(dict.contains(s.substring(p,i)) && wordBreak(i,s,dict)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n2.  DFS with Memoization. There is redundancy in #1. A substr may be checked multiple times. We can cache the result by memoization. This is the optimal solution.\\n* c++  Average O(n^2) Time, O(n+d) space. wordDict.count(string) could be O(1) or O(n) depending on the hash function implementation, see [reference]().\\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<char> mem(s.size(),-1);\\n        return canBrk(0,s,wordDict,mem);    \\n    }\\n    bool canBrk(int start, string& s, unordered_set<string>& wordDict,vector<char>& mem) {\\n        int n = s.size();\\n        if(start == n) return 1;\\n        if(mem[start]!= -1) return mem[start];\\n        string sub;\\n        for(int i = start; i<n; i++) if(wordDict.count(sub+=s[i]) && canBrk(i+1,s,wordDict,mem)) return mem[start] = 1; \\n        return mem[start] = 0;\\n    }\\n```\\n* java O(n^3)\\n```\\n\\tBoolean[] mem;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        mem=new Boolean[s.length()];\\n        return wordBreak(0,s,new HashSet<String>(wordDict));   \\n    }\\n    private boolean wordBreak(int p, String s, Set<String> dict){\\n        int n=s.length();\\n        if(p==n) {\\n            return true;\\n        }\\n        if(mem[p]!=null) {\\n            return mem[p];\\n        }\\n        for(int i=p+1;i<=n;i++) {\\n            if(dict.contains(s.substring(p,i))&&wordBreak(i,s,dict)) { \\n                return mem[p]=true;\\n            }\\n        }\\n        return mem[p]=false;\\n    }\\n```\\n3. dp. For dp problems, many times we go into iterative dp directly without even thinking about dfs. This is a great example showing that dfs is better than dp. DFS returns as soon as it finds one way to break the word while dp computes if each substring starting/ending at i is breakable. The test cases of this problem do not show it but it is shown in a similar problem [Concatenated Words](https://discuss.leetcode.com/topic/78569/a-review-of-top-solutions).\\n* c++ Average O(n^2) \\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        vector<bool> dp(n+1);\\n        dp[n]=1;\\n        for(int i=n-1;i>=0;i--) {\\n            string sub;\\n            for(int j=i;j<n;j++) if (dp[i] = wordDict.count(sub+=s[j]) && dp[j+1]) break;\\n        }\\n        return dp[0];    \\n    }\\n```\\n* java O(n^3)\\n```\\n\\tpublic boolean wordBreak(String s, List<String> wordDict) {\\n        int n=s.length();\\n        boolean[] dp=new boolean[n+1];\\n        dp[n]=true;\\n        Set<String> dict=new HashSet(wordDict);\\n        for(int i=n-1;i>=0;i--) {\\n            for(int j=i+1;!dp[i] && j<=n;j++) { \\n                dp[i] = dp[j] & dict.contains(s.substring(i,j));\\n            }\\n        }\\n        return dp[0];   \\n    }\\n```\\n4. BFS, Average O(n^2) BFS may be better than dp. In dp, for each index i, it checks if the substr starting at i can break. However, if the substr ending before i cannot break, then we do not have to check i. But this is the nature of dp, we visit all the states and derive the next state according to previous states and I don\\'t find a way to improve the dp solution. BFS always starts from a valid index and may visit fewer states. This is similar to [Perfect Squares](https://discuss.leetcode.com/topic/57631/evolve-from-brute-force). But BFS is not guaranteed to be better than dp. If every index is a valid state, then BFS visits the same number of states as dp. The inner for loop of BFS looks more expensive than the inner for loop of dp. So I think which is better is case by case. In general, both BFS and dp visit all the states and are less efficient than dfs.\\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        queue<int> q({0});\\n        unordered_set<int> vstd;\\n        int n = s.size();\\n        while(!q.empty()) {\\n            int start = q.front();\\n            q.pop();\\n            if(vstd.count(start)) continue;\\n            vstd.insert(start);\\n            string sub;\\n            for(int i=start;i<n;i++) \\n                if(wordDict.count(sub+=s[i])) {\\n                    q.push(i+1);\\n                    if(i+1 == n) return 1;    \\n                }\\n        }\\n        return 0;    \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        return canBrk(0,s,wordDict);    \\n    }\\n    bool canBrk(int start, string& s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if(start == n) return 1;\\n        string sub;\\n        for(int i = start; i<n; i++) if(wordDict.count(sub+=s[i]) && canBrk(i+1,s,wordDict)) return 1;\\n        return 0;\\n    }\\n```\n```\\n\\tpublic boolean wordBreak(String s, List<String> wordDict) {    \\n        return wordBreak(0,s,new HashSet(wordDict));   \\n    }\\n    private boolean wordBreak(int p, String s, Set<String> dict){\\n        int n=s.length();\\n        if(p==n) {\\n            return true;\\n        }\\n        for(int i=p+1;i<=n;i++) {\\n            if(dict.contains(s.substring(p,i)) && wordBreak(i,s,dict)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<char> mem(s.size(),-1);\\n        return canBrk(0,s,wordDict,mem);    \\n    }\\n    bool canBrk(int start, string& s, unordered_set<string>& wordDict,vector<char>& mem) {\\n        int n = s.size();\\n        if(start == n) return 1;\\n        if(mem[start]!= -1) return mem[start];\\n        string sub;\\n        for(int i = start; i<n; i++) if(wordDict.count(sub+=s[i]) && canBrk(i+1,s,wordDict,mem)) return mem[start] = 1; \\n        return mem[start] = 0;\\n    }\\n```\n```\\n\\tBoolean[] mem;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        mem=new Boolean[s.length()];\\n        return wordBreak(0,s,new HashSet<String>(wordDict));   \\n    }\\n    private boolean wordBreak(int p, String s, Set<String> dict){\\n        int n=s.length();\\n        if(p==n) {\\n            return true;\\n        }\\n        if(mem[p]!=null) {\\n            return mem[p];\\n        }\\n        for(int i=p+1;i<=n;i++) {\\n            if(dict.contains(s.substring(p,i))&&wordBreak(i,s,dict)) { \\n                return mem[p]=true;\\n            }\\n        }\\n        return mem[p]=false;\\n    }\\n```\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        vector<bool> dp(n+1);\\n        dp[n]=1;\\n        for(int i=n-1;i>=0;i--) {\\n            string sub;\\n            for(int j=i;j<n;j++) if (dp[i] = wordDict.count(sub+=s[j]) && dp[j+1]) break;\\n        }\\n        return dp[0];    \\n    }\\n```\n```\\n\\tpublic boolean wordBreak(String s, List<String> wordDict) {\\n        int n=s.length();\\n        boolean[] dp=new boolean[n+1];\\n        dp[n]=true;\\n        Set<String> dict=new HashSet(wordDict);\\n        for(int i=n-1;i>=0;i--) {\\n            for(int j=i+1;!dp[i] && j<=n;j++) { \\n                dp[i] = dp[j] & dict.contains(s.substring(i,j));\\n            }\\n        }\\n        return dp[0];   \\n    }\\n```\n```\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        queue<int> q({0});\\n        unordered_set<int> vstd;\\n        int n = s.size();\\n        while(!q.empty()) {\\n            int start = q.front();\\n            q.pop();\\n            if(vstd.count(start)) continue;\\n            vstd.insert(start);\\n            string sub;\\n            for(int i=start;i<n;i++) \\n                if(wordDict.count(sub+=s[i])) {\\n                    q.push(i+1);\\n                    if(i+1 == n) return 1;    \\n                }\\n        }\\n        return 0;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43995,
                "title": "a-simple-python-dp-solution",
                "content": "    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: bool\\n            \"\"\"\\n            dp = [False] * (len(s) + 1) # dp[i] means s[:i+1] can be segmented into words in the wordDicts \\n            dp[0] = True\\n            for i in range(len(s)):\\n                for j in range(i, len(s)):\\n                    if dp[i] and s[i: j+1] in wordDict:\\n                        dp[j+1] = True\\n                        \\n            return dp[-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: bool\\n            \"\"\"\\n            dp = [False] * (len(s) + 1) # dp[i] means s[:i+1] can be segmented into words in the wordDicts \\n            dp[0] = True\\n            for i in range(len(s)):\\n                for j in range(i, len(s)):\\n                    if dp[i] and s[i: j+1] in wordDict:\\n                        dp[j+1] = True\\n                        \\n            return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 44054,
                "title": "java-dp-solution",
                "content": "    public boolean wordBreak(String s, Set<String> dict) {\\n      if (s == null || s.length() == 0) return false;\\n      \\n      int n = s.length();\\n      \\n      // dp[i] represents whether s[0...i] can be formed by dict\\n      boolean[] dp = new boolean[n];\\n      \\n      for (int i = 0; i < n; i++) {\\n        for (int j = 0; j <= i; j++) {\\n          String sub = s.substring(j, i + 1);\\n          \\n          if (dict.contains(sub) && (j == 0 || dp[j - 1])) {\\n            dp[i] = true;\\n            break;\\n          }\\n        }\\n      }\\n      \\n      return dp[n - 1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public boolean wordBreak(String s, Set<String> dict) {\\n      if (s == null || s.length() == 0) return false;\\n      \\n      int n = s.length();\\n      \\n      // dp[i] represents whether s[0...i] can be formed by dict\\n      boolean[] dp = new boolean[n];\\n      \\n      for (int i = 0; i < n; i++) {\\n        for (int j = 0; j <= i; j++) {\\n          String sub = s.substring(j, i + 1);\\n          \\n          if (dict.contains(sub) && (j == 0 || dp[j - 1])) {\\n            dp[i] = true;\\n            break;\\n          }\\n        }\\n      }\\n      \\n      return dp[n - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3226285,
                "title": "best-c-3-solution-dp-memoization-tabulation-backtracking-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using String + Backtracking + Hash Table.\\n2. Solved using String + DP(Memoisation) + Hash Table.\\n3. Solved using String + DP(Tabulation) + Hash Table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\\n    results in O(2^N).\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + Backtracking + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set){\\n        if(s.size() == 0){\\n            return true;\\n        }\\n        for(int i=0; i<s.size(); i++){\\n            if(set.count(s.substr(0, i+1)) && wordBreak(s.substr(i+1), set)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\\n    results in O(2^N).\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + Backtracking + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set, int start){\\n        if(start == s.size()){\\n            return true;\\n        }\\n        for(int i=start; i<s.size(); i++){\\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, i+1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set, 0);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Size of recursion tree can go up to N^2.\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + DP(Memoisation) + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set, vector<int> &memo, int start){\\n        if(start == s.size()){\\n            return true;\\n        }\\n        if(memo[start] != -1){\\n            return memo[start];\\n        }\\n        for(int i=start; i<s.size(); i++){\\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, memo, i+1)){\\n                memo[start] = true;\\n                return true;\\n            }\\n        }\\n        return memo[start] = false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<int> memo(s.size(), -1);\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set, memo, 0);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), There are two nested loops, and substring computation at each iteration. Overall\\n    that results in O(N^3) time complexity.\\n\\n    Space Complexity : O(N), Length of dp array is N+1.\\n    \\n    Solved using String + DP(Tabulation) + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, 0);\\n        dp[0] = true;\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        for(int i=1; i<=s.size(); i++){\\n            for(int j=0; j<i; j++){\\n                if(dp[j] && set.count(s.substr(j, i-j))){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\\n    results in O(2^N).\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + Backtracking + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set){\\n        if(s.size() == 0){\\n            return true;\\n        }\\n        for(int i=0; i<s.size(); i++){\\n            if(set.count(s.substr(0, i+1)) && wordBreak(s.substr(i+1), set)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N), Given a string of length N, there are N+1 ways to split it into two parts. At each\\n    step, we have a choice: to split or not to split. In the worse case, when all choices are to be checked, that\\n    results in O(2^N).\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + Backtracking + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set, int start){\\n        if(start == s.size()){\\n            return true;\\n        }\\n        for(int i=start; i<s.size(); i++){\\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, i+1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set, 0);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), Size of recursion tree can go up to N^2.\\n\\n    Space Complexity : O(N), The depth of the recursion tree can go upto N.\\n    \\n    Solved using String + DP(Memoisation) + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    bool wordBreak(string s, unordered_set<string> &set, vector<int> &memo, int start){\\n        if(start == s.size()){\\n            return true;\\n        }\\n        if(memo[start] != -1){\\n            return memo[start];\\n        }\\n        for(int i=start; i<s.size(); i++){\\n            if(set.count(s.substr(start, i+1-start)) && wordBreak(s, set, memo, i+1)){\\n                memo[start] = true;\\n                return true;\\n            }\\n        }\\n        return memo[start] = false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<int> memo(s.size(), -1);\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        return wordBreak(s, set, memo, 0);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^3), There are two nested loops, and substring computation at each iteration. Overall\\n    that results in O(N^3) time complexity.\\n\\n    Space Complexity : O(N), Length of dp array is N+1.\\n    \\n    Solved using String + DP(Tabulation) + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, 0);\\n        dp[0] = true;\\n        unordered_set<string> set(wordDict.begin(), wordDict.end());\\n        for(int i=1; i<=s.size(); i++){\\n            for(int j=0; j<i; j++){\\n                if(dp[j] && set.count(s.substr(j, i-j))){\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43908,
                "title": "4-different-ways-to-solve-this-with-detailed-explanation",
                "content": "```\\n\\n\\n\\n/*\\n SOLUTION 1: bfs\\n    Idea is to try to chop off prefix of s that is in the dict\\n    enqueue the left-over of each chop off\\n    if there is a time the left over happens to be in the dict as well\\n        we know word is breakable, b/c all the previous chops are all in the dict\\n    otherwise the original world is not breakable.\\n    \\n    we can use a set to store all the leftovers that we have tried, to avoid enqueue the \\n    same leftover multiple times.\\n\\n*/\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        int index = 0;\\n        Queue<String> queue = new LinkedList<String>();\\n        queue.offer(s);\\n        Set<String> visited = new HashSet<String>();\\n        while(!queue.isEmpty()){\\n            String candidate = queue.poll();\\n            if(wordDict.contains(candidate)) return true;\\n            for(int i = 0; i < candidate.length(); i++){\\n                String chop = candidate.substring(0,i);\\n                String next = candidate.substring(i, candidate.length());\\n                if(!visited.contains(next) && wordDict.contains(chop)){\\n                    next = candidate.substring(i, candidate.length());\\n                    queue.offer(next);\\n                    visited.add(next);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/* SOLUTION 2: dfs\\n    use a set to record the substring (i, s.length) that is not breakable\\n    start from the front, try to see if the substring (0,i) is in the dict,\\n    if so, recursively check if there is a way to break (i, s.length)\\n    \\n    \\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if(s.length() == 0) return false;\\n        Set<Integer> set = new HashSet<Integer>();\\n        return helper(s, 0, set, wordDict);\\n    }\\n    \\n    private boolean helper(String s, int index, Set<Integer> set, Set<String> dict){\\n        if(index == s.length()) return true;\\n        for(int i = index + 1; i <= s.length(); i++){\\n            if(set.contains(i)) continue;\\n            if(dict.contains(s.substring(index, i))){\\n                 if (helper(s, i, set, dict)) return true;\\n                 set.add(i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n/* SOLUTION 3: dp\\n    dp[i] represents if substring (0,i) is breakable.\\n    for each longer substring, we just need to check \\n\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if(s.length() == 0) return false;\\n        boolean[] breakable = new boolean[s.length() + 1];\\n        breakable[0] = true;\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = 0; j < i; j++){\\n                if(breakable[j] && wordDict.contains(s.substring(j, i))){\\n                    breakable[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        //for(boolean b : breakable) System.out.print(b + \", \");\\n        return breakable[s.length()];\\n    }\\n}\\n*/\\n\\n/* SOLUTION 4: TRIE + MAP  \\n\\n\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        Trie trie = new Trie();\\n        for(String d : wordDict){\\n            trie.insert(d);\\n        }\\n        List<String> prefix = findPrefix(trie, s);\\n        Map<String, Boolean> map = new HashMap<String, Boolean>();\\n        for(String split : prefix){\\n            if(canBeSplitted(trie, s.replaceFirst(split, \"\"), map)){\\n                map.put(split, true);\\n                return true;\\n            }\\n        }\\n        return false;   \\n    }\\n    \\n    private boolean canBeSplitted(Trie root, String input, Map<String, Boolean> map){\\n        if(map.containsKey(input)) return map.get(input);\\n        if(root.search(input) || input.length() == 0) return true;\\n        List<String> prefix = findPrefix(root, input);\\n        for(String s : prefix){\\n            String copy = new String(input);\\n            if(canBeSplitted(root, copy.replaceFirst(s, \"\"), map)){\\n                map.put(input, true);\\n                return true;\\n            } \\n        }\\n        map.put(input, false);\\n        return false;\\n    }\\n    \\n    private List<String> findPrefix(Trie root, String input){\\n        char[] split = input.toCharArray();\\n        List<String> result = new ArrayList<String>();\\n        TrieNode pointer = root.root;\\n        for(int i = 0; i < split.length; i++){\\n            pointer = pointer.next[split[i] - 'a'];\\n            if(pointer == null) break;\\n            if(pointer.word != null) result.add(pointer.word);\\n        }\\n        return result;\\n    }    \\n\\n    class TrieNode {\\n    \\n        public String word;\\n        public TrieNode[] next;\\n        public TrieNode() {\\n            word = null;\\n            next = new TrieNode[26];\\n        }\\n    }\\n\\n    public class Trie {\\n        private TrieNode root;\\n    \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n    \\n        public void insert(String word) {\\n            TrieNode pointer = root;\\n            for(int i = 0; i < word.length(); i++){\\n                if(pointer.next[word.charAt(i) - 'a'] == null){\\n                    pointer.next[word.charAt(i) - 'a'] = new TrieNode();\\n                }\\n                pointer = pointer.next[word.charAt(i) - 'a'];\\n            }\\n            pointer.word = word;\\n        }\\n    \\n        public boolean search(String word) {\\n            TrieNode pointer = root;\\n            if(root.word != null && root.word.equals(word)) return true;\\n            for(int i = 0; i < word.length(); i++){\\n                if(pointer.next[word.charAt(i) - 'a'] == null) return false;\\n                pointer = pointer.next[word.charAt(i) - 'a'];\\n            }\\n            if(pointer.word == null) return false;\\n            return pointer.word.equals(word);\\n        }\\n    \\n    }    \\n    \\n}*/\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\n/*\\n SOLUTION 1: bfs\\n    Idea is to try to chop off prefix of s that is in the dict\\n    enqueue the left-over of each chop off\\n    if there is a time the left over happens to be in the dict as well\\n        we know word is breakable, b/c all the previous chops are all in the dict\\n    otherwise the original world is not breakable.\\n    \\n    we can use a set to store all the leftovers that we have tried, to avoid enqueue the \\n    same leftover multiple times.\\n\\n*/\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        int index = 0;\\n        Queue<String> queue = new LinkedList<String>();\\n        queue.offer(s);\\n        Set<String> visited = new HashSet<String>();\\n        while(!queue.isEmpty()){\\n            String candidate = queue.poll();\\n            if(wordDict.contains(candidate)) return true;\\n            for(int i = 0; i < candidate.length(); i++){\\n                String chop = candidate.substring(0,i);\\n                String next = candidate.substring(i, candidate.length());\\n                if(!visited.contains(next) && wordDict.contains(chop)){\\n                    next = candidate.substring(i, candidate.length());\\n                    queue.offer(next);\\n                    visited.add(next);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/* SOLUTION 2: dfs\\n    use a set to record the substring (i, s.length) that is not breakable\\n    start from the front, try to see if the substring (0,i) is in the dict,\\n    if so, recursively check if there is a way to break (i, s.length)\\n    \\n    \\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if(s.length() == 0) return false;\\n        Set<Integer> set = new HashSet<Integer>();\\n        return helper(s, 0, set, wordDict);\\n    }\\n    \\n    private boolean helper(String s, int index, Set<Integer> set, Set<String> dict){\\n        if(index == s.length()) return true;\\n        for(int i = index + 1; i <= s.length(); i++){\\n            if(set.contains(i)) continue;\\n            if(dict.contains(s.substring(index, i))){\\n                 if (helper(s, i, set, dict)) return true;\\n                 set.add(i);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\n/* SOLUTION 3: dp\\n    dp[i] represents if substring (0,i) is breakable.\\n    for each longer substring, we just need to check \\n\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if(s.length() == 0) return false;\\n        boolean[] breakable = new boolean[s.length() + 1];\\n        breakable[0] = true;\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = 0; j < i; j++){\\n                if(breakable[j] && wordDict.contains(s.substring(j, i))){\\n                    breakable[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        //for(boolean b : breakable) System.out.print(b + \", \");\\n        return breakable[s.length()];\\n    }\\n}\\n*/\\n\\n/* SOLUTION 4: TRIE + MAP  \\n\\n\\npublic class Solution {\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        Trie trie = new Trie();\\n        for(String d : wordDict){\\n            trie.insert(d);\\n        }\\n        List<String> prefix = findPrefix(trie, s);\\n        Map<String, Boolean> map = new HashMap<String, Boolean>();\\n        for(String split : prefix){\\n            if(canBeSplitted(trie, s.replaceFirst(split, \"\"), map)){\\n                map.put(split, true);\\n                return true;\\n            }\\n        }\\n        return false;   \\n    }\\n    \\n    private boolean canBeSplitted(Trie root, String input, Map<String, Boolean> map){\\n        if(map.containsKey(input)) return map.get(input);\\n        if(root.search(input) || input.length() == 0) return true;\\n        List<String> prefix = findPrefix(root, input);\\n        for(String s : prefix){\\n            String copy = new String(input);\\n            if(canBeSplitted(root, copy.replaceFirst(s, \"\"), map)){\\n                map.put(input, true);\\n                return true;\\n            } \\n        }\\n        map.put(input, false);\\n        return false;\\n    }\\n    \\n    private List<String> findPrefix(Trie root, String input){\\n        char[] split = input.toCharArray();\\n        List<String> result = new ArrayList<String>();\\n        TrieNode pointer = root.root;\\n        for(int i = 0; i < split.length; i++){\\n            pointer = pointer.next[split[i] - 'a'];\\n            if(pointer == null) break;\\n            if(pointer.word != null) result.add(pointer.word);\\n        }\\n        return result;\\n    }    \\n\\n    class TrieNode {\\n    \\n        public String word;\\n        public TrieNode[] next;\\n        public TrieNode() {\\n            word = null;\\n            next = new TrieNode[26];\\n        }\\n    }\\n\\n    public class Trie {\\n        private TrieNode root;\\n    \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n    \\n        public void insert(String word) {\\n            TrieNode pointer = root;\\n            for(int i = 0; i < word.length(); i++){\\n                if(pointer.next[word.charAt(i) - 'a'] == null){\\n                    pointer.next[word.charAt(i) - 'a'] = new TrieNode();\\n                }\\n                pointer = pointer.next[word.charAt(i) - 'a'];\\n            }\\n            pointer.word = word;\\n        }\\n    \\n        public boolean search(String word) {\\n            TrieNode pointer = root;\\n            if(root.word != null && root.word.equals(word)) return true;\\n            for(int i = 0; i < word.length(); i++){\\n                if(pointer.next[word.charAt(i) - 'a'] == null) return false;\\n                pointer = pointer.next[word.charAt(i) - 'a'];\\n            }\\n            if(pointer.word == null) return false;\\n            return pointer.word.equals(word);\\n        }\\n    \\n    }    \\n    \\n}*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870144,
                "title": "c-simple-and-short-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        \\n        // we mark as true every index that we managed to segment so far\\n        for (int i = 1; i <= s.size(); i++)\\n            for (int j = 0; j < i; j++)\\n                if ((dp[j]) && (find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) != wordDict.end())) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n        return dp.back();\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        \\n        // we mark as true every index that we managed to segment so far\\n        for (int i = 1; i <= s.size(); i++)\\n            for (int j = 0; j < i; j++)\\n                if ((dp[j]) && (find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) != wordDict.end())) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860456,
                "title": "100-dp-dfs-video-segmenting-a-string",
                "content": "# Intuition\\nWhen given a string and a dictionary of words, the problem requires us to determine if the string can be segmented into a sequence of dictionary words. A common way to approach this problem is to use either Dynamic Programming or Depth-First Search with memoization, considering the constraints and properties of the problem. The comparison includes implementations in multiple languages: Python, C++, Java, JavaScript, Rust, Go, and C#.\\n\\nhttps://youtu.be/9ZIQwa1wCNA\\n\\n# Approaches - Short Description\\n\\n## Dynamic Programming\\nBy utilizing a boolean array dp, we can iteratively build a solution that checks if the string can be segmented into dictionary words. This approach leverages the subproblem overlap and builds a bottom-up solution.\\n\\n## Depth-First Search with Memoization\\nThis approach searches for a valid segmentation by recursively exploring different paths and using a set data structure to efficiently match prefixes. Memoization is used to store results and avoid redundant computations.\\n\\n## Differences\\nWhile Dynamic Programming builds the solution iteratively, Depth-First Search explores recursively. The DP approach has a more straightforward implementation, while DFS with memoization may be more efficient in some cases due to early termination.\\n\\n# Approach - Dynamic Programming\\nThe Dynamic Programming approach provides an efficient way to solve the word break problem by building up a solution iteratively. Here\\'s a step-by-step description:\\n\\n1. **Initialization**: We initialize a boolean array `dp` of length \\\\(n+1\\\\), where \\\\(n\\\\) is the length of the string `s`. The entry `dp[i]` will be `True` if there exists a word in the dictionary that ends at index \\\\(i-1\\\\) in the string `s`. We set `dp[0]` to `True` since an empty string can always be segmented.\\n\\n2. **Determine Maximum Word Length**: We find the maximum length of a word in the dictionary using `max_len = max(map(len, wordDict))`. This helps us in reducing unnecessary iterations.\\n\\n3. **Iterate Through the String**: We iterate through the string from index 1 to \\\\(n\\\\) (inclusive) and for each index `i`, we iterate from index \\\\(i-1\\\\) down to \\\\(i - \\\\text{max_len} - 1\\\\) (or -1, whichever is larger).\\n\\n4. **Check for Segmentation**: For each `j` in the range, we check if `dp[j]` is `True` and if the substring `s[j:i]` is in `wordDict`. If both conditions are met, we set `dp[i]` to `True` and break out of the inner loop. This means that there exists a valid segmentation ending at index \\\\(i-1\\\\).\\n\\n5. **Result**: Finally, we return `dp[n]`, which will be `True` if the entire string can be segmented into words from the dictionary.\\n\\n## Example:\\nConsider the example with `s = \"leetcode\"` and `wordDict = [\"leet\",\"code\"]`. Here\\'s how the algorithm proceeds:\\n\\n- **Initialization**: `dp = [True, False, False, False, False, False, False, False, False]`.\\n- **Determine Maximum Word Length**: `max_len = 4`.\\n- **Iterate Through the String**:\\n  - When `i = 4`, the loop finds that `dp[0]` is `True` and `\"leet\"` is in the dictionary, so `dp[4]` is set to `True`.\\n  - When `i = 8`, the loop finds that `dp[4]` is `True` and `\"code\"` is in the dictionary, so `dp[8]` is set to `True`.\\n- **Result**: `dp[8]` is `True`, so the function returns `True`.\\n\\nThe use of dynamic programming ensures that we are not recomputing solutions to subproblems, and the consideration of the maximum word length helps in avoiding unnecessary iterations, making this approach both elegant and efficient.\\n\\n# Complexity\\n- Time complexity: \\\\( O(n * m) \\\\), where \\\\( n \\\\) is the length of the string and \\\\( m \\\\) is the maximum length of a word in the dictionary.\\n- Space complexity: \\\\( O(n) \\\\)\\n\\n# Performance - DP\\n\\n| Language   | Runtime | Beats   | Memory   | Beats   |\\n|------------|---------|---------|----------|---------|\\n| Go         | 1 ms    | 69.76%  | 2.1 MB   | 99.78%  |\\n| Rust       | 1 ms    | 85.43%  | 2.1 MB   | 75.38%  |\\n| Java       | 1 ms    | 99.85%  | 41.1 MB  | 86.3%   |\\n| C++        | 4 ms    | 84.76%  | 7.6 MB   | 92.64%  |\\n| Python3    | 29 ms   | 99.91%  | 16.3 MB  | 97.29%  |\\n| JavaScript | 52 ms   | 95.93%  | 42.3 MB  | 95.86%  |\\n| C#         | 104 ms  | 73.58%  | 40.8 MB  | 94.98%  |\\n\\n![dp_comparison.png](https://assets.leetcode.com/users/images/cfab53e7-9add-4d41-a397-03773ec82f64_1691117831.0879085.png)\\n\\n\\n# Code - Dynamic Programming\\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        max_len = max(map(len, wordDict))  # The maximum length of a word in the dictionary\\n\\n        for i in range(1, n + 1):\\n            for j in range(i - 1, max(i - max_len - 1, -1), -1): # Only consider words that could fit\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(std::string s, std::vector<std::string>& wordDict) {\\n        int n = s.size();\\n        std::vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        int max_len = 0;\\n        for (const auto& word : wordDict) {\\n            max_len = std::max(max_len, static_cast<int>(word.size()));\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= std::max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && std::find(wordDict.begin(), wordDict.end(), s.substr(j, i - j)) != wordDict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        int max_len = 0;\\n        for (String word : wordDict) {\\n            max_len = Math.max(max_len, word.length());\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= Math.max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let n = s.length;\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n    let max_len = Math.max(...wordDict.map(word => word.length));\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (let j = i - 1; j >= Math.max(i - max_len - 1, 0); j--) {\\n            if (dp[j] && wordDict.includes(s.substring(j, i))) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        int n = s.Length;\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n        int max_len = 0;\\n        foreach (string word in wordDict) {\\n            max_len = Math.Max(max_len, word.Length);\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= Math.Max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && wordDict.Contains(s.Substring(j, i - j))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    n := len(s)\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n    max_len := 0\\n    for _, word := range wordDict {\\n        if len(word) > max_len {\\n            max_len = len(word)\\n        }\\n    }\\n\\n    for i := 1; i <= n; i++ {\\n        for j := i - 1; j >= max(i - max_len - 1, 0); j-- {\\n            if dp[j] && contains(wordDict, s[j:i]) {\\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n\\n    return dp[n]\\n}\\n\\nfunc contains(words []string, target string) bool {\\n    for _, word := range words {\\n        if word == target {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let n = s.len();\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n        let max_len = word_dict.iter().map(|word| word.len()).max().unwrap_or(0);\\n\\n        let word_dict: std::collections::HashSet<String> = word_dict.into_iter().collect();\\n\\n        for i in 1..=n {\\n            for j in (std::cmp::max(i as isize - max_len as isize - 1, 0) as usize..i).rev() {\\n                if dp[j] && word_dict.contains(&s[j..i].to_string()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        dp[n]\\n    }\\n}\\n```\\n\\n# Approach - Depth-First Search with Memoization\\nThe Depth-First Search (DFS) approach with memoization offers a recursive way to solve the word break problem. It leverages the Trie data structure to efficiently match prefixes and employs memoization to store intermediate results. Here\\'s a step-by-step description:\\n\\n1. **Building the Trie**: We initialize an empty Trie and iterate through each word in the dictionary (`wordDict`). For each word, we add it to the Trie, using a nested loop to traverse each character (`ch`) in the word. We use the `\\'#\\'` symbol to mark the end of a word in the Trie. We also determine the maximum length (`max_len`) of a word in the dictionary.\\n\\n2. **Initialization of Memoization**: We initialize an empty dictionary (`memo`) to store the results of subproblems. This helps in avoiding redundant computations.\\n\\n3. **DFS Function Call**: We call the recursive DFS function with initial parameters, starting from index 0.\\n\\n4. **Recursive DFS Function**:\\n    - **Memoization Check**: If the starting index (`start`) is found in `memo`, we return the stored result.\\n    - **Base Case**: If `start` equals the length of the string, we return `True`, as we have reached the end.\\n    - **Iterate Through Prefixes**: We initialize `node` to the root of the Trie and iterate through the string from the `start` index to the minimum of `start + max_len` and the length of the string.\\n    - **Trie Traversal**: For each character (`ch`), we traverse the Trie. If `ch` is not found, we break out of the loop.\\n    - **Check for Word End and Recursion**: If we find the end of a word marker (`\\'#\\'`) in the Trie, we make a recursive call to `dfs` with the next index (`i + 1`).\\n    - **Update Memoization**: If the recursive call returns `True`, we update `memo[start]` to `True` and return `True`.\\n\\n5. **Result**: Finally, we update `memo[start]` to `False` if no valid segmentation is found and return `False`.\\n\\nThis approach leverages the Trie structure to efficiently match prefixes and uses memoization to enhance efficiency. It offers a recursive and elegant solution to the word break problem.\\n\\n# Complexity\\n- Time complexity: \\\\( O(n * m + k) \\\\), where \\\\( n \\\\) is the length of the string, \\\\( m \\\\) is the maximum length of a word in the dictionary, and \\\\( k \\\\) is the total number of characters in all words in the dictionary (for building the Trie).\\n- Space complexity: \\\\( O(n + k) \\\\), where \\\\( n \\\\) is the length of the string and \\\\( k \\\\) is the total number of characters in all words in the dictionary.\\n\\n# Performance - DFS\\n\\n| Language   | Runtime | Beats  | Memory | Beats  |\\n|------------|---------|--------|--------|--------|\\n| Rust       | 0 ms    | 100%   | 2.1 MB  | 75.38% |\\n| Go         | 2 ms    | 66.9%  | 2.4 MB  | 29.16% |\\n| Java       | 8 ms    | 49.31% | 44 MB   | 14.85% |\\n| C++        | 21 ms   | 37.63% | 14.7 MB | 21.91% |\\n| Python3    | 42 ms   | 94.1%  | 17.5 MB | 5.8%   |\\n| JavaScript | 58 ms   | 86.4%  | 44.6 MB | 16.27% |\\n| C#         | 93 ms   | 94.32% | 48.1 MB | 17.47% |\\n\\n![dfs_comparison.png](https://assets.leetcode.com/users/images/49fa36d2-1560-4e64-98f6-d3cf85b253f6_1691117857.6867971.png)\\n\\n# Code - Depth-First Search with Memoization\\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        wordSet = set(wordDict)\\n        return self.dfs(s, wordSet, memo)\\n    \\n    def dfs(self, s, wordSet, memo):\\n        if s in memo:\\n            return memo[s]\\n        if s in wordSet:\\n            return True\\n        for i in range(1, len(s)):\\n            prefix = s[:i]\\n            if prefix in wordSet and self.dfs(s[i:], wordSet, memo):\\n                memo[s] = True\\n                return True\\n        memo[s] = False\\n        return False\\n```\\n``` JavaScript []\\nvar wordBreak = function(s, wordDict) {\\n    let memo = {};\\n    let wordSet = new Set(wordDict);\\n    return dfs(s, wordSet, memo);\\n};\\n\\nfunction dfs(s, wordSet, memo) {\\n    if (s in memo) return memo[s];\\n    if (wordSet.has(s)) return true;\\n    for (let i = 1; i < s.length; i++) {\\n        let prefix = s.substring(0, i);\\n        if (wordSet.has(prefix) && dfs(s.substring(i), wordSet, memo)) {\\n            memo[s] = true;\\n            return true;\\n        }\\n    }\\n    memo[s] = false;\\n    return false;\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(std::string s, std::vector<std::string>& wordDict) {\\n        std::unordered_map<std::string, bool> memo;\\n        std::unordered_set<std::string> wordSet(wordDict.begin(), wordDict.end());\\n        return dfs(s, wordSet, memo);\\n    }\\n    \\nprivate:\\n    bool dfs(const std::string& s, const std::unordered_set<std::string>& wordSet, std::unordered_map<std::string, bool>& memo) {\\n        if (memo.find(s) != memo.end()) return memo[s];\\n        if (wordSet.find(s) != wordSet.end()) return true;\\n        for (int i = 1; i < s.size(); i++) {\\n            std::string prefix = s.substr(0, i);\\n            if (wordSet.find(prefix) != wordSet.end() && dfs(s.substr(i), wordSet, memo)) {\\n                memo[s] = true;\\n                return true;\\n            }\\n        }\\n        memo[s] = false;\\n        return false;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Map<String, Boolean> memo = new HashMap<>();\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        return dfs(s, wordSet, memo);\\n    }\\n    \\n    private boolean dfs(String s, Set<String> wordSet, Map<String, Boolean> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        if (wordSet.contains(s)) return true;\\n        for (int i = 1; i < s.length(); i++) {\\n            String prefix = s.substring(0, i);\\n            if (wordSet.contains(prefix) && dfs(s.substring(i), wordSet, memo)) {\\n                memo.put(s, true);\\n                return true;\\n            }\\n        }\\n        memo.put(s, false);\\n        return false;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        Dictionary<string, bool> memo = new Dictionary<string, bool>();\\n        HashSet<string> wordSet = new HashSet<string>(wordDict);\\n        return Dfs(s, wordSet, memo);\\n    }\\n    \\n    private bool Dfs(string s, HashSet<string> wordSet, Dictionary<string, bool> memo) {\\n        if (memo.ContainsKey(s)) return memo[s];\\n        if (wordSet.Contains(s)) return true;\\n        for (int i = 1; i < s.Length; i++) {\\n            string prefix = s.Substring(0, i);\\n            if (wordSet.Contains(prefix) && Dfs(s.Substring(i), wordSet, memo)) {\\n                memo[s] = true;\\n                return true;\\n            }\\n        }\\n        memo[s] = false;\\n        return false;\\n    }\\n}\\n```\\n``` Rust []\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let mut memo = std::collections::HashMap::new();\\n        let word_set: HashSet<String> = word_dict.into_iter().collect();\\n        Self::dfs(s, &word_set, &mut memo)\\n    }\\n\\n    fn dfs(s: String, word_set: &HashSet<String>, memo: &mut std::collections::HashMap<String, bool>) -> bool {\\n        if let Some(&value) = memo.get(&s) {\\n            return value;\\n        }\\n        if word_set.contains(&s) {\\n            return true;\\n        }\\n        for i in 1..s.len() {\\n            let prefix = &s[0..i];\\n            if word_set.contains(prefix) && Self::dfs(s[i..].to_string(), word_set, memo) {\\n                memo.insert(s, true);\\n                return true;\\n            }\\n        }\\n        memo.insert(s, false);\\n        return false;\\n    }\\n}\\n```\\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n\\tmemo := make(map[string]bool)\\n\\twordSet := make(map[string]bool)\\n\\tfor _, word := range wordDict {\\n\\t\\twordSet[word] = true\\n\\t}\\n\\treturn dfs(s, wordSet, memo)\\n}\\n\\nfunc dfs(s string, wordSet map[string]bool, memo map[string]bool) bool {\\n\\tif value, exists := memo[s]; exists {\\n\\t\\treturn value\\n\\t}\\n\\tif _, exists := wordSet[s]; exists {\\n\\t\\treturn true\\n\\t}\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tprefix := s[:i]\\n\\t\\tif _, exists := wordSet[prefix]; exists && dfs(s[i:], wordSet, memo) {\\n\\t\\t\\tmemo[s] = true\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\tmemo[s] = false\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        max_len = max(map(len, wordDict))  # The maximum length of a word in the dictionary\\n\\n        for i in range(1, n + 1):\\n            for j in range(i - 1, max(i - max_len - 1, -1), -1): # Only consider words that could fit\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(std::string s, std::vector<std::string>& wordDict) {\\n        int n = s.size();\\n        std::vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        int max_len = 0;\\n        for (const auto& word : wordDict) {\\n            max_len = std::max(max_len, static_cast<int>(word.size()));\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= std::max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && std::find(wordDict.begin(), wordDict.end(), s.substr(j, i - j)) != wordDict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        int max_len = 0;\\n        for (String word : wordDict) {\\n            max_len = Math.max(max_len, word.length());\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= Math.max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let n = s.length;\\n    let dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n    let max_len = Math.max(...wordDict.map(word => word.length));\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (let j = i - 1; j >= Math.max(i - max_len - 1, 0); j--) {\\n            if (dp[j] && wordDict.includes(s.substring(j, i))) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        int n = s.Length;\\n        bool[] dp = new bool[n + 1];\\n        dp[0] = true;\\n        int max_len = 0;\\n        foreach (string word in wordDict) {\\n            max_len = Math.Max(max_len, word.Length);\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = i - 1; j >= Math.Max(i - max_len - 1, 0); j--) {\\n                if (dp[j] && wordDict.Contains(s.Substring(j, i - j))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    n := len(s)\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n    max_len := 0\\n    for _, word := range wordDict {\\n        if len(word) > max_len {\\n            max_len = len(word)\\n        }\\n    }\\n\\n    for i := 1; i <= n; i++ {\\n        for j := i - 1; j >= max(i - max_len - 1, 0); j-- {\\n            if dp[j] && contains(wordDict, s[j:i]) {\\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n\\n    return dp[n]\\n}\\n\\nfunc contains(words []string, target string) bool {\\n    for _, word := range words {\\n        if word == target {\\n            return true\\n        }\\n    }\\n    return false\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let n = s.len();\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n        let max_len = word_dict.iter().map(|word| word.len()).max().unwrap_or(0);\\n\\n        let word_dict: std::collections::HashSet<String> = word_dict.into_iter().collect();\\n\\n        for i in 1..=n {\\n            for j in (std::cmp::max(i as isize - max_len as isize - 1, 0) as usize..i).rev() {\\n                if dp[j] && word_dict.contains(&s[j..i].to_string()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        dp[n]\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        wordSet = set(wordDict)\\n        return self.dfs(s, wordSet, memo)\\n    \\n    def dfs(self, s, wordSet, memo):\\n        if s in memo:\\n            return memo[s]\\n        if s in wordSet:\\n            return True\\n        for i in range(1, len(s)):\\n            prefix = s[:i]\\n            if prefix in wordSet and self.dfs(s[i:], wordSet, memo):\\n                memo[s] = True\\n                return True\\n        memo[s] = False\\n        return False\\n```\n``` JavaScript []\\nvar wordBreak = function(s, wordDict) {\\n    let memo = {};\\n    let wordSet = new Set(wordDict);\\n    return dfs(s, wordSet, memo);\\n};\\n\\nfunction dfs(s, wordSet, memo) {\\n    if (s in memo) return memo[s];\\n    if (wordSet.has(s)) return true;\\n    for (let i = 1; i < s.length; i++) {\\n        let prefix = s.substring(0, i);\\n        if (wordSet.has(prefix) && dfs(s.substring(i), wordSet, memo)) {\\n            memo[s] = true;\\n            return true;\\n        }\\n    }\\n    memo[s] = false;\\n    return false;\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(std::string s, std::vector<std::string>& wordDict) {\\n        std::unordered_map<std::string, bool> memo;\\n        std::unordered_set<std::string> wordSet(wordDict.begin(), wordDict.end());\\n        return dfs(s, wordSet, memo);\\n    }\\n    \\nprivate:\\n    bool dfs(const std::string& s, const std::unordered_set<std::string>& wordSet, std::unordered_map<std::string, bool>& memo) {\\n        if (memo.find(s) != memo.end()) return memo[s];\\n        if (wordSet.find(s) != wordSet.end()) return true;\\n        for (int i = 1; i < s.size(); i++) {\\n            std::string prefix = s.substr(0, i);\\n            if (wordSet.find(prefix) != wordSet.end() && dfs(s.substr(i), wordSet, memo)) {\\n                memo[s] = true;\\n                return true;\\n            }\\n        }\\n        memo[s] = false;\\n        return false;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Map<String, Boolean> memo = new HashMap<>();\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        return dfs(s, wordSet, memo);\\n    }\\n    \\n    private boolean dfs(String s, Set<String> wordSet, Map<String, Boolean> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        if (wordSet.contains(s)) return true;\\n        for (int i = 1; i < s.length(); i++) {\\n            String prefix = s.substring(0, i);\\n            if (wordSet.contains(prefix) && dfs(s.substring(i), wordSet, memo)) {\\n                memo.put(s, true);\\n                return true;\\n            }\\n        }\\n        memo.put(s, false);\\n        return false;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        Dictionary<string, bool> memo = new Dictionary<string, bool>();\\n        HashSet<string> wordSet = new HashSet<string>(wordDict);\\n        return Dfs(s, wordSet, memo);\\n    }\\n    \\n    private bool Dfs(string s, HashSet<string> wordSet, Dictionary<string, bool> memo) {\\n        if (memo.ContainsKey(s)) return memo[s];\\n        if (wordSet.Contains(s)) return true;\\n        for (int i = 1; i < s.Length; i++) {\\n            string prefix = s.Substring(0, i);\\n            if (wordSet.Contains(prefix) && Dfs(s.Substring(i), wordSet, memo)) {\\n                memo[s] = true;\\n                return true;\\n            }\\n        }\\n        memo[s] = false;\\n        return false;\\n    }\\n}\\n```\n``` Rust []\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let mut memo = std::collections::HashMap::new();\\n        let word_set: HashSet<String> = word_dict.into_iter().collect();\\n        Self::dfs(s, &word_set, &mut memo)\\n    }\\n\\n    fn dfs(s: String, word_set: &HashSet<String>, memo: &mut std::collections::HashMap<String, bool>) -> bool {\\n        if let Some(&value) = memo.get(&s) {\\n            return value;\\n        }\\n        if word_set.contains(&s) {\\n            return true;\\n        }\\n        for i in 1..s.len() {\\n            let prefix = &s[0..i];\\n            if word_set.contains(prefix) && Self::dfs(s[i..].to_string(), word_set, memo) {\\n                memo.insert(s, true);\\n                return true;\\n            }\\n        }\\n        memo.insert(s, false);\\n        return false;\\n    }\\n}\\n```\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n\\tmemo := make(map[string]bool)\\n\\twordSet := make(map[string]bool)\\n\\tfor _, word := range wordDict {\\n\\t\\twordSet[word] = true\\n\\t}\\n\\treturn dfs(s, wordSet, memo)\\n}\\n\\nfunc dfs(s string, wordSet map[string]bool, memo map[string]bool) bool {\\n\\tif value, exists := memo[s]; exists {\\n\\t\\treturn value\\n\\t}\\n\\tif _, exists := wordSet[s]; exists {\\n\\t\\treturn true\\n\\t}\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tprefix := s[:i]\\n\\t\\tif _, exists := wordSet[prefix]; exists && dfs(s[i:], wordSet, memo) {\\n\\t\\t\\tmemo[s] = true\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\tmemo[s] = false\\n\\treturn false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428606,
                "title": "python-simple-iterative-bfs-or-dfs-24ms",
                "content": "Simple iterative BFS or DFS. 24 to 32 ms (Python 3, Nov 2019).\\n\\nStarts with string `s`. For each string visited, chop off front of string if it starts with a word in the dictionary and adds the shortened string to the queue or stack. If string becomes empty, that means word break succeeded. Keep a set of seen string states  to avoid duplicate work.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        from collections import deque\\n   \\t\\tq = deque([s])\\n\\t\\tseen = set() \\n\\t\\twhile q:\\n            s = q.popleft()    # popleft() = BFS ; pop() = DFS\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    new_s = s[len(word):]\\n\\t\\t\\t\\t\\tif new_s == \"\": \\n                        return True\\n                    if new_s not in seen:\\n                        q.append(new_s)\\n                        seen.add(new_s)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        from collections import deque\\n   \\t\\tq = deque([s])\\n\\t\\tseen = set() \\n\\t\\twhile q:\\n            s = q.popleft()    # popleft() = BFS ; pop() = DFS\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    new_s = s[len(word):]\\n\\t\\t\\t\\t\\tif new_s == \"\": \\n                        return True\\n                    if new_s not in seen:\\n                        q.append(new_s)\\n                        seen.add(new_s)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397927,
                "title": "clean-javascript-solution-bfs-dynamic-programming",
                "content": "**Method 1 BFS**\\n\\n```\\nconst wordBreak = (s, wordDict) => {\\n  if (wordDict == null || wordDict.length === 0) return false;\\n  const set = new Set(wordDict);\\n\\n  // When s = \\'catsandog\\', wordDict = [\\'cats\\', \\'ca\\', \\'ts\\']\\n  // After \\'cats\\' and \\'ca\\', it will become \\'andog\\', \\'tsandog\\'\\n  // For \\'tsandog\\', after \\'ts\\', it will become \\'andog\\' again, visited set here is for memoization\\n  const visited = new Set();\\n  const q = [0];\\n\\n  while (q.length) {\\n    const start = q.shift();\\n\\n    if (!visited.has(start)) {\\n      for (let end = start + 1; end <= s.length; end++) {\\n        if (set.has(s.slice(start, end))) {\\n          if (end === s.length) return true;\\n          q.push(end);\\n        }\\n      }\\n      visited.add(start);\\n    }\\n  }\\n  return false;\\n};\\n```\\n\\n**Method 2 Dynamic Programming**\\n\\n```\\nconst wordBreak = (s, wordDict) => {\\n  if (wordDict == null || wordDict.length === 0) return false;\\n\\n  const set = new Set(wordDict);\\n  const dp = Array(s.length + 1).fill(false);\\n  dp[0] = true;\\n\\n  for (let end = 1; end <= s.length; end++) {\\n    for (let start = 0; start < end; start++) {\\n      const w = s.slice(start, end);\\n      if (dp[start] === true && set.has(w)) {\\n        dp[end] = true;\\n        break;\\n      }\\n    }\\n  }\\n  return dp[s.length];\\n};\\n```\\n\\n```\\n// e.g.\\n// \\'leetcode\\'\\n// [\\'leet\\', \\'code\\']\\n//\\n// i = 1 j = 0 l\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 2 j = 0 le\\n// i = 2 j = 1  e\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 3 j = 0 lee\\n// i = 3 j = 1  ee\\n// i = 3 j = 2   e\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 4 j = 0 leet\\n// match\\n// dp = [true, false, false, false, true, false, false, false, false]\\n//\\n// i = 5 j = 0 leetc\\n// i = 5 j = 1  eetc\\n// i = 5 j = 2   etc\\n// i = 5 j = 3    tc\\n// i = 5 j = 4     c\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 6 j = 0 leetco\\n// i = 6 j = 1  eetco\\n// i = 6 j = 2   etco\\n// i = 6 j = 3    tco\\n// i = 6 j = 4     co\\n// i = 6 j = 5      o\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 7 j = 0 leetcod\\n// i = 7 j = 1  eetcod\\n// i = 7 j = 2   etcod\\n// i = 7 j = 3    tcod\\n// i = 7 j = 4     cod\\n// i = 7 j = 5      od\\n// i = 7 j = 6       d\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 8 j = 0 leetcode\\n// i = 8 j = 1  eetcode\\n// i = 8 j = 2   etcode\\n// i = 8 j = 3    tcode\\n// i = 8 j = 4     code\\n// match\\n// dp = [true, false, false, false, true, false, false, false, true]\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nconst wordBreak = (s, wordDict) => {\\n  if (wordDict == null || wordDict.length === 0) return false;\\n  const set = new Set(wordDict);\\n\\n  // When s = \\'catsandog\\', wordDict = [\\'cats\\', \\'ca\\', \\'ts\\']\\n  // After \\'cats\\' and \\'ca\\', it will become \\'andog\\', \\'tsandog\\'\\n  // For \\'tsandog\\', after \\'ts\\', it will become \\'andog\\' again, visited set here is for memoization\\n  const visited = new Set();\\n  const q = [0];\\n\\n  while (q.length) {\\n    const start = q.shift();\\n\\n    if (!visited.has(start)) {\\n      for (let end = start + 1; end <= s.length; end++) {\\n        if (set.has(s.slice(start, end))) {\\n          if (end === s.length) return true;\\n          q.push(end);\\n        }\\n      }\\n      visited.add(start);\\n    }\\n  }\\n  return false;\\n};\\n```\n```\\nconst wordBreak = (s, wordDict) => {\\n  if (wordDict == null || wordDict.length === 0) return false;\\n\\n  const set = new Set(wordDict);\\n  const dp = Array(s.length + 1).fill(false);\\n  dp[0] = true;\\n\\n  for (let end = 1; end <= s.length; end++) {\\n    for (let start = 0; start < end; start++) {\\n      const w = s.slice(start, end);\\n      if (dp[start] === true && set.has(w)) {\\n        dp[end] = true;\\n        break;\\n      }\\n    }\\n  }\\n  return dp[s.length];\\n};\\n```\n```\\n// e.g.\\n// \\'leetcode\\'\\n// [\\'leet\\', \\'code\\']\\n//\\n// i = 1 j = 0 l\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 2 j = 0 le\\n// i = 2 j = 1  e\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 3 j = 0 lee\\n// i = 3 j = 1  ee\\n// i = 3 j = 2   e\\n// dp = [true, false, false, false, false, false, false, false, false]\\n// i = 4 j = 0 leet\\n// match\\n// dp = [true, false, false, false, true, false, false, false, false]\\n//\\n// i = 5 j = 0 leetc\\n// i = 5 j = 1  eetc\\n// i = 5 j = 2   etc\\n// i = 5 j = 3    tc\\n// i = 5 j = 4     c\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 6 j = 0 leetco\\n// i = 6 j = 1  eetco\\n// i = 6 j = 2   etco\\n// i = 6 j = 3    tco\\n// i = 6 j = 4     co\\n// i = 6 j = 5      o\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 7 j = 0 leetcod\\n// i = 7 j = 1  eetcod\\n// i = 7 j = 2   etcod\\n// i = 7 j = 3    tcod\\n// i = 7 j = 4     cod\\n// i = 7 j = 5      od\\n// i = 7 j = 6       d\\n// dp = [true, false, false, false, true, false, false, false, false]\\n// i = 8 j = 0 leetcode\\n// i = 8 j = 1  eetcode\\n// i = 8 j = 2   etcode\\n// i = 8 j = 3    tcode\\n// i = 8 j = 4     code\\n// match\\n// dp = [true, false, false, false, true, false, false, false, true]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748479,
                "title": "python3-solution-with-a-detailed-explanation-word-break",
                "content": "The idea is that we go over the combinations of substrings of `s` and see whether they are available in the dictionary. Read [this](https://leetcode.com/problems/word-break/discuss/169383/The-Time-Complexity-of-The-Brute-Force-Method-Should-Be-O(2n)-and-Prove-It-Below) to get a better intuition. \\n\\nWe initialize `dp` to take care of cases that sub-string exists in the `wordDict`. `dp[i]` shows whether subarray `s[0:i]` is available in the `wordDict`. Based on this, `dp[0]` is basically an empty string, that\\'s why we set it to `True` before the `for` loops begin. Then we first loop over `s` and check each substring by starting a new `for` loop that checks the availability of each substring between `j` and `i` (`s[j:i]`). For example if `s = \"leetcode\", wordDict = [\"leet\", \"code\"]`, and `i = 2`, in the inner loop `j` takes values of `0, 1`. Then if `d[j]` is true, meaning that up to that particular `j` is found already, and `s[j:i]` is in the `wordDict`, it would turn `dp[i]` to true showing that we\\'ve found `s[:i]` already in the `wordDict` somewhere. In the below example, `dp = [ True, False, False, False, True ..]` since we found `leet` in the `wordDict`. Note that between index `0` and `4`, there are `False`s.  This is because we don\\'t have `l` or `le` or `lee` in `wordDict`. All the available combinations would be `True` in the `dp` (given the possibility of multiple segmentation) and while the second loop is checking substrings, the `if` statement would take care of all of them. This means that there might be multiple possible segmentations in the `wordDict` and once we found the first one, we\\'re done. \\n\\nQuestion: Imagine `wordDic = [\"leet\",\"code\", \"lee\",\"tcode\"]` and `s= \"leetcode\"`, alright? Can you tell which combinations the code will find first? `lee` and `tcode` because when doing the second loop and checking `s[j:i]` when `i = 8`, `tcode` comes before `code` (note the `break` that gets us out of second loop). Note that it finds both `lee` and `leet` as correct substrings and will turn the `dp` to `True` for them (`dp[3] = True` and `dp[4] = True`). \\n\\nYou might ask why `dp[j]` is there in the `if` statement? Consider this `wordDict = [\"leet\",\"ode\"]`. If that wasn\\'t for `dp[j]` in the `if` statement, `dp[i]` could be turned to `True` while we were missing a letter in the `s`. Basically, `dp[j]` marks a safe station for the loop to move forward with the searching having in mind that up to this point is taken care of. \\n```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n\\t\\tdp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(1, len(s)+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n\\t\\t\\t\\t\\tdp[i] = True\\n                    break\\n                    \\n        return dp[-1]\\n    \\n```\\n\\nThat\\'s it.\\n\\n======================================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix it.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n\\t\\tdp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(1, len(s)+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n\\t\\t\\t\\t\\tdp[i] = True\\n                    break\\n                    \\n        return dp[-1]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 43819,
                "title": "dfs-with-path-memorizing-java-solution",
                "content": "I write this method by what I learned from @[mahdy][1] in his post [Decode Ways][2]\\n\\nUse a set to record all position that cannot find a match in dict. That cuts down the run time of DFS to O(n^2)\\n\\n    public class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            // DFS\\n            Set<Integer> set = new HashSet<Integer>();\\n            return dfs(s, 0, dict, set);\\n        }\\n        \\n        private boolean dfs(String s, int index, Set<String> dict, Set<Integer> set){\\n            // base case\\n            if(index == s.length()) return true;\\n            // check memory\\n            if(set.contains(index)) return false;\\n            // recursion\\n            for(int i = index+1;i <= s.length();i++){\\n                String t = s.substring(index, i);\\n                if(dict.contains(t))\\n                    if(dfs(s, i, dict, set))\\n                        return true;\\n                    else\\n                        set.add(i);\\n            }\\n            set.add(index);\\n            return false;\\n        }\\n    }\\n\\n\\n  [1]: https://oj.leetcode.com/discuss/user/mahdy\\n  [2]: https://oj.leetcode.com/discuss/23872/sharing-my-java-memoized-solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            // DFS\\n            Set<Integer> set = new HashSet<Integer>();\\n            return dfs(s, 0, dict, set);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 809993,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool>dp(s.size(),false);\\n        dp[0]=true;\\n        \\n        for(int i = 0; i <= s.size(); i++)\\n        {\\n            for(auto str: wordDict)\\n            {\\n                if(dp[i])\\n                {\\n                    if(s.substr(i,str.size()).compare(str)==0)\\n                    {\\n                        dp[i+str.size()]=true;\\n                    }\\n                }\\n            }\\n        }return dp[s.size()];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool>dp(s.size(),false);\\n        dp[0]=true;\\n        \\n        for(int i = 0; i <= s.size(); i++)\\n        {\\n            for(auto str: wordDict)\\n            {\\n                if(dp[i])\\n                {\\n                    if(s.substr(i,str.size()).compare(str)==0)\\n                    {\\n                        dp[i+str.size()]=true;\\n                    }\\n                }\\n            }\\n        }return dp[s.size()];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311028,
                "title": "3-solutions-cpp",
                "content": "**RECURSION, Time Limit Exceeded o(2^N)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(),wordDict.end(),s)!=wordDict.end())\\n            return true;\\n    \\n        for(int i=1;i<s.size();i++){\\n            string left = s.substr(0,i);\\n            if(find(wordDict.begin(),wordDict.end(),left)!=wordDict.end() && wordBreak(s.substr(i),wordDict)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```\\n\\n**MEMOIZATION, 22.76% of C++ online submissions**\\n```\\nclass Solution {\\n map <string,bool> m;\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(),wordDict.end(),s)!=wordDict.end())\\n            return true;\\n        if(m.find(s)!=m.end())\\n            return m[s];\\n        for(int i=1;i<s.size();i++){\\n            string left = s.substr(0,i);\\n                 cout<<left<<\"#\";\\n            if(find(wordDict.begin(),wordDict.end(),left)!=wordDict.end() && wordBreak(s.substr(i),wordDict)){\\n                  m[s]=true;\\n                return true;\\n            }\\n        }\\n   \\n        m[s]=false;\\n        return false;\\n    }\\n    \\n};\\n```\\n\\n**DP, 16 ms, faster than 54.11% of C++ online submissions**\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int len = s.length();\\n        vector<bool> dp(len+1,false);\\n        dp[0] = true;\\n        \\n        for(int i=1;i<=len;i++){\\n            for(int j=0;j<i;j++){\\n               if(dp[j] and find(wordDict.begin(),wordDict.end(),s.substr(j,i-j))!=wordDict.end()){\\n                dp[i]=true;   \\n               }              \\n            }\\n        }\\n         return dp[len];\\n    }\\n};\\n```\\n\\nANY SUGGESTION WILL BE APPRITIATED AND PLEASE UPVOTE IF FOUND HELPFUL \\uD83D\\uDE00",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(),wordDict.end(),s)!=wordDict.end())\\n            return true;\\n    \\n        for(int i=1;i<s.size();i++){\\n            string left = s.substr(0,i);\\n            if(find(wordDict.begin(),wordDict.end(),left)!=wordDict.end() && wordBreak(s.substr(i),wordDict)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\n map <string,bool> m;\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(),wordDict.end(),s)!=wordDict.end())\\n            return true;\\n        if(m.find(s)!=m.end())\\n            return m[s];\\n        for(int i=1;i<s.size();i++){\\n            string left = s.substr(0,i);\\n                 cout<<left<<\"#\";\\n            if(find(wordDict.begin(),wordDict.end(),left)!=wordDict.end() && wordBreak(s.substr(i),wordDict)){\\n                  m[s]=true;\\n                return true;\\n            }\\n        }\\n   \\n        m[s]=false;\\n        return false;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int len = s.length();\\n        vector<bool> dp(len+1,false);\\n        dp[0] = true;\\n        \\n        for(int i=1;i<=len;i++){\\n            for(int j=0;j<i;j++){\\n               if(dp[j] and find(wordDict.begin(),wordDict.end(),s.substr(j,i-j))!=wordDict.end()){\\n                dp[i]=true;   \\n               }              \\n            }\\n        }\\n         return dp[len];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 161162,
                "title": "from-brute-force-to-dp",
                "content": "### Brute Force\\n> Could we break the word? We can start from putting the first space.\\n> Where should we put the first space? We can enumerate all possible positions to put the first space.\\n\\n> Take `s = leetcodegood, wordDict = {leet, code, good}` for example,\\n ```\\n   leetcodegood______________________________________________________________________________________\\n\\t /                \\\\                     \\\\                \\\\  leet in dict                        \\\\ \\nl(eetcodegood) le(etcodegood) lee(tcodegood)     leet(codegood)________________                      leetc(odegood) ...\\n                                                  /           |        \\\\         \\\\ code in dict\\n                                              c(odegood) co(degood) cod(egood) code(good)\\n                                                                                /\\n                                                                              g(ood), ...\\n ```\\n> We check all possible break positions \\'l\\', \\'le\\', \\'lee\\'... until we meet `leet`, which is in dict.\\n> Then the problem becomes to if we could break `codegood`, etc.\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return recur(s, 0, wordDict);\\n    }\\n    \\n    private boolean recur(String s, int curIndex, List<String> wordDict) {\\n        if (curIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        for (int end = curIndex + 1; end <= s.length(); end++) {\\n            String split = s.substring(curIndex, end);\\n            if (wordDict.contains(split)) {\\n                if(recur(s, end, wordDict)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\n\\n### Top-down DP\\nWe can use memoization to overcome overlapping subproblems.\\n```\\nclass Solution {\\n    private Boolean[] dp;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        dp = new Boolean[s.length()];\\n        return recur(s, 0, wordDict);\\n    }\\n    \\n    \\n    private boolean recur(String s, int curIndex, List<String> wordDict) {\\n        if (curIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        if (dp[curIndex] != null) {\\n            return dp[curIndex];\\n        }\\n        for (int end = curIndex + 1; end <= s.length(); end++) {\\n            String split = s.substring(curIndex, end);\\n            if (wordDict.contains(split)) {\\n                if(recur(s, end, wordDict)) {\\n                    return dp[curIndex] = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[curIndex] = false;\\n    }\\n}\\n```\\n### Bottom-up DP\\nDefine dp[i] as whether we can break s[0, i).\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>();\\n        wordSet.addAll(wordDict);\\n        \\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i < dp.length ; i++) {\\n            for (int k = 1; k <= i; k++) {\\n                dp[i] = dp[i] || (dp[i - k] && wordSet.contains(s.substring(i - k, i)));\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n   leetcodegood______________________________________________________________________________________\\n\\t /                \\\\                     \\\\                \\\\  leet in dict                        \\\\ \\nl(eetcodegood) le(etcodegood) lee(tcodegood)     leet(codegood)________________                      leetc(odegood) ...\\n                                                  /           |        \\\\         \\\\ code in dict\\n                                              c(odegood) co(degood) cod(egood) code(good)\\n                                                                                /\\n                                                                              g(ood), ...\\n ```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        return recur(s, 0, wordDict);\\n    }\\n    \\n    private boolean recur(String s, int curIndex, List<String> wordDict) {\\n        if (curIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        for (int end = curIndex + 1; end <= s.length(); end++) {\\n            String split = s.substring(curIndex, end);\\n            if (wordDict.contains(split)) {\\n                if(recur(s, end, wordDict)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Boolean[] dp;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        dp = new Boolean[s.length()];\\n        return recur(s, 0, wordDict);\\n    }\\n    \\n    \\n    private boolean recur(String s, int curIndex, List<String> wordDict) {\\n        if (curIndex == s.length()) {\\n            return true;\\n        }\\n        \\n        if (dp[curIndex] != null) {\\n            return dp[curIndex];\\n        }\\n        for (int end = curIndex + 1; end <= s.length(); end++) {\\n            String split = s.substring(curIndex, end);\\n            if (wordDict.contains(split)) {\\n                if(recur(s, end, wordDict)) {\\n                    return dp[curIndex] = true;\\n                }\\n            }\\n        }\\n        \\n        return dp[curIndex] = false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>();\\n        wordSet.addAll(wordDict);\\n        \\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i < dp.length ; i++) {\\n            for (int k = 1; k <= i; k++) {\\n                dp[i] = dp[i] || (dp[i - k] && wordSet.contains(s.substring(i - k, i)));\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172343,
                "title": "java-solution-99-faster-90-less-space-memoization",
                "content": "Instead of checking which substrings exist in the dictionary,\\nI used the fact that the given word can be constructed from the words in the dictionary\\n\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t// for memoization\\n        HashMap<String,Boolean> map= new HashMap<>();\\n        return canConstruct(s, wordDict, map);\\n    }\\n    \\n    public boolean canConstruct(String target,List<String> words, HashMap<String,Boolean> map)\\n    {\\n\\t\\n\\t// if answer already cached, return it\\n        if(map.containsKey(target))\\n            return map.get(target);\\n\\t\\t\\t\\n\\t\\t// if target string is empty\\n\\t\\t// it can always be constructed by taking no elements from dictionary\\n        if(target.isEmpty())\\n            return true;\\n\\t\\t\\t\\n\\t\\t// for all words in the dictionary\\n        for(String word: words)\\n        {\\n\\t\\t// if the target starts with the given word\\n            if(target.startsWith(word))\\n            {\\n\\t\\t\\t// and it is possible to construct the rest of the string\\n\\t\\t\\t// from the words in the dictionary\\n                if(canConstruct(target.substring(word.length()),words, map))\\n                {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// save and return true\\n                    map.put(target, true);\\n                    return true;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if it was not possible to construct the target from words from the dictionary\\n\\t\\t// save and return false to the previous call\\n        map.put(target,false);\\n        return false;\\n    }\\n}\\n```\\n\\nUpvote if you liked:)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t// for memoization\\n        HashMap<String,Boolean> map= new HashMap<>();\\n        return canConstruct(s, wordDict, map);\\n    }\\n    \\n    public boolean canConstruct(String target,List<String> words, HashMap<String,Boolean> map)\\n    {\\n\\t\\n\\t// if answer already cached, return it\\n        if(map.containsKey(target))\\n            return map.get(target);\\n\\t\\t\\t\\n\\t\\t// if target string is empty\\n\\t\\t// it can always be constructed by taking no elements from dictionary\\n        if(target.isEmpty())\\n            return true;\\n\\t\\t\\t\\n\\t\\t// for all words in the dictionary\\n        for(String word: words)\\n        {\\n\\t\\t// if the target starts with the given word\\n            if(target.startsWith(word))\\n            {\\n\\t\\t\\t// and it is possible to construct the rest of the string\\n\\t\\t\\t// from the words in the dictionary\\n                if(canConstruct(target.substring(word.length()),words, map))\\n                {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// save and return true\\n                    map.put(target, true);\\n                    return true;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// if it was not possible to construct the target from words from the dictionary\\n\\t\\t// save and return false to the previous call\\n        map.put(target,false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43879,
                "title": "beat-90-java-c-trie-dp-solution-36-lines-7ms-3ms-java-set-dp-solution-31-lines-7ms",
                "content": "So as many have seen this:\\n\\n> **UPDATE (2017/1/4):**\\n> The wordDict parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.\\n\\nIn a (sort of) similar problem <https://leetcode.com/problems/word-search-ii> there's a use of Trie instead of Set of Strings to speed up the lookup - but why not the word break?\\n\\nSo my understanding for this change in word break is that it does not limit interviewee to process it as Set but also as Trie.\\n\\nif you have already written a Trie for the <https://leetcode.com/problems/implement-trie-prefix-tree> problem or the word-search-ii problem, you should probably copy-paste it to here (and adjust it).\\n\\nThe current C++ DP w/ Set solution runs in 4ms but the below C++ DP w/ Trie solution runs in 3ms.\\n\\nMy Java re-write of solution <https://discuss.leetcode.com/topic/74943/c-dp-solution-with-trie-tree>:\\n\\n```\\npublic class Solution {\\n    private TrieNode root = new TrieNode();\\n    public boolean wordBreak(String str, List<String> wordDict) {\\n        for (String word : wordDict)\\n            addToTrie(word);\\n        boolean[] dp = new boolean[str.length() + 1];\\n        char[] s = str.toCharArray();\\n        dp[0] = true;\\n        for (int i = 0; i < s.length; i++) {\\n            if (!dp[i])\\n                continue;\\n            int j = i; // start trie traversal\\n            TrieNode cur = root;\\n            while (j < s.length && cur.children[s[j] - 'a'] != null) {\\n                cur = cur.children[s[j++] - 'a'];\\n                if (cur.isWord)\\n                    dp[j] = true;\\n            }\\n        }\\n        return dp[str.length()];\\n    }\\n\\n    private void addToTrie(String word) {\\n        TrieNode cur = root;\\n        for (char ch : word.toCharArray()) {\\n            if (cur.children[ch - 'a'] == null)\\n                cur.children[ch - 'a'] = new TrieNode();\\n            cur = cur.children[ch - 'a'];\\n        }\\n        cur.isWord = true;\\n    }\\n    class TrieNode {\\n        public boolean isWord;\\n        public TrieNode[] children = new TrieNode[26];\\n    }\\n}\\n```\\n\\nThe original C++ solution:\\n\\n\\n```\\nclass DictNode {\\npublic:\\n    bool isWord = false;\\n    DictNode *next[26] = {0};\\n};\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        buildDict(wordDict);\\n        int len = s.length();\\n        bool *dp = new bool[len + 1]{0};\\n        dp[0] = 1;\\n        for(int i = 0; i < len; ++i) {\\n            if(!dp[i]) continue;\\n            DictNode* p = dict;\\n            int j = i;\\n            while(j < len && p -> next[s[j] - 'a']) {\\n                p = p -> next[s[j++] - 'a'];\\n                if(p -> isWord) dp[j] = 1;\\n            }\\n            if(dp[len]) return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    DictNode *dict;\\n    \\n    void buildDict(vector<string>& wordDict) {\\n        dict = new DictNode();\\n        DictNode* p;\\n        for(auto &w : wordDict) {\\n            p = dict;\\n            for(auto &c : w) {\\n                auto &next = p -> next[c - 'a'];\\n                if(!next) next = new DictNode();\\n                p = next;\\n            }\\n            p -> isWord = true;\\n        }\\n    }\\n};\\n\\n```\\n\\n* discussion inspired by: <https://discuss.leetcode.com/topic/74192/why-worddict-changed-into-list/3>\\n\\nAlso attached my 7ms-beats-90% (as of Feb 2, 2017) Simple DP solution - just use dictionary\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        int[] maxmin = getMaxMin(wordDict);\\n        int maxLen = maxmin[0];\\n        int minLen = maxmin[1];\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int l = Math.max(0, i - maxLen); l + minLen <= i; l++) {\\n                if (dp[l] && wordSet.contains(s.substring(l, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int l = 0; l < s.length(); l++)\\n            for (int len = minLen; len <= maxLen && l + len <= s.length(); len++)\\n                if (!dp[l + len] && dp[l] && wordSet.contains(s.substring(l, l + len)))\\n                    dp[l + len] = true;\\n        return dp[s.length()];\\n    }\\n    private int[] getMaxMin(List<String> list) {\\n        int max = 0, min = 0;\\n        for (String s : list) {\\n            max = Math.max(max, s.length());\\n            min = Math.min(min, s.length());\\n        }\\n        return new int[]{max, min};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\npublic class Solution {\\n    private TrieNode root = new TrieNode();\\n    public boolean wordBreak(String str, List<String> wordDict) {\\n        for (String word : wordDict)\\n            addToTrie(word);\\n        boolean[] dp = new boolean[str.length() + 1];\\n        char[] s = str.toCharArray();\\n        dp[0] = true;\\n        for (int i = 0; i < s.length; i++) {\\n            if (!dp[i])\\n                continue;\\n            int j = i; // start trie traversal\\n            TrieNode cur = root;\\n            while (j < s.length && cur.children[s[j] - 'a'] != null) {\\n                cur = cur.children[s[j++] - 'a'];\\n                if (cur.isWord)\\n                    dp[j] = true;\\n            }\\n        }\\n        return dp[str.length()];\\n    }\\n\\n    private void addToTrie(String word) {\\n        TrieNode cur = root;\\n        for (char ch : word.toCharArray()) {\\n            if (cur.children[ch - 'a'] == null)\\n                cur.children[ch - 'a'] = new TrieNode();\\n            cur = cur.children[ch - 'a'];\\n        }\\n        cur.isWord = true;\\n    }\\n    class TrieNode {\\n        public boolean isWord;\\n        public TrieNode[] children = new TrieNode[26];\\n    }\\n}\\n```\n```\\nclass DictNode {\\npublic:\\n    bool isWord = false;\\n    DictNode *next[26] = {0};\\n};\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        buildDict(wordDict);\\n        int len = s.length();\\n        bool *dp = new bool[len + 1]{0};\\n        dp[0] = 1;\\n        for(int i = 0; i < len; ++i) {\\n            if(!dp[i]) continue;\\n            DictNode* p = dict;\\n            int j = i;\\n            while(j < len && p -> next[s[j] - 'a']) {\\n                p = p -> next[s[j++] - 'a'];\\n                if(p -> isWord) dp[j] = 1;\\n            }\\n            if(dp[len]) return true;\\n        }\\n        return false;\\n    }\\n    \\nprivate:\\n    DictNode *dict;\\n    \\n    void buildDict(vector<string>& wordDict) {\\n        dict = new DictNode();\\n        DictNode* p;\\n        for(auto &w : wordDict) {\\n            p = dict;\\n            for(auto &c : w) {\\n                auto &next = p -> next[c - 'a'];\\n                if(!next) next = new DictNode();\\n                p = next;\\n            }\\n            p -> isWord = true;\\n        }\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        int[] maxmin = getMaxMin(wordDict);\\n        int maxLen = maxmin[0];\\n        int minLen = maxmin[1];\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int l = Math.max(0, i - maxLen); l + minLen <= i; l++) {\\n                if (dp[l] && wordSet.contains(s.substring(l, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int l = 0; l < s.length(); l++)\\n            for (int len = minLen; len <= maxLen && l + len <= s.length(); len++)\\n                if (!dp[l + len] && dp[l] && wordSet.contains(s.substring(l, l + len)))\\n                    dp[l + len] = true;\\n        return dp[s.length()];\\n    }\\n    private int[] getMaxMin(List<String> list) {\\n        int max = 0, min = 0;\\n        for (String s : list) {\\n            max = Math.max(max, s.length());\\n            min = Math.min(min, s.length());\\n        }\\n        return new int[]{max, min};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860709,
                "title": "very-easy-and-short-code-memoization-dp-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBreak the problem into subproblems sb and check if sb can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtu.be/-bSiawDmYkQ\\n or link in my profile.Here,you can find any solution in playlists monthwise from June 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a recursive approach with memoization to determine if the input string `s` can be broken down into valid words from the given `wordDict`. It iterates through all possible prefixes of the input string, and for each prefix, it checks if it exists in the `wordDict`. If found, it makes a recursive call with the remaining suffix of the input string. Memoization is used to avoid redundant computations and improve efficiency. If a valid segmentation is found, the function returns `true`, otherwise `false`.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$ where n is string length.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n     unordered_map<string,bool>dp;\\n    bool solve(string s,unordered_set<string>&m){\\n        if(s.length()==0){\\n            return true;\\n        }\\n        if(dp.find(s)!=dp.end())\\n        return dp[s];\\n        for(int i=0;i<s.length();i++){\\n            string r=s.substr(0,i+1);\\n            if(m.count(r)){\\n                if(solve(s.substr(i+1),m))\\n                return dp[s]=true;\\n            }\\n        }\\n        return dp[s]=false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n         unordered_set<string>m;\\n        for(auto x:wordDict){\\n            m.insert(x);\\n        }\\n         return solve(s,m);\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    private Map<String, Boolean> dp;\\n\\n    public boolean solve(String s, Set<String> m) {\\n        if (s.length() == 0) {\\n            return true;\\n        }\\n        if (dp.containsKey(s))\\n            return dp.get(s);\\n        for (int i = 0; i < s.length(); i++) {\\n            String r = s.substring(0, i + 1);\\n            if (m.contains(r)) {\\n                if (solve(s.substring(i + 1), m)){\\n                    dp.put(s,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        dp.put(s, false);\\n        return false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> m = new HashSet<>(wordDict);\\n        dp = new HashMap<>();\\n        return solve(s, m);\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = {}\\n\\n    def solve(self, s, m):\\n        if not s:\\n            return True\\n        if s in self.dp:\\n            return self.dp[s]\\n        for i in range(len(s)):\\n            r = s[:i + 1]\\n            if r in m:\\n                if self.solve(s[i + 1:], m):\\n                    self.dp[s] = True\\n                    return True\\n        self.dp[s] = False\\n        return False\\n\\n    def wordBreak(self, s, wordDict):\\n        m = set(wordDict)\\n        return self.solve(s, m)\\n\\n```\\n# upvote the article if u understood the solution!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n     unordered_map<string,bool>dp;\\n    bool solve(string s,unordered_set<string>&m){\\n        if(s.length()==0){\\n            return true;\\n        }\\n        if(dp.find(s)!=dp.end())\\n        return dp[s];\\n        for(int i=0;i<s.length();i++){\\n            string r=s.substr(0,i+1);\\n            if(m.count(r)){\\n                if(solve(s.substr(i+1),m))\\n                return dp[s]=true;\\n            }\\n        }\\n        return dp[s]=false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n         unordered_set<string>m;\\n        for(auto x:wordDict){\\n            m.insert(x);\\n        }\\n         return solve(s,m);\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    private Map<String, Boolean> dp;\\n\\n    public boolean solve(String s, Set<String> m) {\\n        if (s.length() == 0) {\\n            return true;\\n        }\\n        if (dp.containsKey(s))\\n            return dp.get(s);\\n        for (int i = 0; i < s.length(); i++) {\\n            String r = s.substring(0, i + 1);\\n            if (m.contains(r)) {\\n                if (solve(s.substring(i + 1), m)){\\n                    dp.put(s,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        dp.put(s, false);\\n        return false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> m = new HashSet<>(wordDict);\\n        dp = new HashMap<>();\\n        return solve(s, m);\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.dp = {}\\n\\n    def solve(self, s, m):\\n        if not s:\\n            return True\\n        if s in self.dp:\\n            return self.dp[s]\\n        for i in range(len(s)):\\n            r = s[:i + 1]\\n            if r in m:\\n                if self.solve(s[i + 1:], m):\\n                    self.dp[s] = True\\n                    return True\\n        self.dp[s] = False\\n        return False\\n\\n    def wordBreak(self, s, wordDict):\\n        m = set(wordDict)\\n        return self.solve(s, m)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870102,
                "title": "pyhon-dfs-using-lru-cache-explained",
                "content": "Let `dfs(k)` be a possibility to split string `s[k:]` into words from `wordSet`. Then to check if word `s[k:]` can be splitted, we need to check if for some `i` word `s[k:i]` in our `wordSet` and if `s[i:]` can be splitted, which is `dfs(i)`.\\n\\n**Complexity**: let `T` be the maximum length of word in our `wordSet`. Then we need `O(T)` time to check if word in our set, so we have overall `O(n^2T)` complexity. Space complexity is `O(n +Tn)` : to keep our cache and to keep our set of `wordSet`\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n   \\n        @lru_cache(None)\\n        def dfs(k):\\n            if k == n: return True\\n            for i in range(k + 1, n + 1):\\n                if s[k:i] in wordSet and dfs(i):\\n                    return True        \\n            return False\\n        \\n        return dfs(0)\\n```\\n\\n**Further discussion**: Another approach is to use KMP for each of the `m` words and create `n x n` table `Mem`, where `Mem[i][j]` is equal to `1` if `s[i:j]` is in our dictionary. The complexity to generate `Mem` table is `O(mn)` and `O(n^2)` to update `dp`. Finally, we have `O(n^2 + nm)` time and `O(n^2)` memory.\\n\\nOne more approach is to use Tries to preprocess our dictionary with `O(mk)` time, where `k` is the average length of words. Then we can fill `dp` table in `O(n^2)` time (CHECK, I am not 100 percent sure). Finally, we have `O(mk + n^2)` time and `O(mk)` memory.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n   \\n        @lru_cache(None)\\n        def dfs(k):\\n            if k == n: return True\\n            for i in range(k + 1, n + 1):\\n                if s[k:i] in wordSet and dfs(i):\\n                    return True        \\n            return False\\n        \\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528858,
                "title": "fastest-javascript-bfs-44ms",
                "content": "```javascript\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    const words = new Set(wordDict);\\n    const wordLens = new Set(wordDict.map((word) => word.length))\\n    const starts = new Set([0])\\n    for (let start of starts) {\\n        for (let len of wordLens) {\\n            if (words.has(s.slice(start, start + len))) {\\n                starts.add(start + len)\\n            }\\n        }\\n    }\\n    return starts.has(s.length)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    const words = new Set(wordDict);\\n    const wordLens = new Set(wordDict.map((word) => word.length))\\n    const starts = new Set([0])\\n    for (let start of starts) {\\n        for (let len of wordLens) {\\n            if (words.has(s.slice(start, start + len))) {\\n                starts.add(start + len)\\n            }\\n        }\\n    }\\n    return starts.has(s.length)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43796,
                "title": "accepted-java-solution",
                "content": "    public class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            boolean [] breakable = new boolean[s.length()+1];\\n            breakable[0] = true;\\n    \\n            for(int i=1;i<=s.length();i++){\\n                for(int j=0;j<i;j++){\\n                    if(breakable[j]&&dict.contains(s.substring(j,i))){\\n                        breakable[i] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            return breakable[s.length()];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            boolean [] breakable = new boolean[s.length()+1];\\n            breakable[0] = true;\\n    \\n            for(int i=1;i<=s.length();i++){\\n                for(int j=0;j<i;j++){\\n                    if(breakable[j]&&dict.contains(s.substring(j,i))){\\n                        breakable[i] = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 43916,
                "title": "a-concise-java-solution-11-line-in-wordbreak-function",
                "content": "    public class Solution {\\n        \\n        public boolean wordBreak(String s, Set<String> wordDict) {\\n            int len = s.length();\\n            boolean[] f = new boolean[len+1];\\n            f[0] = true;\\n            for (int i=1; i<len+1; i++)\\n                for (int j=0; j<i; j++)\\n                    if (f[j] && wordDict.contains(s.substring(j,i)))\\n                    {\\n                        f[i] = true;\\n                        break;\\n                    }\\n            return f[len];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        public boolean wordBreak(String s, Set<String> wordDict) {\\n            int len = s.length();\\n            boolean[] f = new boolean[len+1];\\n            f[0] = true;\\n            for (int i=1; i<len+1; i++)\\n                for (int j=0; j<i; j++)\\n                    if (f[j] && wordDict.contains(s.substring(j,i)))\\n                    {\\n                        f[i] = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 511991,
                "title": "python-trie",
                "content": "I have implemented a Trie directly from my code for the problem https://leetcode.com/problems/implement-trie-prefix-tree/\\nThe main function creates an array like the dp solutions shown in other posts. But it uses a Trie to search for a string. It is always a good choice to optimize search for substrings using a Trie Data Structure. The runtime for the test cases here is similar to the DP solutions but for interview preparation this probably is a good way to demonstrate your knowledge of Trie. \\n\\n```\\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.root = {\\'*\\':\\'*\\'}\\n        \\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n\\n    def insert(self, word):        \\n        \"\"\"\\n        Inserts a word into the trie.\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        current = self.root\\n        \\n        for c in word:\\n            \\n            if c not in current:\\n                \\n                current[c] = {}\\n                \\n            current = current[c]\\n            \\n        current[\\'*\\'] = \\'*\\'\\n        \\n    def search_word(self,word):\\n        \\n        current = self.root\\n        \\n        for c in word:\\n            \\n            if c not in current:\\n                return False\\n                \\n            current = current[c]\\n        if \\'*\\' in current:\\n            return True\\n        \\n        else:\\n            return False\\n\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        trie = Trie()\\n        \\n        for w in wordDict:\\n            \\n            trie.insert(w)\\n        \\n        dp=[False for i in range(len(s)+1)]\\n        dp[0]=True\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(i):\\n                \\n                if dp[j] and trie.search_word(s[j:i]):\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.root = {\\'*\\':\\'*\\'}\\n        \\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n\\n    def insert(self, word):        \\n        \"\"\"\\n        Inserts a word into the trie.\\n        :type word: str\\n        :rtype: None\\n        \"\"\"\\n        current = self.root\\n        \\n        for c in word:\\n            \\n            if c not in current:\\n                \\n                current[c] = {}\\n                \\n            current = current[c]\\n            \\n        current[\\'*\\'] = \\'*\\'\\n        \\n    def search_word(self,word):\\n        \\n        current = self.root\\n        \\n        for c in word:\\n            \\n            if c not in current:\\n                return False\\n                \\n            current = current[c]\\n        if \\'*\\' in current:\\n            return True\\n        \\n        else:\\n            return False\\n\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        trie = Trie()\\n        \\n        for w in wordDict:\\n            \\n            trie.insert(w)\\n        \\n        dp=[False for i in range(len(s)+1)]\\n        dp[0]=True\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(i):\\n                \\n                if dp[j] and trie.search_word(s[j:i]):\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959656,
                "title": "c-recursion-memo-commented",
                "content": "Thank you @Nk_mishra for a clear solution.\\n\\nThe idea is to find all **possible prefixes** and recurse the remaining part of the string. \\nMemoize the function to avoid redundant calls.\\n\\n```Catsandog - [cat, cats, sand, and, dog]```\\nC\\nCa\\nCat\\nLeft = Cat, Recurse(sandog)\\ns\\nsa\\nsan\\nsand\\nLeft = sand, Recurse(og)\\no\\nog\\nreturn false\\nFunction falls on Left = Cats, Recurse(andog) ...\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, bool> memo;\\n    \\n    bool wordBreakHelp(string word, unordered_map<string, bool>& dict)\\n    {\\n        //if present in dict\\n        if(dict.find(word) != dict.end())\\n            return true;\\n        \\n        //if present in memo, no need to call \\n        if(memo.find(word) != memo.end())\\n            return memo[word];\\n        \\n        \\n        for(int i=0; i<word.length(); i++)\\n        {\\n            string left = word.substr(0, i+1); //always starts from beginning\\n            string right = word.substr(i+1); //remaining string till the last letter;\\n            \\n            if(dict.find(left) != dict.end())\\n            {\\n                bool ros = wordBreakHelp(right, dict); //rest of the string is recursed\\n                \\n                if(ros == true)\\n                {\\n                    memo[word] = true; //entire word exists\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        //if no prefix is found to be matching, word does not exist\\n        memo[word] = false;\\n        return false;\\n          \\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) \\n    {\\n        unordered_map<string, bool> dict;\\n        \\n        for(string s : wordDict)\\n            dict[s] = true;\\n        \\n        return wordBreakHelp(s, dict);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```Catsandog - [cat, cats, sand, and, dog]```\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, bool> memo;\\n    \\n    bool wordBreakHelp(string word, unordered_map<string, bool>& dict)\\n    {\\n        //if present in dict\\n        if(dict.find(word) != dict.end())\\n            return true;\\n        \\n        //if present in memo, no need to call \\n        if(memo.find(word) != memo.end())\\n            return memo[word];\\n        \\n        \\n        for(int i=0; i<word.length(); i++)\\n        {\\n            string left = word.substr(0, i+1); //always starts from beginning\\n            string right = word.substr(i+1); //remaining string till the last letter;\\n            \\n            if(dict.find(left) != dict.end())\\n            {\\n                bool ros = wordBreakHelp(right, dict); //rest of the string is recursed\\n                \\n                if(ros == true)\\n                {\\n                    memo[word] = true; //entire word exists\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        //if no prefix is found to be matching, word does not exist\\n        memo[word] = false;\\n        return false;\\n          \\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) \\n    {\\n        unordered_map<string, bool> dict;\\n        \\n        for(string s : wordDict)\\n            dict[s] = true;\\n        \\n        return wordBreakHelp(s, dict);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609045,
                "title": "c-solution-with-dynamic-programming-with-explanation",
                "content": "In this sample explanation, let\\'s take the input string as `\"leetcode\"` and dictionary as follows: `{\"leet\", \"code\"}`. \\nFirst we create the dynamic programming array (dp), initially it looks as follows:\\n![image](https://assets.leetcode.com/users/guney/image_1588442946.png)\\nThen, we keep iterating `e` and `b` pointers. At some point, pointers are creating a substring that is in the dictionary, as follows:\\n![image](https://assets.leetcode.com/users/guney/image_1588443094.png)\\nHere, `b` pointer shows index 0 of dp array and `e` pointer shows index 4 of dp array, which creates the substring `leet`. We update the index 4 of dp array as `true` if the substring is in the dictionary and if dp array at index `b` is `true`. In this case, condition is satisfied and dp array is updated as follows:\\n![image](https://assets.leetcode.com/users/guney/image_1588443414.png)\\nWe keep iterating pointers until we traverse whole input string and keep updating dp array when the condition is satisfied. In the current example, we update it one more time when pointers are shown as below:\\n![image](https://assets.leetcode.com/users/guney/image_1588443527.png)\\n\\nIf the last element is `true`, we have a successful word break. Having more elements in the dictionary with different substrings in the input string would break the algorithm, it would only add more `true` values to the dp array.\\n\\nCode is below for this explanation.\\n\\n```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\t// remove duplicates from dictionary\\n\\tunordered_set<string> word_set(wordDict.begin(), wordDict.end());\\n\\tauto slen = s.size();\\n\\tvector<bool> dp(slen + 1, false);\\n\\tdp[0] = true;\\n\\tfor (int e = 0; e <= slen; ++e) {\\n\\t\\tfor (int b = e; b >= 0; --b) {\\n\\t\\t\\tif (dp[b] && word_set.count(s.substr(b, e - b)) > 0) {\\n\\t\\t\\t\\t// substring begins at location \\'b\\' and end at location \\'e\\'\\n\\t\\t\\t\\t// set location \\'e\\' to true, if substring is in the dictionary & the last word before the substring is also true\\n\\t\\t\\t\\tdp[e] = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[slen];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\t// remove duplicates from dictionary\\n\\tunordered_set<string> word_set(wordDict.begin(), wordDict.end());\\n\\tauto slen = s.size();\\n\\tvector<bool> dp(slen + 1, false);\\n\\tdp[0] = true;\\n\\tfor (int e = 0; e <= slen; ++e) {\\n\\t\\tfor (int b = e; b >= 0; --b) {\\n\\t\\t\\tif (dp[b] && word_set.count(s.substr(b, e - b)) > 0) {\\n\\t\\t\\t\\t// substring begins at location \\'b\\' and end at location \\'e\\'\\n\\t\\t\\t\\t// set location \\'e\\' to true, if substring is in the dictionary & the last word before the substring is also true\\n\\t\\t\\t\\tdp[e] = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[slen];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44011,
                "title": "java-solution-using-dp",
                "content": "    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if (s == null && wordDict == null)\\n            return true;\\n        if (s == null || wordDict == null)\\n            return false;\\n        //dp[i] represents if s.substring(0, i) is wordbreakable.\\n        boolean[] dp = new boolean[s.length()+1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public boolean wordBreak(String s, Set<String> wordDict) {\\n        if (s == null && wordDict == null)\\n            return true;\\n        if (s == null || wordDict == null)\\n            return false;\\n        //dp[i] represents if s.substring(0, i) is wordbreakable.\\n        boolean[] dp = new boolean[s.length()+1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 490911,
                "title": "python-simple-trie-solution-with-detailed-explanation-and-sketches",
                "content": "**For BFS, DFS recursive with memo, and DP solutions, please visit the link below:**\\nhttps://leetcode.com/problems/word-break/discuss/1326943/Python-Two-BFS-solutions-or-Explained-%2B-visualized\\n\\n**Trie Solution Idea:**\\n\\n- Build your dictionary of words using a trie DS.\\n- In the trie dictionary, every word is represented by a path from the root to a leaf (the root is a null node since its shared by all words in the dictionary)\\n- Along every path, a word is stored as a series of nodes (aka linked list) where each node represents a character in the word (path)\\n- The main building block of a trie is a node\\n- The nodes have 3 basic attributes: value, children, a flag to indicate whether the \\n\\n**Time and space complexity:**\\n\\n-  ``` add() ```  O(K) where K = len(words)\\n-  ``` find() ```  O(S) where s = sentence\\n- ``` wordBreak() ```   O(W *  K) OR O(S * S[i+1:]) Whichever is worst, where W=len(words)\\n\\n\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\t\\t# instantiate an empty trie \\n        trie = Trie()\\n        # Iterate over words in dictionary and build trie one word at a time\\n        for word in wordDict:   #------ O(W) where W = len(words)\\n            trie.add(word)  #--------------- O(K) where K = len(word)\\n        print(trie.root.children)\\n        # Words have been added. Find if s is made up of words in the trie\\n        return trie.find(s)  # ---- Overall time : O(W*K) OR O(S*S[i+1:]) Whichever is worst\\n\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.is_done = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n        self.memo = {}\\n\\n    def add(self, word):\\n        root = self.root\\n        for char in word:\\n            if char not in root.children:\\n                root.children[char] = Node(char)\\n            root = root.children[char]   # -- on to the child - going one level down the tire branch/path\\n\\t    root.is_done = True    # -------------- To mark the end of a word.\\n\\t\\t                                                # This is necessary to make the \"word break\" functionality possible) -- SEE SKETCH-1-\\n                                                        # s = \"Ilovecats\", wordDict = [\"I\", \"love\", \"cats\"]\\n                                                        # Marking last chars of each word is the only way for the trie to distinguish between the words and to seperate the words\\n                                                        # while building the trie and also searching the trie later on.\\n\\n    def find(self, s):\\n        root = self.root\\n        for i, char in enumerate(s):\\n            if char not in root.children:   # [1] -- if char does not exist\\n                return False\\n            \\n            if root.children[char].is_done: # [2] --  if char does exit, but it\\'s marked as the last char/leaf node --- \\n\\t\\t\\t                                            # SEE NOTE #[2] FOR A DETAILED EXPLANATION\\n\\n                if s[i+1:] not in self.memo:                  # -- (a) if the remaining part hasn\\'t been seen before, then we need to check it -> call the function recursively\\n                    self.memo[s[i+1:]] = self.find(s[i+1:]) \\n\\n                if self.memo[s[i+1:]]:                        # -- (b) if remaining has been seen - return True (no need to check)\\n                    return True                                      # -- Having seen the \"remaining part\" before is possible if a word repeats in the sentence.\\n                                                                            # for example:\\n                                                                            # A man gotta do what a man gotta do\\n                                                                            # ex: s = \"Amangottadowhatamangottado\"\\n                                                                            # The words \"man\", \"do\", \"gotta\", and \"a\" repeats twice each\\n                                                                            # in such scenario, it\\'s wise to use a memoization dict to speed things up - see sketch 3\\n\\n            root = root.children[char]         # ----- move on to the child node - go one level down the branch\\n        \\n        return root.is_done                   # ----- Only return True if the last char in s is marked as leaf in the trie\\n                                                       # This is another way of saying - we have found every word in our given sentence \"s\" \\n                \\n            \\n    \\n\\t # NOTE 2\\n     # ------   \\n     # We need to capture leaf nodes because in a trie, words that have the same prefix\\n     # will appear as one word as long as they share the prefix and\\n     # will only start to diverge from one another at the first non-mutual letter/character\\n     # *please see sketch -2-*\\n\\n     # Thus, if char exists and it\\'s marked as a leaf node in the trie.\\n     # there\\'s no way to make sure whether this leaf node is \\n     # the GLOBAL leaf node of that path/branch or just a LOCAL leaf node\\n\\n     # GLOBAL leaf node belongs represents the char that belongs\\n     # to the longest word of all the words that share the same prefix.\\n     # While LOCAL leaf node marks the end of a shorter word that shares the\\n     # same prefix with longer words, and thus -in reality- is not really a \\n     # <proper> leaf node as far as the trie is concenred. As a result,\\n     # whenever we encounter a leaf, we need to make sure that there\\'s\\n     # no remaining characters by checking s[i+1:]\\n     # if s[i+1: ] is not None -> this means the word we\\'are trying to find\\n     # extends beyond that initial leaf node that we encountered \\n     # <there are more characters to the word>, hence we need to call the function again\\n     # on that remaining part s[i+1: ] to make sure that it exists in the trie.\\n     # This makes sense becasue, so far we were able to find only the first part\\n     # s[:i] and we\\'re sure it exists but we still have to verify the existence of\\n     # the remaing part. We do that by simply calling the function again -recursively-\\n     # on that remaining part.\\n    \\n```\\n\\n\\n# **Sketch -1-**\\n![image](https://assets.leetcode.com/users/abadawi/image_1580063469.png)\\n.\\n.\\n.\\n.\\n\\n \\n# **Sketch -2-**\\n![image](https://assets.leetcode.com/users/abadawi/image_1580063478.png)\\n\\n.\\n.\\n.\\n.\\n\\n# **Sketch -3-**\\n![image](https://assets.leetcode.com/users/abadawi/image_1580063486.png)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "``` add() ```\n``` find() ```\n``` wordBreak() ```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\t\\t# instantiate an empty trie \\n        trie = Trie()\\n        # Iterate over words in dictionary and build trie one word at a time\\n        for word in wordDict:   #------ O(W) where W = len(words)\\n            trie.add(word)  #--------------- O(K) where K = len(word)\\n        print(trie.root.children)\\n        # Words have been added. Find if s is made up of words in the trie\\n        return trie.find(s)  # ---- Overall time : O(W*K) OR O(S*S[i+1:]) Whichever is worst\\n\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.is_done = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = Node(None)\\n        self.memo = {}\\n\\n    def add(self, word):\\n        root = self.root\\n        for char in word:\\n            if char not in root.children:\\n                root.children[char] = Node(char)\\n            root = root.children[char]   # -- on to the child - going one level down the tire branch/path\\n\\t    root.is_done = True    # -------------- To mark the end of a word.\\n\\t\\t                                                # This is necessary to make the \"word break\" functionality possible) -- SEE SKETCH-1-\\n                                                        # s = \"Ilovecats\", wordDict = [\"I\", \"love\", \"cats\"]\\n                                                        # Marking last chars of each word is the only way for the trie to distinguish between the words and to seperate the words\\n                                                        # while building the trie and also searching the trie later on.\\n\\n    def find(self, s):\\n        root = self.root\\n        for i, char in enumerate(s):\\n            if char not in root.children:   # [1] -- if char does not exist\\n                return False\\n            \\n            if root.children[char].is_done: # [2] --  if char does exit, but it\\'s marked as the last char/leaf node --- \\n\\t\\t\\t                                            # SEE NOTE #[2] FOR A DETAILED EXPLANATION\\n\\n                if s[i+1:] not in self.memo:                  # -- (a) if the remaining part hasn\\'t been seen before, then we need to check it -> call the function recursively\\n                    self.memo[s[i+1:]] = self.find(s[i+1:]) \\n\\n                if self.memo[s[i+1:]]:                        # -- (b) if remaining has been seen - return True (no need to check)\\n                    return True                                      # -- Having seen the \"remaining part\" before is possible if a word repeats in the sentence.\\n                                                                            # for example:\\n                                                                            # A man gotta do what a man gotta do\\n                                                                            # ex: s = \"Amangottadowhatamangottado\"\\n                                                                            # The words \"man\", \"do\", \"gotta\", and \"a\" repeats twice each\\n                                                                            # in such scenario, it\\'s wise to use a memoization dict to speed things up - see sketch 3\\n\\n            root = root.children[char]         # ----- move on to the child node - go one level down the branch\\n        \\n        return root.is_done                   # ----- Only return True if the last char in s is marked as leaf in the trie\\n                                                       # This is another way of saying - we have found every word in our given sentence \"s\" \\n                \\n            \\n    \\n\\t # NOTE 2\\n     # ------   \\n     # We need to capture leaf nodes because in a trie, words that have the same prefix\\n     # will appear as one word as long as they share the prefix and\\n     # will only start to diverge from one another at the first non-mutual letter/character\\n     # *please see sketch -2-*\\n\\n     # Thus, if char exists and it\\'s marked as a leaf node in the trie.\\n     # there\\'s no way to make sure whether this leaf node is \\n     # the GLOBAL leaf node of that path/branch or just a LOCAL leaf node\\n\\n     # GLOBAL leaf node belongs represents the char that belongs\\n     # to the longest word of all the words that share the same prefix.\\n     # While LOCAL leaf node marks the end of a shorter word that shares the\\n     # same prefix with longer words, and thus -in reality- is not really a \\n     # <proper> leaf node as far as the trie is concenred. As a result,\\n     # whenever we encounter a leaf, we need to make sure that there\\'s\\n     # no remaining characters by checking s[i+1:]\\n     # if s[i+1: ] is not None -> this means the word we\\'are trying to find\\n     # extends beyond that initial leaf node that we encountered \\n     # <there are more characters to the word>, hence we need to call the function again\\n     # on that remaining part s[i+1: ] to make sure that it exists in the trie.\\n     # This makes sense becasue, so far we were able to find only the first part\\n     # s[:i] and we\\'re sure it exists but we still have to verify the existence of\\n     # the remaing part. We do that by simply calling the function again -recursively-\\n     # on that remaining part.\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 44033,
                "title": "7-line-python-dp",
                "content": "Original title was \"Naive python solution.. looks like Greedy?\"\\n\\nKeeping track of possible start indices.\\n\\n    def wordBreak(self, s, wordDict):\\n        starts = [0]\\n        for i in range(len(s)):\\n            for j in starts:\\n                if s[j:i+1] in wordDict:\\n                    starts.append(i+1)\\n                    break\\n        return starts[-1] == len(s)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Original title was \"Naive python solution.. looks like Greedy?\"\\n\\nKeeping track of possible start indices.\\n\\n    def wordBreak(self, s, wordDict):\\n        starts = [0]\\n        for i in range(len(s)):\\n            for j in starts:\\n                if s[j:i+1] in wordDict:\\n                    starts.append(i+1)\\n                    break\\n        return starts[-1] == len(s)",
                "codeTag": "Python3"
            },
            {
                "id": 806451,
                "title": "python-dp-bottom-up-solution-with-comments",
                "content": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        dp = [False for i in range(len(s) + 1)] #(1)\\n        dp[0] = True\\n        \\n        for i in range(len(s) + 1): #(2)\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict: #(3)\\n                    dp[i] = True\\n                    break #(4)\\n        \\n        return dp[len(s)] #(5)\\n        \\n    #(1) dp[i] = s[0:i] is breakable\\n    #(2) Considering all possible substrings of s.\\n    #(3) If s[0:j] is breakable and s[j:i] is breakable, then s[0:i] is breakable. Equivalently, if dp[j] is True and s[j:i] is in the wordDict, then dp[i] is True.\\n    #(4) Our goal is to determine if dp[i] is breakable, and once we do, we don\\'t need to consider anything else. This is because we want to construct dp.\\n    #(5) dp[len(s)] tells us if s[0:len(s)] (or equivalently, s) is breakable.\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        \\n        dp = [False for i in range(len(s) + 1)] #(1)\\n        dp[0] = True\\n        \\n        for i in range(len(s) + 1): #(2)\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict: #(3)\\n                    dp[i] = True\\n                    break #(4)\\n        \\n        return dp[len(s)] #(5)\\n        \\n    #(1) dp[i] = s[0:i] is breakable\\n    #(2) Considering all possible substrings of s.\\n    #(3) If s[0:j] is breakable and s[j:i] is breakable, then s[0:i] is breakable. Equivalently, if dp[j] is True and s[j:i] is in the wordDict, then dp[i] is True.\\n    #(4) Our goal is to determine if dp[i] is breakable, and once we do, we don\\'t need to consider anything else. This is because we want to construct dp.\\n    #(5) dp[len(s)] tells us if s[0:len(s)] (or equivalently, s) is breakable.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861895,
                "title": "c-dp-recursion-memoization-day-4",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    map<string,int>m;\\n    bool help(int i,string &s,vector<int>&dp){\\n        if(i==s.size())return true;\\n        if(dp[i]!=-1)return dp[i];\\n        bool ans = false;\\n        string a = \"\";\\n        for(int k=i;k<s.size();k++){\\n            a += s[k];\\n            if(m[a]){\\n                ans |= help(k+1,s,dp);\\n            }\\n        }\\n        return  dp[i] = ans;\\n    }\\n    bool wordBreak(string s, vector<string>& w) {\\n        for(auto i:w){\\n            m[i]++;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return help(0,s,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/7802eeca-3df2-4498-9bd7-0413695bcf8f_1691138462.1918123.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<string,int>m;\\n    bool help(int i,string &s,vector<int>&dp){\\n        if(i==s.size())return true;\\n        if(dp[i]!=-1)return dp[i];\\n        bool ans = false;\\n        string a = \"\";\\n        for(int k=i;k<s.size();k++){\\n            a += s[k];\\n            if(m[a]){\\n                ans |= help(k+1,s,dp);\\n            }\\n        }\\n        return  dp[i] = ans;\\n    }\\n    bool wordBreak(string s, vector<string>& w) {\\n        for(auto i:w){\\n            m[i]++;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return help(0,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617356,
                "title": "recursion-memoization-tabulation-simple-and-precise-c-solution",
                "content": "# Recursion\\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        return f(0, s, dict);\\n    }\\n\\t\\n\\tbool f(int ind, string &s, set<string> &dict) {\\n        if(ind == s.length()) return true;\\n        \\n        for(int i = ind; i < s.length(); i++) {\\n            string cur = s.substr(ind, i-ind+1);\\n            if(dict.find(cur) != dict.end() && f(i+1, s, dict)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\\n\\n# Memoization\\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<int> dp(s.length(), -1);\\n        return f(0, s, dict, dp);\\n    }\\n\\t\\n\\tbool f(int ind, string &s, set<string> &dict, vector<int>& dp) {\\n        if(ind == s.length()) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        for(int i = ind; i < s.length(); i++) {\\n            string cur = s.substr(ind, i-ind+1);\\n            if(dict.find(cur) != dict.end() && f(i+1, s, dict, dp)) {\\n                return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n```\\n\\n# Tabulation\\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        int n = s.length();\\n        vector<bool> dp(n+1, false);\\n        dp[n] = true;\\n        for(int ind = n-1; ind >= 0; ind--) {\\n            for(int i = ind; i < s.length(); i++) {\\n                string cur = s.substr(ind, i-ind+1);\\n                if(dict.find(cur) != dict.end() && dp[i+1]) {\\n                    dp[ind] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n\\t}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        return f(0, s, dict);\\n    }\\n\\t\\n\\tbool f(int ind, string &s, set<string> &dict) {\\n        if(ind == s.length()) return true;\\n        \\n        for(int i = ind; i < s.length(); i++) {\\n            string cur = s.substr(ind, i-ind+1);\\n            if(dict.find(cur) != dict.end() && f(i+1, s, dict)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<int> dp(s.length(), -1);\\n        return f(0, s, dict, dp);\\n    }\\n\\t\\n\\tbool f(int ind, string &s, set<string> &dict, vector<int>& dp) {\\n        if(ind == s.length()) return true;\\n        if(dp[ind] != -1) return dp[ind];\\n        \\n        for(int i = ind; i < s.length(); i++) {\\n            string cur = s.substr(ind, i-ind+1);\\n            if(dict.find(cur) != dict.end() && f(i+1, s, dict, dp)) {\\n                return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n```\n```\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        int n = s.length();\\n        vector<bool> dp(n+1, false);\\n        dp[n] = true;\\n        for(int ind = n-1; ind >= 0; ind--) {\\n            for(int i = ind; i < s.length(); i++) {\\n                string cur = s.substr(ind, i-ind+1);\\n                if(dict.find(cur) != dict.end() && dp[i+1]) {\\n                    dp[ind] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[0];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1326943,
                "title": "python-5-approaches-bfs-recursive-memo-dp-trie-explained-visualized",
                "content": "\\n---------------------------------------------------------------------\\nBFS Idea:\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n![image](https://assets.leetcode.com/users/images/a37c252b-59c6-4203-8432-5b816c785bdd_1625840817.161574.jpeg)\\n\\n\\n---------------------------------------------------------------------\\n[1] Top-down  : Iterative BFS - generate all substrings intially but only traverse the dict-approved ones\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n```\\ndef wordBreak(s, wordDict):\\n        from collections import deque\\n        q = deque()\\n        q.append(0) # startIndx\\n        visited = set()\\n        dictSet = set(wordDict)\\n        while q:\\n            for i in range(len(q)):\\n                startIndx = q.popleft()\\n                if startIndx == len(s): # - NOTE [1]\\n                    return True\\n                \\n                if startIndx not in visited:\\n                    visited.add(startIndx)\\n                    \\n                    for endIndx in range(startIndx+1, len(s)+1): # NOTE [2]\\n                        sub = s[startIndx: endIndx]\\n                        if sub in dictSet:\\n                            q.append(endIndx) # endIndx is the new startIndx\\n                            \\n        return False   \\n    \\n    \\n        # NOTE [1]\\n        # --------\\n        # How do I know when to return true?\\n        # When the start index = len(s) (aka successfully reached the end of s)\\n        # A path won\\'t be able to reach the end of s if any of the genreated substrings \\n        # is not a dictionary word.\\n        # In other words, if a branch resuts in a non-dict word, it gets pruned/terminated\\n        # One successful path is enough to return True (aka to declare s can be broken into dict-apporved words)\\n        # Which is why we use BFS, so that we can find the shortest successful path faster (if more than one successful path exist)\\n        \\n        # NOTE [2]\\n        # --------\\n        # Generate all possible substrings by generating all possible end-indicies\\n        # However we only expand/traverse those substrings that are dict-approved\\n```\\n\\n\\n---------------------------------------------------------------------  \\n[2] Top-down : Faster Iterative BFS - generate only possible substrings using the length of words in dict\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n```\\ndef wordBreak(s, wordDict):\\n        # find lenghths\\n        lengthList = set()\\n        for w in wordDict:\\n            lengthList.add(len(w))\\n        \\n        dictSet = set(wordDict)\\n        visited = set()\\n        \\n        from collections import deque\\n        q = deque()\\n        q.append(0) # start index\\n        while q:\\n            start = q.popleft()\\n            \\n            if start == len(s): # NOTE [1]\\n                return True\\n            \\n            if start not in visited:\\n                visited.add(start)\\n                \\n                for l in lengthList: # -- NOTE [3]\\n                    sub = s[start: start+l]\\n                    if sub in dictSet:\\n                        q.append(start+l)\\n        return False\\n    \\n        # NOTE [3]\\n        # --------\\n        # Instead of generate all possible substrings by generating all possible end-indicies\\n        # We only generate end-indicies that match the are equal to (startIndx + l) where l is the lenght of each dictonary-approved word\\n```\\n\\n\\n\\n---------------------------------------------------------------------\\n[3] Top-down : Recursive with memoization\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n```\\ndef wordBreak(s, wordDict):\\n        # helper\\n        def recurse(start):\\n            \\n            if start == len(s):\\n                return True\\n            \\n            if start in memo:\\n                return memo[start]\\n            \\n            # find end indx\\n            for l in endIndexes:\\n                node = s[start: start+l]\\n\\n                if node in dictSet and recurse(start+l):\\n                    memo[start+l] = True\\n                    return True\\n                \\n            memo[start] = False\\n            return False\\n            \\n        \\n        # main\\n        memo = {}\\n        start = 0\\n        \\n        endIndexes = []\\n        for w in wordDict:\\n            endIndexes.append(len(w))\\n        \\n        dictSet = set(wordDict)\\n        \\n        state = recurse(start)\\n        return state\\n```\\n\\n---------------------------------------------------------------------\\n[4] Bottom - up with tabulation: Dynamic programming\\ncredit to @zhuyinghua1203\\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n```\\ndef wordBreak(s, wordDict):\\n        dictSet = set(wordDict)\\n        starts = [0] # dp[0] is the equivalent of a base-case from the recursive solution and dp[-1] is the overall solution to the complete problem\\n        for i in range(len(s)):\\n            for j in starts:\\n                if s[j:i+1] in dictSet:\\n                    starts.append(i+1) # start of next word\\n                    break # - note [1]\\n        \\n        return starts[-1] == len(s)\\n    \\n\\t# Note [1]\\n\\t# -------\\n\\t# we break because we only care about whether we can build the string s with the \\n\\t# ex: s = catdog, wordDict = [cat, at]\\n\\t# if i -> t\\n\\t#    j -> c\\n\\t# we capture that first and we break even though \"at\" is also a valid dict word\\n\\t# breaking will not affect the answer since our index i is fixed\\n\\t# because we just wanna see if we can get to the end of the string\\n```\\n\\n---------------------------------------------------------------------\\n[5] Trie \\n---------------------------------------------------------------------\\n---------------------------------------------------------------------\\n\\n- For a trie-based solution => [[Python] Simple Trie solution with detailed explanation and sketches](https://leetcode.com/problems/word-break/discuss/490911/Python-Simple-Trie-solution-with-detailed-explanation-and-sketches://)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\ndef wordBreak(s, wordDict):\\n        from collections import deque\\n        q = deque()\\n        q.append(0) # startIndx\\n        visited = set()\\n        dictSet = set(wordDict)\\n        while q:\\n            for i in range(len(q)):\\n                startIndx = q.popleft()\\n                if startIndx == len(s): # - NOTE [1]\\n                    return True\\n                \\n                if startIndx not in visited:\\n                    visited.add(startIndx)\\n                    \\n                    for endIndx in range(startIndx+1, len(s)+1): # NOTE [2]\\n                        sub = s[startIndx: endIndx]\\n                        if sub in dictSet:\\n                            q.append(endIndx) # endIndx is the new startIndx\\n                            \\n        return False   \\n    \\n    \\n        # NOTE [1]\\n        # --------\\n        # How do I know when to return true?\\n        # When the start index = len(s) (aka successfully reached the end of s)\\n        # A path won\\'t be able to reach the end of s if any of the genreated substrings \\n        # is not a dictionary word.\\n        # In other words, if a branch resuts in a non-dict word, it gets pruned/terminated\\n        # One successful path is enough to return True (aka to declare s can be broken into dict-apporved words)\\n        # Which is why we use BFS, so that we can find the shortest successful path faster (if more than one successful path exist)\\n        \\n        # NOTE [2]\\n        # --------\\n        # Generate all possible substrings by generating all possible end-indicies\\n        # However we only expand/traverse those substrings that are dict-approved\\n```\n```\\ndef wordBreak(s, wordDict):\\n        # find lenghths\\n        lengthList = set()\\n        for w in wordDict:\\n            lengthList.add(len(w))\\n        \\n        dictSet = set(wordDict)\\n        visited = set()\\n        \\n        from collections import deque\\n        q = deque()\\n        q.append(0) # start index\\n        while q:\\n            start = q.popleft()\\n            \\n            if start == len(s): # NOTE [1]\\n                return True\\n            \\n            if start not in visited:\\n                visited.add(start)\\n                \\n                for l in lengthList: # -- NOTE [3]\\n                    sub = s[start: start+l]\\n                    if sub in dictSet:\\n                        q.append(start+l)\\n        return False\\n    \\n        # NOTE [3]\\n        # --------\\n        # Instead of generate all possible substrings by generating all possible end-indicies\\n        # We only generate end-indicies that match the are equal to (startIndx + l) where l is the lenght of each dictonary-approved word\\n```\n```\\ndef wordBreak(s, wordDict):\\n        # helper\\n        def recurse(start):\\n            \\n            if start == len(s):\\n                return True\\n            \\n            if start in memo:\\n                return memo[start]\\n            \\n            # find end indx\\n            for l in endIndexes:\\n                node = s[start: start+l]\\n\\n                if node in dictSet and recurse(start+l):\\n                    memo[start+l] = True\\n                    return True\\n                \\n            memo[start] = False\\n            return False\\n            \\n        \\n        # main\\n        memo = {}\\n        start = 0\\n        \\n        endIndexes = []\\n        for w in wordDict:\\n            endIndexes.append(len(w))\\n        \\n        dictSet = set(wordDict)\\n        \\n        state = recurse(start)\\n        return state\\n```\n```\\ndef wordBreak(s, wordDict):\\n        dictSet = set(wordDict)\\n        starts = [0] # dp[0] is the equivalent of a base-case from the recursive solution and dp[-1] is the overall solution to the complete problem\\n        for i in range(len(s)):\\n            for j in starts:\\n                if s[j:i+1] in dictSet:\\n                    starts.append(i+1) # start of next word\\n                    break # - note [1]\\n        \\n        return starts[-1] == len(s)\\n    \\n\\t# Note [1]\\n\\t# -------\\n\\t# we break because we only care about whether we can build the string s with the \\n\\t# ex: s = catdog, wordDict = [cat, at]\\n\\t# if i -> t\\n\\t#    j -> c\\n\\t# we capture that first and we break even though \"at\" is also a valid dict word\\n\\t# breaking will not affect the answer since our index i is fixed\\n\\t# because we just wanna see if we can get to the end of the string\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 164472,
                "title": "python-solution",
                "content": "Dynamic Programming bottom up:\\n\\nWe first convert `wordDict` to a hashset `wordSet` to facilitate `O(1)` look-up. Next, we initialize an array of length `len(s)+1`, where `dp[i]` denotes if `s[:i]` can be segmented into words in `wordSet`. We let `dp[0] = 1`, because the empty string can be segmented into words in `wordSet` (trivially). We iterate `i` over `range(1, len(s)+1)`, and try to find the value for `dp[i]`. Now `dp[i] = 1` if there is some `0 <= j < i`, such that `dp[j] == 1` and `s[j:i]` is in `wordSet`. Therefore, we iterate `j` in `range(i)`, and check if such a `j` exists. If it does, we let `dp[i] = 1`, Otherwise, we let `dp[i] = 0`. Finally, we return `dp[-1] == 1`.\\n\\nTime complexity: `O(n**3)`, where `n = len(s)`, because there are two nested for loops, and the slicing `s[j:i]` costs an extra `O(n)`. Space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        wordSet = set(wordDict)\\n        dp = [0]*(len(s)+1)\\n        dp[0] = 1\\n        for i in range(1, len(s)+1):\\n            for j in range(i):\\n                if dp[j] == 1 and s[j:i] in wordSet:\\n                    dp[i] = 1\\n                    break\\n            else:\\n                dp[i] = 0\\n        return dp[-1] == 1\\n```\\n\\nThe above algorithm can also be implemented in a top-down fashion, as below. The time complexity and space complexity is the same as above.\\n\\nDynamic Programming top down (memoization):\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return True\\n            if rec[i] != -1:\\n                return True if rec[i] == 1 else False\\n            for j in range(i, len(s)):\\n                if s[i:j+1] in wordSet:\\n                    rec[j+1] = 1 if dfs(j+1) else 0\\n                    if rec[j+1] == 1:\\n                        return True\\n            return False\\n        \\n        rec = [-1]*(len(s)+1)\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        wordSet = set(wordDict)\\n        dp = [0]*(len(s)+1)\\n        dp[0] = 1\\n        for i in range(1, len(s)+1):\\n            for j in range(i):\\n                if dp[j] == 1 and s[j:i] in wordSet:\\n                    dp[i] = 1\\n                    break\\n            else:\\n                dp[i] = 0\\n        return dp[-1] == 1\\n```\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return True\\n            if rec[i] != -1:\\n                return True if rec[i] == 1 else False\\n            for j in range(i, len(s)):\\n                if s[i:j+1] in wordSet:\\n                    rec[j+1] = 1 if dfs(j+1) else 0\\n                    if rec[j+1] == 1:\\n                        return True\\n            return False\\n        \\n        rec = [-1]*(len(s)+1)\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43970,
                "title": "concise-dfs-backtracking-solution",
                "content": "Straightforward DFS solution, the only trick is to memorize already checked strings.\\n\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        return dfs(s, wordDict, new HashSet<>());\\n    }\\n    \\n    private boolean dfs(String s, Set<String> wordDict, Set<String> checked) {\\n        if (s.isEmpty()) return true;\\n        if (checked.contains(s)) return false;\\n        checked.add(s);\\n        \\n        for (String w : wordDict) {\\n            if (s.startsWith(w) && dfs(s.substring(w.length()), wordDict, checked)) return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "Straightforward DFS solution, the only trick is to memorize already checked strings.\\n\\n    public boolean wordBreak(String s, Set<String> wordDict) {\\n        return dfs(s, wordDict, new HashSet<>());\\n    }\\n    \\n    private boolean dfs(String s, Set<String> wordDict, Set<String> checked) {\\n        if (s.isEmpty()) return true;\\n        if (checked.contains(s)) return false;\\n        checked.add(s);\\n        \\n        for (String w : wordDict) {\\n            if (s.startsWith(w) && dfs(s.substring(w.length()), wordDict, checked)) return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 821032,
                "title": "java-dp-solution-in-detail-for-beginner",
                "content": "Again the solution I posted is not for opitimization, it\\'s for beginner. :)\\n\\nSo this is a good example of exercising DP in terms of String, let\\'s take a look.\\n\\nThe problem is asking if the given string can be formed of words in the dictionary. Then let\\'s define dp[i] represents at character position i, so far the string.substring[0,i] can/cannot be segmented from dictionary. If it can, d[i] = true, else dp[i] = false. With this definition kept in mind, let\\'s continue by initializing dp array first.\\n\\n```\\nboolean[] dp = new dp[s.length() + 1]\\ndp[0] = true;\\n// we want an extra space because when the string = \"\", empty, it\\'s true. I will explain later why.\\n```\\n\\nNow let\\'s try to find the induction rule.\\n```\\n   l  e  e  t  c  o  d  e\\nT  F  F  F  T  F  F  F  T   <- dp array\\n0  1  2  3  4  5  6  7  8   <- i\\n```\\n\\nSo starting from i = 1, we can see that dp[0] = true. Substring \"l\"  is not in the dictionary, so we set dp[1] = false\\nNext, i = 2, dp[0] = true, Substring \"le\"  is not in the dictionary, so we set dp[2] = false\\nNext, i = 3, dp[0] = true, Substring \"lee\"  is not in the dictionary, so we set dp[3] = false\\nNext, i = 4, dp[0] = true, Substring \"leet\"  is IN the dictionary, so we set dp[4] = true\\n\\nLet\\'s continue.\\nSince we already knew that the substring at the left side of i=4(inclusive) can be found in the dictionary, we can just look at the right side of i=4, the remaining substring.\\nSo when i = 5, dp[4] = true, Substring \"c\" is not in the dictionary, so we set dp[5] = false\\nwhen i = 6, dp[4] = true, Substring \"co\" is not in the dictionary, so we set dp[6] = false\\nwhen i = 7, dp[4] = true, Substring \"cod\" is not in the dictionary, so we set dp[7] = false\\nwhen i = 8, dp[4] = true, Substring \"code\" is now IN the dictionary, so we set dp[8] = true\\n\\nSo based on the these answers, what\\'s the induction rule?\\nIf between [0, i], there is a 0 <= j <= i where dp[j] = true, we just need to check if substring[j+1, i] is in the dictionary. If the substring [j+1,i] is in the dictionary, then dp[i] = true. Now if we look back at dp[0] = true, it means when there is an empty string, it\\'s set for true. This step is important for filling dp array.\\n\\nHere is the code:\\n```\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor(String e : wordDict) {set.add(e);}\\n\\tboolean[] dp = new boolean[s.length() + 1];\\n\\tdp[0] = true;\\n\\t// i is actually a right bound, 0 is the left bound, j is the middle pointer\\n\\t// j is to find where dp[j] = true, so that we can check substring[j+1,i]\\n\\tfor(int i = 1; i < dp.length; i++){\\n\\t\\tfor(int j = 0; j <= i; j++){\\n\\t\\t    // if dp[j] is found true in the dictionary\\n\\t\\t\\tif(dp[j] == true) {\\n\\t\\t\\t    // we just need to take a look at the right side substring [j+1, i]\\n\\t\\t\\t\\tif(set.contains(s.substring(j,i))) {\\n\\t\\t\\t\\t\\tdp[i] = true;\\n\\t\\t\\t\\t\\tbreak;         // we break because there is no need to continue looping\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[dp.length - 1];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nboolean[] dp = new dp[s.length() + 1]\\ndp[0] = true;\\n// we want an extra space because when the string = \"\", empty, it\\'s true. I will explain later why.\\n```\n```\\n   l  e  e  t  c  o  d  e\\nT  F  F  F  T  F  F  F  T   <- dp array\\n0  1  2  3  4  5  6  7  8   <- i\\n```\n```\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n\\tSet<String> set = new HashSet<>();\\n\\tfor(String e : wordDict) {set.add(e);}\\n\\tboolean[] dp = new boolean[s.length() + 1];\\n\\tdp[0] = true;\\n\\t// i is actually a right bound, 0 is the left bound, j is the middle pointer\\n\\t// j is to find where dp[j] = true, so that we can check substring[j+1,i]\\n\\tfor(int i = 1; i < dp.length; i++){\\n\\t\\tfor(int j = 0; j <= i; j++){\\n\\t\\t    // if dp[j] is found true in the dictionary\\n\\t\\t\\tif(dp[j] == true) {\\n\\t\\t\\t    // we just need to take a look at the right side substring [j+1, i]\\n\\t\\t\\t\\tif(set.contains(s.substring(j,i))) {\\n\\t\\t\\t\\t\\tdp[i] = true;\\n\\t\\t\\t\\t\\tbreak;         // we break because there is no need to continue looping\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[dp.length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44035,
                "title": "python-concise-dp-solution",
                "content": "        \\n    def wordBreak(self, s, wordDict):\\n        dp = [False] * (len(s)+1)\\n        dp[0] = True\\n        for i in xrange(1, len(s)+1):\\n            for j in xrange(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    def wordBreak(self, s, wordDict):\\n        dp = [False] * (len(s)+1)\\n        dp[0] = True\\n        for i in xrange(1, len(s)+1):\\n            for j in xrange(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 877547,
                "title": "c-o-n-2-using-dp-trie",
                "content": "Since `substr` is actually an O(N) operation, we could use Trie to further decrease the time complexity to O(max(S, N^2)). Here N is the length of the string, and S is the sum of length of all words in the dictionary.\\n\\n```\\nclass TrieNode {\\npublic:\\n    bool isWord;\\n    vector<TrieNode*> next;\\n    TrieNode(): isWord(false), next(vector<TrieNode*>(26, nullptr)) {}\\n};\\nclass Solution {\\npublic:\\n    TrieNode* buildTrie(vector<string> &wordDict) {\\n        TrieNode *root = new TrieNode();\\n        for (auto &word : wordDict) {\\n            TrieNode *p = root;\\n            for (auto &ch : word) {\\n                if (p->next[ch-\\'a\\'] == nullptr)\\n                    p->next[ch-\\'a\\'] = new TrieNode();\\n                p = p->next[ch-\\'a\\'];\\n            }\\n            p->isWord = true;\\n        }\\n        return root;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int len = s.length();\\n        TrieNode *root = buildTrie(wordDict);\\n\\n        vector<bool> dp(len + 1, false);\\n        dp[0] = true;\\n        for (int i = 0; i <= len; i++) {\\n            if (dp[i]) {\\n                TrieNode *p = root;\\n                for (int j = i; j < len; j++) {\\n                    if (p->next[s[j]-\\'a\\'] == nullptr)\\n                        break;\\n                    p = p->next[s[j] - \\'a\\'];\\n                    if (p->isWord)\\n                        dp[j+1] = true;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n    bool isWord;\\n    vector<TrieNode*> next;\\n    TrieNode(): isWord(false), next(vector<TrieNode*>(26, nullptr)) {}\\n};\\nclass Solution {\\npublic:\\n    TrieNode* buildTrie(vector<string> &wordDict) {\\n        TrieNode *root = new TrieNode();\\n        for (auto &word : wordDict) {\\n            TrieNode *p = root;\\n            for (auto &ch : word) {\\n                if (p->next[ch-\\'a\\'] == nullptr)\\n                    p->next[ch-\\'a\\'] = new TrieNode();\\n                p = p->next[ch-\\'a\\'];\\n            }\\n            p->isWord = true;\\n        }\\n        return root;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int len = s.length();\\n        TrieNode *root = buildTrie(wordDict);\\n\\n        vector<bool> dp(len + 1, false);\\n        dp[0] = true;\\n        for (int i = 0; i <= len; i++) {\\n            if (dp[i]) {\\n                TrieNode *p = root;\\n                for (int j = i; j < len; j++) {\\n                    if (p->next[s[j]-\\'a\\'] == nullptr)\\n                        break;\\n                    p = p->next[s[j] - \\'a\\'];\\n                    if (p->isWord)\\n                        dp[j+1] = true;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870388,
                "title": "python-simple-solution-explained-video-code-fastest",
                "content": "[](https://www.youtube.com/watch?v=tSbBuiO1rXI)\\nhttps://www.youtube.com/watch?v=tSbBuiO1rXI\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        dp = [True] + [False] * len(s)\\n        \\n        for indx in range(1, len(s) + 1):\\n            \\n            for word in wordDict:\\n                if dp[indx - len(word)] and s[:indx].endswith(word):\\n                    dp[indx] = True\\n            \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        dp = [True] + [False] * len(s)\\n        \\n        for indx in range(1, len(s) + 1):\\n            \\n            for word in wordDict:\\n                if dp[indx - len(word)] and s[:indx].endswith(word):\\n                    dp[indx] = True\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537226,
                "title": "javascript-dp",
                "content": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    let table = new Array(s.length + 1).fill(false);\\n    \\n    table[0] = true;\\n    \\n    for(let i = 0; i <= s.length; i++){\\n        if(table[i] === true){\\n\\t\\t\\tfor(let word of wordDict){\\n\\t\\t\\t\\tif(s.slice(i, i + word.length) === word){\\n\\t\\t\\t\\t\\ttable[i + word.length] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    return table[s.length];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    let table = new Array(s.length + 1).fill(false);\\n    \\n    table[0] = true;\\n    \\n    for(let i = 0; i <= s.length; i++){\\n        if(table[i] === true){\\n\\t\\t\\tfor(let word of wordDict){\\n\\t\\t\\t\\tif(s.slice(i, i + word.length) === word){\\n\\t\\t\\t\\t\\ttable[i + word.length] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    return table[s.length];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1475984,
                "title": "c-2-solutions-trie-dp-and-map-dp",
                "content": "**Solution 1: Trie+DP(memoization)**\\n**Time Complexity: O(n*l + N^2)** \\nwhere, \\n*n=length of word dict*,\\n*l=length of longest word in the dict.*\\n*N=length of string (s)*\\n\\t\\t\\t\\n**Prerequisite:**   You should know basic concept of **Trie**.\\nif you dont know, then first try **Leetcode: 208** *[https://leetcode.com/problems/implement-trie-prefix-tree/](http://)*\\n```\\nclass Solution {\\npublic:\\n    class Trie{\\n      public:\\n        Trie *child[26];\\n        bool isEnd = false;\\n    };\\n    \\n    void insert(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(!cur->child[ch-\\'a\\']) cur->child[ch-\\'a\\'] = new Trie();\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(!cur->child[ch-\\'a\\']) return false;\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    int dp[305][305];\\n    bool solve(string &s, Trie *root, int n, int start){\\n        if(start==n) return true;\\n        if(dp[start][n]!=-1) return dp[start][n];\\n        for(int i=start; i<n; ++i){\\n            string str = s.substr(start,i-start+1);\\n            if(search(str,root)){\\n                if(solve(s,root,n,i+1)) return dp[start][n] = true;\\n            }\\n        }\\n        return dp[start][n] = false;\\n    }\\n    \\n    bool wordBreak(string &s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict) insert(word,root);\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,root,n,0);\\n    }\\n};\\n```\\n\\n**Solution 2: Map+DP(memoization)**\\n**Time Complexity: O(Nlog(N) + N^2)**\\nwhere,\\n*N=length of string (s)*\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> map;\\n    int dp[305][305];\\n    bool solve(string &s, int n, int start){\\n        if(start==n) return true;\\n        if(dp[start][n]!=-1) return dp[start][n];\\n        for(int i=start; i<n; ++i){\\n            string str = s.substr(start,i-start+1);\\n            if(map.find(str)!=map.end()){\\n                if(solve(s,n,i+1)) return dp[start][n] = true;\\n            }\\n        }\\n        return dp[start][n] = false;\\n    }\\n    bool wordBreak(string &s, vector<string>& wordDict) {\\n        memset(dp,-1,sizeof(dp));\\n        for(auto &word : wordDict) map[word]++;\\n        int n=s.size();\\n        return solve(s,n,0);\\n    }\\n};\\n```\\n**I will highly recommend to try *Trie+DP solution,*** **It is faster then map+DP method and it will clear lot of concept of trie.  Hope this will help :)**\\n\\nPlease **Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Trie",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class Trie{\\n      public:\\n        Trie *child[26];\\n        bool isEnd = false;\\n    };\\n    \\n    void insert(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(!cur->child[ch-\\'a\\']) cur->child[ch-\\'a\\'] = new Trie();\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string &word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(!cur->child[ch-\\'a\\']) return false;\\n            cur=cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    int dp[305][305];\\n    bool solve(string &s, Trie *root, int n, int start){\\n        if(start==n) return true;\\n        if(dp[start][n]!=-1) return dp[start][n];\\n        for(int i=start; i<n; ++i){\\n            string str = s.substr(start,i-start+1);\\n            if(search(str,root)){\\n                if(solve(s,root,n,i+1)) return dp[start][n] = true;\\n            }\\n        }\\n        return dp[start][n] = false;\\n    }\\n    \\n    bool wordBreak(string &s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict) insert(word,root);\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(s,root,n,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int> map;\\n    int dp[305][305];\\n    bool solve(string &s, int n, int start){\\n        if(start==n) return true;\\n        if(dp[start][n]!=-1) return dp[start][n];\\n        for(int i=start; i<n; ++i){\\n            string str = s.substr(start,i-start+1);\\n            if(map.find(str)!=map.end()){\\n                if(solve(s,n,i+1)) return dp[start][n] = true;\\n            }\\n        }\\n        return dp[start][n] = false;\\n    }\\n    bool wordBreak(string &s, vector<string>& wordDict) {\\n        memset(dp,-1,sizeof(dp));\\n        for(auto &word : wordDict) map[word]++;\\n        int n=s.size();\\n        return solve(s,n,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860687,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing dynamic programming to keep a certain substring is true or not.\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n\\nhttps://youtu.be/LgoAfakGz5E\\n\\n# Subscribe to my channel from here. I have 239 videos as of August 4th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Initialize a list `dp` of size `len(s) + 1`, where `dp[i]` will indicate whether the substring up to index `i` (inclusive) can be segmented into words from `wordDict`. Initialize `dp[0]` as `True`, since an empty string can always be segmented.\\n\\n2. Iterate over each index `i` from 1 to `len(s) + 1` (outer loop):\\n   - For each index `i`, iterate over each word `w` in `wordDict` (inner loop):\\n     - Check if the current word `w` can be appended to the substring ending at index `i - len(w)`.\\n     - This is done by verifying three conditions:\\n       1. `i - len(w) >= 0`: This ensures that the current word can be fit within the current index `i`.\\n       2. `dp[i - len(w)]`: This checks if the substring before the current word can be segmented into words from `wordDict`.\\n       3. `s[:i].endswith(w)`: This checks if the current substring ending at index `i` ends with the word `w`.\\n\\n3. If all three conditions are satisfied, it means that the substring up to index `i` can be segmented using words from `wordDict`. In this case, set `dp[i]` to `True`.\\n\\n4. After iterating through all words in `wordDict` and updating `dp[i]` for the current index `i`, move on to the next index in the outer loop.\\n\\n5. Continue this process until you\\'ve iterated over all possible indices `i` from 1 to `len(s)`.\\n\\n6. Finally, return `dp[-1]`, which indicates whether the entire string `s` can be segmented using words from `wordDict`.\\n\\nIn essence, the algorithm uses dynamic programming to build up the `dp` array, where each entry represents whether a certain substring can be segmented using the words from the dictionary. The algorithm leverages the fact that if a substring up to index `i` can be segmented, and a word from `wordDict` can be appended to it to reach index `i`, then the substring up to index `i + len(word)` can also be segmented.\\n\\n# Complexity\\n- Time complexity: O(n * m * k)\\nn is length of input string and m is length of wordDict. nested loop is n * m and in the nested loop. We check substring operations which costs O(k).\\n\\n- Space complexity: O(n)\\nFor dp list. n is the length of the string s\\n\\n```python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\n        dp = [True] + [False] * len(s)\\n\\n        for i in range(1, len(s) + 1):\\n            for w in wordDict:\\n                if i - len(w) >= 0 and dp[i - len(w)] and s[:i].endswith(w):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    const n = s.length;\\n    const dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (const word of wordDict) {\\n            if (i - word.length >= 0 && dp[i - word.length] && s.substring(i - word.length, i) === word) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (String word : wordDict) {\\n                if (i - word.length() >= 0 && dp[i - word.length()] && s.substring(i - word.length(), i).equals(word)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        \\n        for (int i = 1; i <= s.size(); i++)\\n            for (int j = 0; j < i; j++)\\n                if ((dp[j]) && (find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) != wordDict.end())) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n\\n        return dp.back();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\n        dp = [True] + [False] * len(s)\\n\\n        for i in range(1, len(s) + 1):\\n            for w in wordDict:\\n                if i - len(w) >= 0 and dp[i - len(w)] and s[:i].endswith(w):\\n                    dp[i] = True\\n                    break\\n        return dp[-1]\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    const n = s.length;\\n    const dp = new Array(n + 1).fill(false);\\n    dp[0] = true;\\n\\n    for (let i = 1; i <= n; i++) {\\n        for (const word of wordDict) {\\n            if (i - word.length >= 0 && dp[i - word.length] && s.substring(i - word.length, i) === word) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n\\n    return dp[n];    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (String word : wordDict) {\\n                if (i - word.length() >= 0 && dp[i - word.length()] && s.substring(i - word.length(), i).equals(word)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool> dp(s.size()+1, false);\\n        dp[0] = true;\\n        \\n        for (int i = 1; i <= s.size(); i++)\\n            for (int j = 0; j < i; j++)\\n                if ((dp[j]) && (find(wordDict.begin(), wordDict.end(), s.substr(j, i-j)) != wordDict.end())) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860872,
                "title": "c-java-pyhton3-space-and-time-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo determine if the string s can be segmented into a space-separated sequence of dictionary words, we can use dynamic programming. The idea is to break down the problem into smaller subproblems and build a solution from the subproblems\\' results. We\\'ll keep track of whether a substring can be segmented into dictionary words or not, and use this information to solve the overall problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First, we create a set from the given wordDict to efficiently check if a word is present in the dictionary.\\n- We\\'ll use a dynamic programming approach to fill up a boolean array dp, where dp[i] will be true if the substring s[0:i] (i.e., the first i characters of s) can be segmented into dictionary words. Initially, all elements in dp are set to false.\\n- We\\'ll iterate through each index i in the string s, and for each index, we\\'ll check all possible prefixes s[0:j] (where 0 <= j < i) and see if the prefix is in the dictionary and if the remaining substring s[j:i] is also in the dictionary or if it\\'s an empty string.\\n- If both the prefix and the remaining substring are in the dictionary (or if the remaining substring is empty), then we can set dp[i] to true, indicating that the substring s[0:i] can be segmented.\\n- Finally, we return the value of dp[s.length()], which indicates whether the entire string s can be segmented or not.\\n\\n# Complexity\\n- Time complexity: **O(n^2)**, where n is the length of the input string s\\n\\n- Space complexity: **O(n)**, where n is the length of the input string s\\n\\n# Code\\n## C++\\n```\\nclass Solution {\\npublic:\\n    bool solve(string &s, map<string,bool>& mp, int ind, string temp,map<pair<int,string>,bool>&dp){\\n        if(ind == s.length() && temp == \"\") return true;\\n        if(ind == s.length()) return false;\\n        if(dp.find({ind,temp})!=dp.end()) return dp[{ind,temp}];\\n        bool ans = false;\\n        temp+=s[ind];\\n        if(mp.find(temp)!=mp.end()){\\n            ans = solve(s,mp,ind+1,\"\",dp);\\n        }\\n        ans = ans || solve(s,mp,ind+1,temp,dp);\\n        \\n        return dp[{ind,temp}] = ans;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,bool>mp;\\n        map<pair<int,string>,bool> dp;\\n        for(auto word: wordDict) mp[word] = true;\\n        return solve(s,mp,0,\"\",dp);\\n    }\\n};\\n```\\n## Java\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (dp[j] && dict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n```\\n## Python3\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n\\n        for i in range(1, n + 1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\\n![upvote img.jpg](https://assets.leetcode.com/users/images/e3445fcf-d1b4-43a5-8575-4dffbd7f48fe_1691121465.7283533.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string &s, map<string,bool>& mp, int ind, string temp,map<pair<int,string>,bool>&dp){\\n        if(ind == s.length() && temp == \"\") return true;\\n        if(ind == s.length()) return false;\\n        if(dp.find({ind,temp})!=dp.end()) return dp[{ind,temp}];\\n        bool ans = false;\\n        temp+=s[ind];\\n        if(mp.find(temp)!=mp.end()){\\n            ans = solve(s,mp,ind+1,\"\",dp);\\n        }\\n        ans = ans || solve(s,mp,ind+1,temp,dp);\\n        \\n        return dp[{ind,temp}] = ans;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,bool>mp;\\n        map<pair<int,string>,bool> dp;\\n        for(auto word: wordDict) mp[word] = true;\\n        return solve(s,mp,0,\"\",dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (dp[j] && dict.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n\\n        for i in range(1, n + 1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106264,
                "title": "simple-c-dp-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is that the given problem  can be divided into sub-problems .And  If these subproblems individually satisfy the required conditions, then  complete problem will also satisfy the same. And hence we can say whether it is true to find the word in the dictionary or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Naive Approach**: Use recursion and backtracking. For finding the solution, we check every prefix of the string in the word_dict of words, if it is found , then the recursive function is called for the remaining portion of that string. But this will be$$ 2^n$$ so will give tle . SO we can optimize using memoization or dp.\\n- **DP**: So as we can see that in recurion we call for evrery prefix substring and check if its presnt and like this the whole is presnt or not .So similarly we can store the same ,like upto certain index whether the substring upto that index is present or not. In this way our dp array will be filled with 0\\'s and 1\\'s representing whether the substring is present or not . And at last if last index is true i.e dp[n] is true this means whole string is presnt .\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938500,
                "title": "100-fastest-swift-solution-time-o-n-2-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n ^ 2), where n is the length of s.\\n    //   - space: O(n), where n is the length of s.\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\\n        var dp = [Bool](repeating: false, count: s.count+1)\\n        dp[0] = true\\n\\n        let chars = Array(s)\\n        let wordSet = Set(wordDict)\\n\\n        for i in 1...s.count {\\n            for j in 0..<i {\\n                guard dp[j], wordSet.contains(String(chars[j..<i])) else { continue }\\n                dp[i] = true\\n                break\\n            }\\n        }\\n\\n        return dp[s.count]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n ^ 2), where n is the length of s.\\n    //   - space: O(n), where n is the length of s.\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> Bool {\\n        var dp = [Bool](repeating: false, count: s.count+1)\\n        dp[0] = true\\n\\n        let chars = Array(s)\\n        let wordSet = Set(wordDict)\\n\\n        for i in 1...s.count {\\n            for j in 0..<i {\\n                guard dp[j], wordSet.contains(String(chars[j..<i])) else { continue }\\n                dp[i] = true\\n                break\\n            }\\n        }\\n\\n        return dp[s.count]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354276,
                "title": "python3-breadth-first-search",
                "content": "\\n```\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \"\"\"\\n\\t\\ts = \"catsandog\"\\n\\t\\twordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\\n        0 1 2 3 4 5 6 7 8 9\\n        c a t s a n d d o g\\n\\t\\tqueue = [0]\\n\\t\\tyou find \\'cat\\' and \\'cats\\'\\n\\t\\tqueue = [3,4]\\n\\t\\tyou find \\'and\\u2018  and \\'sand\\'\\n\\t\\tqueue = [7]\\n\\t\\tyou find \\'dog\\', which you reached the end.\\n         0\\n        / \\\\\\n      cat  cats\\n      /      \\\\\\n    sand     and\\n    /         \\\\\\n    dog       dog\\n        \"\"\"\\n        visited = set()\\n        queue = deque([0])\\n        while queue:\\n            start = queue.popleft()\\n            if start not in visited:\\n                for end in range(start + 1, len(s)+1):\\n                    if s[start:end] in wordDict:\\n                        queue.append(end)\\n                        if end == len(s):\\n                            return True\\n                visited.add(start)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \"\"\"\\n\\t\\ts = \"catsandog\"\\n\\t\\twordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\\n        0 1 2 3 4 5 6 7 8 9\\n        c a t s a n d d o g\\n\\t\\tqueue = [0]\\n\\t\\tyou find \\'cat\\' and \\'cats\\'\\n\\t\\tqueue = [3,4]\\n\\t\\tyou find \\'and\\u2018  and \\'sand\\'\\n\\t\\tqueue = [7]\\n\\t\\tyou find \\'dog\\', which you reached the end.\\n         0\\n        / \\\\\\n      cat  cats\\n      /      \\\\\\n    sand     and\\n    /         \\\\\\n    dog       dog\\n        \"\"\"\\n        visited = set()\\n        queue = deque([0])\\n        while queue:\\n            start = queue.popleft()\\n            if start not in visited:\\n                for end in range(start + 1, len(s)+1):\\n                    if s[start:end] in wordDict:\\n                        queue.append(end)\\n                        if end == len(s):\\n                            return True\\n                visited.add(start)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44003,
                "title": "very-clean-python-code-with-trie",
                "content": "    class TrieNode(object):\\n        def __init__(self, char=None, isWord=False):\\n            self.char = char\\n            self.isWord = isWord\\n            self.children = {}\\n    \\n    \\n    class Trie(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n            self.cache = {}\\n    \\n        def insert(self, word):\\n            root = self.root\\n            for char in word:\\n                if char not in root.children:\\n                    root.children[char] = TrieNode(char)\\n                root = root.children[char]\\n            root.isWord = True\\n    \\n        def cache(f):\\n            def method(obj, s):\\n                if s not in obj.cache:\\n                    obj.cache[s] = f(obj, s)\\n                return obj.cache[s]\\n            return method\\n    \\n        @cache\\n        def search(self, s):\\n            root = self.root\\n            for i, char in enumerate(s):\\n                if char not in root.children:\\n                    return False\\n    \\n                if root.children[char].isWord:\\n                    if self.search(s[i + 1:]):\\n                        return True\\n                root = root.children[char]\\n            return root.isWord\\n    \\n    \\n    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            trie = Trie()\\n            [trie.insert(word) for word in wordDict]\\n    \\n            return trie.search(s)",
                "solutionTags": [],
                "code": "    class TrieNode(object):\\n        def __init__(self, char=None, isWord=False):\\n            self.char = char\\n            self.isWord = isWord\\n            self.children = {}\\n    \\n    \\n    class Trie(object):\\n        def __init__(self):\\n            self.root = TrieNode()\\n            self.cache = {}\\n    \\n        def insert(self, word):\\n            root = self.root\\n            for char in word:\\n                if char not in root.children:\\n                    root.children[char] = TrieNode(char)\\n                root = root.children[char]\\n            root.isWord = True\\n    \\n        def cache(f):\\n            def method(obj, s):\\n                if s not in obj.cache:\\n                    obj.cache[s] = f(obj, s)\\n                return obj.cache[s]\\n            return method\\n    \\n        @cache\\n        def search(self, s):\\n            root = self.root\\n            for i, char in enumerate(s):\\n                if char not in root.children:\\n                    return False\\n    \\n                if root.children[char].isWord:\\n                    if self.search(s[i + 1:]):\\n                        return True\\n                root = root.children[char]\\n            return root.isWord\\n    \\n    \\n    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            trie = Trie()\\n            [trie.insert(word) for word in wordDict]\\n    \\n            return trie.search(s)",
                "codeTag": "Java"
            },
            {
                "id": 44086,
                "title": "easy-understand-python-dp-solution",
                "content": "    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a boolean\\n        def wordBreak(self, s, dict):\\n            n = len(s)\\n            f = [False for i in range(n+1)]\\n            f[0] = True\\n            for i in range(n):\\n                if f[i]:\\n                    for j in dict:\\n                        l = len(j)\\n                        if i+l<=n and s[i:i+l] == j:\\n                            f[i+l] = True\\n            return f[n]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a boolean\\n        def wordBreak(self, s, dict):\\n            n = len(s)\\n            f = [False for i in range(n+1)]\\n            f[0] = True\\n            for i in range(n):\\n                if f[i]:\\n                    for j in dict:\\n                        l = len(j)\\n                        if i+l<=n and s[i:i+l] == j:\\n                            f[i+l] = True\\n            return f[n]",
                "codeTag": "Java"
            },
            {
                "id": 3238057,
                "title": "java-3-solutions-with-clear-explanation-and-real-life-application-brute-force-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nDetermine whether a given string can be segmented into words from a given dictionary. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are a couple of approaches to solve this problem:\\n1. Brute force: generate all possible substrings and check whether if the current substring can be segmented into words in the dictionary wordDict. If all the substrings can be segmented into words, then reture true; otherwise, return false.\\n\\n2. Dynamic Programming: we build a boolean array dp of size `n+1` to keep track of whether the first k characters of the input string can be segmented into words from the dictionary.\\n\\n# Code\\n#### **1) Brute force solution (Recursive - Top Down) [TLE] \\u274C**\\n\\n1. The `helper` function iterates over all possible substrings of the input string starting from the first index.\\n\\n2. Check if the substring exists in the dictionary. If it does, then recursively check whether the remaining part of the string can be segmented into words. \\n\\n3. If `index == s.length()`, which means all the substrings can be segmented into words, then return true; otherwise return false.\\n\\n```\\nclass Solution {\\n   public boolean wordBreak(String s, List<String> wordDict) {  \\n        //step 1\\n        return helper(0, s, wordDict);\\n   }\\n\\n   public boolean helper(int index, String s, List<String> wordDict)\\n   {\\n       //step 3\\n       int n = s.length();\\n       if(index == n) return true;\\n\\n       for(int k = index + 1; k <= n; k++)\\n       {\\n           //step 2\\n           if(wordDict.contains(s.substring(index, k)) && helper(k, s, wordDict))\\n           return true;\\n       }\\n       return false;\\n   }\\n}\\n```\\n\\n- Time complexity: $$O(2^n)$$ where n is the length of the input string. We try all possible combinations of substrings in the input string.\\n\\n- Space complexity: $$O(n)$$ where n is the maximum depth of the recursion tree, which is equal to the length of the input array.\\n\\n#### **2) Dynamic programming solutions**\\n##### 1. Recursive - Memoization - Top Down \\u2705\\n\\nThis solution is built on top of the brute force solution, where we use memoization to avoid recomputing the same subproblems.\\n\\nWe also initializes a Boolean array dp with null values, which is used for memoization.\\n\\n```\\nclass Solution {\\n   public boolean wordBreak(String s, List<String> wordDict) {  \\n        Boolean [] dp = new Boolean[s.length()];\\n        return helper(0, s, wordDict, dp);\\n   }\\n\\n   public boolean helper(int index, String s, List<String> wordDict, Boolean [] dp)\\n   {\\n       //step 3\\n       int n = s.length();\\n       if(index == n) return true;\\n       if(dp[index] != null) return dp[index];\\n       for(int k = index + 1; k <= n; k++)\\n       {\\n           //step 2\\n           if(wordDict.contains(s.substring(index, k)) && helper(k, s, wordDict, dp))\\n           return dp[index] = true;\\n       }\\n       return dp[index] = false;\\n   }\\n}\\n```\\n\\n- Time complexity: $$O(n ^ 2)$$ where n is the length of the input string, due to the nested loops used in the helper function.\\n\\n- Space complexity: $$O(n)$$ where n is the length of the input string. This is because we use an array `dp` of size `s.length()` to store results of previous computed subproblems.\\n\\n##### 2. Iterative - Tabulation - Bottom Up \\u2705\\n\\n1. We create a boolean array `dp` of length `s.length()`, where `dp[k]` indicates if the substring from 0 to i can be segmented into words from the dictionary. \\n\\n2. Then we iterate over the input string and checks if anysubstring from `j to k` (where `j <= k`) can be segmented into words from the dictionary. If it does, `dp[k]` is set to true. \\n\\n3. Finally we returns dp[len-1] which indicates if the entire string can be segmented into words from the dictionary.\\n\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int len = s.length();\\n        boolean [] dp = new boolean[len];\\n        for(int k = 0; k < len; k++)\\n        {\\n            for(int j = 0; j <= k; j++)\\n            {\\n                if((j == 0 || dp[j-1] == true) && wordDict.contains(s.substring(j, k + 1)))\\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len-1];\\n    }\\n}\\n```\\n\\n- Time complexity: $$O(n^2)$$ where n is the length of the input string.\\n\\n- Space complexity: $$O(n)$$ due to the `dp` array.\\n\\n\\n\\n# Application\\n\\n###### The Word Break problem have several real-life applications, including the following: \\n\\n1. Spell-checking software: Identify and suggest corrections for misspelled words by breaking down the words into smaller units and comparing them against a dictionary.\\n\\n2. Natural Language Processing (NLP): segment text into meaningful units such as sentences, phrases, and words. This is essential for applications such as text classification, machine translation, and sentiment analysis.\\n\\n3. Search engines: identify relevant keywords and phrases from a user\\'s search query and match them against indexed web pages.\\n\\n4. Auto-complete: suggest completions for partially typed words, by matching them against a dictionary of valid words.\\n\\n5. Speech recognition: segment speech signals into discrete words, which can then be processed and analyzed.\\n\\n6. Optical character recognition (OCR): segment text from images into individual words, which can then be recognized and converted into editable text.\\n\\n*Thank you for reading! If you found this solution helpful, please give me an upvote. Feel free to add suggestions.*\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n   public boolean wordBreak(String s, List<String> wordDict) {  \\n        //step 1\\n        return helper(0, s, wordDict);\\n   }\\n\\n   public boolean helper(int index, String s, List<String> wordDict)\\n   {\\n       //step 3\\n       int n = s.length();\\n       if(index == n) return true;\\n\\n       for(int k = index + 1; k <= n; k++)\\n       {\\n           //step 2\\n           if(wordDict.contains(s.substring(index, k)) && helper(k, s, wordDict))\\n           return true;\\n       }\\n       return false;\\n   }\\n}\\n```\n```\\nclass Solution {\\n   public boolean wordBreak(String s, List<String> wordDict) {  \\n        Boolean [] dp = new Boolean[s.length()];\\n        return helper(0, s, wordDict, dp);\\n   }\\n\\n   public boolean helper(int index, String s, List<String> wordDict, Boolean [] dp)\\n   {\\n       //step 3\\n       int n = s.length();\\n       if(index == n) return true;\\n       if(dp[index] != null) return dp[index];\\n       for(int k = index + 1; k <= n; k++)\\n       {\\n           //step 2\\n           if(wordDict.contains(s.substring(index, k)) && helper(k, s, wordDict, dp))\\n           return dp[index] = true;\\n       }\\n       return dp[index] = false;\\n   }\\n}\\n```\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int len = s.length();\\n        boolean [] dp = new boolean[len];\\n        for(int k = 0; k < len; k++)\\n        {\\n            for(int j = 0; j <= k; j++)\\n            {\\n                if((j == 0 || dp[j-1] == true) && wordDict.contains(s.substring(j, k + 1)))\\n                {\\n                    dp[k] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496203,
                "title": "c-two-solutions-recursive-with-memoization-and-dp-with-comments",
                "content": "#### Recurvice + Memo:\\n\\n```c++\\n    bool helper(const string& s, int start, const unordered_set<string>& d, vector<int>& memo) {\\n        if (start == s.size()) {\\n            return true;\\n        }\\n        \\n        if (memo[start] != -1) return memo[start];\\n        \\n        for (int i = start + 1; i <= s.size(); ++i) {\\n            const string sub = s.substr(start, i - start); \\n            if (d.count(sub) == 1) {\\n                if (helper(s, i, d, memo)) {\\n                    memo[start] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        memo[start] = 0;\\n        return false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> d(wordDict.begin(), wordDict.end());\\n\\t\\t// Use a vector since we can index from 0 to N. \\n\\t\\t// Possible values in vector are: -1, 0, 1.\\n        vector<int> memo(s.length(), -1); \\n        return helper(s, 0, d, memo);\\n    }\\n```\\nFor the worst runtime, take this example: `s = \"abcd\"` and `wordDict = [\"a\", \"b\", \"c\", \"bc\", \"ab\", \"abc\"]`.\\nWIthout memoization the runtime complexity would be O(2^N) but with it we avoid solving the same sub-problems all the time:\\n\\n* Runtime complexity: O(N^2)\\n* Space complexity: O(N)\\n\\n#### DP:\\n\\n```c++\\n    bool wordBreak(string s, vector<string>& words) {\\n        if (words.size() == 0) return false;\\n        \\n        unordered_set<string> d(words.begin(), words.end());\\n           \\n\\t\\t // dp[i] is true only if a valid word or sequence of words ends at i\\n        vector<bool> dp(s.size() + 1, false);\\n        dp[0] = true;\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                // check only if a valid sequence of words (or a word) ends at j\\n                if (dp[j]) {\\n                    const string sub = s.substr(j, i - j);\\n                    if (d.count(sub)) {\\n                        // Ending at i is a valid word\\n                        dp[i] = true; \\n\\t\\t\\t\\t\\t\\t// Others j values might be false\\n\\t\\t\\t\\t\\t\\t// We stop here since there is one valid sequence ending here\\n                        break; \\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n\\t\\n```\\n\\n* Runtime complexity: O(N^2)\\n* Space complexity: O(N)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```c++\\n    bool helper(const string& s, int start, const unordered_set<string>& d, vector<int>& memo) {\\n        if (start == s.size()) {\\n            return true;\\n        }\\n        \\n        if (memo[start] != -1) return memo[start];\\n        \\n        for (int i = start + 1; i <= s.size(); ++i) {\\n            const string sub = s.substr(start, i - start); \\n            if (d.count(sub) == 1) {\\n                if (helper(s, i, d, memo)) {\\n                    memo[start] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        memo[start] = 0;\\n        return false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> d(wordDict.begin(), wordDict.end());\\n\\t\\t// Use a vector since we can index from 0 to N. \\n\\t\\t// Possible values in vector are: -1, 0, 1.\\n        vector<int> memo(s.length(), -1); \\n        return helper(s, 0, d, memo);\\n    }\\n```\n```c++\\n    bool wordBreak(string s, vector<string>& words) {\\n        if (words.size() == 0) return false;\\n        \\n        unordered_set<string> d(words.begin(), words.end());\\n           \\n\\t\\t // dp[i] is true only if a valid word or sequence of words ends at i\\n        vector<bool> dp(s.size() + 1, false);\\n        dp[0] = true;\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                // check only if a valid sequence of words (or a word) ends at j\\n                if (dp[j]) {\\n                    const string sub = s.substr(j, i - j);\\n                    if (d.count(sub)) {\\n                        // Ending at i is a valid word\\n                        dp[i] = true; \\n\\t\\t\\t\\t\\t\\t// Others j values might be false\\n\\t\\t\\t\\t\\t\\t// We stop here since there is one valid sequence ending here\\n                        break; \\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43852,
                "title": "my-java-dp-solution-beats-93-83",
                "content": "    public boolean wordBreak(String s, Set<String> wordDict) {\\n        int maxWord = getMax(wordDict);\\n        int len = s.length();\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= len; i ++) {\\n            int start = Math.max(1, i - maxWord);\\n            for (int j = start; j <= i; j++) {\\n                if (dp[j - 1] && wordDict.contains(s.substring(j - 1, i))) {\\n                    dp[i] = true; \\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n    \\n    private int getMax(Set<String> wordDict) {\\n        int max = 0;\\n        for (String str : wordDict) {\\n            max = Math.max(max, str.length());\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public boolean wordBreak(String s, Set<String> wordDict) {\\n        int maxWord = getMax(wordDict);\\n        int len = s.length();\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= len; i ++) {\\n            int start = Math.max(1, i - maxWord);\\n            for (int j = start; j <= i; j++) {\\n                if (dp[j - 1] && wordDict.contains(s.substring(j - 1, i))) {\\n                    dp[i] = true; \\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n    \\n    private int getMax(Set<String> wordDict) {\\n        int max = 0;\\n        for (String str : wordDict) {\\n            max = Math.max(max, str.length());\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 675314,
                "title": "java-with-picture",
                "content": "\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_139_using_dp.png)  \\n\\n\\n\\n``` java\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int len = s.length();\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= len; i++){\\n            for (int j = 0; j < i; j++){\\n                if (dp[j] && wordDict.contains(s.substring(j, i))){\\n                    dp[i] = true;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n}\\n```\\n\\n`Enjoy it ! `",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int len = s.length();\\n        boolean[] dp = new boolean[len + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= len; i++){\\n            for (int j = 0; j < i; j++){\\n                if (dp[j] && wordDict.contains(s.substring(j, i))){\\n                    dp[i] = true;\\n                }\\n            }\\n        }\\n        return dp[len];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460974,
                "title": "cpp-0ms-simple-solution-recursion-memoization",
                "content": "Just go with the flow, check if the substring of s from 0 to i is a part of wordDIct[i]. if Yes, make a recursive call to check further. Done!!!!!!  \\nOnce you have written the solution recursively, then just memoize it. \\n\\n```\\nclass Solution {\\npublic:\\n    int dp[300];\\n    \\n    bool helper(string s, vector<string>& w)\\n    {\\n        if(s.size() == 0) return dp[s.size()] = true;\\n        if(dp[s.size()] != -1) return dp[s.size()];\\n            \\n        bool check = false;\\n        \\n        for(int idx = 0; idx < w.size(); idx++)\\n        {\\n            if(s.substr(0, w[idx].size()) == w[idx])\\n            {\\n                if(helper(s.substr(w[idx].size()), w)) \\n                {\\n                    check = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()] = check;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& W)\\n    {\\n        if(W.size() == 0) return false;\\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        return helper(s, W);\\n    }\\n};\\n```\\n\\nIf you have any doubts, feel free to message. Do upvote.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[300];\\n    \\n    bool helper(string s, vector<string>& w)\\n    {\\n        if(s.size() == 0) return dp[s.size()] = true;\\n        if(dp[s.size()] != -1) return dp[s.size()];\\n            \\n        bool check = false;\\n        \\n        for(int idx = 0; idx < w.size(); idx++)\\n        {\\n            if(s.substr(0, w[idx].size()) == w[idx])\\n            {\\n                if(helper(s.substr(w[idx].size()), w)) \\n                {\\n                    check = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()] = check;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& W)\\n    {\\n        if(W.size() == 0) return false;\\n        \\n        memset(dp, -1, sizeof dp);\\n        \\n        return helper(s, W);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43951,
                "title": "python-bfs-beats-95",
                "content": "I use BFS to avoid useless states calculation like someone did in Coin Change. I do not check every substring but I check the substring whose length is possible (I store all distinct length of words in a list). Thus, no need to check backward from the current position one by one. \\n\\nIt runs for 44ms in average while my original DP is 58ms.\\n\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        queue = [0]\\n        slen = len(s)\\n        lenList = [l for l in set(map(len,wordDict))]\\n        visited = [0 for _ in range(0, slen + 1)]\\n        while queue:\\n            tmpqueue = []\\n            for start in queue:\\n                for l in lenList:\\n                    if s[start:start+l] in wordDict:\\n                        if start + l == slen:\\n                            return True\\n                        if visited[start + l] == 0:\\n                            tmpqueue.append(start+l)\\n                            visited[start + l] = 1\\n            queue, tmpqueue = tmpqueue, []\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        queue = [0]\\n        slen = len(s)\\n        lenList = [l for l in set(map(len,wordDict))]\\n        visited = [0 for _ in range(0, slen + 1)]\\n        while queue:\\n            tmpqueue = []\\n            for start in queue:\\n                for l in lenList:\\n                    if s[start:start+l] in wordDict:\\n                        if start + l == slen:\\n                            return True\\n                        if visited[start + l] == 0:\\n                            tmpqueue.append(start+l)\\n                            visited[start + l] = 1\\n            queue, tmpqueue = tmpqueue, []\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107044,
                "title": "c-template-for-word-break-i-ii-concatenated-words",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for all the problems:\\nAll the three given problems  can be divided into sub-problems .And  If these subproblems individually satisfy the required conditions, then  complete problem will also satisfy the same. And hence we can say whether it is true to find the word in the dictionary or not.\\n\\n# Approach\\n- **Naive Approach**: Use recursion and backtracking. For finding the solution, we check every prefix of the string in the word_dict of words, if it is found , then the recursive function is called for the remaining portion of that string. But this will be$$ 2^n$$ so will give tle . SO we can optimize using memoization or dp.\\n- **DP**: So as we can see that in recurion we call for evrery prefix substring and check if its presnt and like this the we check the whole is present or not .So similarly we can store the same ,like upto certain index whether the substring upto that index is present or not . In this way our dp array will be filled with 0\\'s and 1\\'s representing whether the substring upto that index is present or not . And at last if last index is true i.e dp[n] is true this means whole string is presnt .\\n- So applying this logic we can do all the three problems with a little modification based on requirements.\\n<!-- Describe your approach to solving the problem. -->\\n# **For Word Break I**\\n\\n# Code\\n\\n```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **For Word Break II**\\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **For concatenated Words**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(N*W^3)$$\\n    - where `N=word.length and W = words[i].length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*W)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615636,
                "title": "c-dp-solution",
                "content": "**Intuition**\\n\\t![image](https://assets.leetcode.com/users/newbiecoder1/image_1588724366.png)\\n\\n**Complexity**\\n- Time: O(n^3)\\n- Space: O(n)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        \\n        //dp[i] indicates whehter substring of length i can be segmented.\\n        bool[] dp = new bool[s.Length + 1];\\n        //assume empty string is always in the wordDict\\n        dp[0] = true;\\n        \\n        // HashSet<T>.Contains(T) is O(1) operation. It\\'s better than List<T>.Contains<T) which is O(n) operation\\n        HashSet<string> set = new HashSet<string>(wordDict);\\n        \\n        // check substring from length 1 to s.Length \\n\\t\\t// i and j represent the length of substrings\\n        for(int i = 1; i < dp.Length; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(dp[j] && set.Contains(s.Substring(j, i - j)))\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n                   \\n        return dp[s.Length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool WordBreak(string s, IList<string> wordDict) {\\n        \\n        //dp[i] indicates whehter substring of length i can be segmented.\\n        bool[] dp = new bool[s.Length + 1];\\n        //assume empty string is always in the wordDict\\n        dp[0] = true;\\n        \\n        // HashSet<T>.Contains(T) is O(1) operation. It\\'s better than List<T>.Contains<T) which is O(n) operation\\n        HashSet<string> set = new HashSet<string>(wordDict);\\n        \\n        // check substring from length 1 to s.Length \\n\\t\\t// i and j represent the length of substrings\\n        for(int i = 1; i < dp.Length; i++)\\n        {\\n            for(int j = 0; j < i; j++)\\n            {\\n                if(dp[j] && set.Contains(s.Substring(j, i - j)))\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n                   \\n        return dp[s.Length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205773,
                "title": "139-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We can use Dynamic programming to solve the problem. Create an array dp of length s+1.\\n- dp[i] represents whether we can segment the substring s[0:i] into words from the dictionary.\\n- Initially, we set dp[0] to True because the empty string can be segmented into an empty sequence of words.\\n- For each substring s[0:i] (i=1 to s+1), we need to check whether the prefix s[0:j] and suffix s[j:i] can be segmented. If so, set dp[i] to True.\\n- To check whether s[0:j] can be segmented, we can use dp[j]. If it is True, then we just need to check whether s[j:i] is in the wordDict.\\n- We can use a set to store the wordDict for constant time lookup.\\n- The final answer is stored in dp[s+1].\\n\\n# Complexity\\n- Time complexity:\\nO(n^2), where n is the length of the string.\\n\\n- Space complexity:\\nO(n), where n is the length of the string.\\n\\n# Code\\n```\\nclass Solution:\\n  def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n    word_set = set(wordDict)  # convert wordDict to a set for constant time lookup\\n    n = len(s)\\n    dp = [False] * (n+1)  # create an array dp of length n+1\\n    dp[0] = True  # empty string can be segmented into an empty sequence of words\\n    \\n    for i in range(1, n+1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in word_set:\\n                dp[i] = True\\n                break\\n    \\n    return dp[n]  # return the final answer\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n    word_set = set(wordDict)  # convert wordDict to a set for constant time lookup\\n    n = len(s)\\n    dp = [False] * (n+1)  # create an array dp of length n+1\\n    dp[0] = True  # empty string can be segmented into an empty sequence of words\\n    \\n    for i in range(1, n+1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in word_set:\\n                dp[i] = True\\n                break\\n    \\n    return dp[n]  # return the final answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552323,
                "title": "javascript-dp-with-heavy-comments",
                "content": "***\\nFirst, lets look at the recursive solution WITHOUT memoization/DP. **(THIS SOLUTION WILL TIME OUT)**\\n***\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict) => {\\n\\t// We break down the word each recursive call\\n\\t// Base case is the broken down word becomes an empty string, which means we found a path\\n    if(!s) return true;\\n    \\n\\t// We need to loop everyword in the wordDict\\n    for(let word of wordDict) {\\n\\t\\t// indexOf will give us the prefix START of the word we pass in\\n        // So if s.indexOf(word) is 0, we know the word is the prefix\\n        if(s.indexOf(word) === 0) {\\n\\t\\t\\t// If they match, we continue our recursion\\n\\t\\t\\t// We pass in the NEW s with the word sliced from the prefix, we also need to pass wordDict\\n\\t\\t\\t// If we ever hit our base case, this will evaluate to true and return true overall\\n            if(wordBreak(s.slice(word.length), wordDict)) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n\\t// If we never make it to a base case, we have no answers\\n    return false;\\n};\\n```\\n***\\nNow, lets look at the solution WITH DP/Memoization, THIS IS THE CORRECT SOLUTION. **(Added lines will have #### after them)**\\n***\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict, memo = {}) => { // Default arg which is our memo object #####\\n\\t// We break down the word each recursive call\\n\\t// Base case is the broken down word becomes an empty string, which means we found a path\\n    if(!s) return true;\\n    if(s in memo) return memo[s]; // Base case to avoid extra computation #####\\n    // ^^ Will be hit if we already computated this word\\n    \\n\\t// We need to loop everyword in the wordDict\\n    for(let word of wordDict) {\\n\\t\\t// indexOf will give us the prefix START of the word we pass in\\n        // So if s.indexOf(word) is 0, we know the word is the prefix\\n        if(s.indexOf(word) === 0) {\\n\\t\\t\\t// If they match, we continue our recursion\\n\\t\\t\\t// We pass in the NEW s with the word sliced from the prefix, we also need to pass wordDict\\n\\t\\t\\t// If we ever hit our base case, this will evaluate to true and return true overall\\n            if(wordBreak(s.slice(word.length), wordDict, memo)) { // Remeber to pass down memo #####\\n                memo[s] = true; // Save our computation #####\\n                return true;\\n            }\\n        }\\n    }\\n    \\n\\t// If we never make it to a base case, we have no answers\\n    memo[s] = false; // Save our computation #####\\n    return false;\\n};\\n```\\n***\\nBONUS Tabulation\\n***\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    // Tablulation\\n    // Init our table, this will be boolean values since return is boolean\\n    const table = Array(s.length + 1).fill(false);\\n    // Seed our simple case, this would be base case in recursive solution\\n    // Basically, we can make an empty string, so 0 would be true\\n    // In our table, each index refers to the letter before\\n    // So table[0] is \"\", table[1] is \"l\", table[2] is \"e\", if testcase is \"leetcode\"\\n    table[0] = true;\\n    \\n    // Loop table\\n    for(let i = 0; i < table.length; i++) {\\n        // We only want to process if current table position is true\\n        if(!table[i]) continue;\\n        \\n        // Loop all letters in wordDict\\n        for(let w of wordDict) {\\n            // We want to test if word matches where we are in s, and the word\\n            // We can slice from i to i + w.length and compare with the word\\n            if(s.slice(i, i + w.length) === w) {\\n                // If we pass the condition above, and the table index we are trying to update is in bounds, update to true\\n                if(i + w.length <= table.length) table[i + w.length] = true;\\n            }\\n        }\\n    }\\n    \\n    // The last item in our table can be returned, as it will be updated to true if we found a solution\\n    return table[s.length];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict) => {\\n\\t// We break down the word each recursive call\\n\\t// Base case is the broken down word becomes an empty string, which means we found a path\\n    if(!s) return true;\\n    \\n\\t// We need to loop everyword in the wordDict\\n    for(let word of wordDict) {\\n\\t\\t// indexOf will give us the prefix START of the word we pass in\\n        // So if s.indexOf(word) is 0, we know the word is the prefix\\n        if(s.indexOf(word) === 0) {\\n\\t\\t\\t// If they match, we continue our recursion\\n\\t\\t\\t// We pass in the NEW s with the word sliced from the prefix, we also need to pass wordDict\\n\\t\\t\\t// If we ever hit our base case, this will evaluate to true and return true overall\\n            if(wordBreak(s.slice(word.length), wordDict)) {\\n                return true;\\n            }\\n        }\\n    }\\n    \\n\\t// If we never make it to a base case, we have no answers\\n    return false;\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict, memo = {}) => { // Default arg which is our memo object #####\\n\\t// We break down the word each recursive call\\n\\t// Base case is the broken down word becomes an empty string, which means we found a path\\n    if(!s) return true;\\n    if(s in memo) return memo[s]; // Base case to avoid extra computation #####\\n    // ^^ Will be hit if we already computated this word\\n    \\n\\t// We need to loop everyword in the wordDict\\n    for(let word of wordDict) {\\n\\t\\t// indexOf will give us the prefix START of the word we pass in\\n        // So if s.indexOf(word) is 0, we know the word is the prefix\\n        if(s.indexOf(word) === 0) {\\n\\t\\t\\t// If they match, we continue our recursion\\n\\t\\t\\t// We pass in the NEW s with the word sliced from the prefix, we also need to pass wordDict\\n\\t\\t\\t// If we ever hit our base case, this will evaluate to true and return true overall\\n            if(wordBreak(s.slice(word.length), wordDict, memo)) { // Remeber to pass down memo #####\\n                memo[s] = true; // Save our computation #####\\n                return true;\\n            }\\n        }\\n    }\\n    \\n\\t// If we never make it to a base case, we have no answers\\n    memo[s] = false; // Save our computation #####\\n    return false;\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    // Tablulation\\n    // Init our table, this will be boolean values since return is boolean\\n    const table = Array(s.length + 1).fill(false);\\n    // Seed our simple case, this would be base case in recursive solution\\n    // Basically, we can make an empty string, so 0 would be true\\n    // In our table, each index refers to the letter before\\n    // So table[0] is \"\", table[1] is \"l\", table[2] is \"e\", if testcase is \"leetcode\"\\n    table[0] = true;\\n    \\n    // Loop table\\n    for(let i = 0; i < table.length; i++) {\\n        // We only want to process if current table position is true\\n        if(!table[i]) continue;\\n        \\n        // Loop all letters in wordDict\\n        for(let w of wordDict) {\\n            // We want to test if word matches where we are in s, and the word\\n            // We can slice from i to i + w.length and compare with the word\\n            if(s.slice(i, i + w.length) === w) {\\n                // If we pass the condition above, and the table index we are trying to update is in bounds, update to true\\n                if(i + w.length <= table.length) table[i + w.length] = true;\\n            }\\n        }\\n    }\\n    \\n    // The last item in our table can be returned, as it will be updated to true if we found a solution\\n    return table[s.length];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309633,
                "title": "3-solutions-memoized-mcm-variation-brut-force",
                "content": "**Sol1:** BRUTFORCE\\nTC: exponential\\n\\n```\\nint helper(string s, vector<string> dict, int i, unordered_set<string> us)\\n    {\\n        if(i==s.size())\\n            return 1;\\n\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(us.find(s.substr(i, j-i+1))!= us.end() && helper(s, dict, j+1, us))\\n                return 1;\\n        }\\n\\n        return 0;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n                \\n        unordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return helper(s, wordDict, 0, us);\\n    }\\n```\\n\\n\\n**Sol2:** MEMOIZED  \\n\\nTC: O(N^2)\\n\\n```\\n    int dp[302];\\n\\t\\n\\tint helper(string s, vector<string> dict, int i, unordered_set<string> us)\\n    {\\n        if(i==s.size())\\n            return 1;\\n        \\n        if(dp[i]!= -1)\\n            return dp[i];\\n\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(us.find(s.substr(i, j-i+1))!= us.end() && helper(s, dict, j+1, us))\\n                return dp[i] = 1;\\n        }\\n\\n        return dp[i] = 0;\\n    }\\n\\t\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        unordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return helper(s, wordDict, 0, us);\\n    }\\n```\\n\\n**Sol3:** MATRIX CHAIN MULTIPLICATION VARIATION\\nTC: O(N^3)\\n\\n```\\nint dp[302][302];\\n    \\n    int wordBreakHelper(string A, vector<string> B, int i, int j, unordered_set<string> us)\\n    {\\n        if(i>j)\\n            return 0;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        bool ans = 0, tempAns;\\n\\n        if(us.find(A.substr(i, j-i+1)) != us.end())\\n            return 1;\\n\\n        for(int k=i;k<j;k++)\\n        {\\n            int leftChoice;\\n            if(dp[i][k]!= -1)\\n                leftChoice = dp[i][k];\\n            else\\n                dp[i][k] = leftChoice = wordBreakHelper(A, B, i, k, us);\\n\\n            int rightChoice;\\n            if(dp[k+1][j]!= -1)\\n                rightChoice = dp[k+1][j];\\n            else\\n                dp[k+1][j] = rightChoice = wordBreakHelper(A, B, k+1, j, us);\\n\\n            tempAns = leftChoice && rightChoice;\\n            ans = ans || tempAns;\\n        }\\n\\n        return dp[i][j] = ans;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\tunordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return wordBreakHelper(s, wordDict, 0, s.size()-1, us);\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint helper(string s, vector<string> dict, int i, unordered_set<string> us)\\n    {\\n        if(i==s.size())\\n            return 1;\\n\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(us.find(s.substr(i, j-i+1))!= us.end() && helper(s, dict, j+1, us))\\n                return 1;\\n        }\\n\\n        return 0;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n                \\n        unordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return helper(s, wordDict, 0, us);\\n    }\\n```\n```\\n    int dp[302];\\n\\t\\n\\tint helper(string s, vector<string> dict, int i, unordered_set<string> us)\\n    {\\n        if(i==s.size())\\n            return 1;\\n        \\n        if(dp[i]!= -1)\\n            return dp[i];\\n\\n        for(int j=i;j<s.size();j++)\\n        {\\n            if(us.find(s.substr(i, j-i+1))!= us.end() && helper(s, dict, j+1, us))\\n                return dp[i] = 1;\\n        }\\n\\n        return dp[i] = 0;\\n    }\\n\\t\\n\\tbool wordBreak(string s, vector<string>& wordDict) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        unordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return helper(s, wordDict, 0, us);\\n    }\\n```\n```\\nint dp[302][302];\\n    \\n    int wordBreakHelper(string A, vector<string> B, int i, int j, unordered_set<string> us)\\n    {\\n        if(i>j)\\n            return 0;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        bool ans = 0, tempAns;\\n\\n        if(us.find(A.substr(i, j-i+1)) != us.end())\\n            return 1;\\n\\n        for(int k=i;k<j;k++)\\n        {\\n            int leftChoice;\\n            if(dp[i][k]!= -1)\\n                leftChoice = dp[i][k];\\n            else\\n                dp[i][k] = leftChoice = wordBreakHelper(A, B, i, k, us);\\n\\n            int rightChoice;\\n            if(dp[k+1][j]!= -1)\\n                rightChoice = dp[k+1][j];\\n            else\\n                dp[k+1][j] = rightChoice = wordBreakHelper(A, B, k+1, j, us);\\n\\n            tempAns = leftChoice && rightChoice;\\n            ans = ans || tempAns;\\n        }\\n\\n        return dp[i][j] = ans;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\tunordered_set<string> us(wordDict.begin(), wordDict.end());\\n    \\n        return wordBreakHelper(s, wordDict, 0, s.size()-1, us);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350836,
                "title": "simple-java-dp-bfs-and-dfs-solution",
                "content": "All solutions take O(n* n) time and O(n) space.\\n\\nDP\\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        boolean [] dp = new boolean[s.length()+1];\\n        dp[0] = true;\\n        for(int i = 0; i < s.length(); i++){\\n            for(int j = i + 1; j <= s.length(); j++){\\n                if(set.contains(s.substring(i,j)) && dp[i]){\\n                    dp[j] = true;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\\n\\nDFS\\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        HashMap<String, Boolean> map = new HashMap<>();\\n        return helper(s, map, set);\\n    }\\n    \\n    boolean helper(String s, HashMap<String, Boolean> map, HashSet<String> set){\\n        if(s.length() == 0) return true;\\n        if(map.containsKey(s)) return map.get(s);\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(set.contains(s.substring(0, i +1)) && helper(s.substring(i + 1), map, set)){\\n                map.put(s, true);\\n                return map.get(s);\\n            }\\n        }\\n\\n        map.put(s, false);\\n        return map.get(s);\\n    }\\n```\\n\\nBFS\\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(s);\\n        HashSet<String> v = new HashSet<>();\\n        while(!q.isEmpty()){\\n            String t = q.poll();\\n            for(int i = 1; i <= t.length(); i++){\\n                if(set.contains(t.substring(0,i))){\\n                    if(i == t.length()) return true;\\n                    if(!v.contains(t.substring(i))){\\n                        q.offer(t.substring(i));\\n                        v.add(t.substring(i));\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n```\\n\\nDo up vote if you find it useful! :)",
                "solutionTags": [],
                "code": "```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        boolean [] dp = new boolean[s.length()+1];\\n        dp[0] = true;\\n        for(int i = 0; i < s.length(); i++){\\n            for(int j = i + 1; j <= s.length(); j++){\\n                if(set.contains(s.substring(i,j)) && dp[i]){\\n                    dp[j] = true;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        HashMap<String, Boolean> map = new HashMap<>();\\n        return helper(s, map, set);\\n    }\\n    \\n    boolean helper(String s, HashMap<String, Boolean> map, HashSet<String> set){\\n        if(s.length() == 0) return true;\\n        if(map.containsKey(s)) return map.get(s);\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(set.contains(s.substring(0, i +1)) && helper(s.substring(i + 1), map, set)){\\n                map.put(s, true);\\n                return map.get(s);\\n            }\\n        }\\n\\n        map.put(s, false);\\n        return map.get(s);\\n    }\\n```\n```\\n    public boolean wordBreak(String s, List<String> wordDict) { \\n        HashSet<String> set = new HashSet<>(wordDict);\\n        Queue<String> q = new LinkedList<>();\\n        q.offer(s);\\n        HashSet<String> v = new HashSet<>();\\n        while(!q.isEmpty()){\\n            String t = q.poll();\\n            for(int i = 1; i <= t.length(); i++){\\n                if(set.contains(t.substring(0,i))){\\n                    if(i == t.length()) return true;\\n                    if(!v.contains(t.substring(i))){\\n                        q.offer(t.substring(i));\\n                        v.add(t.substring(i));\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030368,
                "title": "java-dynamic-programming-hashset",
                "content": "# Intuition\\nThe problem requires determining whether a given string `s` can be segmented into space-separated words from a dictionary. The intuition is to use dynamic programming to keep track of valid word breaks.\\n\\n# Approach\\n- Create a `wordSet` HashSet containing all the words from the `wordDict` list to allow for efficient word lookup.\\n- Initialize a boolean array `dp` of size `n+1` (where `n` is the length of the input string `s`). Each element `dp[i]` will represent whether the substring `s[0:i]` can be segmented into words from the dictionary.\\n- Set `dp[0]` to `true` because an empty string can be segmented into words (base case).\\n- Use two nested loops to iterate through the string `s`. The outer loop iterates through the positions in the string from `1` to `n`, and the inner loop iterates from `0` to the current position `i`.\\n- For each `i`, check if `dp[j]` is `true` (where `j` is in the range `[0, i)`) and whether the substring `s[j:i]` (inclusive at `i`) is in the `wordSet`. If both conditions are met, set `dp[i]` to `true`, indicating that the substring `s[0:i]` can be segmented into words.\\n- Continue this process until the outer loop has traversed the entire string.\\n- Finally, return `dp[n]`, which represents whether the entire string `s` can be segmented into words from the dictionary.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n  The algorithm uses two nested loops to fill the `dp` array, resulting in a time complexity of O(n^2), where n is the length of the input string `s`.\\n\\n- Space complexity: O(n)\\n  The algorithm uses additional space for the `wordSet` HashSet and the `dp` array, both of which have a maximum size of `n+1`, resulting in a space complexity of O(n).\\n\\n# Code\\n```java\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordSet = new HashSet<>(wordDict);\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672860,
                "title": "easy-c-trie-for-lookup-solution",
                "content": "```\\nclass Trie {\\npublic:\\n    unordered_map<char, Trie*> children;\\n    bool isEnd=false;\\n    \\n    void insert(string word) {\\n        Trie* node=this;\\n        for(char c : word){\\n            if(node->children.find(c)==node->children.end())\\n                node->children[c]=new Trie();\\n            node=node->children[c];\\n        }\\n        node->isEnd=true;\\n    }\\n        \\n    bool search(string word) {\\n        Trie* node=this;\\n        for(char c : word){\\n            if(node->children.find(c)==node->children.end())\\n                return false;\\n            node=node->children[c];\\n        }\\n        return node->isEnd;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for(string word : wordDict)\\n            trie.insert(word);\\n        \\n        vector<bool> dp(s.size()+1, false);\\n        dp[0]=true;\\n        \\n        for(int len=1; len<=s.size(); len++){\\n            for(int i=0; i<len; i++){\\n                if(dp[i] && trie.search(s.substr(i, len-i)))\\n                    dp[len]=true;\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for(string word : wordDict)\\n            trie.insert(word);\\n        \\n        vector<bool> dp(s.size()+1, false);\\n        dp[0]=true;\\n        \\n        for(int len=1; len<=s.size(); len++){\\n            for(int i=0; i<len; i++){\\n                if(dp[i] && trie.search(s.substr(i, len-i)))\\n                    dp[len]=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 642382,
                "title": "python-with-dp-dfs-bfs",
                "content": "## DP\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False]*(n+1)\\n        dp[0] = True\\n        for i in range(n+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n        return dp[n]\\n```\\n## DFS\\n>### 1. DFS\\n```\\n#DFS Time Limit Exceeded\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False]*(n+1)\\n        \\n        def dfs(s):\\n            if s in wordDict:\\n                return True\\n            for i in range(len(s)):\\n                if dfs(s[:i]) and dfs(s[i:]):\\n                    return True\\n            return False\\n        \\n        return dfs(s)```\\n```\\n>###  2. DFS+memoization\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        table = {}\\n        def dfs(s,loc):\\n            if loc in table:\\n                return table[loc]\\n            if s in wordDict:\\n                return True\\n            start,end = loc\\n            for i in range(len(s)):\\n                if dfs(s[:i],(start,start+i)) and dfs(s[i:],(start+i,end)):\\n                    table[loc] = True\\n                    return True\\n            table[loc] = False\\n            return False\\n        \\n        return dfs(s,(0,n))\\n```\\n## BFS\\n>### 1. BFS\\n\\n```\\n#BFS Time Limit Exceeded\\n    stack = []\\n        stack.append(s)\\n        \\n        while(stack):\\n            token = stack.pop()\\n            if token in wordDict:\\n                return True\\n            for i in range(len(token)):\\n                if token[:i] in wordDict:\\n                    stack.append(token[i:])\\n        \\n        return False\\n```\\n>### 2. BFS+memoization\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        stack = []\\n        stack.append(0)\\n        visited = [False]*(n+1)\\n        while(stack):\\n            idx = stack.pop()\\n            if not visited[idx]:\\n                for i in range(idx,n):\\n                    if s[idx:i+1] in wordDict:\\n                        if s[i+1:] == \\'\\' or s[i+1:] in wordDict:\\n                            return True\\n                        stack.append(i+1)\\n            visited[idx] = True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False]*(n+1)\\n        dp[0] = True\\n        for i in range(n+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n        return dp[n]\\n```\n```\\n#DFS Time Limit Exceeded\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False]*(n+1)\\n        \\n        def dfs(s):\\n            if s in wordDict:\\n                return True\\n            for i in range(len(s)):\\n                if dfs(s[:i]) and dfs(s[i:]):\\n                    return True\\n            return False\\n        \\n        return dfs(s)```\n```\\n>###  2. DFS+memoization\\n```\n```\\n## BFS\\n>### 1. BFS\\n\\n```\n```\\n>### 2. BFS+memoization\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306561,
                "title": "a-simple-solution-using-tries",
                "content": "As many of you know, for optimized searching of a string in a list of strings we use Tries.\\nTries take some time to build but then all the searches are much faster.\\nHere is the time for sol with and w/o tries -\\n* Without trie ( str in list )-\\n\\tO(n*k) where n is length of list and k is length of the string\\n\\t\\n* With trie ( Trie.checkWord(str) )-\\n\\tO(n*k) for building trie\\n\\tO(k) for querying\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        t = Trie()\\n        for w in wordDict:\\n            t.addWord(w)\\n        \\n        #dp[i] = True if s[:i] is word breakable\\n        #dp[i] = dp[j(<i)] and t.checkWord(s[j,i])\\n        \\n        dp=[False for i in range(len(s)+1)]\\n        dp[0]=True\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(i):\\n                \\n                if dp[j] and t.checkWord(s[j:i]):\\n                    # print(s[j:i])\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[-1]\\n \\n            \\n\\nclass TrieNode:\\n    def __init__(self, letter):\\n        self.nodes = {}\\n        self.val = letter\\n        self.term = False\\n\\n    def markTerm(self, stat):\\n        self.term = stat\\n\\n    def isTerm(self):\\n        return self.term\\n\\n    def addKid(self, kid):\\n        if kid not in self.nodes:\\n            self.nodes[kid] = TrieNode(kid)\\n        return self.nodes[kid]\\n\\n    def getKid(self, kid):\\n        return self.nodes.get(kid)\\n\\n    def hasKid(self, kid):\\n        return True if kid in self.nodes else False\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\\'Root\\')\\n\\n    def addWord(self, word):\\n        p = self.root\\n        for w in word:\\n            p = p.addKid(w)\\n        p.markTerm(True)\\n\\n    def checkWord(self, word):\\n        p = self.root\\n        for w in word:\\n            p = p.getKid(w)\\n            if p is None:\\n                return False\\n        return True if p.isTerm() else False\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        t = Trie()\\n        for w in wordDict:\\n            t.addWord(w)\\n        \\n        #dp[i] = True if s[:i] is word breakable\\n        #dp[i] = dp[j(<i)] and t.checkWord(s[j,i])\\n        \\n        dp=[False for i in range(len(s)+1)]\\n        dp[0]=True\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(i):\\n                \\n                if dp[j] and t.checkWord(s[j:i]):\\n                    # print(s[j:i])\\n                    dp[i] = True\\n                    break\\n            \\n        return dp[-1]\\n \\n            \\n\\nclass TrieNode:\\n    def __init__(self, letter):\\n        self.nodes = {}\\n        self.val = letter\\n        self.term = False\\n\\n    def markTerm(self, stat):\\n        self.term = stat\\n\\n    def isTerm(self):\\n        return self.term\\n\\n    def addKid(self, kid):\\n        if kid not in self.nodes:\\n            self.nodes[kid] = TrieNode(kid)\\n        return self.nodes[kid]\\n\\n    def getKid(self, kid):\\n        return self.nodes.get(kid)\\n\\n    def hasKid(self, kid):\\n        return True if kid in self.nodes else False\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\\'Root\\')\\n\\n    def addWord(self, word):\\n        p = self.root\\n        for w in word:\\n            p = p.addKid(w)\\n        p.markTerm(True)\\n\\n    def checkWord(self, word):\\n        p = self.root\\n        for w in word:\\n            p = p.getKid(w)\\n            if p is None:\\n                return False\\n        return True if p.isTerm() else False\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 434582,
                "title": "java-solutions-backtracking-memoization-dp-with-detailed-exp",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/word-break/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n\\n\\n## Problem\\n\\n> Given a **non-empty** string `s` and a dictionary `wordDict` containing a list of **non-empty** words, determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\n**Note:** \\n\\n- The same word in the dictionary **may be reused multiple times** in the segmentation.\\n- You may assume the dictionary does not contain duplicate words.\\n\\n**Example:** \\n\\n```java\\nInput: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\\nOutput: true\\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\\n\\nInput: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\\nOutput: true\\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\\n             Note that you are allowed to reuse a dictionary word.\\n\\nInput: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\\nOutput: false\\n```\\n\\n\\n## Analysis\\n\\n\\n### Backtracking\\n\\nFirst, we put `wordSet` into a hash set for quick `contains` examination.\\n\\nFor each character `S[depth]`, we consider substrings `S[depth, i]` including `S[depth]`, `S[depth, depth + 1]`, ..., `S[depth, n - 1]`. If one of them is in `wordDict`, we then redo the task on character `S[i + 1]`; otherwise, return `false`.\\n\\nOne of the most difficult part is to write the `reject & accept` code. Think about it carefully, we notice that if the recursive call goes into a situation where `n == s.length()`, it means the string `s` can be successfully segmented; otherwise, it won\\'t go into that situation. **We don\\'t write reject case in this backtracking function.**\\n\\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  return backtracking(0, s, new HashSet<>(wordDict));\\n}\\n\\nprivate boolean backtracking(int depth, String s, Set<String> wordSet) {\\n  int n = s.length();\\n  // accept\\n  if (depth == n) {\\n    return true;\\n  }\\n  \\n  for (int i = depth; i < n; ++i) {\\n    String str = s.substring(depth, i + 1); // substring[depth, i]\\n    if (wordSet.contains(str)) {\\n      if (backtracking(i + 1, s, wordSet)) return true;\\n    }\\n  }\\n  \\n  return false;\\n}\\n```\\n\\n**Time:** `O(N^N)` since each time it has at most `N` choices and the depth (problem size) is `N`. (this is an `upper bound`)\\n**Space:** `O(N)` (string length and call stack depth)\\n\\n<span class=\"purple\">Marked</span> For the time complexity, if we count `substring` operation (`O(N)`), it would be `O(N \\\\times N^N) = O(N^(N + 1))`.\\n\\n\\n\\n### Backtracking (Memoization)\\n\\nLet\\'s use an example to see if we can optimize the above method.\\n\\n```java\\n// String: \"abcde\" | wordDict: [\"a\", ...]\\n\\ndepth = 0 (\\'a\\')\\nwe have substrings: \"a\", \"ab\", \"abc\", \"abcd\", \"abcde\"\\n```\\n\\nFor the first substring `\"a\"`, it is in `wordDict`, so `depth` becomes 1 and we would examine if `\"bcde\"` is breakable.\\n\\nIn the process of checking if `\"bcde\"` is breakable, we may check if `\"cde\", \"de\", \"e\"` are breakable. Once we know the answers, we can cache them for future usage no matter they are true or false.\\n\\nIn future when we\\'ve done processing the first substring `\"a\"`, we will examine `\"b\"`, and you will see there could be a lot of repeated computation for `\"cde\", \"de\", \"e\"`.\\n\\n**Difficulty:** Using memoization in a backtracking-style recursive function is quite uncommon than other DP memoization. This is the new form I learned. There are three places that we need to set and get `memo[]`.\\n\\n**Note:** We use `Boolean` since initially we want values to be `null`.\\n\\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  int n = s.length();\\n  Boolean[] memo = new Boolean[n]; // memo[i] --> S[i...] is breakable or not\\n  return backtracking(0, s, new HashSet<>(wordDict), memo);\\n}\\n\\nprivate boolean backtracking(int depth, String s, Set<String> wordSet, Boolean[] memo) {\\n  int n = s.length();\\n  // accept\\n  if (depth == n) {\\n    return true;\\n  }\\n  // memoization\\n  if (memo[depth] != null) { // memo\\n    return memo[depth];\\n  }\\n  \\n  for (int i = depth; i < n; ++i) {\\n    String str = s.substring(depth, i + 1); // substring[depth, i]\\n    if (wordSet.contains(str)) {\\n      if (backtracking(i + 1, s, wordSet, memo)) {\\n        memo[depth] = true; // memo\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  memo[depth] = false; // memo\\n  return false;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(N)`\\n\\n\\n\\n\\n### DP\\n\\nThe idea is that given a problem(s) we can divide it into two subproblems `s1` and `s2`. If both of them are **breakable**, `s` is breakable (by saying breakable I mean it satisfies the required conditions).\\n\\n**Note:** Substring `s(i, j)` (character `i` to `j`) in Java is denoted by `s.substring(i, j + 1)`.\\n\\nFirst, we define our `dp[]` array, where `dp[i]` is `true` if the substring `s(0, i - 1)` or `s.substring(0, i)` is breakable; otherwise, it should be `false`.\\n\\nThen, we process string length from `1` to `n` in `dp[i]`. For each substring `s(0, i - 1)`, we examine each combination of substrings `s(0, j - 1)` (`s.substring(0, j)`) and `s(j, i - 1)` (`s.substring(j, i)`). The first subproblem can be calculated directly by `dp[j]` while the second one can be checked by `wordDict` set. **Question:** Why don\\'t we break the second substring and examine it further? (e.g. `abc` is not in `wordDict`, but `ab` and `c` could be in `wordDict`)\\n\\n```java\\n// String: a b c d e f\\nIn the final round, we are looking into the whole string. We would examine the follow pair of two substrings:\\na     bcdef\\nab    cdef\\nabc   def\\nabcd  ef\\nabcde f\\n```\\n**The question is:** what happen if `\"cdef\"` is not in wordDict while `\"cd\"` and `\"ef\"` are both in `wordDict`?\\n\\nIt is handled previously! If `\"cd\"` is in `wordDict`, in the previously fourth round for substring `\"abcd\"`, we would examine `\"ab\"` and `\"cd\"`. If `dp(\"ab\")` is true and `\"cd\"` is in `wordDict`, we would mark `dp(\"abcd\")` as true!\\n\\nThen in the final round, `dp(\"abcd\")` is true and `\"ef\"` is in `wordDict`, so we have the whole string breakable.\\n\\n**Note:** In addition, please think about the `initialization step` and the `break statement` in the code.\\n\\n\\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  int n = s.length();\\n  Set<String> set = new HashSet<>(wordDict);\\n  \\n  boolean[] dp = new boolean[n + 1];\\n  dp[0] = true; // consider the begining! (\"\" + \"a\")\\n  \\n  for (int i = 1; i <= n; ++i) { // for each length\\n    for (int j = 0; j < i; ++j) {\\n      // s1 = substring(0, j) = dp[j]\\n      // s2 = substring(j, i) = s[j, i - 1]\\n      if (dp[j] && set.contains(s.substring(j, i))) {\\n        dp[i] = true;\\n        break;\\n      }\\n    }\\n  }\\n  \\n  return dp[n];\\n}\\n```\\n\\n**Time:** `O(N^3)` since `substring` takes `O(N)`.\\n**Space:** `O(N)`\\n\\n\\n\\n### BFS\\n\\nGo To: [LeetCode Solution](https://leetcode.com/problems/word-break/solution/)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```java\\nInput: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\\nOutput: true\\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\\n\\nInput: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\\nOutput: true\\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\\n             Note that you are allowed to reuse a dictionary word.\\n\\nInput: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\\nOutput: false\\n```\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  return backtracking(0, s, new HashSet<>(wordDict));\\n}\\n\\nprivate boolean backtracking(int depth, String s, Set<String> wordSet) {\\n  int n = s.length();\\n  // accept\\n  if (depth == n) {\\n    return true;\\n  }\\n  \\n  for (int i = depth; i < n; ++i) {\\n    String str = s.substring(depth, i + 1); // substring[depth, i]\\n    if (wordSet.contains(str)) {\\n      if (backtracking(i + 1, s, wordSet)) return true;\\n    }\\n  }\\n  \\n  return false;\\n}\\n```\n```java\\n// String: \"abcde\" | wordDict: [\"a\", ...]\\n\\ndepth = 0 (\\'a\\')\\nwe have substrings: \"a\", \"ab\", \"abc\", \"abcd\", \"abcde\"\\n```\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  int n = s.length();\\n  Boolean[] memo = new Boolean[n]; // memo[i] --> S[i...] is breakable or not\\n  return backtracking(0, s, new HashSet<>(wordDict), memo);\\n}\\n\\nprivate boolean backtracking(int depth, String s, Set<String> wordSet, Boolean[] memo) {\\n  int n = s.length();\\n  // accept\\n  if (depth == n) {\\n    return true;\\n  }\\n  // memoization\\n  if (memo[depth] != null) { // memo\\n    return memo[depth];\\n  }\\n  \\n  for (int i = depth; i < n; ++i) {\\n    String str = s.substring(depth, i + 1); // substring[depth, i]\\n    if (wordSet.contains(str)) {\\n      if (backtracking(i + 1, s, wordSet, memo)) {\\n        memo[depth] = true; // memo\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  memo[depth] = false; // memo\\n  return false;\\n}\\n```\n```java\\n// String: a b c d e f\\nIn the final round, we are looking into the whole string. We would examine the follow pair of two substrings:\\na     bcdef\\nab    cdef\\nabc   def\\nabcd  ef\\nabcde f\\n```\n```java\\npublic boolean wordBreak(String s, List<String> wordDict) {\\n  // assume s and wordDict are non-empty\\n  int n = s.length();\\n  Set<String> set = new HashSet<>(wordDict);\\n  \\n  boolean[] dp = new boolean[n + 1];\\n  dp[0] = true; // consider the begining! (\"\" + \"a\")\\n  \\n  for (int i = 1; i <= n; ++i) { // for each length\\n    for (int j = 0; j < i; ++j) {\\n      // s1 = substring(0, j) = dp[j]\\n      // s2 = substring(j, i) = s[j, i - 1]\\n      if (dp[j] && set.contains(s.substring(j, i))) {\\n        dp[i] = true;\\n        break;\\n      }\\n    }\\n  }\\n  \\n  return dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44059,
                "title": "easy-to-understand-c-solution",
                "content": "Using a vector to record if it is possible to have a combination of dictionary of words at point i.\\n\\n    class Solution {\\n    public:\\n        bool wordBreak(string s, unordered_set<string>& wordDict) {\\n            s = \"!\" + s;\\n            vector<bool> dpArray(s.size());\\n            dpArray[0] = true;\\n            for(int i=0; i<s.size(); i++){\\n                for(int j=i+1; j<s.size(); j++) {\\n                    if(dpArray[j]) continue;\\n                    if(wordDict.find(s.substr(i+1, j-i))!=wordDict.end() && dpArray[i])\\n                        dpArray[j] = true;\\n                }\\n            }\\n            return dpArray[dpArray.size()-1];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool wordBreak(string s, unordered_set<string>& wordDict) {\\n            s = \"!\" + s;\\n            vector<bool> dpArray(s.size());\\n            dpArray[0] = true;\\n            for(int i=0; i<s.size(); i++){\\n                for(int j=i+1; j<s.size(); j++) {\\n                    if(dpArray[j]) continue;\\n                    if(wordDict.find(s.substr(i+1, j-i))!=wordDict.end() && dpArray[i])\\n                        dpArray[j] = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44103,
                "title": "a-java-solution-with-similar-dp-idea",
                "content": "The idea is pretty similar to other DP solution. \\n1)keep all positions which could form substring contained in the set in a linkedlist\\n2) Iterate the target string, check  substring between current position and stored positions. If new sub string hits the dictionary,add it the front of linkedlist\\n3)After iteration, check if the front element of linkedlist equals to the length of string.\\n\\nIt consumes 296ms\\n\\nThis solution is still a time O(n^2) and space O(n) one. It is better if dictionary contains long words. \\n\\n  \\n\\n    public class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            if (s==null||s.length()==0) return false;\\n            else if (dict.contains(s)) return true;\\n            \\n            List<Integer> starts = new LinkedList<Integer>();\\n            starts.add(0);\\n           \\n            for (int end=1;end<=s.length();end++){\\n            \\tboolean found=false;\\n                for (Integer start:starts)\\n                    if (dict.contains(s.substring(start,end))){\\n                    \\tfound=true;\\n                    \\tbreak;\\n                    }\\n                if(found)  starts.add(0,end);\\n            }\\n    \\n            return (starts.get(0)==s.length());\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean wordBreak(String s, Set<String> dict) {\\n            if (s==null||s.length()==0) return false;\\n            else if (dict.contains(s)) return true;\\n            \\n            List<Integer> starts = new LinkedList<Integer>();\\n            starts.add(0);\\n           \\n            for (int end=1;end<=s.length();end++){\\n            \\tboolean found=false;\\n                for (Integer start:starts)\\n                    if (dict.contains(s.substring(start,end))){\\n                    \\tfound=true;\\n                    \\tbreak;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3860527,
                "title": "100-dynamic-programming",
                "content": "# Intuition\\nThe Word Break problem requires us to determine if a given string can be segmented into a sequence of dictionary words. This can be visualized as finding a path through a sequence of characters where each step corresponds to a valid word in the dictionary. Special thanks to vanAmsen for their invaluable insights and contributions to this problem [139 - Word Break](https://youtu.be/9ZIQwa1wCNA) The problem can be solved efficiently using Dynamic Programming.\\n\\n# Approach - Dynamic Programming\\nThe Dynamic Programming approach involves breaking down the problem into smaller subproblems and solving them iteratively. We initialize a boolean array `dp`, where `dp[i]` represents whether the substring up to the `i`-th character can be segmented into dictionary words. By considering the maximum word length, we reduce unnecessary iterations, making the solution more efficient.\\n\\n1. **Initialization**: Set `dp[0]` to `true` and the rest to `false`.\\n2. **Iteration**: Iterate through the string from left to right, and for each position `i`, check the substrings ending at `i` to see if they are in the dictionary.\\n3. **Memoization**: If a valid segmentation is found, update `dp[i]` to `true`.\\n4. **Result**: The final result is stored in `dp[n]`, where `n` is the length of the string.\\n\\n# Complexity\\n- **Time complexity**: \\\\(O(n * m)\\\\), where \\\\(n\\\\) is the length of the string and \\\\(m\\\\) is the maximum length of a word in the dictionary. We iterate through the string and for each position, we may consider up to \\\\(m\\\\) characters.\\n- **Space complexity**: \\\\(O(n + k)\\\\), where \\\\(n\\\\) is the length of the string and \\\\(k\\\\) is the size of the dictionary. The space is used for the `dp` array and storing the dictionary as a HashSet.\\n\\n# Code\\n``` Rust []\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let n = s.len();\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n        let max_len = word_dict.iter().map(|word| word.len()).max().unwrap_or(0);\\n\\n        let word_dict: std::collections::HashSet<String> = word_dict.into_iter().collect();\\n\\n        for i in 1..=n {\\n            for j in (std::cmp::max(i as isize - max_len as isize - 1, 0) as usize..i).rev() {\\n                if dp[j] && word_dict.contains(&s[j..i].to_string()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        dp[n]\\n    }\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        max_len = max(map(len, wordDict)) \\n        for i in range(1, n + 1):\\n            for j in range(i - 1, max(i - max_len - 1, -1), -1): \\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    n := len(s)\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n    max_len := 0\\n    for _, word := range wordDict {\\n        if len(word) > max_len {\\n            max_len = len(word)\\n        }\\n    }\\n    for i := 1; i <= n; i++ {\\n        for j := i - 1; j >= max(i - max_len - 1, 0); j-- {\\n            if dp[j] && contains(wordDict, s[j:i]) {\\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n\\n    return dp[n]\\n}\\nfunc contains(words []string, target string) bool {\\n    for _, word := range words {\\n        if word == target {\\n            return true\\n        }\\n    }\\n    return false\\n}\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```\\n\\nThis code offers a concise and efficient solution to the Word Break problem by leveraging the power of Dynamic Programming, carefully considering the constraints, and using Rust\\'s standard library to handle the dictionary.",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "``` Rust []\\nimpl Solution {\\n    pub fn word_break(s: String, word_dict: Vec<String>) -> bool {\\n        let n = s.len();\\n        let mut dp = vec![false; n + 1];\\n        dp[0] = true;\\n        let max_len = word_dict.iter().map(|word| word.len()).max().unwrap_or(0);\\n\\n        let word_dict: std::collections::HashSet<String> = word_dict.into_iter().collect();\\n\\n        for i in 1..=n {\\n            for j in (std::cmp::max(i as isize - max_len as isize - 1, 0) as usize..i).rev() {\\n                if dp[j] && word_dict.contains(&s[j..i].to_string()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        dp[n]\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        max_len = max(map(len, wordDict)) \\n        for i in range(1, n + 1):\\n            for j in range(i - 1, max(i - max_len - 1, -1), -1): \\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i] = True\\n                    break\\n\\n        return dp[n]\\n```\n``` Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    n := len(s)\\n    dp := make([]bool, n+1)\\n    dp[0] = true\\n    max_len := 0\\n    for _, word := range wordDict {\\n        if len(word) > max_len {\\n            max_len = len(word)\\n        }\\n    }\\n    for i := 1; i <= n; i++ {\\n        for j := i - 1; j >= max(i - max_len - 1, 0); j-- {\\n            if dp[j] && contains(wordDict, s[j:i]) {\\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n\\n    return dp[n]\\n}\\nfunc contains(words []string, target string) bool {\\n    for _, word := range words {\\n        if word == target {\\n            return true\\n        }\\n    }\\n    return false\\n}\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714428,
                "title": "c-dp-faster-easy-to-understand",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n\\n    int dp[305];\\n\\n    unordered_set<string> s;\\n\\n    bool helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return true;\\n        }\\n        \\n        // if already calculated\\n\\n        if(dp[i] != -1)\\n        {\\n            return dp[i];\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for remaining part \\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                if(helper(str, j + 1, n))\\n                {\\n                    return dp[i] = true;\\n                }\\n            }\\n        }\\n        \\n        // store the res and return\\n\\n        return dp[i] = false;\\n    }\\n    \\n    bool wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n        \\n        // declare dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(str, 0, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n\\n    int dp[305];\\n\\n    unordered_set<string> s;\\n\\n    bool helper(string& str, int i, int n)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return true;\\n        }\\n        \\n        // if already calculated\\n\\n        if(dp[i] != -1)\\n        {\\n            return dp[i];\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for remaining part \\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                if(helper(str, j + 1, n))\\n                {\\n                    return dp[i] = true;\\n                }\\n            }\\n        }\\n        \\n        // store the res and return\\n\\n        return dp[i] = false;\\n    }\\n    \\n    bool wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n        \\n        // declare dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(str, 0, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089632,
                "title": "c-dp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& w) {\\n      int n=s.length();\\n      unordered_set<string>m(w.begin(),w.end());\\n      int dp[n+1];\\n      memset(dp,0,sizeof dp);\\n      dp[n]=1;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n        string t=\"\";\\n        for(int j=i;j<n;j++)\\n        {\\n          t+=s[j];\\n          if(m.find(t)!=m.end())\\n            if(dp[j+1]==1)\\n              dp[i]=1;\\n        }\\n      }\\n        return dp[0];\\n    }\\n};\\n```\\n**Upvote Pls**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& w) {\\n      int n=s.length();\\n      unordered_set<string>m(w.begin(),w.end());\\n      int dp[n+1];\\n      memset(dp,0,sizeof dp);\\n      dp[n]=1;\\n      for(int i=n-1;i>=0;i--)\\n      {\\n        string t=\"\";\\n        for(int j=i;j<n;j++)\\n        {\\n          t+=s[j];\\n          if(m.find(t)!=m.end())\\n            if(dp[j+1]==1)\\n              dp[i]=1;\\n        }\\n      }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413187,
                "title": "java-two-solutions-dfs-memoization-dp-detailed-explanation",
                "content": "```\\nclass Solution {\\n    // get the max length of string in dict\\n    int maxLen = 0;\\n    // Recursion with memoization, time O(n^2), space O(n)\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for (String str : wordDict) {\\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        Set<String> set = new HashSet(wordDict);\\n        return helper(s, set, 0, new Boolean[s.length()]);\\n    }\\n    \\n    public boolean helper(String s, Set<String> wordDict, int start, Boolean[] memo) {\\n        if (start == s.length()) {\\n            return true;\\n        }\\n        if (memo[start] != null) {\\n            return memo[start];\\n        }\\n        /* \\u6CE8\\u610F\\u5230recursion\\u7684\\u8BB0\\u5FC6\\u5316\\u641C\\u7D22\\u662F\\u6709\\u540E\\u6548\\u6027\\u7684\\uFF0Cmemo[]\\u7684\\u6539\\u53D8\\u662F\\u4ECE\\u540E\\u5F80\\u524D\\u8FDB\\u884C\\u7684\\n        \\u6BCF\\u6B21\\u5C1D\\u8BD5\\u4ECE\\u6700\\u77ED\\u7684\\u5728\\u5B57\\u5178\\u91CC\\u7684\\u5B57\\u7B26\\u4E32\\u5F00\\u59CB\\uFF0C\\u7136\\u540E\\u7EE7\\u7EED\\u641C\\u7D22\\u5269\\u4E0B\\u7684\\u5B50\\u4E32\\uFF0C\\u5982\\u679C\\u67D0\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u5F80\\u540E\\n        \\u662F\\u4E0D\\u53EF\\u80FD\\u7684\\uFF08for\\u5FAA\\u73AF\\u5B8C\\u5168\\u7ED3\\u675F\\uFF09\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u7684memo[i]\\u5C31\\u53D8\\u6210false.\\u4E0B\\u6B21\\u518D\\u641C\\u7D22\\u5230\\n        \\u8FD9\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u5C31\\u76F4\\u63A5\\u8FD4\\u56DEfalse\\u4E86\\u3002\\n        \\n        e.g. s = \"catsandogxxx\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\",\"xxx\"]\\n        \\u4E00\\u5F00\\u59CB\\u4F9D\\u6B21\\u641C\\u7D22\\u5230cat, sand\\uFF0C\\u7136\\u540E\\u53D1\\u73B0og\\u662F\\u4E0D\\u53EF\\u80FD\\u7684\\uFF0C\\u90A3\\u4E48o\\u4F4D\\u7F6E\\u7684memo\\u5C31\\u8BBE\\u4E3Afalse\\uFF0C\\u63A5\\u4E0B\\u6765sand\\n        \\u4E00\\u76F4\\u641C\\u5230sandogxxx\\uFF0C\\u90FD\\u6CA1\\u6709\\u5339\\u914D\\uFF0C\\u90A3\\u4E48s\\u4F4D\\u7F6E\\u7684memo\\u5C31\\u8BBE\\u4E3Afalse\\u3002\\u4E4B\\u540E\\u641C\\u7D22\\u5230cats, and\\uFF0C\\u6CE8\\u610F\\u5230\\n        \\u8FD9\\u91CC\\u63A5\\u4E0B\\u6765start\\u53D8\\u4E3Ao\\u7684\\u4F4D\\u7F6E\\uFF0C\\u8FD9\\u65F6\\u5019\\u4E0D\\u4F1A\\u518D\\u6B21\\u641C\\u7D22\\uFF0C\\u800C\\u662F\\u76F4\\u63A5\\u8FD4\\u56DE\\u8BB0\\u5FC6\\u4E2D\\u7684false!\\u56E0\\u4E3A\\u5B83\\u77E5\\u9053\\u4E86o\\u4E4B\\u540E\\n        \\u662F\\u6CA1\\u6709\\u6210\\u529F\\u7684\\u8DEF\\u7684\\u3002\\n        \\n        \\u6211\\u4EEC\\u8FD8\\u53EF\\u4EE5\\u518D\\u63D0\\u5347\\u641C\\u7D22\\u7684\\u6548\\u7387\\uFF0C\\u901A\\u8FC7\\u9650\\u5236\\u6BCF\\u6B21\\u641C\\u7D22\\u7684\\u957F\\u5EA6\\uFF0C\\u6BD4\\u5982\\u6211\\u4EEC\\u4E0D\\u9700\\u8981\\u4ECEsand\\u4E00\\u76F4\\u641C\\u5230sandogxxx\\uFF0C\\n        \\u6211\\u4EEC\\u901A\\u8FC7\\u5148\\u7B97\\u51FA\\u5B57\\u5178\\u91CC\\u6700\\u957F\\u5B57\\u7B26\\u4E32\\u7684\\u957F\\u5EA6\\uFF0C\\u7136\\u540E\\u6BCF\\u6B21\\u641C\\u7D22\\u90FD\\u9650\\u5236\\u5728\\u8FD9\\u4E2A\\u957F\\u5EA6\\u4EE5\\u5185\\u3002\\u5BF9\\u4E8E\\u5F88\\u957F\\u7684s\\uFF0C\\u8FD9\\u6837\\n        \\u80FD\\u63D0\\u9AD8\\u5F88\\u5927\\u7684\\u6548\\u7387\\u3002*/\\n        for (int end = start + 1; end <= s.length() && end - start <= maxLen; end++) {\\n            // \\u5B57\\u5178\\u5305\\u542B\\u5F53\\u524D\\u5B50\\u4E32(start, end)\\uFF0C\\u5982\\u679Cend\\u4E4B\\u540E\\u7684\\u5B50\\u4E32\\u8FD4\\u56DEtrue\\uFF0C\\u8BF4\\u660E\\n            if (wordDict.contains(s.substring(start, end)) && \\n                helper(s, wordDict, end, memo)) {\\n                return memo[start] = true;\\n            }\\n        }\\n        return memo[start] = false;\\n    }\\n    \\n    // DP solution, time O(n^2), space O(n)\\n    public boolean wordBreak1(String s, List<String> wordDict) {\\n        // get the max length of string in dict\\n        int maxLen = 0;\\n        for (String str : wordDict) {\\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        \\n        /* \\n        for current substring from 0 -> i, use j to iterate over 0 -> maxLen, \\n        and check whether:\\n        1. substring(i - j, i + 1) is in dict\\n        2. isBreak[i - j] == true\\n        */\\n        \\n        boolean[] isBreak = new boolean[s.length() + 1];\\n        isBreak[0] = true;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < maxLen && j <= i; j++) {\\n                String sub = s.substring(i - j, i + 1);\\n                if (wordDict.contains(sub) && isBreak[i - j]) {\\n                    isBreak[i + 1] = true;\\n                }\\n            }\\n        }\\n        return isBreak[s.length()];\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // get the max length of string in dict\\n    int maxLen = 0;\\n    // Recursion with memoization, time O(n^2), space O(n)\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for (String str : wordDict) {\\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        Set<String> set = new HashSet(wordDict);\\n        return helper(s, set, 0, new Boolean[s.length()]);\\n    }\\n    \\n    public boolean helper(String s, Set<String> wordDict, int start, Boolean[] memo) {\\n        if (start == s.length()) {\\n            return true;\\n        }\\n        if (memo[start] != null) {\\n            return memo[start];\\n        }\\n        /* \\u6CE8\\u610F\\u5230recursion\\u7684\\u8BB0\\u5FC6\\u5316\\u641C\\u7D22\\u662F\\u6709\\u540E\\u6548\\u6027\\u7684\\uFF0Cmemo[]\\u7684\\u6539\\u53D8\\u662F\\u4ECE\\u540E\\u5F80\\u524D\\u8FDB\\u884C\\u7684\\n        \\u6BCF\\u6B21\\u5C1D\\u8BD5\\u4ECE\\u6700\\u77ED\\u7684\\u5728\\u5B57\\u5178\\u91CC\\u7684\\u5B57\\u7B26\\u4E32\\u5F00\\u59CB\\uFF0C\\u7136\\u540E\\u7EE7\\u7EED\\u641C\\u7D22\\u5269\\u4E0B\\u7684\\u5B50\\u4E32\\uFF0C\\u5982\\u679C\\u67D0\\u4E00\\u4E2A\\u4F4D\\u7F6E\\u5F80\\u540E\\n        \\u662F\\u4E0D\\u53EF\\u80FD\\u7684\\uFF08for\\u5FAA\\u73AF\\u5B8C\\u5168\\u7ED3\\u675F\\uFF09\\uFF0C\\u90A3\\u4E48\\u8FD9\\u4E2A\\u4F4D\\u7F6E\\u7684memo[i]\\u5C31\\u53D8\\u6210false.\\u4E0B\\u6B21\\u518D\\u641C\\u7D22\\u5230\\n        \\u8FD9\\u4E2A\\u4F4D\\u7F6E\\uFF0C\\u5C31\\u76F4\\u63A5\\u8FD4\\u56DEfalse\\u4E86\\u3002\\n        \\n        e.g. s = \"catsandogxxx\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\",\"xxx\"]\\n        \\u4E00\\u5F00\\u59CB\\u4F9D\\u6B21\\u641C\\u7D22\\u5230cat, sand\\uFF0C\\u7136\\u540E\\u53D1\\u73B0og\\u662F\\u4E0D\\u53EF\\u80FD\\u7684\\uFF0C\\u90A3\\u4E48o\\u4F4D\\u7F6E\\u7684memo\\u5C31\\u8BBE\\u4E3Afalse\\uFF0C\\u63A5\\u4E0B\\u6765sand\\n        \\u4E00\\u76F4\\u641C\\u5230sandogxxx\\uFF0C\\u90FD\\u6CA1\\u6709\\u5339\\u914D\\uFF0C\\u90A3\\u4E48s\\u4F4D\\u7F6E\\u7684memo\\u5C31\\u8BBE\\u4E3Afalse\\u3002\\u4E4B\\u540E\\u641C\\u7D22\\u5230cats, and\\uFF0C\\u6CE8\\u610F\\u5230\\n        \\u8FD9\\u91CC\\u63A5\\u4E0B\\u6765start\\u53D8\\u4E3Ao\\u7684\\u4F4D\\u7F6E\\uFF0C\\u8FD9\\u65F6\\u5019\\u4E0D\\u4F1A\\u518D\\u6B21\\u641C\\u7D22\\uFF0C\\u800C\\u662F\\u76F4\\u63A5\\u8FD4\\u56DE\\u8BB0\\u5FC6\\u4E2D\\u7684false!\\u56E0\\u4E3A\\u5B83\\u77E5\\u9053\\u4E86o\\u4E4B\\u540E\\n        \\u662F\\u6CA1\\u6709\\u6210\\u529F\\u7684\\u8DEF\\u7684\\u3002\\n        \\n        \\u6211\\u4EEC\\u8FD8\\u53EF\\u4EE5\\u518D\\u63D0\\u5347\\u641C\\u7D22\\u7684\\u6548\\u7387\\uFF0C\\u901A\\u8FC7\\u9650\\u5236\\u6BCF\\u6B21\\u641C\\u7D22\\u7684\\u957F\\u5EA6\\uFF0C\\u6BD4\\u5982\\u6211\\u4EEC\\u4E0D\\u9700\\u8981\\u4ECEsand\\u4E00\\u76F4\\u641C\\u5230sandogxxx\\uFF0C\\n        \\u6211\\u4EEC\\u901A\\u8FC7\\u5148\\u7B97\\u51FA\\u5B57\\u5178\\u91CC\\u6700\\u957F\\u5B57\\u7B26\\u4E32\\u7684\\u957F\\u5EA6\\uFF0C\\u7136\\u540E\\u6BCF\\u6B21\\u641C\\u7D22\\u90FD\\u9650\\u5236\\u5728\\u8FD9\\u4E2A\\u957F\\u5EA6\\u4EE5\\u5185\\u3002\\u5BF9\\u4E8E\\u5F88\\u957F\\u7684s\\uFF0C\\u8FD9\\u6837\\n        \\u80FD\\u63D0\\u9AD8\\u5F88\\u5927\\u7684\\u6548\\u7387\\u3002*/\\n        for (int end = start + 1; end <= s.length() && end - start <= maxLen; end++) {\\n            // \\u5B57\\u5178\\u5305\\u542B\\u5F53\\u524D\\u5B50\\u4E32(start, end)\\uFF0C\\u5982\\u679Cend\\u4E4B\\u540E\\u7684\\u5B50\\u4E32\\u8FD4\\u56DEtrue\\uFF0C\\u8BF4\\u660E\\n            if (wordDict.contains(s.substring(start, end)) && \\n                helper(s, wordDict, end, memo)) {\\n                return memo[start] = true;\\n            }\\n        }\\n        return memo[start] = false;\\n    }\\n    \\n    // DP solution, time O(n^2), space O(n)\\n    public boolean wordBreak1(String s, List<String> wordDict) {\\n        // get the max length of string in dict\\n        int maxLen = 0;\\n        for (String str : wordDict) {\\n            maxLen = Math.max(maxLen, str.length());\\n        }\\n        \\n        /* \\n        for current substring from 0 -> i, use j to iterate over 0 -> maxLen, \\n        and check whether:\\n        1. substring(i - j, i + 1) is in dict\\n        2. isBreak[i - j] == true\\n        */\\n        \\n        boolean[] isBreak = new boolean[s.length() + 1];\\n        isBreak[0] = true;\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < maxLen && j <= i; j++) {\\n                String sub = s.substring(i - j, i + 1);\\n                if (wordDict.contains(sub) && isBreak[i - j]) {\\n                    isBreak[i + 1] = true;\\n                }\\n            }\\n        }\\n        return isBreak[s.length()];\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534354,
                "title": "c-easy-top-down-approach",
                "content": "```\\nclass Solution {\\n    int dp[301];\\n    //top-down approach\\n    int helper(int i, string s, set<string>&st)\\n    {\\n        if(i==s.size())\\n            return 1;\\n        string temp;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        for(int j=i;j<s.size();j++)\\n        {\\n            temp+=s[j];\\n            if(st.find(temp)!=st.end())\\n            {\\n                if(helper(j+1,s,st))\\n                    return dp[i]=1;\\n            }\\n        }\\n        return dp[i]=0;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        memset(dp,-1,sizeof(dp));\\n        for(auto a:wordDict)\\n        {\\n            st.insert(a);\\n        }\\n        return helper(0,s,st);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[301];\\n    //top-down approach\\n    int helper(int i, string s, set<string>&st)\\n    {\\n        if(i==s.size())\\n            return 1;\\n        string temp;\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        for(int j=i;j<s.size();j++)\\n        {\\n            temp+=s[j];\\n            if(st.find(temp)!=st.end())\\n            {\\n                if(helper(j+1,s,st))\\n                    return dp[i]=1;\\n            }\\n        }\\n        return dp[i]=0;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        memset(dp,-1,sizeof(dp));\\n        for(auto a:wordDict)\\n        {\\n            st.insert(a);\\n        }\\n        return helper(0,s,st);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500768,
                "title": "python-dp-memoization",
                "content": "```\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str],):\\n        \\n        \\n        memo = {}\\n        \\n        def memoize(target, wordDict):\\n            if target == \"\":\\n                return True\\n            if target in memo:\\n                return memo[target]\\n            \\n            for word in wordDict:\\n                if target[:len(word)] == word and memoize(target[len(word):], wordDict):\\n                    memo[target] = True\\n                    return memo[target]\\n            memo[target] = False\\n            return memo[target]\\n        \\n        return memoize(s, wordDict)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str],):\\n        \\n        \\n        memo = {}\\n        \\n        def memoize(target, wordDict):\\n            if target == \"\":\\n                return True\\n            if target in memo:\\n                return memo[target]\\n            \\n            for word in wordDict:\\n                if target[:len(word)] == word and memoize(target[len(word):], wordDict):\\n                    memo[target] = True\\n                    return memo[target]\\n            memo[target] = False\\n            return memo[target]\\n        \\n        return memoize(s, wordDict)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1215873,
                "title": "word-break-cpp-solution-recursive-memoization",
                "content": "\\nThe idea is to check every possible prefix of that string in the dictionary of words, if it is found in the dictionary, then the recursive function is called for the remaining portion of that string. And, if in some function call, it is found that the complete string is in dictionary, then it will return true.\\n\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(2^N), Space: O(N)\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(), wordDict.end(), s) != wordDict.end())\\n            return true;\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            string prefix = s.substr(0, i);\\n            \\n            //finding the prefix in the wordDict\\n            auto it = find(wordDict.begin(), wordDict.end(), prefix) != wordDict.end();\\n            \\n            //check for the remaining portion of string\\n            if(it && wordBreak(s.substr(i), wordDict))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Memoization**\\n```\\nclass Solution {\\npublic:\\n    //Time: O(N^3), Space: O(N)\\n    unordered_map<string, bool> memo;\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(), wordDict.end(), s) != wordDict.end())\\n            return true;\\n        \\n        //check before doing any further calculation\\n        if(memo.find(s) != memo.end()) return memo[s];\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            string prefix = s.substr(0, i);\\n            \\n            //finding the prefix in the wordDict\\n            auto it = find(wordDict.begin(), wordDict.end(), prefix) != wordDict.end();\\n            \\n            //check for the remaining portion of string\\n            if(it && wordBreak(s.substr(i), wordDict)){\\n                return memo[s] = true;   \\n            }\\n        }\\n        return memo[s] = false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(2^N), Space: O(N)\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(), wordDict.end(), s) != wordDict.end())\\n            return true;\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            string prefix = s.substr(0, i);\\n            \\n            //finding the prefix in the wordDict\\n            auto it = find(wordDict.begin(), wordDict.end(), prefix) != wordDict.end();\\n            \\n            //check for the remaining portion of string\\n            if(it && wordBreak(s.substr(i), wordDict))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Time: O(N^3), Space: O(N)\\n    unordered_map<string, bool> memo;\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(find(wordDict.begin(), wordDict.end(), s) != wordDict.end())\\n            return true;\\n        \\n        //check before doing any further calculation\\n        if(memo.find(s) != memo.end()) return memo[s];\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            string prefix = s.substr(0, i);\\n            \\n            //finding the prefix in the wordDict\\n            auto it = find(wordDict.begin(), wordDict.end(), prefix) != wordDict.end();\\n            \\n            //check for the remaining portion of string\\n            if(it && wordBreak(s.substr(i), wordDict)){\\n                return memo[s] = true;   \\n            }\\n        }\\n        return memo[s] = false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113876,
                "title": "efficient-trie-solution-with-explanation-o-len-s-length-of-longest-word",
                "content": "This implementation is based on @abhijith97 \\'s comment in the solution page discussion.  With this idea, we essentially go through the dp idea from solution #4 (in reverse), but match words to strings in s more efficiently.  In the official dp solution, we loop through each end point in s for substrings, then loop through each start point to the left or equal to the end point.  Then, we slice the substring of s from the start point to the end point: if the substring matches a word in wordDict, and the end of the previous word in s was also a match in the dp array, then we set the current word is a successful match in the dp array.  That process is O(n^3), because we loop through each pair of start/end points in O(n^2), and for each start/end point pair we substring s in O(n).\\n\\nWith the implementation here, we do the following: we begin by constructing a normal trie from the words in wordDict.  Then, we loop through the start points from the end to the beginning of the array (this is done so indices in s match indices in dp out of convenience, versus having the base case for the dp at the start of the dp array and shifting all the dp indices by 1, like in solution #4).  Starting at each start point in s, we then loop through characters in s while they allow us to step further into the trie.  At each character match, if that character marks the end of a word in the trie, AND the start of the following word is a successful dp match (similar idea to solution #4), then we mark the start of the current word as a successful match, and move to the next starting point.\\n\\nSo, for each starting point, we do a simple loop up to the maximum length of a word in the trie (rather than also looping through each corresponding endpoint and getting the substring).  Letting n be the length of string s, and k be the maximum length of a word in wordDict, the time complexity is O(nk).  The space complexity is the size of the wordDict, as we populate a trie using each word in wordDict.\\n\\nMy implementation differs from @abhijith97 \\'s comment in that I\\'ve adjusted the idea to go from the end to the beginning of s; this lets us construct the trie as normal (because we then loop through starting points of words, rather than ending points), and also lets the dp indicies match indicies in s which removes another headache.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        # construct a regular trie from all the words\\n        trie = {}\\n        \\n        for w in wordDict:\\n            root = trie\\n            \\n            for c in w:\\n                root = root.setdefault(c, {})\\n                \\n            root[None] = None # use None *key* as end of word marker\\n        \\n        # set up base case with dp, from end to beginning of word;\\n        # for a word to match a part of s, we require that the start\\n        # of the next word was a successful True match in dp.\\n        # so, we start with an additional True value at end of dp,\\n        # so when we begin by matching a word to the end of s,\\n        # the \"next word after\" is True as a base case\\n        dp = [False]*len(s) + [True]\\n        \\n        # do dp in reverse\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] in trie:\\n                # we can start matching our trie with char at position i\\n                root = trie\\n                j = i # j is a separate iterator for the word match\\n                \\n                # loop through characters in s while they\\n                # are also present in the trie\\n                while j < len(s) and s[j] in root:\\n                    root = root[s[j]]\\n                    \\n                    # if at any point we jump to a matching character,\\n                    # and that character marks the end of the word (None in root),\\n                    # and the following character in dp marks the start of\\n                    # a successful word (dp[j+1] == True), then we can mark the\\n                    # start of the current word at position i as True and be done;\\n                    # we just need to set this word at i once, so we don\\'t\\n                    # need to continue looping\\n                    if None in root and dp[j+1]:\\n                        dp[i] = 1\\n                        break\\n                    \\n                    j += 1\\n        \\n        # returns if we can match words from end to beginning of s\\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        # construct a regular trie from all the words\\n        trie = {}\\n        \\n        for w in wordDict:\\n            root = trie\\n            \\n            for c in w:\\n                root = root.setdefault(c, {})\\n                \\n            root[None] = None # use None *key* as end of word marker\\n        \\n        # set up base case with dp, from end to beginning of word;\\n        # for a word to match a part of s, we require that the start\\n        # of the next word was a successful True match in dp.\\n        # so, we start with an additional True value at end of dp,\\n        # so when we begin by matching a word to the end of s,\\n        # the \"next word after\" is True as a base case\\n        dp = [False]*len(s) + [True]\\n        \\n        # do dp in reverse\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] in trie:\\n                # we can start matching our trie with char at position i\\n                root = trie\\n                j = i # j is a separate iterator for the word match\\n                \\n                # loop through characters in s while they\\n                # are also present in the trie\\n                while j < len(s) and s[j] in root:\\n                    root = root[s[j]]\\n                    \\n                    # if at any point we jump to a matching character,\\n                    # and that character marks the end of the word (None in root),\\n                    # and the following character in dp marks the start of\\n                    # a successful word (dp[j+1] == True), then we can mark the\\n                    # start of the current word at position i as True and be done;\\n                    # we just need to set this word at i once, so we don\\'t\\n                    # need to continue looping\\n                    if None in root and dp[j+1]:\\n                        dp[i] = 1\\n                        break\\n                    \\n                    j += 1\\n        \\n        # returns if we can match words from end to beginning of s\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023786,
                "title": "trie-dfs-solution",
                "content": "I kind of jumped at the opportunity to use a trie here. It seems that the solutions here based off of using substrings are much simpler to read, yet may be slower if the dictionary has a large amount of strings with common prefixes. I am unsure of the time complexity here.\\n\\n```\\nclass Solution {\\n    class TrieNode{\\n        Character c;\\n        boolean isWord;\\n        HashMap<Character, TrieNode> children = new HashMap();\\n        \\n        TrieNode(){\\n            \\n        }\\n        \\n        TrieNode(Character c, boolean isWord){\\n            this.c = c;\\n            this.isWord = isWord;\\n        }\\n   }\\n    \\n    TrieNode trie = new TrieNode();\\n    boolean[] visited;\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        buildTrie(wordDict);\\n        visited = new boolean[s.length()];\\n        return traverseTree(s, 0);\\n    }\\n    \\n    public boolean traverseTree(String s, int idx){\\n        TrieNode curr = trie;\\n        //end state\\n        if(idx == s.length())\\n            return true;\\n        \\n        if(visited[idx] == true)\\n            return false;\\n        visited[idx] = true;\\n\\n        //traverse\\n        while(idx < s.length() && curr.children.containsKey(s.charAt(idx))){\\n            curr = curr.children.get(s.charAt(idx));\\n            if(curr.isWord){\\n                boolean answer = traverseTree(s, idx + 1);\\n                if(answer)\\n                    return true;\\n            }\\n            idx++;\\n        }\\n        \\n        //not found, back track or possibly exit\\n        return false;\\n    }\\n    \\n    private void buildTrie(List<String> wordDict){\\n        for(String s: wordDict){\\n            TrieNode curr = trie;\\n            for(int i = 0; i < s.length(); i++){\\n                if(!curr.children.containsKey(s.charAt(i)))\\n                    curr.children.put(s.charAt(i), new TrieNode(s.charAt(i), false));\\n                curr = curr.children.get(s.charAt(i));\\n                if(i == s.length() - 1)\\n                   curr.isWord = true;\\n            }\\n        }\\n    }\\n}```\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode{\\n        Character c;\\n        boolean isWord;\\n        HashMap<Character, TrieNode> children = new HashMap();\\n        \\n        TrieNode(){\\n            \\n        }\\n        \\n        TrieNode(Character c, boolean isWord){\\n            this.c = c;\\n            this.isWord = isWord;\\n        }\\n   }\\n    \\n    TrieNode trie = new TrieNode();\\n    boolean[] visited;\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        buildTrie(wordDict);\\n        visited = new boolean[s.length()];\\n        return traverseTree(s, 0);\\n    }\\n    \\n    public boolean traverseTree(String s, int idx){\\n        TrieNode curr = trie;\\n        //end state\\n        if(idx == s.length())\\n            return true;\\n        \\n        if(visited[idx] == true)\\n            return false;\\n        visited[idx] = true;\\n\\n        //traverse\\n        while(idx < s.length() && curr.children.containsKey(s.charAt(idx))){\\n            curr = curr.children.get(s.charAt(idx));\\n            if(curr.isWord){\\n                boolean answer = traverseTree(s, idx + 1);\\n                if(answer)\\n                    return true;\\n            }\\n            idx++;\\n        }\\n        \\n        //not found, back track or possibly exit\\n        return false;\\n    }\\n    \\n    private void buildTrie(List<String> wordDict){\\n        for(String s: wordDict){\\n            TrieNode curr = trie;\\n            for(int i = 0; i < s.length(); i++){\\n                if(!curr.children.containsKey(s.charAt(i)))\\n                    curr.children.put(s.charAt(i), new TrieNode(s.charAt(i), false));\\n                curr = curr.children.get(s.charAt(i));\\n                if(i == s.length() - 1)\\n                   curr.isWord = true;\\n            }\\n        }\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 870741,
                "title": "c-dp-different-approach-fast-beats-100-of-submissions-and-simple",
                "content": "\\n* This takes a slightly different approach to solving this problem in a more intuitive manner\\n* Maintain a dp where dp[i] indicates whether the string ending at s[i - 1] can be formed using words from wordDict\\n* Set dp[0] as true - since any empty string can be formed without using any words from the Word Dictionary\\n* Now from each i where dp[i] has been set as true, check each word of the dictionary to see if that string can be formed from i. If it\\'s possible, then set dp[i + word.size()] = true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int i, n = s.size();\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        for(i=0; i<n; i++) {\\n            if(!dp[i]) continue;\\n            for(auto word : wordDict) {\\n                int len = word.size();\\n                if(i + len > n) continue;\\n                if(word == s.substr(i, len)) \\n                    dp[i + len] = true;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int i, n = s.size();\\n        vector<bool> dp(n + 1, false);\\n        dp[0] = true;\\n        for(i=0; i<n; i++) {\\n            if(!dp[i]) continue;\\n            for(auto word : wordDict) {\\n                int len = word.size();\\n                if(i + len > n) continue;\\n                if(word == s.substr(i, len)) \\n                    dp[i + len] = true;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674046,
                "title": "javascript-bfs-with-comments",
                "content": "Basically, from every character index we build substrings up and until the end of the string. \\nE.g. given string s = \\'abcd\\', we start with index 0 to search from and build\\n0 : a\\n1: ab\\n2: abc\\n3: abcd\\n\\nuntil we find the word that is in the given dictionary. If we find a word and our search index is at the last character of s, then we are done. \\n```\\n// rephrased question: Can you build this string with the given dictionary?\\n// BFS approach\\nfunction wordBreak(s, wordDict) {\\n    // switch dict to a set for faster lookup\\n    const dictionary = new Set(wordDict);\\n\\n    let visited = new Set();\\n    let queue = [0]; // index of the letter where we will start searching from. Start with 0\\n\\n\\t// while we have character indexes left to search\\n    while (queue.length > 0) {\\n\\t    // take the latest added index, we will explore all words that begin with the character at this index\\n        const currentIndex = queue.shift();\\n        // if we haven\\'t explored the current index already\\n        if (!visited.has(currentIndex)) {\\n            // from the currentIndex we need all substrings up to the end of the string s\\n            for (let i = currentIndex; i < s.length; i++) {\\n                // get the current substring from current index exploring, to latest character i\\n                const substring = s.slice(currentIndex, i + 1); // (remember slice is not inclusive, so we need + 1 to get the full substr)\\n\\n                // if our dictionary contains the current substring, then we have all the letters we need for this word\\n                if (dictionary.has(substring)) {\\n                    // check if we are done searching (our search has searched until last character in s)\\n                    if (i === s.length - 1) { // if we are at the end of the string, and we have a word in the dictionary, it must be last word\\n                        return true; // done\\n                    }\\n                    // otherwise, we have all the letters we need for the word we just found, but we need to look for more words (not at end of s) \\n                    // so add the next unfound letter to our queue\\n                    queue.push(i + 1);\\n                }\\n            }\\n\\n            // we visited all we can for the current index, lets add it and move on\\n            visited.add(currentIndex);\\n        }\\n    }\\n\\n    // we didn\\'t find all the words, and ran out of elements to search in our queue\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n// rephrased question: Can you build this string with the given dictionary?\\n// BFS approach\\nfunction wordBreak(s, wordDict) {\\n    // switch dict to a set for faster lookup\\n    const dictionary = new Set(wordDict);\\n\\n    let visited = new Set();\\n    let queue = [0]; // index of the letter where we will start searching from. Start with 0\\n\\n\\t// while we have character indexes left to search\\n    while (queue.length > 0) {\\n\\t    // take the latest added index, we will explore all words that begin with the character at this index\\n        const currentIndex = queue.shift();\\n        // if we haven\\'t explored the current index already\\n        if (!visited.has(currentIndex)) {\\n            // from the currentIndex we need all substrings up to the end of the string s\\n            for (let i = currentIndex; i < s.length; i++) {\\n                // get the current substring from current index exploring, to latest character i\\n                const substring = s.slice(currentIndex, i + 1); // (remember slice is not inclusive, so we need + 1 to get the full substr)\\n\\n                // if our dictionary contains the current substring, then we have all the letters we need for this word\\n                if (dictionary.has(substring)) {\\n                    // check if we are done searching (our search has searched until last character in s)\\n                    if (i === s.length - 1) { // if we are at the end of the string, and we have a word in the dictionary, it must be last word\\n                        return true; // done\\n                    }\\n                    // otherwise, we have all the letters we need for the word we just found, but we need to look for more words (not at end of s) \\n                    // so add the next unfound letter to our queue\\n                    queue.push(i + 1);\\n                }\\n            }\\n\\n            // we visited all we can for the current index, lets add it and move on\\n            visited.add(currentIndex);\\n        }\\n    }\\n\\n    // we didn\\'t find all the words, and ran out of elements to search in our queue\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 523264,
                "title": "python3-one-minor-change-from-18-77-to-96-07",
                "content": "Just make the wordDict from a list to a set : )\\n\\n```\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        n = len(s)\\n\\t\\t# List->Set\\n        dic = set(wordDict)\\n\\n        dp = [False for _ in range(n + 1)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            for j in range(i+1, n+1):\\n                if dp[i] == True and s[i:j] in dic:\\n                    dp[j] = True\\n        \\n        return dp[-1]\\n```\\n![image](https://assets.leetcode.com/users/lenah/image_1583130194.png)\\n\\n\\n(1) Initialization\\uFF1A\\ndp = [False, ... , False], and length of dp is n+1.\\ndp[i] means if s[:i] is contained in wordDict.\\n\\n(2) Base case:\\nNull character is always contained, so dp[0] = True.\\n\\n(3) Tranversal:\\ndp[i] = True means that s[0,..., i) can be segmented into words in the dictionary. When s[i, ... , j) also appears in wordDict, dp[j] is True.\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        n = len(s)\\n\\t\\t# List->Set\\n        dic = set(wordDict)\\n\\n        dp = [False for _ in range(n + 1)]\\n        dp[0] = True\\n        \\n        for i in range(n):\\n            for j in range(i+1, n+1):\\n                if dp[i] == True and s[i:j] in dic:\\n                    dp[j] = True\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 43813,
                "title": "c-solution-using-trie",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct Node {\\n        bool isValid;\\n        Node* child[256];\\n    };\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        Node* root = new Node();\\n        for (auto& word : wordDict) {\\n            Node* tmp = root;\\n            for (auto& c : word)\\n                tmp = (tmp->child[c] ? tmp->child[c] : tmp->child[c] = new Node());\\n            tmp->isValid = true;\\n        }\\n        vector<bool> f(s.size(), false);\\n        f[0] = true;\\n        for (int i = 0; i < s.size(); ++ i)\\n            if (f[i]) {\\n                Node* tmp = root;\\n                for (int j = i; j < s.size(); ++ j) {\\n                    if (!tmp->child[s[j]]) break;\\n                    tmp = tmp->child[s[j]];\\n                    f[j + 1] = f[j + 1] || tmp->isValid;\\n                }\\n            }\\n        return f[(int)s.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Node {\\n        bool isValid;\\n        Node* child[256];\\n    };\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        Node* root = new Node();\\n        for (auto& word : wordDict) {\\n            Node* tmp = root;\\n            for (auto& c : word)\\n                tmp = (tmp->child[c] ? tmp->child[c] : tmp->child[c] = new Node());\\n            tmp->isValid = true;\\n        }\\n        vector<bool> f(s.size(), false);\\n        f[0] = true;\\n        for (int i = 0; i < s.size(); ++ i)\\n            if (f[i]) {\\n                Node* tmp = root;\\n                for (int j = i; j < s.size(); ++ j) {\\n                    if (!tmp->child[s[j]]) break;\\n                    tmp = tmp->child[s[j]];\\n                    f[j + 1] = f[j + 1] || tmp->isValid;\\n                }\\n            }\\n        return f[(int)s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43987,
                "title": "easy-to-understand-2ms-java-solution-using-dp",
                "content": "    public boolean wordBreak(String s, Set<String> wordDict) \\n    {\\n        int n = s.length();\\n        boolean[] canBreak = new boolean[1 + n];\\n        canBreak[n] = true;\\n        \\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            for(int j = i + 1; j <= n; ++j)\\n            {\\n                if(canBreak[j] && wordDict.contains(s.substring(i, j)))\\n                {\\n                    canBreak[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return canBreak[0];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public boolean wordBreak(String s, Set<String> wordDict) \\n    {\\n        int n = s.length();\\n        boolean[] canBreak = new boolean[1 + n];\\n        canBreak[n] = true;\\n        \\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            for(int j = i + 1; j <= n; ++j)\\n            {\\n                if(canBreak[j] && wordDict.contains(s.substring(i, j)))\\n                {\\n                    canBreak[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return canBreak[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43993,
                "title": "dp-using-c-4ms",
                "content": "    class Solution {\\n    public:\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        int m = s.length();\\n        \\n        bool *dp = new bool[m+1];\\n        for(int i = 0; i <= m; i ++) dp[i] = false;\\n        \\n        dp[0] = true;\\n        for(int i = 1; i <= m; i ++){\\n            for(int j = 1; j <= i; j ++){\\n                string tmp = s.substr(i - j, j);\\n                if(wordDict.find(tmp) != wordDict.end()){\\n                    dp[i] = dp[i-j];\\n                    if(dp[i]) break;\\n                }\\n            }\\n        }\\n        bool res = dp[m];\\n        delete [] dp;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        int m = s.length();\\n        \\n        bool *dp = new bool[m+1];\\n        for(int i = 0; i <= m; i ++) dp[i] = false;\\n        \\n        dp[0] = true;\\n        for(int i = 1; i <= m; i ++){\\n            for(int j = 1; j <= i; j ++){\\n                string tmp = s.substr(i - j, j);\\n                if(wordDict.find(tmp) != wordDict.end()){\\n                    dp[i] = dp[i-j];\\n                    if(dp[i]) break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44057,
                "title": "a-short-dp-c-solution",
                "content": "    public class Solution {\\n        public bool WordBreak(string s, ISet<string> wordDict) {\\n            int len = s.Length;\\n            bool[] f = new bool[len + 1];\\n            f[0] = true;\\n            for (int i = 1; i < len + 1; i++)\\n                for (int j = 0; j < i; j++)\\n                    if (f[j] && wordDict.Contains(s.Substring(j, i - j))){\\n                        f[i] = true;\\n                        break;\\n                    }\\n            return f[len];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public bool WordBreak(string s, ISet<string> wordDict) {\\n            int len = s.Length;\\n            bool[] f = new bool[len + 1];\\n            f[0] = true;\\n            for (int i = 1; i < len + 1; i++)\\n                for (int j = 0; j < i; j++)\\n                    if (f[j] && wordDict.Contains(s.Substring(j, i - j))){\\n                        f[i] = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3862716,
                "title": "simple-solution-explained-with-example-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI will explain two things \\n\\n**1) How do we start thinking when we such questions**\\n\\n**2) How do i write code for such a thing...**\\n\\nAnswer 1) \\n\\nYou are given a string , let us say **s=\"Leetcode\"** and your **array = [\"leet , \"code\",\"shit\"]**\\n\\nNow, how do i start, \\n\\nRemember this rule, When you can\\'t understand where to start, **just break the string in the lowest size possible...**\\n\\nSO, here Let us break..Leetcode into smallest size possible ..**that is \"L\", \"e\" , \"e\" ,\"t\" \"c\", \"o\", \"d\" ,\"e\"**...Are any of the chactarcters present in your array ... **your ans is  no**\\n\\nNow, let us move to the second smallest size possible .. that is..**\"le\",\"ee\" ,\"et\" , \"tc\" ,\"co\" ,\"od\" , \"de\"**..Are any of the strings presnt in your array..**The ans is no..**\\n\\nNow, Let us move to the **fourth smallest size possible**..that is **\"leet\", \"eetc\"...and so on..**.\\n\\nNow , you found **that atleast leet is present in your array**, Now once you find that** atleast somnething is presnt** ..we will start **forming strings again from the next index onwards..**\\n\\nLet me explain , After leet, we will again form **strings of size 1..****then 2 ..then 3 and so on.**..Let us say you again **find a string of size 4 which is present so**..you will again start the same process from the next index....\\n\\n**Now, how do we write the code for such a thing ...**\\n\\n```\\n        string x;\\n        bool ans  = false;\\n\\n        for(int k=i; k<s.size(); k++)\\n        {\\n            x+=s[k];\\n\\n            if(jd.find(x)!=jd.end())\\n            {\\n                ans = check(k+1,s,jd,dp);\\n                if(ans==true)\\n                {\\n                    dp[i] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n```\\n\\nNow, what will be the base case...\\n\\nLet us say after **incrementing the index \"i\"**, you reach the end of the string..**It means you were able to find all the combinations**..**so return a true...**\\n\\n```\\n  if(i==s.size())\\n    {\\n        return true;\\n    }\\n```\\n\\nNow, how do i memoize it...The ans is simple...\\n\\nWe know that , **only a single index \"i\" is changing**...so we will make a **1-d dp array** and **store 1 or 0**, if it is true we will **store 1 and if false , we will store a 0 in the dp array...**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are making a 1-d dp array and we are just iterating the string given to us so...**O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe made a 1-d dp array and a hash map , where the hashmap stores all the strings so it will be **O(N +M)**, where M will be the no of strings presnt in the array...\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int i,string &s,unordered_map<string,int>&jd, vector<int>&dp)\\n    {\\n\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n\\n        \\n        if(dp[i]!=-1)\\n        {\\n            if(dp[i]==1)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        string x;\\n        bool ans  = false;\\n\\n        for(int k=i; k<s.size(); k++)\\n        {\\n            x+=s[k];\\n\\n            if(jd.find(x)!=jd.end())\\n            {\\n                ans = check(k+1,s,jd,dp);\\n                if(ans==true)\\n                {\\n                    dp[i] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n\\n        if(ans==false)\\n        {\\n            dp[i]=0;\\n            \\n        }\\n        else\\n        {\\n            dp[i]=1;\\n        }\\n\\n      \\n\\n        return ans;\\n    }\\n\\n\\n    bool wordBreak(string s, vector<string>& worddict) {\\n        \\n        vector<int>dp(s.size(),-1);\\n        unordered_map<string,int>jd;\\n\\n        for(int i=0; i<worddict.size(); i++)\\n        {\\n            jd[worddict[i]]=0;\\n        }\\n\\n        bool z = check(0,s,jd,dp);\\n\\n        return z;\\n\\n    }\\n};\\n```\\n**TIME FOR A MEME NOW**\\n\\n![WhatsApp Image 2023-08-04 at 17.51.43.jpeg](https://assets.leetcode.com/users/images/e1154413-0781-46fc-87a0-bfa66c4fc659_1691151736.4184039.jpeg)\\n\\n# **IF YOU LIKE MY SOLUTION, PLEASE UPVOTEE.....**\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n        string x;\\n        bool ans  = false;\\n\\n        for(int k=i; k<s.size(); k++)\\n        {\\n            x+=s[k];\\n\\n            if(jd.find(x)!=jd.end())\\n            {\\n                ans = check(k+1,s,jd,dp);\\n                if(ans==true)\\n                {\\n                    dp[i] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n```\n```\\n  if(i==s.size())\\n    {\\n        return true;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\n    bool check(int i,string &s,unordered_map<string,int>&jd, vector<int>&dp)\\n    {\\n\\n        if(i==s.size())\\n        {\\n            return true;\\n        }\\n\\n        \\n        if(dp[i]!=-1)\\n        {\\n            if(dp[i]==1)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n\\n        string x;\\n        bool ans  = false;\\n\\n        for(int k=i; k<s.size(); k++)\\n        {\\n            x+=s[k];\\n\\n            if(jd.find(x)!=jd.end())\\n            {\\n                ans = check(k+1,s,jd,dp);\\n                if(ans==true)\\n                {\\n                    dp[i] = 1;\\n                    return true;\\n                } \\n            }\\n        }\\n\\n        if(ans==false)\\n        {\\n            dp[i]=0;\\n            \\n        }\\n        else\\n        {\\n            dp[i]=1;\\n        }\\n\\n      \\n\\n        return ans;\\n    }\\n\\n\\n    bool wordBreak(string s, vector<string>& worddict) {\\n        \\n        vector<int>dp(s.size(),-1);\\n        unordered_map<string,int>jd;\\n\\n        for(int i=0; i<worddict.size(); i++)\\n        {\\n            jd[worddict[i]]=0;\\n        }\\n\\n        bool z = check(0,s,jd,dp);\\n\\n        return z;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616181,
                "title": "amortized-linear-o-k-m-solution-using-aho-corasick-automaton",
                "content": "# Approach\\nI used an advanced data structure that can detect matches in one-pass. This data structure is called Aho-Corasick automaton. The present solutions in leetcode are at $$O(n^2)$$ solution. This solution runs at $$O(k + m)$$ at test time with an overhead of $$O(n)$$. I hope this helps you impress your future interviewer. (\\u25CD\\u2022\\u1D17\\u2022\\u25CD)\\n# Complexity\\n- Time complexity: $$O(n + k + m)$$\\nBuild Automaton: $$O(n)$$ where $$n$$ is the total number of characters in the dictionary.\\nTest segmentation: $$O(k + m)$$ where $$k$$ is the length of string to segment and $$m$$ represents the number of matches present between the dictionary and the string to segment.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n + m)$$\\nAutomaton: $$O(n + m)$$\\nDP Array: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.fail = None\\n        self.output = set()\\n\\n\\nclass AhoCorasick:\\n    def __init__(self, words):\\n        self.root = TrieNode()\\n        self.build_trie(words)\\n        self.build_fail()\\n\\n    def build_trie(self, words):\\n        for word in words:\\n            curr = self.root\\n            for c in word:\\n                curr = curr.children[c]\\n            curr.output.add(word)\\n    \\n    def build_fail(self):\\n        q = deque([self.root])\\n        while q:\\n            curr = q.popleft()\\n            for n, child in list(curr.children.items()):\\n                if curr is self.root:\\n                    child.fail = curr\\n                else:\\n                    p = curr.fail\\n                    while p is not self.root and n not in p.children:\\n                        p = p.fail\\n                    if n in p.children:\\n                        p = p.children[n]\\n                    child.fail = p\\n                    child.output.update(p.output)\\n                q.append(child)\\n\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        ac = AhoCorasick(wordDict)\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        curr = ac.root\\n        for i in range(n):\\n            c = s[i]\\n            while curr is not ac.root and c not in curr.children:\\n                curr = curr.fail\\n            if c in curr.children:\\n                curr = curr.children[c]\\n            else:\\n                return False\\n            \\n            for word in curr.output:\\n                start = i - len(word) + 1\\n                dp[i + 1] = dp[start] or dp[i + 1]\\n                if dp[i + 1]: break\\n        \\n        return dp[-1]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.fail = None\\n        self.output = set()\\n\\n\\nclass AhoCorasick:\\n    def __init__(self, words):\\n        self.root = TrieNode()\\n        self.build_trie(words)\\n        self.build_fail()\\n\\n    def build_trie(self, words):\\n        for word in words:\\n            curr = self.root\\n            for c in word:\\n                curr = curr.children[c]\\n            curr.output.add(word)\\n    \\n    def build_fail(self):\\n        q = deque([self.root])\\n        while q:\\n            curr = q.popleft()\\n            for n, child in list(curr.children.items()):\\n                if curr is self.root:\\n                    child.fail = curr\\n                else:\\n                    p = curr.fail\\n                    while p is not self.root and n not in p.children:\\n                        p = p.fail\\n                    if n in p.children:\\n                        p = p.children[n]\\n                    child.fail = p\\n                    child.output.update(p.output)\\n                q.append(child)\\n\\n\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        ac = AhoCorasick(wordDict)\\n        n = len(s)\\n        dp = [False] * (n + 1)\\n        dp[0] = True\\n        curr = ac.root\\n        for i in range(n):\\n            c = s[i]\\n            while curr is not ac.root and c not in curr.children:\\n                curr = curr.fail\\n            if c in curr.children:\\n                curr = curr.children[c]\\n            else:\\n                return False\\n            \\n            for word in curr.output:\\n                start = i - len(word) + 1\\n                dp[i + 1] = dp[start] or dp[i + 1]\\n                if dp[i + 1]: break\\n        \\n        return dp[-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621627,
                "title": "my-dp-c-solution-using-sliding-window",
                "content": "**Upvote If helpful please**\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> st(wordDict.begin(),wordDict.end());\\n        vector<bool> dp(s.size(),0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp=\"\";\\n            for(int j=i;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                if(st.find(temp)!=st.end())\\n                {\\n                    //cout<<temp<<\" \";\\n                    if(i==0)\\n                    {\\n                        dp[j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[j]=dp[i-1] or dp[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()-1];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> st(wordDict.begin(),wordDict.end());\\n        vector<bool> dp(s.size(),0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string temp=\"\";\\n            for(int j=i;j<s.size();j++)\\n            {\\n                temp+=s[j];\\n                if(st.find(temp)!=st.end())\\n                {\\n                    //cout<<temp<<\" \";\\n                    if(i==0)\\n                    {\\n                        dp[j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[j]=dp[i-1] or dp[j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1355839,
                "title": "c-simple-and-intuitive-solutions-top-down-and-bottom-up-dp",
                "content": "**1. Top Down DP Approach**\\n\\n```\\nclass Solution {\\n    unordered_map<string, int> dict;\\n    vector<vector<int> > dp;\\npublic:\\n    bool findSequence(int i, int j, string s, string curr){\\n        if(j >= s.size()){\\n            if(curr == \"\" or dict.find(curr) != dict.end()){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        if(dict.find(curr + s[j]) != dict.end()){\\n            return dp[i][j] = findSequence(i, j+1, s, curr+s[j]) || findSequence(j+1, j+1, s, \"\");\\n        }\\n        else{\\n            return dp[i][j] = findSequence(i, j+1, s, curr+s[j]);\\n        }\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int n = s.size();\\n        for(int i=0;i<wordDict.size();i++){\\n            dict[wordDict[i]] = 1;\\n        }\\n        \\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return findSequence(0, 0, s, \"\");\\n    }\\n};\\n```\\n\\n**2. Bottom Up DP Approach**\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(wordDict.size() == 0)\\n            return false;\\n        \\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        int longestWord = 0;\\n        for(string str: wordDict){\\n            longestWord = max(longestWord, (int)str.size());\\n        }\\n        \\n        int n = s.size();\\n        vector<bool> dp(n+1, false);\\n        dp[0] = true;\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = i-1; j >= max(i-longestWord, 0); j--){\\n                if(dp[j] == true){\\n                    if(dict.find(s.substr(j, i-j)) != dict.end()){\\n                        dp[i] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string, int> dict;\\n    vector<vector<int> > dp;\\npublic:\\n    bool findSequence(int i, int j, string s, string curr){\\n        if(j >= s.size()){\\n            if(curr == \"\" or dict.find(curr) != dict.end()){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        if(dict.find(curr + s[j]) != dict.end()){\\n            return dp[i][j] = findSequence(i, j+1, s, curr+s[j]) || findSequence(j+1, j+1, s, \"\");\\n        }\\n        else{\\n            return dp[i][j] = findSequence(i, j+1, s, curr+s[j]);\\n        }\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int n = s.size();\\n        for(int i=0;i<wordDict.size();i++){\\n            dict[wordDict[i]] = 1;\\n        }\\n        \\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return findSequence(0, 0, s, \"\");\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        if(wordDict.size() == 0)\\n            return false;\\n        \\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        int longestWord = 0;\\n        for(string str: wordDict){\\n            longestWord = max(longestWord, (int)str.size());\\n        }\\n        \\n        int n = s.size();\\n        vector<bool> dp(n+1, false);\\n        dp[0] = true;\\n        \\n        for(int i = 1; i <= n; i++){\\n            for(int j = i-1; j >= max(i-longestWord, 0); j--){\\n                if(dp[j] == true){\\n                    if(dict.find(s.substr(j, i-j)) != dict.end()){\\n                        dp[i] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178842,
                "title": "memoization-easy-matrix-chain-multiplication-aditya-verma-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    bool fun(string &s, int i, int j, vector<string> &dict)\\n    {\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        if(find(dict.begin(),dict.end(),s.substr(i,j-i+1))!=dict.end())\\n            return dp[i][j] = true;\\n        \\n        for(int k = i+1;k<=j;k++)\\n        {\\n            if(fun(s,i,k-1,dict) and fun(s,k,j,dict))\\n                return dp[i][j] = true;\\n        }\\n        \\n        return dp[i][j] = false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& dict) \\n    {   \\n        int n = s.size();\\n        \\n        int i = 0;\\n        int j = s.size()-1;\\n        \\n        dp.clear();\\n        dp.resize(n+1,vector<int> (n+1,-1));\\n        \\n        return fun(s,i,j,dict);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    bool fun(string &s, int i, int j, vector<string> &dict)\\n    {\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        if(find(dict.begin(),dict.end(),s.substr(i,j-i+1))!=dict.end())\\n            return dp[i][j] = true;\\n        \\n        for(int k = i+1;k<=j;k++)\\n        {\\n            if(fun(s,i,k-1,dict) and fun(s,k,j,dict))\\n                return dp[i][j] = true;\\n        }\\n        \\n        return dp[i][j] = false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& dict) \\n    {   \\n        int n = s.size();\\n        \\n        int i = 0;\\n        int j = s.size()-1;\\n        \\n        dp.clear();\\n        dp.resize(n+1,vector<int> (n+1,-1));\\n        \\n        return fun(s,i,j,dict);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880049,
                "title": "python-easiest-soln-top-down-dp-bottom-up-dp-dp-with-trie-soln-faster-than-90",
                "content": "**Top-down DP**\\n\\n```\\nclass Solution:\\n    def dp(self, s, dic, dp):   #Top-Down\\n        if s == \"\":\\n            return True\\n\\n        if s in dic:\\n            return True\\n\\n        if s in dp:\\n            return dp[s]\\n\\n        for i in range(1,len(s)+1):\\n            if s[:i] in dic and self.dp(s[i:],dic,dp):\\n                dp[s] = True\\n                return dp[s]\\n\\n        dp[s] = False\\n        return dp[s]\\n\\n    def wordBreak(self, s, dic):\\n        n = len(s)\\n        dp = {}\\n        return self.dp(s, dic,dp)\\n```\\n\\n**Bottom-Up**\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s, dic):   #Bottom-Up\\n        n = len(s)\\n        dp = [False for _ in range(n + 1)]\\n        dp[0] = True\\n        for i in range(1, n + 1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in dic:\\n                    dp[i] = True\\n\\n        return dp[-1]\\n```\\n\\n**DP with Trie**\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = {}\\n        self.terminal = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, w):\\n        n = len(w)\\n        head = self.root\\n        \\n        for i in range(n):\\n            if w[i] in head.child:\\n                head = head.child[w[i]]\\n            else:\\n                head.child[w[i]] = TrieNode()\\n                head = head.child[w[i]]\\n        \\n        head.terminal = True\\n    \\n    def search(self, w):\\n        n = len(w)\\n        head = self.root\\n        \\n        for i in range(n):\\n            if w[i] not in head.child:\\n                return False\\n            \\n            head = head.child[w[i]]\\n        \\n        return True if head.terminal else False\\n    \\nclass Solution:\\n    def wordBreak(self, s: str, dic: List[str]) -> bool:\\n        n = len(s)\\n        trie = Trie()\\n        for i in dic:\\n            trie.insert(i)\\n\\n        dp = [False for _ in range(n+1)]\\n        dp[0] = True\\n\\n        for i in range(1, n+1):\\n            for j in range(i):\\n                if dp[j] and trie.search(s[j:i]):\\n                    dp[i] = True\\n                    break\\n\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, s, dic, dp):   #Top-Down\\n        if s == \"\":\\n            return True\\n\\n        if s in dic:\\n            return True\\n\\n        if s in dp:\\n            return dp[s]\\n\\n        for i in range(1,len(s)+1):\\n            if s[:i] in dic and self.dp(s[i:],dic,dp):\\n                dp[s] = True\\n                return dp[s]\\n\\n        dp[s] = False\\n        return dp[s]\\n\\n    def wordBreak(self, s, dic):\\n        n = len(s)\\n        dp = {}\\n        return self.dp(s, dic,dp)\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s, dic):   #Bottom-Up\\n        n = len(s)\\n        dp = [False for _ in range(n + 1)]\\n        dp[0] = True\\n        for i in range(1, n + 1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in dic:\\n                    dp[i] = True\\n\\n        return dp[-1]\\n```\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.child = {}\\n        self.terminal = False\\n        \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, w):\\n        n = len(w)\\n        head = self.root\\n        \\n        for i in range(n):\\n            if w[i] in head.child:\\n                head = head.child[w[i]]\\n            else:\\n                head.child[w[i]] = TrieNode()\\n                head = head.child[w[i]]\\n        \\n        head.terminal = True\\n    \\n    def search(self, w):\\n        n = len(w)\\n        head = self.root\\n        \\n        for i in range(n):\\n            if w[i] not in head.child:\\n                return False\\n            \\n            head = head.child[w[i]]\\n        \\n        return True if head.terminal else False\\n    \\nclass Solution:\\n    def wordBreak(self, s: str, dic: List[str]) -> bool:\\n        n = len(s)\\n        trie = Trie()\\n        for i in dic:\\n            trie.insert(i)\\n\\n        dp = [False for _ in range(n+1)]\\n        dp[0] = True\\n\\n        for i in range(1, n+1):\\n            for j in range(i):\\n                if dp[j] and trie.search(s[j:i]):\\n                    dp[i] = True\\n                    break\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818969,
                "title": "c-trie-dp-o-n-l-space-o-n-l-time-complexity",
                "content": "\\tstruct TrieNode{\\n\\t\\tTrieNode *children[26];\\n\\t\\tbool isEnd;\\n    \\n\\t\\tTrieNode()\\n\\t\\t{\\n\\t\\t\\tfor(int i=0; i<26; i++)\\n\\t\\t\\t\\tchildren[i] = NULL;\\n\\t\\t\\tisEnd = false;\\n\\t\\t}\\n\\t};\\n\\n\\tTrieNode *root;\\n\\tvector<bool> dp;\\n\\n\\tvoid insert(string word)\\n\\t{\\n\\t\\tint n = word.size();\\n\\t\\tTrieNode *temp = root;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tint x = (int)(word[i] - \\'a\\');\\n\\t\\t\\tif(!temp->children[x])\\n\\t\\t\\t\\ttemp->children[x] = new TrieNode();\\n\\t\\t\\ttemp = temp->children[x];\\n\\t\\t}\\n\\t\\ttemp->isEnd = true;\\n\\t}\\n\\n\\tvoid search(string word, int start)\\n\\t{\\n\\t\\tint n = word.size();\\n\\t\\tTrieNode *temp = root;\\n\\t\\tfor(int i=start; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tint x = word[i] - \\'a\\';\\n\\t\\t\\tif(!temp->children[x])\\n\\t\\t\\t\\treturn;\\n\\t\\t\\ttemp = temp->children[x];\\n\\t\\t\\tif(temp->isEnd)\\n\\t\\t\\t\\tdp[i+1] = 1;\\n\\t\\t}\\n\\n\\t\\tif(temp->isEnd)\\n\\t\\t\\tdp[n] = 1;\\n\\t}\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool wordBreak(string s, vector<string>& A) {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t\\tint n = A.size(), l = s.size();\\n\\t\\t\\tdp.assign(l+1, 0);\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t\\tinsert(A[i]);\\n\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i=0; i<l; i++)\\n\\t\\t\\t\\tif(dp[i])\\n\\t\\t\\t\\t\\tsearch(s, i);\\n\\n\\t\\t\\treturn dp[l];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool wordBreak(string s, vector<string>& A) {\\n\\t\\t\\troot = new TrieNode();\\n\\t\\t\\tint n = A.size(), l = s.size();\\n\\t\\t\\tdp.assign(l+1, 0);\\n\\t\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t\\t\\tinsert(A[i]);\\n\\n\\t\\t\\tdp[0] = 1;\\n\\t\\t\\tfor(int i=0; i<l; i++)\\n\\t\\t\\t\\tif(dp[i])\\n\\t\\t\\t\\t\\tsearch(s, i);\\n\\n\\t\\t\\treturn dp[l];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 673369,
                "title": "java-simple-recursion-with-memoization-solution",
                "content": "\\nclass Solution {\\n    \\n    Map<String, Boolean> map = new HashMap<String,Boolean>();\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        \\n        if(s.length() == 0) return true;\\n        \\n        if(map.containsKey(s) && !map.get(s)) return false;\\n        for(String str:wordDict){\\n            \\n            int len = str.length();\\n            \\n            if(s.indexOf(str) == 0){\\n                \\n               if(wordBreak(s.substring(len),wordDict)){\\n                   return true;\\n               }\\n            }\\n            \\n            \\n        }\\n        map.put(s,false);\\n        return false;\\n    }\\n    \\n    \\n}\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    Map<String, Boolean> map = new HashMap<String,Boolean>();\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        \\n        if(s.length() == 0) return true;\\n        \\n        if(map.containsKey(s) && !map.get(s)) return false;\\n        for(String str:wordDict){\\n            \\n            int len = str.length();\\n            \\n            if(s.indexOf(str) == 0){\\n                \\n               if(wordBreak(s.substring(len),wordDict)){\\n                   return true;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 597051,
                "title": "java-dp-bfs-solutions-clean-code",
                "content": "```\\n// Bottom Up Dynamic Programming\\n// Time Complexity: O(n^2) quadratic\\n// Space Complexity:  O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        Set<String> dict = new HashSet<>(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1]; // Don\\'t forget +1 or you\\'ll get an index out of bounds error for dp[s.length()]\\n        dp[0] = true;\\n        \\n        for (int end = 0; end <= s.length(); end++) {\\n            for (int start = 0; start < end; start++) {\\n                if (dp[start] && dict.contains(s.substring(start, end))) {\\n                    dp[end] = true;\\n                    break; // Optional: Prevents unneccesary cycles after solution is found\\n                }\\n            }\\n        }\\n        \\n        return dp[s.length()];\\n    }\\n}\\n```\\n```\\n// Top Down Dynamic Programming - Recusion + Memoization\\n// Time Complexity: O(n^2) quadratic time\\n// Space Complexity: O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        return bckTrck(s, new HashSet<>(wordDict), 0, new Boolean[s.length()]);\\n    }\\n    \\n    public boolean bckTrck(String s, Set<String> dict, int idx, Boolean[] memo) {\\n        if (idx == s.length()) return true;\\n        \\n        if (memo[idx] != null) return memo[idx];\\n        \\n        for (int end = idx + 1; end <= s.length(); end++) {\\n            if (dict.contains(s.substring(idx, end)) && bckTrck(s, dict, end, memo)){\\n                memo[idx] = true;\\n                return true;\\n            } \\n        }\\n        \\n        memo[idx] = false;\\n        return false;\\n    }\\n}\\n```\\n```\\n// BFS\\n// Time Complexity: O(n^2) quadratic time\\n// Space Complexity: O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        Set<String> dict = new HashSet<>(wordDict);\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[s.length()];\\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            int start = q.poll();\\n            \\n            if (!visited[start]) {\\n                for (int end = start + 1; end <= s.length(); end++) {\\n                    if (dict.contains(s.substring(start, end))) {  \\n                        if (end == s.length()) return true;\\n                        \\n                        q.offer(end);\\n                    }\\n                }\\n                \\n                visited[start] = true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Bottom Up Dynamic Programming\\n// Time Complexity: O(n^2) quadratic\\n// Space Complexity:  O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        Set<String> dict = new HashSet<>(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1]; // Don\\'t forget +1 or you\\'ll get an index out of bounds error for dp[s.length()]\\n        dp[0] = true;\\n        \\n        for (int end = 0; end <= s.length(); end++) {\\n            for (int start = 0; start < end; start++) {\\n                if (dp[start] && dict.contains(s.substring(start, end))) {\\n                    dp[end] = true;\\n                    break; // Optional: Prevents unneccesary cycles after solution is found\\n                }\\n            }\\n        }\\n        \\n        return dp[s.length()];\\n    }\\n}\\n```\n```\\n// Top Down Dynamic Programming - Recusion + Memoization\\n// Time Complexity: O(n^2) quadratic time\\n// Space Complexity: O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        return bckTrck(s, new HashSet<>(wordDict), 0, new Boolean[s.length()]);\\n    }\\n    \\n    public boolean bckTrck(String s, Set<String> dict, int idx, Boolean[] memo) {\\n        if (idx == s.length()) return true;\\n        \\n        if (memo[idx] != null) return memo[idx];\\n        \\n        for (int end = idx + 1; end <= s.length(); end++) {\\n            if (dict.contains(s.substring(idx, end)) && bckTrck(s, dict, end, memo)){\\n                memo[idx] = true;\\n                return true;\\n            } \\n        }\\n        \\n        memo[idx] = false;\\n        return false;\\n    }\\n}\\n```\n```\\n// BFS\\n// Time Complexity: O(n^2) quadratic time\\n// Space Complexity: O(n) linear space\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {        \\n        Set<String> dict = new HashSet<>(wordDict);\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[s.length()];\\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            int start = q.poll();\\n            \\n            if (!visited[start]) {\\n                for (int end = start + 1; end <= s.length(); end++) {\\n                    if (dict.contains(s.substring(start, end))) {  \\n                        if (end == s.length()) return true;\\n                        \\n                        q.offer(end);\\n                    }\\n                }\\n                \\n                visited[start] = true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560793,
                "title": "c-dynamic-programming-with-explanation",
                "content": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n        if(wordDict.size()==0 || s.empty()) return false;\\n        int n = s.length();\\n        \\n        vector<bool> dp(n+1,false);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) { //fix the s.legth\\n            for(auto k : wordDict){ // find in dictionary\\n                int startIdx = i - k.size(); //start index of substring\\n                if(startIdx < 0 || dp[startIdx] == false) continue;\\n                if ( k == s.substr(startIdx, k.size())){ //compare substring with the element of wordDict\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n        if(wordDict.size()==0 || s.empty()) return false;\\n        int n = s.length();\\n        \\n        vector<bool> dp(n+1,false);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) { //fix the s.legth\\n            for(auto k : wordDict){ // find in dictionary\\n                int startIdx = i - k.size(); //start index of substring\\n                if(startIdx < 0 || dp[startIdx] == false) continue;\\n                if ( k == s.substr(startIdx, k.size())){ //compare substring with the element of wordDict\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 495603,
                "title": "python-simple-dp-idea-using-set-instead-of-list",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        wordDict = set(wordDict)\\n        \\n        # dp[i] means if s[:i] meets\\n        dp = [False for _ in range(n+1)]\\n        dp[0] = True\\n        \\n        for i in range(1, n+1):\\n            for j in range(i):\\n                sub_string = s[j:i]\\n                if dp[j] and sub_string in wordDict:\\n                    dp[i] = True\\n\\t\\t\\t\\t\\tbreak\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        wordDict = set(wordDict)\\n        \\n        # dp[i] means if s[:i] meets\\n        dp = [False for _ in range(n+1)]\\n        dp[0] = True\\n        \\n        for i in range(1, n+1):\\n            for j in range(i):\\n                sub_string = s[j:i]\\n                if dp[j] and sub_string in wordDict:\\n                    dp[i] = True\\n\\t\\t\\t\\t\\tbreak\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148450,
                "title": "clean-java-code-11-lines-5ms",
                "content": "```\\nclass Solution {\\n    Set<String> map = new HashSet();\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(wordDict.contains(s)) return true;\\n        if(map.contains(s)) return false;\\n        for(String word : wordDict){\\n            if(s.startsWith(word)){\\n                if(wordBreak(s.substring(word.length()), wordDict)) return true;\\n            }\\n        }\\n        map.add(s);\\n        return false;\\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<String> map = new HashSet();\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(wordDict.contains(s)) return true;\\n        if(map.contains(s)) return false;\\n        for(String word : wordDict){\\n            if(s.startsWith(word)){\\n                if(wordBreak(s.substring(word.length()), wordDict)) return true;\\n            }\\n        }\\n        map.add(s);\\n        return false;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138398,
                "title": "javascript-solution-using-bfs-and-memoization",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    if (wordDict.length === 0) return false;\\n    if (wordDict.length === 1) return s === wordDict[0];\\n    \\n    let queue = [\\'\\'];\\n    let memo = new Map();\\n    \\n    while (queue.length > 0) {\\n        const val = queue.shift();\\n        \\n        for (let word of wordDict) {\\n            const searchWord = `${val}${word}`;\\n            const startsWith = s.indexOf(searchWord) === 0;\\n            \\n            if (searchWord === s) return true;\\n            else if (!memo.has(searchWord) && startsWith) {\\n                memo.set(searchWord, true);\\n                queue.push(searchWord);\\n            }\\n        }\\n    }\\n    \\n    return false;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    if (wordDict.length === 0) return false;\\n    if (wordDict.length === 1) return s === wordDict[0];\\n    \\n    let queue = [\\'\\'];\\n    let memo = new Map();\\n    \\n    while (queue.length > 0) {\\n        const val = queue.shift();\\n        \\n        for (let word of wordDict) {\\n            const searchWord = `${val}${word}`;\\n            const startsWith = s.indexOf(searchWord) === 0;\\n            \\n            if (searchWord === s) return true;\\n            else if (!memo.has(searchWord) && startsWith) {\\n                memo.set(searchWord, true);\\n                queue.push(searchWord);\\n            }\\n        }\\n    }\\n    \\n    return false;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130922,
                "title": "python-dfs-98",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        start = 0\\n        stack = [start]\\n        visited = set()\\n        while stack:\\n            start = stack.pop()\\n            if start in visited:\\n                continue\\n            visited.add(start)\\n            for word in wordDict:\\n                if s[start:].startswith(word):\\n                    x = len(word)\\n                    if x == len(s[start:]):\\n                        return True\\n                    stack.append(start + x)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        start = 0\\n        stack = [start]\\n        visited = set()\\n        while stack:\\n            start = stack.pop()\\n            if start in visited:\\n                continue\\n            visited.add(start)\\n            for word in wordDict:\\n                if s[start:].startswith(word):\\n                    x = len(word)\\n                    if x == len(s[start:]):\\n                        return True\\n                    stack.append(start + x)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862763,
                "title": "python-easy-explanation",
                "content": "# Intuition\\nTo solve this problem, we can use dynamic programming.\\n\\n# Approach\\nWe\\'ll define a boolean array dp of length n+1, where n is the length of the input string s. dp[i] will be true if the substring s[0:i] can be segmented into space-separated sequences of words from the wordDict.\\n\\nThe idea is to iterate through the string s and check if any substring ending at index i can be formed using words from the wordDict. To do this, we\\'ll check if there is any index j such that dp[j] is true (meaning s[0:j] can be segmented) and the substring s[j:i] (s[j:i] is the substring from index j to i-1) is present in the wordDict.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        n= len(s)\\n        dp= [False] * (n+1)\\n        dp[0]= True\\n\\n        for i in range(1,n+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i]=True\\n                    break\\n        return dp[n]\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        n= len(s)\\n        dp= [False] * (n+1)\\n        dp[0]= True\\n\\n        for i in range(1,n+1):\\n            for j in range(i):\\n                if dp[j] and s[j:i] in wordDict:\\n                    dp[i]=True\\n                    break\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860723,
                "title": "easy-intutive-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are trying to partition the string in the best possible way.\\nFor a particular index we\\'re trying to find the maximum length of the string that can be formed from the current index that is present in the dictionary.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the recursive solution would have a exponential complexity, we\\'ll be using memoization and bring it down to O(n) (n=given string length).\\nWe\\'ve further optimized our searching time by using hashmap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n m=wordDict size hashmap, n=given string length\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n+m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(int ind,string&s,unordered_map<string,int>&mp,vector<int>&dp) \\n    {\\n        if(ind==s.length()) \\n         return 0;\\n        if(dp[ind]!=-1) \\n         return dp[ind];\\n        string tmp=\"\";\\n        int len=0; \\n        for(int j=ind;j<s.length();j++) \\n        {\\n            tmp+=s[j]; \\n            if(mp[tmp]) \\n            {   \\n                len=max(len,(j-ind+1)+fun(j+1,s,mp,dp));\\n            }   \\n        } \\n        return dp[ind]=len;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,int>mp;\\n        for(auto it:wordDict) \\n            mp[it]++;\\n        int n=s.length();\\n            vector<int>dp(n,-1);\\n        return fun(0,s,mp,dp)==s.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int ind,string&s,unordered_map<string,int>&mp,vector<int>&dp) \\n    {\\n        if(ind==s.length()) \\n         return 0;\\n        if(dp[ind]!=-1) \\n         return dp[ind];\\n        string tmp=\"\";\\n        int len=0; \\n        for(int j=ind;j<s.length();j++) \\n        {\\n            tmp+=s[j]; \\n            if(mp[tmp]) \\n            {   \\n                len=max(len,(j-ind+1)+fun(j+1,s,mp,dp));\\n            }   \\n        } \\n        return dp[ind]=len;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,int>mp;\\n        for(auto it:wordDict) \\n            mp[it]++;\\n        int n=s.length();\\n            vector<int>dp(n,-1);\\n        return fun(0,s,mp,dp)==s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860474,
                "title": "easy-recursive-dfs-c-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    bool solve(int i, string s, vector<string>& wordDict){\\n        if (i < 0) return 1;\\n        if (dp[i] != -1) return dp[i] == 1;\\n        for (string& w : wordDict) {\\n            int sz = w.size();\\n            if (i - sz + 1 < 0) continue;\\n            if (s.rfind(w, i-sz+1)== i-sz+1 && solve(i - sz, s, wordDict)) {\\n                dp[i] = 1;\\n                return 1;\\n            }\\n        }\\n        dp[i] = 0;\\n        return 0;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int&& n = s.size();\\n        dp.assign(n, -1);\\n        return solve(n - 1, s, wordDict );\\n    }\\n};\\n\\n\\n\\n```\\n# Python code\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [-1] * n\\n\\n        def solve(i, s):\\n            if i < 0:\\n                return True\\n            if dp[i] != -1:\\n                return dp[i] == 1\\n            for w in wordDict:\\n                sz = len(w)\\n                if i-sz+1 >= 0 and s[i-sz+1:i+1] == w:\\n                    if solve(i - sz, s):\\n                        dp[i] = 1\\n                        return True\\n            dp[i] = 0\\n            return False\\n\\n        return solve(n-1, s)\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    bool solve(int i, string s, vector<string>& wordDict){\\n        if (i < 0) return 1;\\n        if (dp[i] != -1) return dp[i] == 1;\\n        for (string& w : wordDict) {\\n            int sz = w.size();\\n            if (i - sz + 1 < 0) continue;\\n            if (s.rfind(w, i-sz+1)== i-sz+1 && solve(i - sz, s, wordDict)) {\\n                dp[i] = 1;\\n                return 1;\\n            }\\n        }\\n        dp[i] = 0;\\n        return 0;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int&& n = s.size();\\n        dp.assign(n, -1);\\n        return solve(n - 1, s, wordDict );\\n    }\\n};\\n\\n\\n\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        n = len(s)\\n        dp = [-1] * n\\n\\n        def solve(i, s):\\n            if i < 0:\\n                return True\\n            if dp[i] != -1:\\n                return dp[i] == 1\\n            for w in wordDict:\\n                sz = len(w)\\n                if i-sz+1 >= 0 and s[i-sz+1:i+1] == w:\\n                    if solve(i - sz, s):\\n                        dp[i] = 1\\n                        return True\\n            dp[i] = 0\\n            return False\\n\\n        return solve(n-1, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328049,
                "title": "c-faster-96-recursive-iterative",
                "content": "**Intuition**\\nBoth approaches attempt to create a substring starting from a particular position, and when a word from the dictionary is identified, they branch out to explore alternate paths from the next index.\\n\\nFirst, I tried the `recursive approach` which was easier to reason about.\\n\\n**Recursive Approach**\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> bag(dict.begin(), dict.end());\\n        unordered_map<int, bool> cache;\\n\\t\\t\\n        // Define a recursive function to solve the problem\\n        function<bool(int)> go = [&](auto start) {\\n            // Base case: if we have reached the end of the string, return true\\n            if (start == s.size()) return true;\\n            // Check if we have already solved this subproblem\\n            if (cache.count(start)) return cache[start];\\n            \\n            // Otherwise, try all possible ways to split the string from the current position\\n            bool is_possible = false;\\n            string builder = \"\";\\n            for (int i = start; i < s.size(); i++) {\\n                builder += s[i];\\n                if (bag.count(builder)) is_possible |= go(i + 1);\\n            }\\n            // Memoize the result of this subproblem and return it\\n            return cache[start] = is_possible;\\n        };\\n\\t\\t\\n        // Solve the problem starting from the beginning of the string\\n        return go(0);\\n    }\\n};\\n```\\n\\nHowever, as the recursive approach was slower, I converted it to iterative resulting in 96% faster solution.\\n\\n**Iterative Approach**\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> bag(dict.begin(), dict.end());\\n        \\n        // Create a vector of boolean values, initialized to false, \\n        // to store whether a substring of s can be broken into words\\n        vector<bool> dp(s.size() + 1, false);\\n        \\n        // Set the value of dp[0] to true, as an empty string can always be broken into words\\n        dp[0] = true;\\n        \\n        // Create a queue to store the starting index of the substring to be processed\\n        queue<int> q; q.push(0);\\n        \\n        // Loop through the queue until it is empty\\n        while (q.size()) {\\n            // Get the starting index of the next substring to be processed\\n            auto start = q.front(); q.pop();\\n            \\n            // If we\\'ve processed the entire string, skip\\n            if (start == s.size()) continue;\\n            \\n            // Create a string to store the current substring being built\\n            string builder = \"\";\\n            \\n            // Loop through the remaining characters of s, starting from the current index\\n            for (int i = start; i < s.size(); i++) {\\n                // Add the current character to the builder string\\n                builder += s[i];\\n                \\n                // If the builder string is in the dictionary, and the previous substring (dp[start]) \\n                // can be broken into words, and the current substring has not been processed yet (not dp[i + 1]), \\n                // mark the current substring as being able to be broken into words, and add the \\n                // starting index of the next substring to the queue to be processed later\\n                if (bag.count(builder) && dp[start] && !dp[i + 1]) {\\n                    q.push(i + 1);\\n                    dp[i + 1] = true;\\n                }\\n            }\\n        }\\n        \\n        // Return the value of the last element of the dp array, which represents whether \\n        // the entire string can be broken into words\\n        return dp[s.size()];\\n    }\\n};\\n```\\n\\n**Similar Problem** \\n- [Word Break II](https://leetcode.com/problems/word-break-ii/discuss/3328288/C%2B%2B-oror-Recursive-solution)\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [github repo](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> bag(dict.begin(), dict.end());\\n        unordered_map<int, bool> cache;\\n\\t\\t\\n        // Define a recursive function to solve the problem\\n        function<bool(int)> go = [&](auto start) {\\n            // Base case: if we have reached the end of the string, return true\\n            if (start == s.size()) return true;\\n            // Check if we have already solved this subproblem\\n            if (cache.count(start)) return cache[start];\\n            \\n            // Otherwise, try all possible ways to split the string from the current position\\n            bool is_possible = false;\\n            string builder = \"\";\\n            for (int i = start; i < s.size(); i++) {\\n                builder += s[i];\\n                if (bag.count(builder)) is_possible |= go(i + 1);\\n            }\\n            // Memoize the result of this subproblem and return it\\n            return cache[start] = is_possible;\\n        };\\n\\t\\t\\n        // Solve the problem starting from the beginning of the string\\n        return go(0);\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> bag(dict.begin(), dict.end());\\n        \\n        // Create a vector of boolean values, initialized to false, \\n        // to store whether a substring of s can be broken into words\\n        vector<bool> dp(s.size() + 1, false);\\n        \\n        // Set the value of dp[0] to true, as an empty string can always be broken into words\\n        dp[0] = true;\\n        \\n        // Create a queue to store the starting index of the substring to be processed\\n        queue<int> q; q.push(0);\\n        \\n        // Loop through the queue until it is empty\\n        while (q.size()) {\\n            // Get the starting index of the next substring to be processed\\n            auto start = q.front(); q.pop();\\n            \\n            // If we\\'ve processed the entire string, skip\\n            if (start == s.size()) continue;\\n            \\n            // Create a string to store the current substring being built\\n            string builder = \"\";\\n            \\n            // Loop through the remaining characters of s, starting from the current index\\n            for (int i = start; i < s.size(); i++) {\\n                // Add the current character to the builder string\\n                builder += s[i];\\n                \\n                // If the builder string is in the dictionary, and the previous substring (dp[start]) \\n                // can be broken into words, and the current substring has not been processed yet (not dp[i + 1]), \\n                // mark the current substring as being able to be broken into words, and add the \\n                // starting index of the next substring to the queue to be processed later\\n                if (bag.count(builder) && dp[start] && !dp[i + 1]) {\\n                    q.push(i + 1);\\n                    dp[i + 1] = true;\\n                }\\n            }\\n        }\\n        \\n        // Return the value of the last element of the dp array, which represents whether \\n        // the entire string can be broken into words\\n        return dp[s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943110,
                "title": "c-dp-easy-and-fast-100",
                "content": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    vector<int> dp;\\n\\n    bool dfs(int i, string s, vector<string>& wordDict){\\n        if(i == n)\\n            return true;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n        for(auto word : wordDict){\\n            int sz = word.size();\\n            if(sz > n-i)\\n                continue;\\n            string newWord = s.substr(i, sz);\\n\\n            if(word == newWord)\\n                ans |= dfs(i+sz, s, wordDict);\\n\\n            dp[i] = ans;\\n            if(ans == true)\\n                return ans;\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        n = s.size();\\n\\n        dp = vector<int>(n, -1);\\n        return dfs(0, s, wordDict);\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/8b410b2a-8874-4747-83be-08a23177505b_1671818287.144914.png){:style=\\'width:300px\\'}",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    int n;\\n    vector<int> dp;\\n\\n    bool dfs(int i, string s, vector<string>& wordDict){\\n        if(i == n)\\n            return true;\\n        \\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        bool ans = false;\\n        for(auto word : wordDict){\\n            int sz = word.size();\\n            if(sz > n-i)\\n                continue;\\n            string newWord = s.substr(i, sz);\\n\\n            if(word == newWord)\\n                ans |= dfs(i+sz, s, wordDict);\\n\\n            dp[i] = ans;\\n            if(ans == true)\\n                return ans;\\n        }\\n\\n        return ans;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        n = s.size();\\n\\n        dp = vector<int>(n, -1);\\n        return dfs(0, s, wordDict);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442365,
                "title": "java-dp-1ms-99-91-dp",
                "content": "Key Optimization over standard DP:\\n1. sort all unique length in wordDict by ascending order \\n2. iterate over len only, when length is more than sub-problem length, no need to check further\\n\\n```java\\nclass Solution {\\n    Set<String> set = new HashSet<>();\\n    int[] lens;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        // create unique and ascending word length array\\n        int n = s.length(), j;\\n        prep(set, wordDict, n);\\n        boolean[] dp = new boolean[n+1];\\n\\n        // start dp\\n        dp[0] = true;\\n        for (int i = 1; i <= n; i++) for (int x : lens) { // inner loop: iterate over len\\n            if ((j = i - x) < 0) break; // key: early termination on len\\n            if (dp[j] && set.contains(s.substring(j, i))) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private void prep(Set<String> set, List<String> wordDict, int n) {\\n        Set<Integer> lenSet = new HashSet<>();\\n        for (String w : wordDict) {\\n            set.add(w);\\n            lenSet.add(w.length());\\n        }\\n\\n        // convert lenSet to int[] and sort it for speed and early termination\\n        lens = new int[lenSet.size()]; int k = 0;\\n        for (int x : lenSet) lens[k++] = x;\\n        Arrays.sort(lens);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    Set<String> set = new HashSet<>();\\n    int[] lens;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        // create unique and ascending word length array\\n        int n = s.length(), j;\\n        prep(set, wordDict, n);\\n        boolean[] dp = new boolean[n+1];\\n\\n        // start dp\\n        dp[0] = true;\\n        for (int i = 1; i <= n; i++) for (int x : lens) { // inner loop: iterate over len\\n            if ((j = i - x) < 0) break; // key: early termination on len\\n            if (dp[j] && set.contains(s.substring(j, i))) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n        return dp[n];\\n    }\\n\\n    private void prep(Set<String> set, List<String> wordDict, int n) {\\n        Set<Integer> lenSet = new HashSet<>();\\n        for (String w : wordDict) {\\n            set.add(w);\\n            lenSet.add(w.length());\\n        }\\n\\n        // convert lenSet to int[] and sort it for speed and early termination\\n        lens = new int[lenSet.size()]; int k = 0;\\n        for (int x : lenSet) lens[k++] = x;\\n        Arrays.sort(lens);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316020,
                "title": "c-dp-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool>dp(s.size(),false);\\n        dp[0]=true;\\n        \\n        for(int i = 0; i <= s.size(); i++)\\n        {\\n            for(auto str: wordDict)\\n            {\\n                if(dp[i])\\n                {\\n                    if(s.substr(i,str.size()).compare(str)==0)\\n                    {\\n                        dp[i+str.size()]=true;\\n                    }\\n                }\\n            }\\n        }return dp[s.size()];    \\n    }\\n};\\n```\\n**Please Upvote!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        vector<bool>dp(s.size(),false);\\n        dp[0]=true;\\n        \\n        for(int i = 0; i <= s.size(); i++)\\n        {\\n            for(auto str: wordDict)\\n            {\\n                if(dp[i])\\n                {\\n                    if(s.substr(i,str.size()).compare(str)==0)\\n                    {\\n                        dp[i+str.size()]=true;\\n                    }\\n                }\\n            }\\n        }return dp[s.size()];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101379,
                "title": "0ms-100-fast-top-down-dp-solution",
                "content": "Here to optimize the time and space compleixity I\\'ve passed the string by reference and used \"short\" data type instead of \"int\" to store the dp values!\\nI\\'ve used an unordered map to store the frequency of all the strings, and then used recursion + memorization.\\n\\nFeel free to share any opinions (o\\uFF9F\\u25BD\\uFF9F)o\\n```\\nclass Solution {\\npublic:\\n    bool partition(int curr,int last_break,string &s,unordered_map<string,int>& m,short dp[],int mx)\\n    {\\n        if(dp[last_break]!=-1) \\n            return dp[last_break]; // returning the ans stored in dp[last_break] as we\\'ve encountered this case in past\\n        if(last_break-curr>mx)\\n            return dp[last_break]=0;  // returning 0 in case the length difference becomes greater than the max length of strings\\n        if(curr==0)\\n        {\\n            string t=s.substr(curr,last_break-curr);\\n            if(m[t]>0)\\n            return 1;\\n            return 0;\\n        }\\n        string t=s.substr(curr,last_break-curr);\\n        if(m[t]>0)  // checking if there exists a substring from curr_index to last_break-1 in the dictionary\\n        {\\n            if(partition(curr-1,curr,s,m,dp,mx))\\n            return dp[curr]=1;  // if yes then returning 1 as the answer\\n            dp[curr]=0;\\n        }\\n        if(partition(curr-1,last_break,s,m,dp,mx))\\n        return dp[last_break]=1;\\n        return dp[last_break]=0;\\n    }\\n    int wordBreak(string A, vector<string> &B) {\\n        //code here\\n        unordered_map<string,int> m;\\n        int n=A.size();\\n        short dp[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=-1;\\n        int mx=0;\\n        for(auto it: B)\\n        {\\n            m[it]++;\\n            if(it.size()>mx)\\n                mx=it.size();\\n        }\\n        if(partition(n-1,n,A,m,dp,mx))\\n        return 1;\\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool partition(int curr,int last_break,string &s,unordered_map<string,int>& m,short dp[],int mx)\\n    {\\n        if(dp[last_break]!=-1) \\n            return dp[last_break]; // returning the ans stored in dp[last_break] as we\\'ve encountered this case in past\\n        if(last_break-curr>mx)\\n            return dp[last_break]=0;  // returning 0 in case the length difference becomes greater than the max length of strings\\n        if(curr==0)\\n        {\\n            string t=s.substr(curr,last_break-curr);\\n            if(m[t]>0)\\n            return 1;\\n            return 0;\\n        }\\n        string t=s.substr(curr,last_break-curr);\\n        if(m[t]>0)  // checking if there exists a substring from curr_index to last_break-1 in the dictionary\\n        {\\n            if(partition(curr-1,curr,s,m,dp,mx))\\n            return dp[curr]=1;  // if yes then returning 1 as the answer\\n            dp[curr]=0;\\n        }\\n        if(partition(curr-1,last_break,s,m,dp,mx))\\n        return dp[last_break]=1;\\n        return dp[last_break]=0;\\n    }\\n    int wordBreak(string A, vector<string> &B) {\\n        //code here\\n        unordered_map<string,int> m;\\n        int n=A.size();\\n        short dp[n+1];\\n        for(int i=0;i<=n;i++)\\n            dp[i]=-1;\\n        int mx=0;\\n        for(auto it: B)\\n        {\\n            m[it]++;\\n            if(it.size()>mx)\\n                mx=it.size();\\n        }\\n        if(partition(n-1,n,A,m,dp,mx))\\n        return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665660,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func wordBreak(_ s: String, _ wd: [String]) -> Bool {\\n        guard !s.isEmpty else { return false }\\n        let len = s.count, wdset = Set(wd)\\n        let arrS = Array(s), maxw = wdset.reduce(0, { max($0, $1.count) })\\n        \\n        var dp = [Bool](repeating: false, count: len + 1)\\n        dp[0] = true\\n        \\n        for a in 0..<len where dp[a] {\\n            for b in a + 1...(min(len, a + 1 + maxw)) where wdset.contains(String(arrS[a..<b])) {\\n                dp[b] = true\\n            }\\n        }\\n        return dp[len]\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.016 (0.018) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Return true because \"leetcode\" can be segmented as \"leet code\".\\n    func test0() {\\n        let value = solution.wordBreak(\"leetcode\", [\"leet\",\"code\"])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    // Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"applepenapple\", [\"apple\",\"pen\"])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func wordBreak(_ s: String, _ wd: [String]) -> Bool {\\n        guard !s.isEmpty else { return false }\\n        let len = s.count, wdset = Set(wd)\\n        let arrS = Array(s), maxw = wdset.reduce(0, { max($0, $1.count) })\\n        \\n        var dp = [Bool](repeating: false, count: len + 1)\\n        dp[0] = true\\n        \\n        for a in 0..<len where dp[a] {\\n            for b in a + 1...(min(len, a + 1 + maxw)) where wdset.contains(String(arrS[a..<b])) {\\n                dp[b] = true\\n            }\\n        }\\n        return dp[len]\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Return true because \"leetcode\" can be segmented as \"leet code\".\\n    func test0() {\\n        let value = solution.wordBreak(\"leetcode\", [\"leet\",\"code\"])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    // Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"applepenapple\", [\"apple\",\"pen\"])\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064004,
                "title": "python-code-using-dp-with-visualization-and-explanation",
                "content": "I found out many of posts even though said `detailed explanation` and `easy to understand` but they didnt put or barly put explanation there... \\nSo here you are:\\n\\nLet\\'s use the string \"catsandog\" as an example. By using dp, the foundamental logic is we divide the string to two parts: prefix and right side string. Let\\'s say prefix is \"c\" then rightside is \"atsandog\" etc. Then we initialize a array with the length len(s) + 1 and for index 0 with True and all other with False. So it will be:\\n`prefixChecks = [T, F,F,F,F,F,F,F,F, F]` which represent the string `_catsandog`. Before `c` there should be a empty string and we can think of empty string is always existed in both string and word_dic so that\\'s why we initialized with True here.\\n\\nThen we have a nested loop, `isPrefixDecmposed` will get if the prefix before the current index whether is decomposable which measn it existed in word_dict. If it is and our rightside of current idx, which also included, is also in word_dict, then we update `prefixChecks[i] = True` and break inner loop.\\n\\n\\n```\\ndef wordBreak(strings, wordDict):\\n    prefixChecks = [False for i in range(len(strings) + 1)]\\n    prefixChecks[0] = True\\n\\n    for i in range(len(strings) + 1):\\n        for j in range(i):\\n            isPrefixDecmposed = prefixChecks[j]\\n            rightSideString = strings[j:i]\\n            if isPrefixDecmposed and rightSideString in wordDict:\\n                prefixChecks[i] = True\\n                break\\n    return prefixChecks[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef wordBreak(strings, wordDict):\\n    prefixChecks = [False for i in range(len(strings) + 1)]\\n    prefixChecks[0] = True\\n\\n    for i in range(len(strings) + 1):\\n        for j in range(i):\\n            isPrefixDecmposed = prefixChecks[j]\\n            rightSideString = strings[j:i]\\n            if isPrefixDecmposed and rightSideString in wordDict:\\n                prefixChecks[i] = True\\n                break\\n    return prefixChecks[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1017085,
                "title": "simple-python-solution-w-memoization",
                "content": "The main idea is to check if s begins with any dict words. If we find one, strip it off of s and make recursive call with that new s. If we end up with the empty string return true.\\n\\nThis results in 0(2^n) but if we store every substring in a map that maps to True if we\\'ve already solved for that substring, it becomes 0(n^2)\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, wordDict, memo)\\n        \\n    \\n    def helper(self, s, wordDict, memo):\\n        # base case: if word is empty its in dict or we\\'ve stripped off every word and result is empty\\n        if len(s) == 0:\\n            return True\\n        elif s in memo:\\n            return memo[s]\\n        \\n        for word in wordDict:\\n            # check if any words in dictionary are in the beginning of s\\n            prefix = s[0:len(word)]\\n            \\n            # if we found a match, recursive call with that part stripped off\\n            if prefix == word and self.helper(s[len(word):], wordDict, memo):\\n                memo[prefix] = True\\n                return True\\n                \\n        memo[s] = False\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, wordDict, memo)\\n        \\n    \\n    def helper(self, s, wordDict, memo):\\n        # base case: if word is empty its in dict or we\\'ve stripped off every word and result is empty\\n        if len(s) == 0:\\n            return True\\n        elif s in memo:\\n            return memo[s]\\n        \\n        for word in wordDict:\\n            # check if any words in dictionary are in the beginning of s\\n            prefix = s[0:len(word)]\\n            \\n            # if we found a match, recursive call with that part stripped off\\n            if prefix == word and self.helper(s[len(word):], wordDict, memo):\\n                memo[prefix] = True\\n                return True\\n                \\n        memo[s] = False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890163,
                "title": "java-memorized-recursion-and-dynamic-programming-solutions",
                "content": "This is a popular question. To solve this, a more intuitive solution is recursion. But a trivial recurstion will return TLE, which is not accepted. We can apply a memorized recursion here to reduce the time complexity, to which is acceptable.\\n\\nIt is worth to note that, memorized recursion can be deemed as a top down dynamic programming solution. Then we can also propose a bottom up dynamic programming solution, which is the solution 2 below.\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t// Solution 1: Memorized Recursion\\n         Set<String> set = new HashSet<>();\\n         Map<String, Boolean> map = new HashMap<>();\\n         for (String a : wordDict) {\\n             set.add(a);\\n         }\\n         return canBreak(s, set, map);\\n     }\\n    \\n     public boolean canBreak(String s, Set<String> set, Map<String, Boolean> map) {\\n         if (map.containsKey(s)) return map.get(s);\\n         if (set.contains(s)) {\\n             map.put(s, true);\\n             return true;\\n         }\\n         for (int i=0; i<s.length(); i++) {\\n             if (set.contains(s.substring(0, i+1)) && canBreak(s.substring(i+1, s.length()), set, map)) {\\n                 map.put(s.substring(i+1, s.length()), true);\\n                 return true;\\n             }                \\n         }\\n         map.put(s, false);\\n         return false;\\n\\t}\\n}\\n        \\n\\t// Solution 2: Dynamic Programming       \\n//        Set<String> set = new HashSet<>();\\n//        for (String a : wordDict) {\\n//            set.add(a);\\n//        }\\n//        if (set.contains(s)) return true;\\n//        int[] dp = new int[s.length() + 1];\\n//        dp[0] = 1; // end with 0, which is \"\", is true\\n//        for (int i=1; i<s.length()+1; i++) {\\n//            for (int j=0; j<i; j++) {\\n//                if (dp[j] == 1 && set.contains(s.substring(j, i))) {\\n//                    dp[i] = 1;\\n//                    break;\\n//                }\\n//            }\\n//        }\\n//        return dp[s.length()] == 1 ? true : false;\\n//    }\\n//}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t// Solution 1: Memorized Recursion\\n         Set<String> set = new HashSet<>();\\n         Map<String, Boolean> map = new HashMap<>();\\n         for (String a : wordDict) {\\n             set.add(a);\\n         }\\n         return canBreak(s, set, map);\\n     }\\n    \\n     public boolean canBreak(String s, Set<String> set, Map<String, Boolean> map) {\\n         if (map.containsKey(s)) return map.get(s);\\n         if (set.contains(s)) {\\n             map.put(s, true);\\n             return true;\\n         }\\n         for (int i=0; i<s.length(); i++) {\\n             if (set.contains(s.substring(0, i+1)) && canBreak(s.substring(i+1, s.length()), set, map)) {\\n                 map.put(s.substring(i+1, s.length()), true);\\n                 return true;\\n             }                \\n         }\\n         map.put(s, false);\\n         return false;\\n\\t}\\n}\\n        \\n\\t// Solution 2: Dynamic Programming       \\n//        Set<String> set = new HashSet<>();\\n//        for (String a : wordDict) {\\n//            set.add(a);\\n//        }\\n//        if (set.contains(s)) return true;\\n//        int[] dp = new int[s.length() + 1];\\n//        dp[0] = 1; // end with 0, which is \"\", is true\\n//        for (int i=1; i<s.length()+1; i++) {\\n//            for (int j=0; j<i; j++) {\\n//                if (dp[j] == 1 && set.contains(s.substring(j, i))) {\\n//                    dp[i] = 1;\\n//                    break;\\n//                }\\n//            }\\n//        }\\n//        return dp[s.length()] == 1 ? true : false;\\n//    }\\n//}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870697,
                "title": "trie-dp-gg",
                "content": "If we use a trie, we don\\'t need to test substrings against every word in `wordDict`.\\n\\nFirst, construct a trie from `wordDict`. Now, for each character in `s` we can traverse from one node to the next in the trie, or if we reach the end of a word, we can insert a space and go back to the root of the trie. It\\'s possible that we could break up a substring into words in multiple ways, but once we determine that it\\'s possible to do it one way, there is no need to find the solution again. This is why `@lru_cache` is used to automatically enable dynamic programming. Without this, the algorithm times out.\\n\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n        for word in wordDict:\\n            node = trie\\n            for c in word:\\n                node = node[c]\\n            node[\\'$\\'] = None\\n            \\n        @lru_cache(None)\\n        def space(i: int) -> bool:\\n            return traverse(trie, i)\\n            \\n        def traverse(node, i):\\n            if i == len(s):\\n                return \\'$\\' in node\\n            c = s[i]\\n            if c in node:\\n                if traverse(node[c], i + 1):\\n                    return True\\n            if \\'$\\' in node:\\n                if space(i):\\n                    return True\\n            \\n            return False\\n            \\n        return space(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        Trie = lambda: defaultdict(Trie)\\n        trie = Trie()\\n        for word in wordDict:\\n            node = trie\\n            for c in word:\\n                node = node[c]\\n            node[\\'$\\'] = None\\n            \\n        @lru_cache(None)\\n        def space(i: int) -> bool:\\n            return traverse(trie, i)\\n            \\n        def traverse(node, i):\\n            if i == len(s):\\n                return \\'$\\' in node\\n            c = s[i]\\n            if c in node:\\n                if traverse(node[c], i + 1):\\n                    return True\\n            if \\'$\\' in node:\\n                if space(i):\\n                    return True\\n            \\n            return False\\n            \\n        return space(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707358,
                "title": "java-dp-top-down",
                "content": "* Break the string if the first part of it is in the set of dictionary words\\n* Check that the rest of the string can be also broken into dictionary words by doing a recursive call\\n* This is divide and concur.\\n* There are overlapping subproblems so memoize\\n```\\nclass Solution {\\n    Set<String> set;\\n    Map<String, Boolean> map;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        set = new HashSet<>(wordDict);\\n        map = new HashMap<>();\\n        \\n        return check(s);\\n    }\\n    \\n    public boolean check(String s) {\\n        if(s.length() == 0 || set.contains(s)) return true;\\n        if(map.containsKey(s)) return map.get(s);\\n        for(int i = 1; i <= s.length() - 1; i++) {\\n            if(set.contains(s.substring(0, i)) && check(s.substring(i))) {\\n                map.put(s, true);\\n                return true;\\n            }\\n        }\\n        map.put(s, false);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<String> set;\\n    Map<String, Boolean> map;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        set = new HashSet<>(wordDict);\\n        map = new HashMap<>();\\n        \\n        return check(s);\\n    }\\n    \\n    public boolean check(String s) {\\n        if(s.length() == 0 || set.contains(s)) return true;\\n        if(map.containsKey(s)) return map.get(s);\\n        for(int i = 1; i <= s.length() - 1; i++) {\\n            if(set.contains(s.substring(0, i)) && check(s.substring(i))) {\\n                map.put(s, true);\\n                return true;\\n            }\\n        }\\n        map.put(s, false);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632205,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n---\\n\\n**Top-Down:** Recursively `go()` explore each `i`<sup>th</sup> index of the input string `s` as a subproblem with the goal of reaching `N`, the cardinality of `s`.  The base case occurs when `i == N`, ie. we can reach the empty string without having to do anything, so we can return `true`.  Then we see if each candidate `cand` substring `s[i..j)` (from `i` inclusive to `j` non-inclusive) has been `seen` in the input array `A`.  If so, then we recursively explore the `j`<sup>th</sup> subproblem.  As the recursive stack unwinds, each `i`<sup>th</sup> subproblem is set to `true` if and only if the candidate `cand` substring `s[i..j)` has been `seen` and the `j`<sup>th</sup> subproblem was also previously set to `true`, ie. we are attempting to \"append\" each candidate `cand` substring `s[i..j)` onto previously found `j`<sup>th</sup> subproblem solutions.\\n\\n**Bottom-Up:** Let `dp[i]` denote the `i`<sup>th</sup> index of the input string `s` is reachable.  Explicitly set the base case `dp[N] = true` to denote the empty string is reachable.  Then iteratively explore each candidate `cand` substring `s[i..j)` attempting to build upon each previously found `j`<sup>th</sup> subproblem solution to mimic the recursive stack unwinding from `i = N - 1..0` inclusive.\\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            for (j in i + 1..N) {\\n                var cand = s.substring(i, j)\\n                if (seen.contains(cand) && go(j))\\n                    return true\\n            }\\n            return false\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Boolean>()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            if (!m.contains(i)) {\\n                m[i] = false\\n                for (j in i + 1..N) {\\n                    var cand = s.substring(i, j)\\n                    if (seen.contains(cand) && go(j))\\n                        m[i] = true\\n                }\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        var dp = BooleanArray(N + 1) { false }\\n        dp[N] = true\\n        for (i in N - 1 downTo 0) {\\n            for (j in i + 1..N) {\\n                if (!dp[j])\\n                    continue\\n                var cand = s.substring(i, j)\\n                if (seen.contains(cand))\\n                    dp[i] = true\\n            }\\n        }\\n        return dp[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet wordBreak = (s, A) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = s.substring(i, j);\\n            if (seen.has(cand) && go(j))\\n                return true;\\n        }\\n        return false;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet wordBreak = (s, A, m = new Map()) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        if (!m.has(i)) {\\n            m.set(i, false);\\n            for (let j = i + 1; j <= N; ++j) {\\n                let cand = s.substring(i, j);\\n                if (seen.has(cand) && go(j))\\n                    m.set(i, true);\\n            }\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet wordBreak = (s, A, m = new Map()) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let dp = Array(N + 1).fill(false);\\n    dp[N] = true;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        for (let j = i + 1; j <= N; ++j) {\\n            if (!dp[j])\\n                continue;\\n            let cand = s.substring(i, j);\\n            if (seen.has(cand))\\n                dp[i] = true;\\n        }\\n    }\\n    return dp[0];\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            j = i + 1\\n            while j <= N:\\n                cand = s[i:j]\\n                if cand in seen:\\n                    return go(j)\\n                j += 1\\n            return False\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        @cache\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            j = i + 1\\n            while j <= N:\\n                cand = s[i:j]\\n                if cand in seen and go(j):\\n                    return True\\n                j += 1\\n            return False\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        dp = [False] * (N + 1)\\n        dp[N] = True\\n        for i in range(N - 1, -1, -1):\\n            for j in range(i + 1, N + 1):\\n                if not dp[j]:\\n                    continue\\n                cand = s[i:j]\\n                if cand in seen:\\n                    dp[i] = True\\n        return dp[0]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\n// TODO: how to implement a recursive closure which captures the outter-scope?\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\ntype VS = Vec<String>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn word_break(S: String, A: VS) -> bool {\\n        let seen = A.iter().map(|s| &s[..]).collect::<HashSet<&str>>();\\n        let N = S.len();\\n        let mut dp = vec![false; N + 1];       // \\uD83E\\uDD14 memo\\n        dp[N] = true;                          // \\uD83D\\uDED1 base case\\n        for i in (0..N).rev() {\\n            for k in 1..=N - i {\\n                dp[i] |= seen.contains(&&S[i..i + k]) && dp[i + k];  // \\uD83C\\uDFAF recurrence relation target\\n            }\\n        }\\n        dp[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int)>;\\n    bool wordBreak(string s, VS& A) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            for (auto j{ 1 }; i + j <= N; ++j) {\\n                auto cand = s.substr(i, j);\\n                if (seen.find(cand) != seen.end() && go(i + j))\\n                    return true;\\n            }\\n            return false;\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, bool>;\\n    bool wordBreak(string s, VS& A, Map m = {}) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            if (m.find(i) == m.end()) {\\n                for (auto j{ 1 }; i + j <= N; ++j) {\\n                    auto cand = s.substr(i, j);\\n                    if (seen.find(cand) != seen.end() && go(i + j))\\n                        m[i] = true;\\n                }\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VI = vector<int>;\\n    using Set = unordered_set<string>;\\n    bool wordBreak(string s, VS& A) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        VI dp(N + 1);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            for (auto j{ 1 }; i + j <= N; ++j) {\\n                if (!dp[i + j])\\n                    continue;\\n                auto cand = s.substr(i, j);\\n                if (seen.find(cand) != seen.end())\\n                    dp[i] = 1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            for (j in i + 1..N) {\\n                var cand = s.substring(i, j)\\n                if (seen.contains(cand) && go(j))\\n                    return true\\n            }\\n            return false\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        var m = mutableMapOf<Int, Boolean>()\\n        fun go(i: Int = 0): Boolean {\\n            if (i == N)\\n                return true\\n            if (!m.contains(i)) {\\n                m[i] = false\\n                for (j in i + 1..N) {\\n                    var cand = s.substring(i, j)\\n                    if (seen.contains(cand) && go(j))\\n                        m[i] = true\\n                }\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun wordBreak(s: String, A: List<String>): Boolean {\\n        var N = s.length\\n        var seen = A.toSet()\\n        var dp = BooleanArray(N + 1) { false }\\n        dp[N] = true\\n        for (i in N - 1 downTo 0) {\\n            for (j in i + 1..N) {\\n                if (!dp[j])\\n                    continue\\n                var cand = s.substring(i, j)\\n                if (seen.contains(cand))\\n                    dp[i] = true\\n            }\\n        }\\n        return dp[0]\\n    }\\n}\\n```\n```\\nlet wordBreak = (s, A) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = s.substring(i, j);\\n            if (seen.has(cand) && go(j))\\n                return true;\\n        }\\n        return false;\\n    };\\n    return go();\\n};\\n```\n```\\nlet wordBreak = (s, A, m = new Map()) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let go = (i = 0) => {\\n        if (i == N)\\n            return true;\\n        if (!m.has(i)) {\\n            m.set(i, false);\\n            for (let j = i + 1; j <= N; ++j) {\\n                let cand = s.substring(i, j);\\n                if (seen.has(cand) && go(j))\\n                    m.set(i, true);\\n            }\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet wordBreak = (s, A, m = new Map()) => {\\n    let N = s.length;\\n    let seen = new Set(A);\\n    let dp = Array(N + 1).fill(false);\\n    dp[N] = true;\\n    for (let i = N - 1; 0 <= i; --i) {\\n        for (let j = i + 1; j <= N; ++j) {\\n            if (!dp[j])\\n                continue;\\n            let cand = s.substring(i, j);\\n            if (seen.has(cand))\\n                dp[i] = true;\\n        }\\n    }\\n    return dp[0];\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            j = i + 1\\n            while j <= N:\\n                cand = s[i:j]\\n                if cand in seen:\\n                    return go(j)\\n                j += 1\\n            return False\\n        return go()\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        @cache\\n        def go(i = 0):\\n            if i == N:\\n                return True\\n            j = i + 1\\n            while j <= N:\\n                cand = s[i:j]\\n                if cand in seen and go(j):\\n                    return True\\n                j += 1\\n            return False\\n        return go()\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, A: List[str]) -> bool:\\n        N = len(s)\\n        seen = set(A)\\n        dp = [False] * (N + 1)\\n        dp[N] = True\\n        for i in range(N - 1, -1, -1):\\n            for j in range(i + 1, N + 1):\\n                if not dp[j]:\\n                    continue\\n                cand = s[i:j]\\n                if cand in seen:\\n                    dp[i] = True\\n        return dp[0]\\n```\n```\\n// TODO: how to implement a recursive closure which captures the outter-scope?\\n```\n```\\ntype VS = Vec<String>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn word_break(S: String, A: VS) -> bool {\\n        let seen = A.iter().map(|s| &s[..]).collect::<HashSet<&str>>();\\n        let N = S.len();\\n        let mut dp = vec![false; N + 1];       // \\uD83E\\uDD14 memo\\n        dp[N] = true;                          // \\uD83D\\uDED1 base case\\n        for i in (0..N).rev() {\\n            for k in 1..=N - i {\\n                dp[i] |= seen.contains(&&S[i..i + k]) && dp[i + k];  // \\uD83C\\uDFAF recurrence relation target\\n            }\\n        }\\n        dp[0]\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int)>;\\n    bool wordBreak(string s, VS& A) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            for (auto j{ 1 }; i + j <= N; ++j) {\\n                auto cand = s.substr(i, j);\\n                if (seen.find(cand) != seen.end() && go(i + j))\\n                    return true;\\n            }\\n            return false;\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, bool>;\\n    bool wordBreak(string s, VS& A, Map m = {}) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        fun go = [&](auto i) {\\n            if (i == N)\\n                return true;\\n            if (m.find(i) == m.end()) {\\n                for (auto j{ 1 }; i + j <= N; ++j) {\\n                    auto cand = s.substr(i, j);\\n                    if (seen.find(cand) != seen.end() && go(i + j))\\n                        m[i] = true;\\n                }\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VI = vector<int>;\\n    using Set = unordered_set<string>;\\n    bool wordBreak(string s, VS& A) {\\n        int N = s.size();\\n        Set seen{ A.begin(), A.end() };\\n        VI dp(N + 1);\\n        dp[N] = 1;\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            for (auto j{ 1 }; i + j <= N; ++j) {\\n                if (!dp[i + j])\\n                    continue;\\n                auto cand = s.substr(i, j);\\n                if (seen.find(cand) != seen.end())\\n                    dp[i] = 1;\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492700,
                "title": "javascript-simple-solution-using-dfs",
                "content": "```\\nvar  wordBreak = function(s,wordDict) {\\n        let set = new Set(wordDict);\\n        let cache = new Map();\\n        return recurFind(set, s, cache);\\n    }\\n    \\n    function recurFind(set, s, cache) {\\n        if (cache.has(s)){\\n            return cache.get(s);\\n        } \\n        if (set.has(s)) return true;\\n        for (let i = 1; i < s.length; i++) {\\n            if (set.has(s.substring(0, i)) && recurFind(set, s.substring(i, s.length), cache)) {\\n                cache.set(s,true);\\n                return true;   \\n            }\\n        }\\n        cache.set(s,false);\\n        return false;\\n    }\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar  wordBreak = function(s,wordDict) {\\n        let set = new Set(wordDict);\\n        let cache = new Map();\\n        return recurFind(set, s, cache);\\n    }\\n    \\n    function recurFind(set, s, cache) {\\n        if (cache.has(s)){\\n            return cache.get(s);\\n        } \\n        if (set.has(s)) return true;\\n        for (let i = 1; i < s.length; i++) {\\n            if (set.has(s.substring(0, i)) && recurFind(set, s.substring(i, s.length), cache)) {\\n                cache.set(s,true);\\n                return true;   \\n            }\\n        }\\n        cache.set(s,false);\\n        return false;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378192,
                "title": "trie-bfs-1ms-with-99-68-time-and-94-memory",
                "content": "I followed these steps. \\n\\n1. Build Trie Tree of words. \\n2. Run BFS to try out all options. \\n\\nclass Solution {\\n    \\n    class TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        \\n        TrieNode t = new TrieNode();\\n        for(String word:wordDict){\\n            insertString(word, t);\\n        }\\n        \\n        return helper(s.toCharArray(), 0, t);\\n        \\n    }\\n    \\n    public boolean helper(char[] charArray, int startIndex, TrieNode root){\\n    \\n                \\n        Queue<TrieNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        boolean[] visited = new boolean[charArray.length];\\n        \\n        while(!queue.isEmpty() && startIndex < charArray.length) {\\n            \\n            int size = queue.size();\\n                        \\n            for(int i=0;i<size;i++){\\n                TrieNode t = queue.poll();    \\n                 if(t.children[charArray[startIndex]-\\'a\\'] != null){\\n                    queue.add(t.children[charArray[startIndex]-\\'a\\']);\\n                    if(t.children[charArray[startIndex]-\\'a\\'].isWord && !visited[startIndex]){\\n                        queue.add(root);\\n                        visited[startIndex] = true;\\n                    }\\n               \\n                }\\n            }\\n            \\n            if(queue.size() != 0)\\n                startIndex++;        \\n           \\n        }\\n                \\n        if(startIndex == charArray.length && visited[startIndex-1]){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public void insertString(String s, TrieNode t){\\n        \\n        char[] charArray = s.toCharArray();\\n        \\n        for(int i=0;i<charArray.length;i++) {\\n            \\n            if(t.children[charArray[i]-\\'a\\'] == null){\\n              t.children[charArray[i]-\\'a\\'] = new TrieNode();\\n            }\\n            \\n             t = t.children[charArray[i]-\\'a\\'];\\n            \\n        }\\n        \\n        t.isWord = true;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "class Solution {\\n    \\n    class TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 318377,
                "title": "c-concise-dp",
                "content": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\tvector<bool> dp(s.size() + 1, false);\\n\\tdp[0] = true;\\n\\tfor(int i = 1; i < dp.size(); i++)\\n\\t\\tfor(string &w : wordDict)\\n\\t\\t\\tif(i >= w.size() && dp[i - w.size()] && s.substr(i - w.size(), w.size()) == w) {\\n\\t\\t\\t\\tdp[i] = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\treturn dp.back();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\tvector<bool> dp(s.size() + 1, false);\\n\\tdp[0] = true;\\n\\tfor(int i = 1; i < dp.size(); i++)\\n\\t\\tfor(string &w : wordDict)\\n\\t\\t\\tif(i >= w.size() && dp[i - w.size()] && s.substr(i - w.size(), w.size()) == w) {\\n\\t\\t\\t\\tdp[i] = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\treturn dp.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215547,
                "title": "c-4ms-using-dp",
                "content": "Time complexity: O(N^2)\\n\\n`dp[i]`: whether the substring starting from index `0` with length `i` could be segmented using the words in the dictionary.\\nThat is to say: `dp[i] = wordBreak(s.substr(0, i))`, where `dp[0]` is set to `true`.\\n\\nThe underlying point is that if `s.substr(0, i)` could be segmented by the dict words, it could **always** be decomposed to `s.substr(0, j) + a-single-word`, where `j < i` and `wordBreak(s.substr(0, j))`  is also `true`. \\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string> &wordDict) {\\n        set<string> word_set(wordDict.begin(), wordDict.end());\\n        auto len_s = s.size();\\n        vector<bool> dp(len_s + 1, false);\\n        dp[0] = true;\\n        for (int i = 0; i <= len_s; ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                if (dp[j] && word_set.find(s.substr(j, i - j)) != word_set.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len_s];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string> &wordDict) {\\n        set<string> word_set(wordDict.begin(), wordDict.end());\\n        auto len_s = s.size();\\n        vector<bool> dp(len_s + 1, false);\\n        dp[0] = true;\\n        for (int i = 0; i <= len_s; ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                if (dp[j] && word_set.find(s.substr(j, i - j)) != word_set.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[len_s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169669,
                "title": "java-7ms-solution-using-trie",
                "content": "\\n```\\nclass Solution {\\n    class Trie{\\n        boolean isWord;\\n        int height;\\n        Trie[] children;\\n        \\n        public Trie(){\\n            isWord = false;\\n            height = 0;\\n            children = new Trie[26];\\n        }\\n        \\n        public void add(String s){\\n            add(s, 0);\\n        }\\n        \\n        // Helper method for add\\n        public void add(String s, int pos){\\n            if (s.length() == pos){\\n                isWord = true;\\n                return;\\n            }\\n            int index = s.charAt(pos) - \\'a\\';\\n            if (children[index] == null)\\n                children[index] = new Trie();\\n            children[index].add(s, pos+1);\\n            // Update the height of the tree\\n            height = Math.max(height, children[index].height+1);\\n        }\\n        \\n        // Check if the substring is present in the trie\\n        public boolean search(String s, int start, int end){\\n            // Return false if the string is longer than the height of the tree\\n            if (end - start > height)\\n                return false;\\n            if (start == end)\\n                return isWord;\\n            Trie child = children[s.charAt(start) - \\'a\\'];\\n            if (child == null)\\n                return false;\\n            else \\n                return child.search(s, start+1, end);\\n        }\\n        \\n    }\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Trie trie = new Trie();\\n        for (String word: wordDict)\\n            trie.add(word);\\n        \\n        // Idea: s[0:i] can be separated if and only if s[0:j] can be separated\\n        //       and s[j:i] is present in the trie, for some j (0 <= j < i)\\n        boolean[] memo = new boolean[s.length()+1];\\n        memo[0] = true;\\n        for (int i = 1; i < s.length()+1; i++){\\n            for (int j = 0; j < i; j++){\\n                if (memo[j]){\\n                    if (trie.search(s, j, i))\\n                        memo[i] = true;\\n                }\\n            }\\n        }\\n        \\n        return memo[s.length()];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Trie{\\n        boolean isWord;\\n        int height;\\n        Trie[] children;\\n        \\n        public Trie(){\\n            isWord = false;\\n            height = 0;\\n            children = new Trie[26];\\n        }\\n        \\n        public void add(String s){\\n            add(s, 0);\\n        }\\n        \\n        // Helper method for add\\n        public void add(String s, int pos){\\n            if (s.length() == pos){\\n                isWord = true;\\n                return;\\n            }\\n            int index = s.charAt(pos) - \\'a\\';\\n            if (children[index] == null)\\n                children[index] = new Trie();\\n            children[index].add(s, pos+1);\\n            // Update the height of the tree\\n            height = Math.max(height, children[index].height+1);\\n        }\\n        \\n        // Check if the substring is present in the trie\\n        public boolean search(String s, int start, int end){\\n            // Return false if the string is longer than the height of the tree\\n            if (end - start > height)\\n                return false;\\n            if (start == end)\\n                return isWord;\\n            Trie child = children[s.charAt(start) - \\'a\\'];\\n            if (child == null)\\n                return false;\\n            else \\n                return child.search(s, start+1, end);\\n        }\\n        \\n    }\\n    \\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Trie trie = new Trie();\\n        for (String word: wordDict)\\n            trie.add(word);\\n        \\n        // Idea: s[0:i] can be separated if and only if s[0:j] can be separated\\n        //       and s[j:i] is present in the trie, for some j (0 <= j < i)\\n        boolean[] memo = new boolean[s.length()+1];\\n        memo[0] = true;\\n        for (int i = 1; i < s.length()+1; i++){\\n            for (int j = 0; j < i; j++){\\n                if (memo[j]){\\n                    if (trie.search(s, j, i))\\n                        memo[i] = true;\\n                }\\n            }\\n        }\\n        \\n        return memo[s.length()];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43817,
                "title": "scala-implementation",
                "content": "```\\ndef wordBreak(s: String, wordDict: List[String]): Boolean = {\\n\\tval res = (1 to s.length).foldLeft(List(0)){\\n\\t\\t(acc, i) =>\\n\\t\\t\\tif(acc.exists(x => wordDict.contains(s.substring(x, i)))) //substring is [...)\\n\\t\\t\\t\\ti :: acc\\n\\t\\t\\telse\\n\\t\\t\\t\\tacc\\n\\t}  \\n\\n\\tres.head == s.length\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef wordBreak(s: String, wordDict: List[String]): Boolean = {\\n\\tval res = (1 to s.length).foldLeft(List(0)){\\n\\t\\t(acc, i) =>\\n\\t\\t\\tif(acc.exists(x => wordDict.contains(s.substring(x, i)))) //substring is [...)\\n\\t\\t\\t\\ti :: acc\\n\\t\\t\\telse\\n\\t\\t\\t\\tacc\\n\\t}  \\n\\n\\tres.head == s.length\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 43890,
                "title": "javascript-dp-beats-91-golang-dp-3ms",
                "content": "Javascript:\\n```\\nvar wordBreak = function(s, wordDict) {\\n    if (!wordDict || wordDict.length == 0) return false\\n    var dp = new Array(s.length + 1);\\n    dp.fill(false)\\n    dp[0] = true\\n    \\n    for(var i = 1; i <= s.length; i++) {\\n        for(var j = 0; j < i; j++) {\\n            if(dp[j] && wordDict.indexOf(s.substring(j, i)) >= 0) {\\n                \\n                dp[i] = true\\n                break;\\n            }\\n        }\\n    }\\n    return dp[s.length]\\n};\\n```\\n\\nGolang:\\n\\n```\\nfunc wordBreak(s string, wordDict []string) bool {\\n    if wordDict == nil || len(wordDict) == 0 { return false }\\n    dp := make([]bool, len(s) + 1)\\n    for k, _:= range dp {\\n        dp[k] = false\\n    }\\n\\n    dp[0] = true\\n    sort.Strings(wordDict)\\n\\n    for i := 1; i <= len(s); i++ {\\n        for j := 0; j < i; j++ {\\n            if dp[j] && stringInSlice(s[j:i], wordDict) {\\n                \\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n    return dp[len(s)]\\n}\\n\\n func stringInSlice(str string, list []string) bool {\\n \\tfor _, v := range list {\\n \\t\\tif v == str {\\n \\t\\t\\treturn true\\n \\t\\t}\\n \\t}\\n \\treturn false\\n }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    if (!wordDict || wordDict.length == 0) return false\\n    var dp = new Array(s.length + 1);\\n    dp.fill(false)\\n    dp[0] = true\\n    \\n    for(var i = 1; i <= s.length; i++) {\\n        for(var j = 0; j < i; j++) {\\n            if(dp[j] && wordDict.indexOf(s.substring(j, i)) >= 0) {\\n                \\n                dp[i] = true\\n                break;\\n            }\\n        }\\n    }\\n    return dp[s.length]\\n};\\n```\n```\\nfunc wordBreak(s string, wordDict []string) bool {\\n    if wordDict == nil || len(wordDict) == 0 { return false }\\n    dp := make([]bool, len(s) + 1)\\n    for k, _:= range dp {\\n        dp[k] = false\\n    }\\n\\n    dp[0] = true\\n    sort.Strings(wordDict)\\n\\n    for i := 1; i <= len(s); i++ {\\n        for j := 0; j < i; j++ {\\n            if dp[j] && stringInSlice(s[j:i], wordDict) {\\n                \\n                dp[i] = true\\n                break\\n            }\\n        }\\n    }\\n    return dp[len(s)]\\n}\\n\\n func stringInSlice(str string, list []string) bool {\\n \\tfor _, v := range list {\\n \\t\\tif v == str {\\n \\t\\t\\treturn true\\n \\t\\t}\\n \\t}\\n \\treturn false\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43903,
                "title": "python-solutions-with-detailed-explanations",
                "content": "**Solution**\\n\\n**Word Break** https://leetcode.com/problems/word-break/\\n\\n**Memoization: Time: O(N^2)**\\n* We parameterize the sub-problem as helper(k, s, ..) which answers the question whether we can break the string s[k:] into smaller strings.\\n* In the test cases for this problem, if s is a part of the dictionary, then it can be broken. There is no limitation that we should have atleast two parts.\\n* There are N sub-problems and in each sub problem we do O(N) work. So complexity is N^2.\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        return self.helper(0, s, wordDict, {})\\n\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return True\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            for i in range(k, len(s)):\\n                if s[k:i+1] in wordDict:\\n                    if self.helper(i+1, s, wordDict, cache):\\n                        cache[k] = True\\n                        return True\\n        cache[k] = False\\n        return cache[k]\\n```\\n\\n**Dynamic Programming**\\n* Initialize a table of len(s). table[j] means whether we can break the string s[0:j+1].\\n* For every ending index j, we move towards left and extract every right word. If the word is valid, then we just lookup the table if the left half is breakable or not.\\n* The boundary condition is string of length 0 is breakable. This is implemented when we calculate left_is_breakable.\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        table = [False]*(len(s))\\n        for j in range(len(s)):\\n            for i in range(j, -1, -1):\\n                word_so_far = s[i:j+1]\\n                left_is_breakable = table[i-1] if i > 0 else True \\n                if word_so_far in wordDict and left_is_breakable:\\n                    table[j] = True\\n                    break\\n        return table[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        return self.helper(0, s, wordDict, {})\\n\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return True\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            for i in range(k, len(s)):\\n                if s[k:i+1] in wordDict:\\n                    if self.helper(i+1, s, wordDict, cache):\\n                        cache[k] = True\\n                        return True\\n        cache[k] = False\\n        return cache[k]\\n```\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: bool\\n        \"\"\"\\n        table = [False]*(len(s))\\n        for j in range(len(s)):\\n            for i in range(j, -1, -1):\\n                word_so_far = s[i:j+1]\\n                left_is_breakable = table[i-1] if i > 0 else True \\n                if word_so_far in wordDict and left_is_breakable:\\n                    table[j] = True\\n                    break\\n        return table[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43980,
                "title": "two-intuitive-solutions-both-beating-100-submissions-in-c-using-deque-or-stack-instead-of-dp",
                "content": "Actually this problem can be quite simple but intuitively if you treat it that way and using DFS recursive method to solve it, you're bound to get TLE in this test case: \\n>\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nsince there are so many tries till the final failure.\\n\\nSo let's take another look around it:\\n\\n- first we do not really need to check all the length of the substring -> we retrieve the minimal and maximal length of the words in dictionary first -> this operation will save us much time;\\n- using a queue to record the next all possible start index -> suppose we start from index 0 and try length [min, max], there might be several possible ways around, several substrings start in the same index in different lengths fit the dictionary -> at this very moment we record the next start index for later traversal;\\n- at last, let's search the substring (from the start index and try each length [minLen, maxLen] inclusive) in dictionary; now we are to use an array to record whether the start index is visited which will prevent us from another useless try -> this's the major improvement which will ensure us almost linearity of the time complexity;\\n\\n\\nEssence part Done! End of Story!\\n\\n- space complexity can be O(n) or O(kn) k is a special argument which will be explained.\\n- time complexity can be O(n) since we only check the unvisited index.\\n\\nSeveral tricks are used to further improve the performance:\\n\\n- check only limited length of the substring from [min, max] instead of always checking till the end of the string;\\n- storing the length for each word in dictionary, since we are using C, so when we compare the substring with the word in dictionary, we will need to ensure the length for both -> strncmp(word, substring, length);\\n- using a huge deque to imitate the queue instead of two parallel stacks - exchanging space for time and that's why the space complexity can O(kn);\\n\\n----------\\n    //BFS - 0ms;\\n    bool wordBreak(char* s, char** dict, int size)\\n    {\\n        int min=INT_MAX, max=0; //compare only in a limited range of length of the substring actually;\\n        int* lens = (int*)malloc(sizeof(int)*size); //used to compare substring with words;\\n        int lSize = 0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int len = strlen(dict[i]);\\n            lens[lSize++] = len;\\n            if(len < min) min = len;\\n            if(len > max) max = len;\\n        }\\n        int len = strlen(s);\\n        bool* visited = (bool*)malloc(sizeof(bool)*len); //used to record whether the index visited or not;\\n        memset(visited, 0, len*sizeof(bool));\\n        int* queue = (int*)malloc(sizeof(int)*len*100); //avoid parallel stacks' interdenpendency;\\n        int begin=0, end=-1;\\n        queue[++end] = 0;\\n        while(end-begin > -1)\\n        {\\n            int start = queue[begin++]; \\n            if(!visited[start]) //unvisited so far;\\n            {\\n                visited[start] = true; //label it as visited;\\n                for(int j = min; j <= MIN(max, len-start); j++) //check different length of substringfrom the start index;\\n                {\\n                    int i = 0;\\n                    for(; i < size; i++)\\n                        if(lens[i]==j && strncmp(dict[i], s+start, j)==0)\\n                            break;\\n                    if(i != size)\\n                    {\\n                        int next = start+j;\\n                        queue[++end] = next;\\n                        if(next == len)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\nAs you may say, actually we can just use stack to run DFS instead of deque running BFS to achieve the same goal using the same algorithm and tricks ^^.\\n\\nSo amazing! Right! And again it's accepted with 0ms and beating all the other submissions! \\n\\n> I think it should be voted up! Thanks in advance!\\n\\n\\n----------\\n\\n    //DFS - 0ms;\\n    bool wordBreak(char* s, char** dict, int size)\\n    {\\n        int min=INT_MAX, max=0; //compare only in a limited range of length of the substring actually;\\n        int* lens = (int*)malloc(sizeof(int)*size); //used to compare substring with words;\\n        int lSize = 0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int len = strlen(dict[i]);\\n            lens[lSize++] = len;\\n            if(len < min) min = len;\\n            if(len > max) max = len;\\n        }\\n        int len = strlen(s);\\n        bool* visited = (bool*)malloc(sizeof(bool)*len); //used to record whether the index visited or not;\\n        memset(visited, 0, len*sizeof(bool));\\n        int* stack = (int*)malloc(sizeof(int)*len*100); //avoid parallel stacks' interdenpendency;\\n        int top = -1;\\n        stack[++top] = 0;\\n        while(top > -1)\\n        {\\n            int start = stack[top--]; \\n            if(!visited[start]) //unvisited so far;\\n            {\\n                visited[start] = true; //label it as visited;\\n                for(int j = min; j <= MIN(max, len-start); j++) //check different length of substringfrom the start index;\\n                {\\n                    int i = 0;\\n                    for(; i < size; i++)\\n                        if(lens[i]==j && strncmp(dict[i], s+start, j)==0)\\n                            break;\\n                    if(i != size)\\n                    {\\n                        int next = start+j;\\n                        stack[++top] = next;\\n                        if(next == len)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "Actually this problem can be quite simple but intuitively if you treat it that way and using DFS recursive method to solve it, you're bound to get TLE in this test case: \\n>\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nsince there are so many tries till the final failure.\\n\\nSo let's take another look around it:\\n\\n- first we do not really need to check all the length of the substring -> we retrieve the minimal and maximal length of the words in dictionary first -> this operation will save us much time;\\n- using a queue to record the next all possible start index -> suppose we start from index 0 and try length [min, max], there might be several possible ways around, several substrings start in the same index in different lengths fit the dictionary -> at this very moment we record the next start index for later traversal;\\n- at last, let's search the substring (from the start index and try each length [minLen, maxLen] inclusive) in dictionary; now we are to use an array to record whether the start index is visited which will prevent us from another useless try -> this's the major improvement which will ensure us almost linearity of the time complexity;\\n\\n\\nEssence part Done! End of Story!\\n\\n- space complexity can be O(n) or O(kn) k is a special argument which will be explained.\\n- time complexity can be O(n) since we only check the unvisited index.\\n\\nSeveral tricks are used to further improve the performance:\\n\\n- check only limited length of the substring from [min, max] instead of always checking till the end of the string;\\n- storing the length for each word in dictionary, since we are using C, so when we compare the substring with the word in dictionary, we will need to ensure the length for both -> strncmp(word, substring, length);\\n- using a huge deque to imitate the queue instead of two parallel stacks - exchanging space for time and that's why the space complexity can O(kn);\\n\\n----------\\n    //BFS - 0ms;\\n    bool wordBreak(char* s, char** dict, int size)\\n    {\\n        int min=INT_MAX, max=0; //compare only in a limited range of length of the substring actually;\\n        int* lens = (int*)malloc(sizeof(int)*size); //used to compare substring with words;\\n        int lSize = 0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int len = strlen(dict[i]);\\n            lens[lSize++] = len;\\n            if(len < min) min = len;\\n            if(len > max) max = len;\\n        }\\n        int len = strlen(s);\\n        bool* visited = (bool*)malloc(sizeof(bool)*len); //used to record whether the index visited or not;\\n        memset(visited, 0, len*sizeof(bool));\\n        int* queue = (int*)malloc(sizeof(int)*len*100); //avoid parallel stacks' interdenpendency;\\n        int begin=0, end=-1;\\n        queue[++end] = 0;\\n        while(end-begin > -1)\\n        {\\n            int start = queue[begin++]; \\n            if(!visited[start]) //unvisited so far;\\n            {\\n                visited[start] = true; //label it as visited;\\n                for(int j = min; j <= MIN(max, len-start); j++) //check different length of substringfrom the start index;\\n                {\\n                    int i = 0;\\n                    for(; i < size; i++)\\n                        if(lens[i]==j && strncmp(dict[i], s+start, j)==0)\\n                            break;\\n                    if(i != size)\\n                    {\\n                        int next = start+j;\\n                        queue[++end] = next;\\n                        if(next == len)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\n----------\\n\\nAs you may say, actually we can just use stack to run DFS instead of deque running BFS to achieve the same goal using the same algorithm and tricks ^^.\\n\\nSo amazing! Right! And again it's accepted with 0ms and beating all the other submissions! \\n\\n> I think it should be voted up! Thanks in advance!\\n\\n\\n----------\\n\\n    //DFS - 0ms;\\n    bool wordBreak(char* s, char** dict, int size)\\n    {\\n        int min=INT_MAX, max=0; //compare only in a limited range of length of the substring actually;\\n        int* lens = (int*)malloc(sizeof(int)*size); //used to compare substring with words;\\n        int lSize = 0;\\n        for(int i = 0; i < size; i++)\\n        {\\n            int len = strlen(dict[i]);\\n            lens[lSize++] = len;\\n            if(len < min) min = len;\\n            if(len > max) max = len;\\n        }\\n        int len = strlen(s);\\n        bool* visited = (bool*)malloc(sizeof(bool)*len); //used to record whether the index visited or not;\\n        memset(visited, 0, len*sizeof(bool));\\n        int* stack = (int*)malloc(sizeof(int)*len*100); //avoid parallel stacks' interdenpendency;\\n        int top = -1;\\n        stack[++top] = 0;\\n        while(top > -1)\\n        {\\n            int start = stack[top--]; \\n            if(!visited[start]) //unvisited so far;\\n            {\\n                visited[start] = true; //label it as visited;\\n                for(int j = min; j <= MIN(max, len-start); j++) //check different length of substringfrom the start index;\\n                {\\n                    int i = 0;\\n                    for(; i < size; i++)\\n                        if(lens[i]==j && strncmp(dict[i], s+start, j)==0)\\n                            break;\\n                    if(i != size)\\n                    {\\n                        int next = start+j;\\n                        stack[++top] = next;\\n                        if(next == len)\\n                            return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43978,
                "title": "4-ms-15-lines-c-dp-solution-easy-to-read",
                "content": "```\\n bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<int> helper(s.size()+1, 0);\\n        helper[0]=1;\\n        for (int i = 0; i < helper.size(); i++) {\\n            for (int j = 0; j < i && !helper[i]; j++) {\\n                if (helper[j] && wordDict.count(s.substr(j,i-j))) {\\n                    helper[i]=1;\\n                }\\n            }\\n        }\\n        return helper[s.size()];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n bool wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<int> helper(s.size()+1, 0);\\n        helper[0]=1;\\n        for (int i = 0; i < helper.size(); i++) {\\n            for (int j = 0; j < i && !helper[i]; j++) {\\n                if (helper[j] && wordDict.count(s.substr(j,i-j))) {\\n                    helper[i]=1;\\n                }\\n            }\\n        }\\n        return helper[s.size()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44046,
                "title": "share-c-c-4ms-68ms-explained-dynamic-programming-solution",
                "content": "C++ version\\n\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n      // Check Bad Input Values\\n      if(wordDict.size() == 0)\\n        return false;\\n    \\n      if (s.length() == 0)\\n      {\\n        return wordDict.find(s) != wordDict.end();\\n      }\\n    \\n      // Check the whole word first\\n      if (wordDict.find(s) != wordDict.end())\\n        return true;\\n    \\n      int n = s.size();\\n      // Suppose i is the start of a word and j it's end with 0 < i <= j< n\\n      // Lets create a table C (n*n) that check if s(i,j) is breakable\\n      // We have this formula for C[i,j]\\n      // C[i,j] = C[i,j-1] and s[j,j] is in the dictionary\\n      // C[i,j] = s(i,j) is in dictionary\\n      // C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n      bool** C = new bool*[n];\\n      for(int i = 0; i < n; ++i)\\n      {\\n        C[i] = new bool[n];\\n        for(int j = 0; j<n; ++j)\\n        {\\n          // initialiazed to false;\\n          C[i][j] = false;\\n        }\\n      }\\n    \\n      // Fill the diagonal by checking if a word i,i is in the dictionary\\n      for (int i = 0; i < n; ++i)\\n      {\\n        C[i][i] = wordDict.find(s.substr(i,1)) != wordDict.end();\\n      }\\n    \\n      // Compute C[0,j] here\\n      for (int j = 1; j < n; ++j)\\n      {\\n        C[0][j] = C[0][j] ||\\n          (C[0][j - 1] && C[j][ j]) || // C[i,j-1] and s[j,j] is in the dictionary\\n          wordDict.find(s.substr(0, j + 1)) != wordDict.end();//s(i,j) is in dictionary\\n        if (!C[0][ j])\\n        {\\n          // Search for k: C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n          int k = 0;\\n          while (k < j - 1 && !C[0][j])\\n          {\\n            C[k + 1][ j] = (wordDict.find(s.substr(k + 1, j - k)) != wordDict.end());\\n            C[0][ j] = C[0][ k] && C[k + 1][ j];\\n            ++k;\\n          }\\n        }\\n      }\\n    \\n      // Return true if s(0,n-1) is breakable\\n      bool result = C[0][n-1];\\n    \\n      // delete memory\\n      for(int i = 0; i < n; ++i)\\n      {\\n        delete [] C[i];\\n      }\\n    \\n      delete []C;\\n      C=NULL;\\n    \\n      return result;\\n    }\\n\\nC# version\\n\\n    public static bool WordBreak(string s, ISet<string> wordDict)\\n    {\\n      // Check Bad Input Values\\n      if(wordDict == null || wordDict.Count == 0)\\n        return false;\\n      if (string.IsNullOrEmpty(s))\\n        return wordDict.Contains(s);\\n\\n      // Check the whole word first\\n      if (wordDict.Contains(s))\\n        return true;\\n\\n      int n = s.Length;\\n      // Suppose i is the start of a word and j it's end with 0 < i <= j< n\\n      // Lets create a table C (n*n) that check if s(i,j) is breakable\\n      // We have this formula for C[i,j]\\n      // C[i,j] = C[i,j-1] and s[j,j] is in the dictionary\\n      // C[i,j] = s(i,j) is in dictionary\\n      // C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n      bool[,] C = new bool[n,n]; // initialiazed to false;\\n\\n      // Fill the diagonal by checking if a word i,i is in the dictionary\\n      for (int i = 0; i < n; ++i)\\n      {\\n        C[i, i] = wordDict.Contains(s.Substring(i, 1));\\n      }\\n\\n      // Compute C[0,j] here\\n      for (int j = 1; j < n; ++j)\\n      {\\n        C[0, j] = C[0, j] ||\\n          (C[0, j - 1] && C[j, j]) || // C[i,j-1] and s[j,j] is in the dictionary\\n          wordDict.Contains(s.Substring(0, j + 1));//s(i,j) is in dictionary\\n        if (!C[0, j])\\n        {\\n          // Search for k: C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n          int k = 0;\\n          while (k < j - 1 && !C[0, j])\\n          {\\n            C[k + 1, j] = wordDict.Contains(s.Substring(k + 1, j - k));\\n            C[0, j] = C[0, k] && C[k + 1, j];\\n            ++k;\\n          }\\n        }\\n      }\\n\\n      // Return true if s(0,n-1) is breakable\\n      return C[0,n-1];\\n    }",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "C++ version\\n\\n    bool wordBreak(string s, unordered_set<string>& wordDict) {\\n      // Check Bad Input Values\\n      if(wordDict.size() == 0)\\n        return false;\\n    \\n      if (s.length() == 0)\\n      {\\n        return wordDict.find(s) != wordDict.end();\\n      }\\n    \\n      // Check the whole word first\\n      if (wordDict.find(s) != wordDict.end())\\n        return true;\\n    \\n      int n = s.size();\\n      // Suppose i is the start of a word and j it's end with 0 < i <= j< n\\n      // Lets create a table C (n*n) that check if s(i,j) is breakable\\n      // We have this formula for C[i,j]\\n      // C[i,j] = C[i,j-1] and s[j,j] is in the dictionary\\n      // C[i,j] = s(i,j) is in dictionary\\n      // C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n      bool** C = new bool*[n];\\n      for(int i = 0; i < n; ++i)\\n      {\\n        C[i] = new bool[n];\\n        for(int j = 0; j<n; ++j)\\n        {\\n          // initialiazed to false;\\n          C[i][j] = false;\\n        }\\n      }\\n    \\n      // Fill the diagonal by checking if a word i,i is in the dictionary\\n      for (int i = 0; i < n; ++i)\\n      {\\n        C[i][i] = wordDict.find(s.substr(i,1)) != wordDict.end();\\n      }\\n    \\n      // Compute C[0,j] here\\n      for (int j = 1; j < n; ++j)\\n      {\\n        C[0][j] = C[0][j] ||\\n          (C[0][j - 1] && C[j][ j]) || // C[i,j-1] and s[j,j] is in the dictionary\\n          wordDict.find(s.substr(0, j + 1)) != wordDict.end();//s(i,j) is in dictionary\\n        if (!C[0][ j])\\n        {\\n          // Search for k: C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n          int k = 0;\\n          while (k < j - 1 && !C[0][j])\\n          {\\n            C[k + 1][ j] = (wordDict.find(s.substr(k + 1, j - k)) != wordDict.end());\\n            C[0][ j] = C[0][ k] && C[k + 1][ j];\\n            ++k;\\n          }\\n        }\\n      }\\n    \\n      // Return true if s(0,n-1) is breakable\\n      bool result = C[0][n-1];\\n    \\n      // delete memory\\n      for(int i = 0; i < n; ++i)\\n      {\\n        delete [] C[i];\\n      }\\n    \\n      delete []C;\\n      C=NULL;\\n    \\n      return result;\\n    }\\n\\nC# version\\n\\n    public static bool WordBreak(string s, ISet<string> wordDict)\\n    {\\n      // Check Bad Input Values\\n      if(wordDict == null || wordDict.Count == 0)\\n        return false;\\n      if (string.IsNullOrEmpty(s))\\n        return wordDict.Contains(s);\\n\\n      // Check the whole word first\\n      if (wordDict.Contains(s))\\n        return true;\\n\\n      int n = s.Length;\\n      // Suppose i is the start of a word and j it's end with 0 < i <= j< n\\n      // Lets create a table C (n*n) that check if s(i,j) is breakable\\n      // We have this formula for C[i,j]\\n      // C[i,j] = C[i,j-1] and s[j,j] is in the dictionary\\n      // C[i,j] = s(i,j) is in dictionary\\n      // C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n      bool[,] C = new bool[n,n]; // initialiazed to false;\\n\\n      // Fill the diagonal by checking if a word i,i is in the dictionary\\n      for (int i = 0; i < n; ++i)\\n      {\\n        C[i, i] = wordDict.Contains(s.Substring(i, 1));\\n      }\\n\\n      // Compute C[0,j] here\\n      for (int j = 1; j < n; ++j)\\n      {\\n        C[0, j] = C[0, j] ||\\n          (C[0, j - 1] && C[j, j]) || // C[i,j-1] and s[j,j] is in the dictionary\\n          wordDict.Contains(s.Substring(0, j + 1));//s(i,j) is in dictionary\\n        if (!C[0, j])\\n        {\\n          // Search for k: C[i,j] = C[i,k] and s(k+1,j) is in dictonary, 0<k<j\\n          int k = 0;\\n          while (k < j - 1 && !C[0, j])\\n          {\\n            C[k + 1, j] = wordDict.Contains(s.Substring(k + 1, j - k));\\n            C[0, j] = C[0, k] && C[k + 1, j];\\n            ++k;\\n          }\\n        }\\n      }\\n\\n      // Return true if s(0,n-1) is breakable\\n      return C[0,n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44110,
                "title": "python-code-dp",
                "content": "    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a boolean\\n    \\n                \\n        def wordBreak(self, s, dict):\\n            if s == '':\\n                return True\\n            checklist = [False]*(len(s)+1)\\n            checklist[len(s)] = True\\n            for i in range(len(s)-1,-1,-1):\\n                for j in range(i,len(s)):\\n                    if s[i:j+1] in dict and checklist[j+1]==True:\\n                        checklist[i]=True\\n            return checklist[0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a boolean\\n    \\n                \\n        def wordBreak(self, s, dict):\\n            if s == '':\\n                return True\\n            checklist = [False]*(len(s)+1)\\n            checklist[len(s)] = True\\n            for i in range(len(s)-1,-1,-1):\\n                for j in range(i,len(s)):\\n                    if s[i:j+1] in dict and checklist[j+1]==True:\\n                        checklist[i]=True\\n            return checklist[0]",
                "codeTag": "Java"
            },
            {
                "id": 3863868,
                "title": "bfs-memoization-99-63-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought that comes to mind is prefix, this can be done plainly with BFS, but would lead to memory limit. \\n\\n```Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        q = deque([s])\\n        while q:\\n            remaining = q.popleft()\\n            for word in wordDict:\\n                if remaining == word:\\n                    return True\\n                elif remaining.startswith(word):\\n                    q.append(remaining[len(word):])\\n        return False\\n```\\n```Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    q := []string{s}\\n    for len(q) != 0 {\\n        remaining := q[0]\\n        q = q[1:] // Dequeue\\n        for _, word := range wordDict {\\n            if word == remaining {\\n                return true\\n            }\\n            if strings.HasPrefix(remaining, word) {\\n                q = append(q, remaining[len(word):]) // Enqueue\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\\nTo optimise we add memoization by storing values of strings we\\'ve already processed.\\n\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        q = deque([s])\\n        memo = set()\\n        while q:\\n            remaining = q.popleft()\\n            if remaining in memo:\\n                continue\\n            for word in wordDict:\\n                if remaining == word:\\n                    return True\\n                elif remaining.startswith(word):\\n                    q.append(remaining[len(word):])\\n                    memo.add(remaining)\\n        return False\\n```\\n```golang []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    q := []string{s}\\n    memo := make(map[string]bool)\\n    for len(q) != 0 {\\n        remaining := q[0]\\n        q = q[1:] // Dequeue\\n        if _, ok := memo[remaining]; ok {\\n            continue\\n        }\\n        for _, word := range wordDict {\\n            if word == remaining {\\n                return true\\n            }\\n            if strings.HasPrefix(remaining, word) {\\n                q = append(q, remaining[len(word):]) // Enqueue\\n                memo[remaining] = true\\n            }\\n        }\\n    }\\n    return false\\n}\\n\\n```\\n# Complexity\\n- Time complexity: $$O(N^2 * M)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![Screenshot 2023-08-05 at 12.40.38 AM.png](https://assets.leetcode.com/users/images/d363daa0-4356-40a8-996f-42d1a912ce98_1691167251.0166585.png)\\n\\n![Screenshot 2023-08-05 at 1.22.13 AM.png](https://assets.leetcode.com/users/images/d779f2f6-2241-419d-b110-2c9b09431eca_1691169748.0013075.png)\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Go"
                ],
                "code": "```Python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        q = deque([s])\\n        while q:\\n            remaining = q.popleft()\\n            for word in wordDict:\\n                if remaining == word:\\n                    return True\\n                elif remaining.startswith(word):\\n                    q.append(remaining[len(word):])\\n        return False\\n```\n```Go []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    q := []string{s}\\n    for len(q) != 0 {\\n        remaining := q[0]\\n        q = q[1:] // Dequeue\\n        for _, word := range wordDict {\\n            if word == remaining {\\n                return true\\n            }\\n            if strings.HasPrefix(remaining, word) {\\n                q = append(q, remaining[len(word):]) // Enqueue\\n            }\\n        }\\n    }\\n    return false\\n}\\n```\n```python []\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        q = deque([s])\\n        memo = set()\\n        while q:\\n            remaining = q.popleft()\\n            if remaining in memo:\\n                continue\\n            for word in wordDict:\\n                if remaining == word:\\n                    return True\\n                elif remaining.startswith(word):\\n                    q.append(remaining[len(word):])\\n                    memo.add(remaining)\\n        return False\\n```\n```golang []\\nfunc wordBreak(s string, wordDict []string) bool {\\n    q := []string{s}\\n    memo := make(map[string]bool)\\n    for len(q) != 0 {\\n        remaining := q[0]\\n        q = q[1:] // Dequeue\\n        if _, ok := memo[remaining]; ok {\\n            continue\\n        }\\n        for _, word := range wordDict {\\n            if word == remaining {\\n                return true\\n            }\\n            if strings.HasPrefix(remaining, word) {\\n                q = append(q, remaining[len(word):]) // Enqueue\\n                memo[remaining] = true\\n            }\\n        }\\n    }\\n    return false\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863694,
                "title": "c-complete-approach-and-solution",
                "content": "\\n# Approach\\n\\nThe given code is a C++ solution to the word break problem. The problem is defined as follows: Given a string s and a dictionary of strings wordDict, we need to determine if the string s can be segmented into a space-separated sequence of one or more words from the wordDict.\\n\\nLet\\'s break down the code and explain each part:\\n\\nThe code defines a class Solution that contains a function wordBreak that takes the input string s and the dictionary of words dictionary.\\n\\nInside the wordBreak function, the code initializes a vector dp of size s.length() + 1 with all elements set to -1. This vector will be used for memoization to store the results of subproblems to avoid redundant computations.\\n\\nThe main logic is implemented in the help function, which takes the current substring s of length n, the dictionary of words word, and the memoization vector dp.\\n\\nIn the help function, the code first checks if the result for the current substring s is already memoized in the dp vector. If so, it returns the precomputed result to avoid recomputation.\\n\\nThe code then iterates over all possible substrings of s with lengths from 1 to n. For each substring, it checks if it exists in the dictionary wordDict.\\n\\nIf the substring is found in the dictionary, it means that the current substring can be formed using words from the dictionary. If the current substring is equal to the whole string s (i == n), then the word segmentation is successful, and the function returns 1.\\n\\nIf the substring is found in the dictionary and it is not equal to the whole string s, the code calls the help function recursively with the remaining part of the string (i.e., s.substr(i, n)) to check if the remaining part can also be segmented into words from the dictionary. The result of the recursive call is added to the cnt variable.\\n\\nThe cnt variable keeps track of the total number of ways the string s can be segmented into words from the dictionary.\\n\\nFinally, the result of the help function is stored in the dp vector for the current substring s and returned as the result of the wordBreak function.\\n\\nIn the wordBreak function, the result returned by the help function is directly returned to determine whether the string s can be segmented into words from the dictionary.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\t\\tvector<string> v;\\n\\t\\tint help(string s, int n, vector<string> &word,vector<int> &dp)\\n\\t\\t{\\n\\t\\t\\tif(dp[n]!=-1)\\n\\t\\t\\t\\treturn dp[n];\\n            long long cnt = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring ss = s.substr(0, i);\\n\\t\\t\\t\\tint l = word.size();\\n\\t\\t\\t\\tbool flag = false;\\n\\n\\t\\t\\t\\tfor (int j = 0; j < l; j++)\\n\\t\\t\\t\\t\\tif (word[j] == ss)\\n\\t\\t\\t\\t\\t\\tflag = true;\\n\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (i == n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcnt+=help(s.substr(i, n), n - i, word,dp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n]=cnt;\\n\\t\\t}\\n\\n\\t\\tbool wordBreak(string s, vector<string> &dictionary)\\n\\t\\t{\\n\\t\\t\\tvector<int> dp(s.length()+1,-1);\\n\\t\\t\\treturn help(s, s.size(), dictionary,dp);\\n\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\tvector<string> v;\\n\\t\\tint help(string s, int n, vector<string> &word,vector<int> &dp)\\n\\t\\t{\\n\\t\\t\\tif(dp[n]!=-1)\\n\\t\\t\\t\\treturn dp[n];\\n            long long cnt = 0;\\n\\t\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring ss = s.substr(0, i);\\n\\t\\t\\t\\tint l = word.size();\\n\\t\\t\\t\\tbool flag = false;\\n\\n\\t\\t\\t\\tfor (int j = 0; j < l; j++)\\n\\t\\t\\t\\t\\tif (word[j] == ss)\\n\\t\\t\\t\\t\\t\\tflag = true;\\n\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (i == n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcnt+=help(s.substr(i, n), n - i, word,dp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n]=cnt;\\n\\t\\t}\\n\\n\\t\\tbool wordBreak(string s, vector<string> &dictionary)\\n\\t\\t{\\n\\t\\t\\tvector<int> dp(s.length()+1,-1);\\n\\t\\t\\treturn help(s, s.size(), dictionary,dp);\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861407,
                "title": "memoization-dp-java-simple",
                "content": "# Approach\\n- Memoization DP\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        Boolean[] dp = new Boolean[n];    // dp array\\n        HashSet<String> set = new HashSet<>(wordDict); // for easy searching\\n        return canBreakWord(0, n, s, set, dp);\\n    }\\n\\n    private boolean canBreakWord(int ind, int n, String s, HashSet<String> set, Boolean[] dp){\\n        if (ind == n)\\n            return true;\\n        if (dp[ind] != null)\\n            return dp[ind];\\n        \\n        for (int i = ind; i < n; i++){\\n            if (set.contains(s.substring(ind, i + 1))){\\n                if (canBreakWord(i + 1, n, s, set, dp))\\n                    return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        int n = s.length();\\n        Boolean[] dp = new Boolean[n];    // dp array\\n        HashSet<String> set = new HashSet<>(wordDict); // for easy searching\\n        return canBreakWord(0, n, s, set, dp);\\n    }\\n\\n    private boolean canBreakWord(int ind, int n, String s, HashSet<String> set, Boolean[] dp){\\n        if (ind == n)\\n            return true;\\n        if (dp[ind] != null)\\n            return dp[ind];\\n        \\n        for (int i = ind; i < n; i++){\\n            if (set.contains(s.substring(ind, i + 1))){\\n                if (canBreakWord(i + 1, n, s, set, dp))\\n                    return dp[ind] = true;\\n            }\\n        }\\n        return dp[ind] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861366,
                "title": "100-faster-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition behind this problem was to search for a possible dictionary word at every index. For this purpose, a map was created with a vector of strings for the letter they start with.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt every index, if substring was found matching a dictionary word, the same thing is continued until the end of the string was reached.\\nThe dp stores whether a set of words from dictionary can be fused to complete the string from a particular index till the end of string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<char,vector<string>> m;\\n    vector<int> dp;\\n    bool f(string s, int i){\\n        if(i==s.size()){\\n            return true;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        bool ans=false;\\n        for(auto it:m[s[i]]){\\n            if(s.substr(i,it.size())==it){\\n                ans|=f(s,i+it.size());\\n            }\\n        }\\n        return dp[i]=ans;\\n\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        dp.resize(s.size(),-1);\\n        for(auto it:wordDict){\\n            m[it[0]].push_back(it);\\n        }\\n        return f(s,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,vector<string>> m;\\n    vector<int> dp;\\n    bool f(string s, int i){\\n        if(i==s.size()){\\n            return true;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        bool ans=false;\\n        for(auto it:m[s[i]]){\\n            if(s.substr(i,it.size())==it){\\n                ans|=f(s,i+it.size());\\n            }\\n        }\\n        return dp[i]=ans;\\n\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        dp.resize(s.size(),-1);\\n        for(auto it:wordDict){\\n            m[it[0]].push_back(it);\\n        }\\n        return f(s,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860547,
                "title": "c-optimal",
                "content": "# Intuition\\nThe Word Break problem can be visualized as attempting to partition a string into a sequence of words present in a dictionary. The challenge is to find a valid segmentation, if one exists. This naturally leads to the idea of breaking down the problem into smaller subproblems and solving them iteratively or recursively.\\n\\n# Approach - Dynamic Programming\\nThe Dynamic Programming (DP) approach is used to solve this problem in an iterative manner. By utilizing a boolean array `dp`, the algorithm builds a solution that checks if the string can be segmented into dictionary words.\\n\\n1. **Initialization**: Create an unordered set containing the dictionary words and initialize a DP array with `dp[0] = true`.\\n2. **Iteration**: Iterate through the string, and for each position `i`, check the substrings ending at `i` to see if they are in the dictionary.\\n3. **Memoization**: If a valid segmentation is found, update `dp[i]` to `true`.\\n4. **Result**: The final result is stored in `dp[s.size()]`.\\n\\n# Complexity\\n- **Time complexity**: \\\\(O(n^2 * m)\\\\), where \\\\(n\\\\) is the length of the string, and \\\\(m\\\\) is the maximum length of a word in the dictionary. This considers the nested iteration through the string and the substring operation.\\n- **Space complexity**: \\\\(O(n + k)\\\\), where \\\\(n\\\\) is the length of the string, and \\\\(k\\\\) is the size of the dictionary.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> st(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1, false);\\n        dp[0] = true;\\n        \\n        for(int i = 1; i <= s.size(); i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(dp[j] && st.find(s.substr(j, i - j)) != st.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()];\\n    }\\n};\\n```\\n\\nThe provided code offers a concise and efficient solution to the Word Break problem by leveraging the power of Dynamic Programming. By carefully considering the constraints and using C++\\'s standard library, the algorithm ensures an optimal solution.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> st(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1, false);\\n        dp[0] = true;\\n        \\n        for(int i = 1; i <= s.size(); i++) {\\n            for(int j = 0; j < i; j++) {\\n                if(dp[j] && st.find(s.substr(j, i - j)) != st.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860520,
                "title": "c-backtracking",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:** \\n* for all index, we will determine *prefix* & *suffix* strings.\\n* if *preffix* is present in *dictionary*, then its a valid break point and remaining *suffix* becomes our sub-problem.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(string s, set<string> &st, map<string,bool> &mp){\\n        int n=s.length();\\n        \\n        if(n==0) return true;\\n        \\n        if(mp.find(s)!=mp.end()) return mp[s];\\n        \\n        for(int i=0;i<s.length();i++){\\n            string pre=s.substr(0,i+1); // current prefix string\\n            string suf=s.substr(i+1); // left over suffix string\\n            \\n            if(st.find(pre)!=st.end() && (st.find(suf)!=st.end() || check(suf,st,mp)==true)) return mp[s]=true;\\n        }\\n        return mp[s]=false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string> &dict) {\\n        set<string> st;\\n        for(int i=0;i<dict.size();i++) st.insert(dict[i]);\\n        \\n        map<string,bool> mp;\\n        return check(s,st,mp);\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(string s, set<string> &st, map<string,bool> &mp){\\n        int n=s.length();\\n        \\n        if(n==0) return true;\\n        \\n        if(mp.find(s)!=mp.end()) return mp[s];\\n        \\n        for(int i=0;i<s.length();i++){\\n            string pre=s.substr(0,i+1); // current prefix string\\n            string suf=s.substr(i+1); // left over suffix string\\n            \\n            if(st.find(pre)!=st.end() && (st.find(suf)!=st.end() || check(suf,st,mp)==true)) return mp[s]=true;\\n        }\\n        return mp[s]=false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string> &dict) {\\n        set<string> st;\\n        for(int i=0;i<dict.size();i++) st.insert(dict[i]);\\n        \\n        map<string,bool> mp;\\n        return check(s,st,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766655,
                "title": "a-general-template-solution-for-dp-memoization",
                "content": "# Intuition\\nThis is exactly the same as [coin change problem](https://leetcode.com/problems/coin-change/) and [Number of Dice Rolls With Target Sum\\n](https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/description/). So many medium or hard problems have been solved using this template and now I share it. The solution for this type of problems is straightforward and can be summarized into a template as follows: \\n1. Discuss some corner cases\\n2. Define a recursive structure where we can apply memoization\\n3. Call the recursive structure\\n```\\nclass Solution:\\n    def someProblem(self, nums) -> bool:\\n        # 1. some corner case discussion\\n        if not nums:\\n            return []\\n\\n        # 2. the recursive function\\n        @cache\\n        def helper(s):\\n            # 2.1 base cases for recursion\\n            if len(s) == 0:\\n                return True\\n            # 2.2 recursive call with smaller input size\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    if helper(s[len(word):]):\\n                        return True\\n            return False\\n\\n        # 3. wrap the function call\\n        return helper(s)\\n\\n```\\n\\nSome examples on how to use the template:\\n\\n# 139. Word Break\\nRecursively try each word in the word dictionary, and input the ``helper`` function again with smaller input. If the input size is reduced to zero, we find the word break. Otherwise, return False.\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        # no need for base case\\n\\n        # recursive call\\n        @cache\\n        def helper(s):\\n            if len(s) == 0:\\n                return True\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    if helper(s[len(word):]):\\n                        return True\\n            return False\\n        return helper(s)\\n```\\n\\n# 322. Coin Change\\nStart with 1 or 2 or 5, in order to get 11, the remaining balance now becomes 10 or 9 or 6. For each subcase, we can use 1 or 2 or 5 again, and calculate the corresponding remaining balance... which just forms a recursive structure with smaller input size.\\n\\n```\\nclass Solution:\\n    def coinChange(self, coins: List[int], amount: int) -> int:\\n        # corner cases\\n        if amount == 0: return 0\\n        @cache\\n        def helper(balance): # return the optimal strategy with balance\\n            if balance < 0:\\n                return float(\\'inf\\')\\n            elif balance == 0:\\n                return 0\\n            res = []\\n            for coin in coins:\\n                res.append(1 + helper(balance-coin))\\n            return min(res) # get the minimum possible outcomes\\n\\n        return helper(amount) if helper(amount) != float(\\'inf\\') else -1\\n\\n```\\n# 91. Decode Ways\\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        @cache\\n        def helper(s):\\n            if s.startswith(\\'0\\'):\\n                return 0\\n\\n            if not s or len(s) == 1:\\n                return 1\\n\\n            return helper(s[1:]) + helper(s[2:]) if int(s[:2]) <= 26 else helper(s[1:])\\n\\n        return helper(s)\\n```\\n\\n# 416. Partition Equal Subset Sum\\nOne of the most famous problem in leetcode.\\n```\\nclass Solution:\\n    def canPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        total_sum = sum(nums)\\n        # discuss corner case\\n        if total_sum % 2 != 0:\\n            return False\\n        @cache\\n        def helper(target, idx):\\n            # recursion base cases\\n            if target == 0:\\n                return True\\n            if target < 0 or idx > n-1:\\n                return False\\n            if target < nums[idx]:\\n                return helper(target, idx + 1)\\n            return helper(target-nums[idx], idx+1) or helper(target, idx+1)\\n        subset_sum = total_sum // 2\\n        return helper(subset_sum, 0)\\n```\\n\\n# 1155. Number of Dice Rolls With Target Sum\\n```\\nclass Solution:\\n    def numRollsToTarget(self, n: int, k: int, target: int) -> int:\\n        @cache\\n        def helper(n, target):\\n            # base case for recursion\\n            if n == 1 and target>0 and target<=k:\\n                return 1\\n            if n == 0 or target < 0:\\n                return 0\\n            res = []\\n            for i in range(1,k+1):\\n                res.append(helper(n-1, target-i)) # recursive call\\n            ans = 0\\n            for j in res:\\n                ans = (ans+j)%(10**9+7)\\n            return ans\\n        return helper(n, target)\\n\\n```\\n\\n# 2767. Partition String Into Minimum Beautiful Substrings\\nA biweekly contest problem which can be written in less than 10 minutes if you are familiar with this template.\\n```\\nclass Solution:\\n    def minimumBeautifulSubstrings(self, s: str) -> int:\\n        ans = [\\'1\\', \\'101\\', \\'11001\\', \\'1111101\\', \\'1001110001\\', \\'110000110101\\', \\'11110100001001\\']\\n        @cache\\n        def helper(s):\\n            if s.startswith(\\'0\\'):\\n                return float(\\'inf\\')\\n            if not s:\\n                return 0\\n            res = []\\n            for i in ans:\\n                if s.startswith(i):\\n                    res.append(1 + helper(s[len(i):]))\\n            return min(res) if res else -1\\n        return helper(s) if helper(s) < float(\\'inf\\') else -1\\n```\\n\\n\\n\\n\\n\\nPlease upvote if you find this helpful! Thanks a lot.\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def someProblem(self, nums) -> bool:\\n        # 1. some corner case discussion\\n        if not nums:\\n            return []\\n\\n        # 2. the recursive function\\n        @cache\\n        def helper(s):\\n            # 2.1 base cases for recursion\\n            if len(s) == 0:\\n                return True\\n            # 2.2 recursive call with smaller input size\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    if helper(s[len(word):]):\\n                        return True\\n            return False\\n\\n        # 3. wrap the function call\\n        return helper(s)\\n\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        # no need for base case\\n\\n        # recursive call\\n        @cache\\n        def helper(s):\\n            if len(s) == 0:\\n                return True\\n            for word in wordDict:\\n                if s.startswith(word):\\n                    if helper(s[len(word):]):\\n                        return True\\n            return False\\n        return helper(s)\\n```\n```\\nclass Solution:\\n    def coinChange(self, coins: List[int], amount: int) -> int:\\n        # corner cases\\n        if amount == 0: return 0\\n        @cache\\n        def helper(balance): # return the optimal strategy with balance\\n            if balance < 0:\\n                return float(\\'inf\\')\\n            elif balance == 0:\\n                return 0\\n            res = []\\n            for coin in coins:\\n                res.append(1 + helper(balance-coin))\\n            return min(res) # get the minimum possible outcomes\\n\\n        return helper(amount) if helper(amount) != float(\\'inf\\') else -1\\n\\n```\n```\\nclass Solution:\\n    def numDecodings(self, s: str) -> int:\\n        @cache\\n        def helper(s):\\n            if s.startswith(\\'0\\'):\\n                return 0\\n\\n            if not s or len(s) == 1:\\n                return 1\\n\\n            return helper(s[1:]) + helper(s[2:]) if int(s[:2]) <= 26 else helper(s[1:])\\n\\n        return helper(s)\\n```\n```\\nclass Solution:\\n    def canPartition(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        total_sum = sum(nums)\\n        # discuss corner case\\n        if total_sum % 2 != 0:\\n            return False\\n        @cache\\n        def helper(target, idx):\\n            # recursion base cases\\n            if target == 0:\\n                return True\\n            if target < 0 or idx > n-1:\\n                return False\\n            if target < nums[idx]:\\n                return helper(target, idx + 1)\\n            return helper(target-nums[idx], idx+1) or helper(target, idx+1)\\n        subset_sum = total_sum // 2\\n        return helper(subset_sum, 0)\\n```\n```\\nclass Solution:\\n    def numRollsToTarget(self, n: int, k: int, target: int) -> int:\\n        @cache\\n        def helper(n, target):\\n            # base case for recursion\\n            if n == 1 and target>0 and target<=k:\\n                return 1\\n            if n == 0 or target < 0:\\n                return 0\\n            res = []\\n            for i in range(1,k+1):\\n                res.append(helper(n-1, target-i)) # recursive call\\n            ans = 0\\n            for j in res:\\n                ans = (ans+j)%(10**9+7)\\n            return ans\\n        return helper(n, target)\\n\\n```\n```\\nclass Solution:\\n    def minimumBeautifulSubstrings(self, s: str) -> int:\\n        ans = [\\'1\\', \\'101\\', \\'11001\\', \\'1111101\\', \\'1001110001\\', \\'110000110101\\', \\'11110100001001\\']\\n        @cache\\n        def helper(s):\\n            if s.startswith(\\'0\\'):\\n                return float(\\'inf\\')\\n            if not s:\\n                return 0\\n            res = []\\n            for i in ans:\\n                if s.startswith(i):\\n                    res.append(1 + helper(s[len(i):]))\\n            return min(res) if res else -1\\n        return helper(s) if helper(s) < float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607067,
                "title": "c-fast-solution-beats-100-o-mn-2-runtime-explanation-provided",
                "content": "# Intuition\\nThink of the problem this way: if we were going to build ```s``` from the words in ```wordDict```, then at any given index ```i``` of ```s``` we have the opportunity to insert some string, ```word```, from the dictionary (i.e. use ```word``` to cover the characters ```s[i,...,i + word.size() - 1]```). So at each index, we can try and check if we can insert a word from the given dictionary. But what exactly does it mean \"to be able to insert a word\"? Of course, the only actual requirement is that if we\\'re inserting some word, ```word```, at index ```i``` in ```s```, then the characters of ```word``` and the substring in ```s``` that it covers have to match. For example, if \\n```s = \"leetcode\"``` and ```wordDict = [\"le\", \"et\", \"co\", \"de\"]```, we can insert ```wordDict[2] = \"co\"``` at index $4$ in ```s``` (since the substring ```\"co\"``` begins at index $4$ in ```s```). So far we know that we could insert ```\"co\"``` at index $4$ and properly form the substring ```\"co\"``` of ```s```. One important observation that we can make here that will be important in our implementation is that we don\\'t need to try inserting every word in dictionary at some index ```i``` in ```s```. We only need to try those that start with the character ```s[i]```. Now we make another important observation: there\\'s a subproblem here (DP!). What if I knew that I could form the substring \\n```s[4 + wordDict[2].size(), ..., s.size() - 1] = \"de\"``` (i.e. the substring that follows our inserted word, which is the substring ```\"de\"```)? Well, then I know that I can form the substring ```\"code\"``` since we\\'ve confirmed that we can form the two independent substrings ```\"co\"``` and ```\"de\"```. This is the basis of our dynamic programming approach.\\n\\n# Approach\\n\\n1. Initialize a boolean ```dp``` array of size ```s.size() + 1``` to ```false```. ```dp[i] = true``` denotes that the substring ```s[i, ..., s.size() - 1]``` can be formed using the words in ```wordDict```. Set ```dp[s.size()] = true``` (explained later).\\n2. Construct an unordered map ```insertions```. This map must map the first character of a given string, ```word```, to a vector of strings from ```wordDict``` that all start with that first character (including ```word```). For example, if ```wordDict = [\"Skill\", \"Issue\", \"IMO\"]```, then ```insertions[\\'I\\'] = [\"Issue\", \"IMO\"]```\\n3. Begin a backwards iteration starting at the last character of ```s``` In other words our iteration starts at ```i = s.size() - 1```. At each step of this iteration we will try inserting words from ```wordDict``` that start with ```s[i]```.\\n4. At each index ```i``` loop through all the words from ```wordDict``` that start with ```s[i]``` (recall that a vector containing all such words exists at ```insertions[s[i]]```). For each possible insertion, ```word```, in ```insertions[s[i]]``` check that the substring following our insertion can be formed (i.e. ```dp[i + word.size()] == true]```) and that ```word``` is a valid insertion (i.e. ```word == s[i, ..., i + word.size() - 1]```). If our word is both a valid insertion AND the substring following our insertion can be formed, then we set ```dp[i] = true```. We can also exit the loop for index ```i``` because we\\'ve already confirmed that we can form the string ```s[i, ..., s.size() - 1]```,\\n5. Return ```dp[0]```, which denotes that ```s[0,...,s.size() - 1]``` (i.e. the entire string) can be formed using the words in ```wordDict```.\\n\\n\\n## Notes\\n- The reason why we have the extra entry in the ```dp``` array is for the inserted strings that terminate ```s```. To elaborate, remember that when updating the ```dp``` array, we consider if the substring following our insertion can be formed. But if our insertion happens at the end of ```s```, then there is no substring following our insertion. For example, if ```s = \"tim\"```, ```wordDict = [\"t\", \"im\"]``` we try inserting the string of length $2$, ```\"im\"```, at ```s[1]```, we want ```dp[1 + 2] = dp[s.size()]``` to be set to ```true```.\\n- While the unordered map technically doesn\\'t have an effect on the time complexity, it\\'s a pretty useful optimization when the dictionary is large with many different words.\\n- Possible Improvements: If duplicate strings were allowed in the dictionary, we could use an unordered set instead of a vector to store the strings within the unordered map. Also, if the length of a word in the dictionary is longer than the input string ```s```, we could just not put it in our map.\\n---\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m \\\\cdot n^2)$$ ($m$ is the length of the dictionary, $n$ is the length of the longest string)\\n\\nIn the outermost loop we iterate over ```s``` ($n$). In the inner loop iterate over words from ```wordDict``` ,which are mapped by their first character ($m$). Inside the inner loop, we may make a call to ```compare()```, ($n$), which gives us our runtime $O(m \\\\cdot n^2)$.\\n\\n- Space complexity:\\n$$O(l + m \\\\cdot w)$$ ($l$ is the length of ```s```, $m$ is the length of the dictionary, and $w$ is the length of the longest word in the dictionary)\\n\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n\\n        unordered_map<char, vector<string>> insertions;\\n        vector<bool> dp(s.size() + 1, false);\\n        int nxt;\\n\\n        dp[s.size()] = true;\\n\\n        for (string& word : wordDict)\\n            insertions[word[0]].push_back(word);\\n\\n        for (int i = s.size() - 1; i > -1; --i)\\n        {\\n            // Attempt insertion of all strings in wordDict beginning with character s[i]\\n            for (string& word : insertions[s[i]])\\n            {\\n                nxt = i + word.size();\\n\\n                // Check that the substring following the current string (word) can be \\n                // formed and that the current string (word) is valid \\n                if (nxt <= s.size() && dp[nxt] && s.compare(i, word.size(), word) == 0)\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\nYou could also replace \\n\\n```\\nif (nxt <= s.size() && dp[nxt] && s.compare(i, word.size(), word) == 0)\\n```\\n\\nwith\\n\\n```\\nif (s.compare(i, word.size(), word) == 0 && dp[nxt])\\n```\\n---\\n# Performance\\n![Screen Shot 2023-06-07 at 1.00.44 AM.png](https://assets.leetcode.com/users/images/d4c84d4b-99a6-4374-aa5d-8ec6ac8bceda_1686114102.6830206.png)\\n\\n---\\n# Saving Space\\n\\nThis approach definitely uses a significant amount of memory if `wordDict` is very large since we store a copy each `word` in `wordDict` in our map, but we can fix this problem if we store the index of each `word` in the original `wordDict` array rather than the `word` itself. Because we no longer store a copy of the words in `wordDict`, our space complexity is reduced to $O(l + m)$ ($l$ is the length of ```s``` and $m$ is the length of the dictionary) and the time complexity remains the same.\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n\\n        unordered_map<char, vector<int>> insertions;\\n        vector<bool> dp(s.size() + 1, false);\\n        int nxt;\\n\\n        dp[s.size()] = true;\\n\\n        for (int i = 0; i < wordDict.size(); ++i)\\n            insertions[wordDict[i][0]].push_back(i);\\n\\n        for (int i = s.size() - 1; i > -1; --i)\\n        {\\n            for (int pos : insertions[s[i]])\\n            {\\n                nxt = i + wordDict[pos].size();\\n                if (nxt <= s.size() && dp[nxt] && s.compare(i, wordDict[pos].size(), wordDict[pos]) == 0)\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```s```\n```wordDict```\n```i```\n```s```\n```word```\n```word```\n```s[i,...,i + word.size() - 1]```\n```word```\n```i```\n```s```\n```word```\n```s```\n```s = \"leetcode\"```\n```wordDict = [\"le\", \"et\", \"co\", \"de\"]```\n```wordDict[2] = \"co\"```\n```s```\n```\"co\"```\n```s```\n```\"co\"```\n```\"co\"```\n```s```\n```i```\n```s```\n```s[i]```\n```s[4 + wordDict[2].size(), ..., s.size() - 1] = \"de\"```\n```\"de\"```\n```\"code\"```\n```\"co\"```\n```\"de\"```\n```dp```\n```s.size() + 1```\n```false```\n```dp[i] = true```\n```s[i, ..., s.size() - 1]```\n```wordDict```\n```dp[s.size()] = true```\n```insertions```\n```word```\n```wordDict```\n```word```\n```wordDict = [\"Skill\", \"Issue\", \"IMO\"]```\n```insertions[\\'I\\'] = [\"Issue\", \"IMO\"]```\n```s```\n```i = s.size() - 1```\n```wordDict```\n```s[i]```\n```i```\n```wordDict```\n```s[i]```\n```insertions[s[i]]```\n```word```\n```insertions[s[i]]```\n```dp[i + word.size()] == true]```\n```word```\n```word == s[i, ..., i + word.size() - 1]```\n```dp[i] = true```\n```i```\n```s[i, ..., s.size() - 1]```\n```dp[0]```\n```s[0,...,s.size() - 1]```\n```wordDict```\n```dp```\n```s```\n```dp```\n```s```\n```s = \"tim\"```\n```wordDict = [\"t\", \"im\"]```\n```\"im\"```\n```s[1]```\n```dp[1 + 2] = dp[s.size()]```\n```true```\n```s```\n```s```\n```wordDict```\n```compare()```\n```s```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n\\n        unordered_map<char, vector<string>> insertions;\\n        vector<bool> dp(s.size() + 1, false);\\n        int nxt;\\n\\n        dp[s.size()] = true;\\n\\n        for (string& word : wordDict)\\n            insertions[word[0]].push_back(word);\\n\\n        for (int i = s.size() - 1; i > -1; --i)\\n        {\\n            // Attempt insertion of all strings in wordDict beginning with character s[i]\\n            for (string& word : insertions[s[i]])\\n            {\\n                nxt = i + word.size();\\n\\n                // Check that the substring following the current string (word) can be \\n                // formed and that the current string (word) is valid \\n                if (nxt <= s.size() && dp[nxt] && s.compare(i, word.size(), word) == 0)\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\n```\\nif (nxt <= s.size() && dp[nxt] && s.compare(i, word.size(), word) == 0)\\n```\n```\\nif (s.compare(i, word.size(), word) == 0 && dp[nxt])\\n```\n```s```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n\\n        unordered_map<char, vector<int>> insertions;\\n        vector<bool> dp(s.size() + 1, false);\\n        int nxt;\\n\\n        dp[s.size()] = true;\\n\\n        for (int i = 0; i < wordDict.size(); ++i)\\n            insertions[wordDict[i][0]].push_back(i);\\n\\n        for (int i = s.size() - 1; i > -1; --i)\\n        {\\n            for (int pos : insertions[s[i]])\\n            {\\n                nxt = i + wordDict[pos].size();\\n                if (nxt <= s.size() && dp[nxt] && s.compare(i, wordDict[pos].size(), wordDict[pos]) == 0)\\n                {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107848,
                "title": "without-dp-c-easy",
                "content": "# Approach\\nSo I have seen many DP Solutions here.\\nInstead of DP I used normal BFS but with Set,\\nBasically what DP does here is to avoid the same computation at a given index being queried multiple times due to recursion (worst case exponential)....so you use DP so as the queries are only entertained once and convert it into n^2 time (for n=string length).\\n\\nBasically I kept this same concept in mind and Made a set which records partitions already pushed in queue once and so to not to compute them further every time they are added in queue due to various possible ways to reach there for a partition.\\n\\n# Complexity\\n- Time complexity:\\nO(N*maxlenofstr+(maxlenofstr)^2)\\n\\n- Space complexity:\\nO(N*maxlenofstr)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string str,vector<string>wordDict) \\n    {\\n        unordered_map<string,bool>existsinDict;\\n        for(string j:wordDict)\\n        {\\n            existsinDict[j]=true;\\n        }\\n        queue<int>tocheck;\\n        vector<bool>alreadypushedinqueue(str.size(),false);\\n        bool partitionreachedend=false;\\n        tocheck.push(-1);\\n        while(!tocheck.empty())\\n        {\\n            int indexofstr=tocheck.front();\\n            tocheck.pop();\\n            if(indexofstr==(str.size()-1))\\n            {\\n                partitionreachedend=true;\\n                break;\\n            }\\n            string checkinDict;\\n            for(int i=indexofstr+1;i<str.size();i++)\\n            {\\n                checkinDict.push_back(str[i]);\\n                if(existsinDict[checkinDict] && !alreadypushedinqueue[i])\\n                {\\n                    tocheck.push(i);\\n                    alreadypushedinqueue[i]=true;\\n                }\\n            }\\n        }\\n        return partitionreachedend;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string str,vector<string>wordDict) \\n    {\\n        unordered_map<string,bool>existsinDict;\\n        for(string j:wordDict)\\n        {\\n            existsinDict[j]=true;\\n        }\\n        queue<int>tocheck;\\n        vector<bool>alreadypushedinqueue(str.size(),false);\\n        bool partitionreachedend=false;\\n        tocheck.push(-1);\\n        while(!tocheck.empty())\\n        {\\n            int indexofstr=tocheck.front();\\n            tocheck.pop();\\n            if(indexofstr==(str.size()-1))\\n            {\\n                partitionreachedend=true;\\n                break;\\n            }\\n            string checkinDict;\\n            for(int i=indexofstr+1;i<str.size();i++)\\n            {\\n                checkinDict.push_back(str[i]);\\n                if(existsinDict[checkinDict] && !alreadypushedinqueue[i])\\n                {\\n                    tocheck.push(i);\\n                    alreadypushedinqueue[i]=true;\\n                }\\n            }\\n        }\\n        return partitionreachedend;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917101,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        if(dict.size()==0)\\n            return false;\\n        unordered_map<string, int> mp;\\n        for(auto s1:dict)\\n            mp[s1]++;\\n        vector<bool> dp(s.size()+1);\\n        dp[0]=true;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(dp[j])\\n                {\\n                    string word=s.substr(j, i-j+1);\\n                    if(mp.find(word)!=mp.end())\\n                    {\\n                        dp[i+1]=true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        if(dict.size()==0)\\n            return false;\\n        unordered_map<string, int> mp;\\n        for(auto s1:dict)\\n            mp[s1]++;\\n        vector<bool> dp(s.size()+1);\\n        dp[0]=true;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(dp[j])\\n                {\\n                    string word=s.substr(j, i-j+1);\\n                    if(mp.find(word)!=mp.end())\\n                    {\\n                        dp[i+1]=true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557501,
                "title": "fastest-solution-detailed-explanation-easy-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it***\\n\\n**Intution 1 (String DP):-**\\n**Approach**\\nThe approach is simple, we\\'ll just call recursively for all substrings of the given string and check if that substring exists inside the dictionary, then make a new call to the next substring to check further. In this recursive call we have used unordered map \\'dp\\', which prevents recall for the same substring again. Finally if the size of the substring becomes zero it means the given string is present inside the dictionary, then return true else false.\\n\\n**Dry run:-**\\n\\n![image](https://assets.leetcode.com/users/images/029f9586-3839-44a8-82cd-3c79aa8dd678_1662807900.2093604.jpeg)\\n\\n**Code:-**\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp;\\n    \\n    int solve(string s, vector<string>& wordDict){\\n        int sz=s.length();\\n        if(sz==0) return 1;\\n        if(dp[s]!=0) return dp[s];\\n        \\n        for(int i=1;i<=sz;i++)\\n        {\\n            int f=0;\\n            string ss=s.substr(0,i);\\n            for(int j=0;j<wordDict.size();j++){\\n                if(ss.compare(b[j])==0){\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(f==1 and solve(s.substr(i,sz-i),b)==1) return dp[s]=1;\\n        }\\n        return dp[s]=-1;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int x=solve(s,wordDict);\\n        if(x==1) return true;\\n        else return false;\\n        \\n    }\\n};\\n```\\n\\n**Intution 1 (DP):-**\\n**Approach 1 : Recursion (TLE)**\\nTake a set insert all dictionary words. Create recursive fuction pass \\'0\\' as starting index, given string and set. inside function check current index is equal to number of char in string then return true (base case). Take a blank temp string and run loop from current index till size of string and add char one by one with temp simultaneously check temp present in set if true then call same function pass current index as i+1. at the you will get your answer.\\n\\n**~Time Complexity: O(N^2) \\n~Space Complexity: O(N) ~stack space**\\n\\n**C++ Code (TLE)**\\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind,string str,set<string> st){\\n        if(ind==str.size()) return true;\\n        string temp=\"\";\\n        for(int i=ind;i<str.size();i++){\\n            temp+=str[i];\\n            if(st.find(temp)!=st.end()){\\n                if(solve(i+1,str,st)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        return solve(0,s,st);\\n    }\\n};\\n```\\n\\n**Approach 2 : Memoization (Accepted)**\\n**~Time Complexity: O(N^2) \\n~Space Complexity:  O(N)+O(N) stack space and dp vector**\\n\\n**C++ Code (Accepted)**\\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind,string str,set<string> st,vector<int>& dp){\\n        if(ind==str.size()) return true;\\n        if(dp[ind]!=-1) return dp[ind];\\n        string temp=\"\";\\n        for(int i=ind;i<str.size();i++){\\n            temp+=str[i];\\n            if(st.find(temp)!=st.end()){\\n                if(solve(i+1,str,st,dp)){\\n                    return dp[ind]=true;\\n                }\\n            }\\n        }\\n        return dp[ind]=false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        vector<int> dp(s.size(),-1);\\n        return solve(0,s,st,dp);\\n    }\\n};\\n```\\n\\n**Approach 3 : Tabulation (Accepted)**\\n\\n**~Time Complexity: O(N^2) \\n~Space Complexity:  O(N) ~dp vector**\\n\\n**C++ Code (Accepted)**\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        \\n        vector<bool> dp(n,false);\\n        dp[n]=true;\\n        \\n        for(int ind=n-1;ind>=0;ind--){\\n            string temp=\"\";\\n            for(int i=ind;i<n;i++){\\n                temp+=s[i];\\n                if(st.find(temp)!=st.end()){\\n                    if(dp[i+1]){\\n                        dp[ind]=true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> dp;\\n    \\n    int solve(string s, vector<string>& wordDict){\\n        int sz=s.length();\\n        if(sz==0) return 1;\\n        if(dp[s]!=0) return dp[s];\\n        \\n        for(int i=1;i<=sz;i++)\\n        {\\n            int f=0;\\n            string ss=s.substr(0,i);\\n            for(int j=0;j<wordDict.size();j++){\\n                if(ss.compare(b[j])==0){\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(f==1 and solve(s.substr(i,sz-i),b)==1) return dp[s]=1;\\n        }\\n        return dp[s]=-1;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int x=solve(s,wordDict);\\n        if(x==1) return true;\\n        else return false;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind,string str,set<string> st){\\n        if(ind==str.size()) return true;\\n        string temp=\"\";\\n        for(int i=ind;i<str.size();i++){\\n            temp+=str[i];\\n            if(st.find(temp)!=st.end()){\\n                if(solve(i+1,str,st)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        return solve(0,s,st);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind,string str,set<string> st,vector<int>& dp){\\n        if(ind==str.size()) return true;\\n        if(dp[ind]!=-1) return dp[ind];\\n        string temp=\"\";\\n        for(int i=ind;i<str.size();i++){\\n            temp+=str[i];\\n            if(st.find(temp)!=st.end()){\\n                if(solve(i+1,str,st,dp)){\\n                    return dp[ind]=true;\\n                }\\n            }\\n        }\\n        return dp[ind]=false;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        vector<int> dp(s.size(),-1);\\n        return solve(0,s,st,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        set<string> st;\\n        for(auto x:wordDict) st.insert(x);\\n        \\n        vector<bool> dp(n,false);\\n        dp[n]=true;\\n        \\n        for(int ind=n-1;ind>=0;ind--){\\n            string temp=\"\";\\n            for(int i=ind;i<n;i++){\\n                temp+=s[i];\\n                if(st.find(temp)!=st.end()){\\n                    if(dp[i+1]){\\n                        dp[ind]=true;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422836,
                "title": "c-solution-memoization-tabulation-both-dp-comments",
                "content": "Memoization\\n```\\n// created a dp[pos], to store the boolean value of string being formed at that pos\\nint dp [301];\\nint helper(string s, vector<string> wordDict, int pos){\\n\\t// if we reach the end of string, we formed the string from the dict of wordDict\\n\\tif(pos==s.length()) return true;\\n\\t\\n\\t// if already saved in dp, return.\\n\\tif(dp[pos]!=-1) return dp[pos];\\n\\t\\n\\tstring temp = \"\";\\n\\tfor(int i =pos; i<s.length(); i++){\\n\\t\\t// we keep adding in temp, and search if present in wordDict\\n\\t\\ttemp +=s[i];\\n\\t\\tif(find(wordDict.begin(), wordDict.end(),temp)!=wordDict.end()){\\n\\t\\t\\tif(helper(s, wordDict, i+1))    return true;            \\n\\t\\t}\\n\\t}\\n\\treturn dp[pos] =  false;        \\n}\\n\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\tmemset(dp, -1, sizeof(dp));\\n\\treturn helper(s, wordDict, 0);\\n}\\n```\\n\\nTabulation: Here we do the following,\\n-> For each word in wordDict, we check that length\\'s string in the string **s** and if it is present, we save it in res, and move up the string.\\n```\\nbool wordBreak(string s, vector<string>& wordDict) {        \\n\\tvector<bool> res(s.size(),false);\\n\\tres[0]=true;\\n\\tfor(int i=0;i<s.size();i++){\\n\\t\\tif(res[i]){\\n\\t\\t\\tfor(auto str:wordDict){\\n\\t\\t\\t\\tif(s.substr(i,str.size()).compare(str)==0){\\n\\t\\t\\t\\t\\tres[i+str.size()]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res[s.size()];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// created a dp[pos], to store the boolean value of string being formed at that pos\\nint dp [301];\\nint helper(string s, vector<string> wordDict, int pos){\\n\\t// if we reach the end of string, we formed the string from the dict of wordDict\\n\\tif(pos==s.length()) return true;\\n\\t\\n\\t// if already saved in dp, return.\\n\\tif(dp[pos]!=-1) return dp[pos];\\n\\t\\n\\tstring temp = \"\";\\n\\tfor(int i =pos; i<s.length(); i++){\\n\\t\\t// we keep adding in temp, and search if present in wordDict\\n\\t\\ttemp +=s[i];\\n\\t\\tif(find(wordDict.begin(), wordDict.end(),temp)!=wordDict.end()){\\n\\t\\t\\tif(helper(s, wordDict, i+1))    return true;            \\n\\t\\t}\\n\\t}\\n\\treturn dp[pos] =  false;        \\n}\\n\\nbool wordBreak(string s, vector<string>& wordDict) {\\n\\tmemset(dp, -1, sizeof(dp));\\n\\treturn helper(s, wordDict, 0);\\n}\\n```\n```\\nbool wordBreak(string s, vector<string>& wordDict) {        \\n\\tvector<bool> res(s.size(),false);\\n\\tres[0]=true;\\n\\tfor(int i=0;i<s.size();i++){\\n\\t\\tif(res[i]){\\n\\t\\t\\tfor(auto str:wordDict){\\n\\t\\t\\t\\tif(s.substr(i,str.size()).compare(str)==0){\\n\\t\\t\\t\\t\\tres[i+str.size()]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res[s.size()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906412,
                "title": "very-efficient-code-faster-solution-than-5-06-of-problem-solvers-1905-ms-440-mb",
                "content": "Used divide and conquer in this code. Basically breaking the string into several substrings and checking whether they exist in the word dictionary or not . **Am*z0n interviewer was so proud , he realised that i had to be hired or else any other fintech shall hire me instead.**\\n    \\n    bool search(string s,set<string>& dict,int l,int r,vector<vector<int>>& dp)\\n    {\\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        string temp = s.substr(l,r-l+1);\\n        \\n        if(dict.find(temp)!=dict.end())\\n        {\\n            return dp[l][r] = 1;\\n        }\\n        \\n        for(int k=l;k<r;k++)\\n        {\\n            bool lt = search(s,dict,l,k,dp);\\n            bool rt = search(s,dict,k+1,r,dp);\\n            \\n            if(lt && rt)return dp[l][r] = true;\\n        }\\n        \\n        return dp[l][r] = false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict;\\n        \\n        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        \\n        for(auto x:wordDict)dict.insert(x);\\n        \\n        return search(s,dict,0,s.length()-1,dp);\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "Used divide and conquer in this code. Basically breaking the string into several substrings and checking whether they exist in the word dictionary or not . **Am*z0n interviewer was so proud , he realised that i had to be hired or else any other fintech shall hire me instead.**\\n    \\n    bool search(string s,set<string>& dict,int l,int r,vector<vector<int>>& dp)\\n    {\\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        string temp = s.substr(l,r-l+1);\\n        \\n        if(dict.find(temp)!=dict.end())\\n        {\\n            return dp[l][r] = 1;\\n        }\\n        \\n        for(int k=l;k<r;k++)\\n        {\\n            bool lt = search(s,dict,l,k,dp);\\n            bool rt = search(s,dict,k+1,r,dp);\\n            \\n            if(lt && rt)return dp[l][r] = true;\\n        }\\n        \\n        return dp[l][r] = false;\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict;\\n        \\n        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        \\n        for(auto x:wordDict)dict.insert(x);\\n        \\n        return search(s,dict,0,s.length()-1,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1582771,
                "title": "python-easy-dfs-dp-solution",
                "content": "```\\ndef wordBreak(self, string, wordDict):\\n\\tn = len(string)\\n\\tdp = {}\\n\\tdef dfs(i):\\n\\t\\tif i in dp: return dp[i]\\n\\t\\tif i == n: return True\\n\\t\\tif i > n:\\n\\t\\t\\treturn False\\n\\n\\t\\tfor word in wordDict: # check if there is a match for any word form \\'wordDict\\' starting from index i of \\'string\\'\\n\\t\\t\\tif i+ len(word) > n: continue\\n\\t\\t\\tif word == string[i:i + len(word)]: # if yes then do the same from i + len(word) => next index from end of match\\n\\t\\t\\t\\tdp[i] = dfs(i + len(word))\\n\\t\\t\\t\\tif dp[i]: return True\\n\\n\\t\\tdp[i] = False\\n\\t\\treturn dp[i]\\n\\n\\treturn dfs(0)\\n\\t# like if you find it useful\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef wordBreak(self, string, wordDict):\\n\\tn = len(string)\\n\\tdp = {}\\n\\tdef dfs(i):\\n\\t\\tif i in dp: return dp[i]\\n\\t\\tif i == n: return True\\n\\t\\tif i > n:\\n\\t\\t\\treturn False\\n\\n\\t\\tfor word in wordDict: # check if there is a match for any word form \\'wordDict\\' starting from index i of \\'string\\'\\n\\t\\t\\tif i+ len(word) > n: continue\\n\\t\\t\\tif word == string[i:i + len(word)]: # if yes then do the same from i + len(word) => next index from end of match\\n\\t\\t\\t\\tdp[i] = dfs(i + len(word))\\n\\t\\t\\t\\tif dp[i]: return True\\n\\n\\t\\tdp[i] = False\\n\\t\\treturn dp[i]\\n\\n\\treturn dfs(0)\\n\\t# like if you find it useful\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1483038,
                "title": "python3-recursive-with-memoization-faster-than-99",
                "content": "\\'\\'\\'\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n\\n\\n        def can_construct(target, strings_bank, memo):    \\n            if target in memo:\\n                return memo[target]\\n            if target == \"\":\\n                return True\\n            for element in strings_bank: # for every element in our dict we check if we can start constructing the string \"s\"\\n                if element == target[0:len(element)]: # the remaining of the string \"s\" (which is the suffix) is the new target \\n                    suffix = target[len(element):]\\n                    if can_construct(suffix, strings_bank, memo):\\n                        memo[target] = True\\n                        return True\\n            memo[target] = False\\n            return False\\n\\n\\n        return can_construct(s, wordDict, memo)\\n```\\nIf you like it, please upvote!\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n\\n\\n        def can_construct(target, strings_bank, memo):    \\n            if target in memo:\\n                return memo[target]\\n            if target == \"\":\\n                return True\\n            for element in strings_bank: # for every element in our dict we check if we can start constructing the string \"s\"\\n                if element == target[0:len(element)]: # the remaining of the string \"s\" (which is the suffix) is the new target \\n                    suffix = target[len(element):]\\n                    if can_construct(suffix, strings_bank, memo):\\n                        memo[target] = True\\n                        return True\\n            memo[target] = False\\n            return False\\n\\n\\n        return can_construct(s, wordDict, memo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480275,
                "title": "well-explained-clean-concise-98-faster",
                "content": "## IDEA:\\n*Mark the end point upto which we can reach by using the words from given dictionary.*\\n### Explainantion:\\n\\n\\t* For this we can use dp to mark the index which is reachable or not.\\n\\t* In starting we can reach the 0th index of any string so make it True.\\n\\t* Now, start the loop of length of given string and when you find the index is reachable i.e. **dp[i]==True** start checking for the next word to be fitted in string.\\n\\t* If found make dp[i]=True.\\n\\t* By going all the index if we are unable to reach last index then it will remain as False.\\n\\t* Return the dp[-1] which will signify that we aare able form string or not from wordDictionary given.\\n\\n### CODE:\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        n=len(s)\\n        dp = [False for _ in range(n+1)]\\n        dp[0]=True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for w in wordDict:\\n                    if s[i:i+len(w)]==w:\\n                        dp[i+len(w)]=True\\n        return dp[-1]\\n\\t\\t\\n**Feel free to ask if you have any doubt.\\uD83E\\uDD1E**\\n#### Thanks and *Upvote* if you got any help!!\\uD83E\\uDD17",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "## IDEA:\\n*Mark the end point upto which we can reach by using the words from given dictionary.*\\n### Explainantion:\\n\\n\\t* For this we can use dp to mark the index which is reachable or not.\\n\\t* In starting we can reach the 0th index of any string so make it True.\\n\\t* Now, start the loop of length of given string and when you find the index is reachable i.e. **dp[i]==True** start checking for the next word to be fitted in string.\\n\\t* If found make dp[i]=True.\\n\\t* By going all the index if we are unable to reach last index then it will remain as False.\\n\\t* Return the dp[-1] which will signify that we aare able form string or not from wordDictionary given.\\n\\n### CODE:\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        \\n        n=len(s)\\n        dp = [False for _ in range(n+1)]\\n        dp[0]=True\\n        \\n        for i in range(n):\\n            if dp[i]:\\n                for w in wordDict:\\n                    if s[i:i+len(w)]==w:\\n                        dp[i+len(w)]=True\\n        return dp[-1]\\n\\t\\t\\n**Feel free to ask if you have any doubt.\\uD83E\\uDD1E**\\n#### Thanks and *Upvote* if you got any help!!\\uD83E\\uDD17",
                "codeTag": "Java"
            },
            {
                "id": 1354876,
                "title": "o-n-2-regular-mcm-approach",
                "content": "In this question if we observe carefully, the problem statement can be reduced to this ->\"*it is saying us to make partitions of the given string such that all the partitions should be present in the dictionary*\".\\n\\nSo, for making partitions we can use MCM (**matrix chain multiplication**) approach. \\n\\nHere is my code for MCM approach with memoization.\\n\\n```\\nclass Solution {\\npublic:\\n    bool MCM(string &s, unordered_map<string, bool> &ourmap, int i, int j, vector<vector<int>> &dp){\\n        if(i>j) return false;            //base case\\n        if(dp[i][j]!=-1) return dp[i][j];        //using previously stored sub-problem\\n        string temp = s.substr(i,j-i+1);\\n        if(ourmap.count(temp))  return true;\\n        bool flag=false;\\n\\t\\t//running loop for checking valid partition \\n        for(int k=i;k<j;k++){\\n            if(MCM(s,ourmap,i,k,dp) && MCM(s,ourmap,k+1,j,dp)){\\n                flag=true;\\n            }\\n        }\\n        return dp[i][j]=flag;    //storing final answer and returing it too\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n       unordered_map<string,bool> ourmap;     //map for storing dictionary\\n        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,-1));     //dp array for storing sub-problems answers\\n        for(int i=0;i<wordDict.size();i++){\\n            ourmap[wordDict[i]]=true;\\n        }\\n        \\n        return MCM(s,ourmap,0,s.size()-1,dp);      //calling MCM function\\n    }\\n};\\n```\\n\\nThanks for reading!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool MCM(string &s, unordered_map<string, bool> &ourmap, int i, int j, vector<vector<int>> &dp){\\n        if(i>j) return false;            //base case\\n        if(dp[i][j]!=-1) return dp[i][j];        //using previously stored sub-problem\\n        string temp = s.substr(i,j-i+1);\\n        if(ourmap.count(temp))  return true;\\n        bool flag=false;\\n\\t\\t//running loop for checking valid partition \\n        for(int k=i;k<j;k++){\\n            if(MCM(s,ourmap,i,k,dp) && MCM(s,ourmap,k+1,j,dp)){\\n                flag=true;\\n            }\\n        }\\n        return dp[i][j]=flag;    //storing final answer and returing it too\\n    }\\n    \\n    bool wordBreak(string s, vector<string>& wordDict) {\\n       unordered_map<string,bool> ourmap;     //map for storing dictionary\\n        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1,-1));     //dp array for storing sub-problems answers\\n        for(int i=0;i<wordDict.size();i++){\\n            ourmap[wordDict[i]]=true;\\n        }\\n        \\n        return MCM(s,ourmap,0,s.size()-1,dp);      //calling MCM function\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984987,
                "title": "c-solution",
                "content": "```\\n bool solve(string s,unordered_map<string,int> dict)\\n    {\\n            int n = s.size();\\n            vector<int>dp(n+1);\\n            dp[0] = true;\\n            for(int len = 1;len<=s.length();len++)\\n            {\\n                    for(int i = 0;i<len;i++)\\n                    {\\n                            if(dp[i] == true && dict.find(s.substr(i,len- i)) != dict.end()){\\n                                    dp[len] = true;\\n                                    break;\\n                            }\\n                    }\\n            }\\n         return dp[n];\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n            unordered_map<string,int> dict;\\n            for(int i = 0;i<wordDict.size();i++)\\n            {\\n                   dict[wordDict[i]]++; \\n            }\\n           return solve(s,dict);\\n    }",
                "solutionTags": [],
                "code": "```\\n bool solve(string s,unordered_map<string,int> dict)\\n    {\\n            int n = s.size();\\n            vector<int>dp(n+1);\\n            dp[0] = true;\\n            for(int len = 1;len<=s.length();len++)\\n            {\\n                    for(int i = 0;i<len;i++)\\n                    {\\n                            if(dp[i] == true && dict.find(s.substr(i,len- i)) != dict.end()){\\n                                    dp[len] = true;\\n                                    break;\\n                            }\\n                    }\\n            }\\n         return dp[n];\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n            unordered_map<string,int> dict;\\n            for(int i = 0;i<wordDict.size();i++)\\n            {\\n                   dict[wordDict[i]]++; \\n            }\\n           return solve(s,dict);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 870576,
                "title": "python-dynamic-programming",
                "content": "```\\ndef wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\tdp = [False]*(len(s)+1)\\n\\tdp[0] = True\\n\\twordDict = set(wordDict)\\n\\n\\t# check if words until index i are valid(in wordDict)\\n\\tfor i in range(len(s)):\\n\\t\\t# if word until index j is valid, than we only need to check if word[j:i+1] is valid for all substring word[:i+1] to be valid\\n\\t\\tfor j in range(i+1):\\n\\t\\t\\tif not dp[j]:\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t# we know word[:j] is valid if we are here, so if word[j:i+1] is valid we can check substring word[:i+1] as valid too\\n\\t\\t\\tsubword = s[j:i+1]\\n\\t\\t\\tif subword in wordDict:\\n\\t\\t\\t\\tdp[i+1] = True\\n\\t\\t\\t\\tbreak\\n\\n\\treturn dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n\\tdp = [False]*(len(s)+1)\\n\\tdp[0] = True\\n\\twordDict = set(wordDict)\\n\\n\\t# check if words until index i are valid(in wordDict)\\n\\tfor i in range(len(s)):\\n\\t\\t# if word until index j is valid, than we only need to check if word[j:i+1] is valid for all substring word[:i+1] to be valid\\n\\t\\tfor j in range(i+1):\\n\\t\\t\\tif not dp[j]:\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t# we know word[:j] is valid if we are here, so if word[j:i+1] is valid we can check substring word[:i+1] as valid too\\n\\t\\t\\tsubword = s[j:i+1]\\n\\t\\t\\tif subword in wordDict:\\n\\t\\t\\t\\tdp[i+1] = True\\n\\t\\t\\t\\tbreak\\n\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 870374,
                "title": "java-short-and-crisp-dfs-time-space-beats-99-with-explanation",
                "content": "Instead of breaking string at every index from 0 to string.length() ,search if the word in Dictionary is prefix of the string.\\nIf (word is prefix of string) Break the string upto prefix and again apply recursion\\n\\nExample:\\ns = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\\nSol:\\ndfs(\"applepenapple\", Dictionary wordDict){\\nfor(word in wordDict)\\n\"applepenapple\" starts with \"apple\". so apply dfs on \"penapple\"\\n}\\ndfs(\"penapple\",apple,Dictionary wordDict){\\nfor(word in wordDict){\\n\"penapple\" does not start with apple ,so continue\\n\"penapple\" starts with pen ,so apply dfs on \"apple\"\\n}\\ndfs(\"apple\",Dictionary wordDict){\\nfor(word in wordDict){\\n\"apple\" starts with apple, so apply dfs on \"\"\\n}\\n}\\ndfs(\"\") {\\nif string is empty then we have successfully broken string using words in dictionary\\n}\\n\\nUse a hashmap to store already computed results.This is called memoization ,which hugely reduces time and space complexity.\\n\\n```\\nclass Solution {\\n    private HashMap<String,Boolean> memo;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t//Hashmap for memoization\\n        memo=new HashMap<String,Boolean>();\\n\\t//We know that ,if string is empty ,return true\\n        memo.put(\"\",true);\\n\\t//Start Depth-first-Search\\n        return recur(s,wordDict);\\n    }\\n    private boolean recur(String s,List<String> dictionary){\\n\\t//If given string is already computed,then return stored result\\n        if(memo.containsKey(s)) return memo.get(s);\\n\\t//Variable to store result\\n        boolean res=false;\\n\\t//For every word in Dictionary,check if the word is prefix of input string\\n        for(String word: dictionary){\\n            if(s.startsWith(word)){\\n\\t\\t\\t//If you find string can be broken ,then stop searching \\n                if(recur(s.substring(word.length()),dictionary)){\\n                    res=true;\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\t//Store result to prevent same computations in future\\n        memo.put(s,res);\\n        return res;\\n    }\\n}\\n```\\nLink for follow up problem : **Word Break 2**\\nhttps://leetcode.com/problems/word-break-ii/discuss/871333/Java-short-and-crisp-DFSmemoization-or-With-Explanation\\n\\nHope you find it useful.\\nThank You",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private HashMap<String,Boolean> memo;\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n\\t//Hashmap for memoization\\n        memo=new HashMap<String,Boolean>();\\n\\t//We know that ,if string is empty ,return true\\n        memo.put(\"\",true);\\n\\t//Start Depth-first-Search\\n        return recur(s,wordDict);\\n    }\\n    private boolean recur(String s,List<String> dictionary){\\n\\t//If given string is already computed,then return stored result\\n        if(memo.containsKey(s)) return memo.get(s);\\n\\t//Variable to store result\\n        boolean res=false;\\n\\t//For every word in Dictionary,check if the word is prefix of input string\\n        for(String word: dictionary){\\n            if(s.startsWith(word)){\\n\\t\\t\\t//If you find string can be broken ,then stop searching \\n                if(recur(s.substring(word.length()),dictionary)){\\n                    res=true;\\n                    break;\\n                }\\n            }\\n        }\\n\\t\\t//Store result to prevent same computations in future\\n        memo.put(s,res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1841940,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567045,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1568170,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1570170,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567885,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999348,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999923,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999123,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567312,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1576436,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1841940,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567045,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1568170,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1570170,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567885,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999348,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999923,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1999123,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1567312,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1576436,
                "content": [
                    {
                        "username": "simmimourya1",
                        "content": "Explanation: I wish the question was explained in bit more detail. \\n\\nThe question should be reframed as; Is there a combination of words in wordDict that can be used to recreate the original string s. Notice that I mentioned the word combination, this does not mean that you will need all the words in wordDict to recreate s (Using some words from wordDict as long as they perfectly recreate the string s; is a valid solution or word break). Also note that you can use the words in wordDict more than once. \\n\\nTake this example for reference: \\n\\nInput: \"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nExpected: true\\n\\nHere, word \"b\" from wordDict can be used to perfectly to recreate the string s = \"b\" + \"b\" , which is why the expected output is True. Note that we did not use all the words in the dictionary and still found a valid word break.\\n\\nNow, let\\'s take another example:\\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\nOutput: false\\n\\nHere, no combination of words exist in wordDict that can perfectly recreate the input string s.\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on. \\n\\nThe intuition is that you will have consider every combination of words in the wordDict, moreover these words can be used more than once when computing the combinations.  \\n"
                    },
                    {
                        "username": "nemesis_123",
                        "content": "Thanks for tip"
                    },
                    {
                        "username": "bparanj",
                        "content": "That\\'s exactly right! The word break problem asks us to determine whether the entire input string `s` can be broken down into a sequence of one or more words from the dictionary `wordDict`. It\\'s not enough to just find some words from the dictionary within the string. The key requirement is that we use the words from the dictionary to build up the entire string `s`, potentially using some words multiple times.\\n\\nAs you mentioned, the core of this problem lies in identifying all possible combinations of words from the dictionary that can be put together to recreate the string `s`. This involves iterating through the string, breaking it down into substrings, and checking if these substrings exist in the word dictionary.\\n\\nA brute force approach could involve generating all possible substrings and checking if each one is in the dictionary. However, this would be quite inefficient. A more efficient approach is to use dynamic programming, where we keep track of which parts of the string can be broken down into dictionary words, and use this information to guide how we break down the rest of the string.\\n"
                    },
                    {
                        "username": "sshubhamk1",
                        "content": "\"cats\" + \"dog\" will require \"an\" in wordDict in order to recreate s"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "Thanks for the explanation, My code failed at that bb testcase just as you said.\\nI think the problem statement should be rephrased as you said above."
                    },
                    {
                        "username": "Rtorres",
                        "content": "I don\\'t understand why this should output false given that the description says at least one dictionary word. It has at least one dictionary word in catsandog, so why output false? What am I missing?"
                    },
                    {
                        "username": "centr0",
                        "content": "[@bparanj](/bparanj) Thank you! I was stuck right at this place."
                    },
                    {
                        "username": "Li_tCode",
                        "content": "[@bparanj](/bparanj) you mean \"san\" not \"sand\""
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is not asking if the string contains at least one dictionary word. Rather, the problem is asking if the entire string can be segmented into dictionary words, with no extra characters left over.\\n\\nIn other words, you must be able to divide the entire string such that each segment (which can be of varying length) is a word in the dictionary. If this is possible, the function should return True. If it\\'s not possible to divide the string such that each segment is in the dictionary, then the function should return False.\\n\\nIn the case of \"catsandog\", even though it contains dictionary words like \"cat\" and \"dog\", it can\\'t be completely segmented into dictionary words because \"sand\" is not in the dictionary provided. Thus, the function returns False.\\n"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "catsandog can be partitioned to either cats+and+og or cats+an+dog but not cats+and+dog"
                    },
                    {
                        "username": "ravikumargautam049",
                        "content": "[@Abhishekg25](/Abhishekg25)   but question ask for one or more word----> so one can be cats or dog or sand or and. isn\\'t it ?   "
                    },
                    {
                        "username": "davidtn",
                        "content": "[@Abhishekg25](/Abhishekg25) not all of which words? The partitioned words in 1,2,3,etc? We can do better than dangling modifiers"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "jaspier",
                        "content": "Why this input is false\\n\\n\"catsandog\"\\n[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nand this one is true\\n\\n\"cars\"\\n[\"car\",\"ca\",\"rs\"]\\n\\n?\\n\\n\\n\\n"
                    },
                    {
                        "username": "vimarshj3",
                        "content": "\"cars\" can be generated with the help of \"ca\" and \"rs\""
                    },
                    {
                        "username": "ranaabdulmuneeb",
                        "content": "[@bparanj](/bparanj) \"s\" where in dictionary ?"
                    },
                    {
                        "username": "SaqlainRashid",
                        "content": "\"ca\" + \"rs\" = \"cars\" is possible thus the later is possible but in the former :\\n\"cats\" + \"dog\" will require \"san\" in wordDict in order to recreate s\\n\"cats\" + \"and\" will require \"og\" in wordDict in order to recreate s\\n\"cat\" + \"sand\" will require \"og\" in wordDict in order to recreate s\\n... and so on."
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem is asking if the entire string `s` can be segmented into one or more dictionary words. \\n\\nLet\\'s look at the two examples:\\n\\n1. For `s=\"catsandog\"` and `wordDict=[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]`:\\n\\n    We can see that the words \"cats\", \"and\", and \"dog\" are in `wordDict`, but the leftover part \"og\" from \"sandog\" is not in the `wordDict`, so we cannot break up the entire string `s` using words from `wordDict`. Therefore, the answer is `False`.\\n\\n2. For `s=\"cars\"` and `wordDict=[\"car\",\"ca\",\"rs\"]`:\\n\\n    The string `s` can be broken up into \"car\"+\"s\" or \"ca\"+\"rs\". Since both \"car\", \"ca\", \"rs\" and \"s\" are in `wordDict`, we can segment the entire string `s` into dictionary words. Therefore, the answer is `True`.\\n\\nRemember, the goal of the problem is to check if we can break up the entire string `s` into words present in the `wordDict`, not just a part of it."
                    },
                    {
                        "username": "Vithesh",
                        "content": "why are you even asking this..."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "[@bumate90](/bumate90) car + s will create the issue. since \\'s\\' is not present in the list."
                    },
                    {
                        "username": "bumate90",
                        "content": "[@Abhishekg25](/Abhishekg25) \\nAnd how come \"car\" + \"s\" is not an issue?"
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "catsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nbut cars ->\\n1. ca + rs\\nis present in the list"
                    },
                    {
                        "username": "ML-SWE",
                        "content": "For the test case \\n\\ns=\"a\"\\nwordDict = [\"b\"]\\n\\nwhen clicking submit, leetcode claims my code outputs \"True\" when the output should be \"False\". When I run the code locally or when I change the custom test case to match, they both return \"False\". What is wrong with leetcodes compiler??"
                    },
                    {
                        "username": "ankitk742",
                        "content": "[@sharadbhat](/sharadbhat)  use global variable \\n\\n\\ndef __init__(self):\\n        self.memo = {}\\n\\ndon\\'t call memoization through the function"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "[@nikulinsmr0](/nikulinsmr0) Hey! I have the exact same problem as him. What do you mean resetting the global variable? What and where do I have to change?"
                    },
                    {
                        "username": "nikulinsmr0",
                        "content": "got the same issue, fixed by resetting global variable in your wordBreak method"
                    },
                    {
                        "username": "sharadbhat",
                        "content": "Are you using a global variable? That\\'s probably the reason."
                    },
                    {
                        "username": "heyaoyu",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"bb\", [\"a\",\"b\",\"bbb\",\"bbbb\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "YadavVicky",
                        "content": "[@amitjha00](/amitjha00) It will not because there is no such segmentation possible for eg if we segment cat + san + dog so, we have \\'cat\\' and \\'dog\\' but no \\'san\\' in the word dict, if we segment cats + and + og, we have \\'cats\\' and \\'and\\' but no \\'og\\' in the word dict. You can try. "
                    },
                    {
                        "username": "amitjha00",
                        "content": "[@dkochetov](/dkochetov) by your explanation the 3rd case given in the sample input output should be true then because we can also use wordDict elements to from that string ?"
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "I assumed this was also true based on Example 3. My problem was that I read the string as \"Cats and dog\" instead of \"Cats an dog\" which can\\'t match \"an\" to a word in the word bank."
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@THE_BMKJS_LEADER](/THE_BMKJS_LEADER) You can use any word multiple times. In this case using word \"b\" twice would give you the string \"bb\". No need to use the remaining words \"a\",\"bbb\",\"bbbb\""
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "[@peihao61](/peihao61) Please expalin little bit more"
                    },
                    {
                        "username": "genewangtp",
                        "content": "Yes it\\'s weird, why \"bb\" can be segmented to \"a\", \"b\" ???"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": "[@peihao61](/peihao61) can you explain why this happens\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case: \"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Imagine you\\'re solving a word puzzle, where you have to split a string into meaningful words. The catch? You can use words from your dictionary as many times as you want. \\uD83E\\uDDE9\\n\\n\\uD83C\\uDFAF Step 1: Breaking Down the Puzzle \\uD83C\\uDFAF\\n\\nThink of your string as a trail of letters. Your job is to find if you can split it into valid words from your dictionary. \\uD83D\\uDCDA Start by asking, \"Can I make a word from the letters I\\'ve seen so far?\"\\n\\n\\uD83D\\uDD0D Step 2: Navigating Choices \\uD83D\\uDD0D\\n\\nAs you move along the string, keep track of two points: where a valid word began last and where you are now. This is like placing breadcrumbs along the trail. \\uD83E\\uDD56 Now, when you find a word, you decide: \"Should I use this word and continue, or move ahead?\" ( Yes, these are the recursion choices you have XD)\\n\\n\\uD83E\\uDDE0 Step 3: Remembering Choices with Memoization \\uD83E\\uDDE0\\n\\nJust like taking notes, memoization helps you remember your decisions. Create a table to jot down whether you can split the part between the last word and the current point into valid words.\\n\\n\\uD83D\\uDEE0\\uFE0F Step 4: Putting the Puzzle Together \\uD83D\\uDEE0\\uFE0F\\n\\nWith each step, you\\'re solving a piece of the puzzle. Should you include the current word, or skip it and explore further? Your \"trail\" of breadcrumbs (last index) and memoization table guide you to the answer.\\n\\n\\uD83D\\uDC69\\u200D\\uD83D\\uDCBBHere are some things you should consider while encountering something like this:\\n\\nDivide & Conquer: Break the big problem into smaller ones.\\nNote Down Solutions: Use memoization to remember your solutions.\\nMake Smart Choices: Decide whether to use a word or explore more.\\nBe Efficient: Use your memory (memoization) to avoid repeating work.\\n\\nhappy word breaking! \\n"
                    },
                    {
                        "username": "emlitke",
                        "content": "I have pen. I have pine apple. Pen pineapple apple pen. "
                    },
                    {
                        "username": "vaibhavjuly123",
                        "content": "i was thinking the same lol\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "try DFS recursion with DP"
                    },
                    {
                        "username": "pwh",
                        "content": "Has anybody thought about the solution when the problem is changed such that each word in the dictionary can be only used once?\\n\\nMy initial thoughts:\\n\\u2022 DP:\\nAt each point i where the string is breakable, we need to use a set to remember which words we have used to break the string up to this point. And when we are considering a later point j, based on which previous breakable point we are using as a pivot, we will need to consider the \"breakability\" of the string at index j with (input set - set stored at index j)\\n\\n\\u2022 DFS + Memo:\\nThe memo is not only keyed by the starting index, but should also encode the information of what words are still available in the set, because both of those together represent the state of the DFS (whether the substring starting at index i, *with the remaining usable words*, is breakable). But I am not exactly sure how to encode a set of strings as a key. (sort the strings and concatenate?)\\n\\nJust food for thought."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@bparanj](/bparanj) Keeping track of the used words in ``wordDict`` is easy. When a word has been used, remove the word at the end of ``wordDict`` and use it to replace the current word. (The size of ``wordDict`` gets reduced by 1)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Great thinking! You are right on track.\\n\\nIf each word in the dictionary can only be used once, it does become a more complex problem.\\n\\nFor a DP solution, you would indeed need to track the used words at each possible break point. For each new word you encounter, you\\'d need to check if it can be formed using the remaining words in the dictionary. This could potentially be quite inefficient as the size of the word dictionary increases, since you\\'d be creating and comparing sets of words at each possible break point.\\n\\nFor a DFS + Memo approach, it\\'s a bit trickier. You can\\'t just key the memoization structure by the start index anymore, as the remaining words in the dictionary become part of the state.\\n\\nA potential way to handle this could be to convert the remaining words into a bitmask. This will work well if the number of words in the dictionary is relatively small (up to about 20 words due to the limitation of integer size). Each bit in the bitmask would correspond to whether a particular word is still available. This would allow for efficient comparison and combination of states. Here\\'s a high-level idea of how the solution might look like:\\n\\n1. Convert the word dictionary into an indexed list of words, so each word corresponds to an index.\\n\\n2. Initialize a DP table or memoization structure that is keyed by the start index in the string and the bitmask representing the remaining words.\\n\\n3. Perform the DFS or DP process as normal, but when marking a word as used, also update the bitmask to indicate that the corresponding word is no longer available.\\n\\nRemember that this approach would only be feasible for a small dictionary size. For larger dictionaries, a different approach would be required, potentially involving complex data structures to efficiently represent the set of remaining words."
                    },
                    {
                        "username": "R140",
                        "content": "The question asks to check \" if s can be segmented into a space-separated sequence of** one or more** dictionary words.\"\\n\\nSince it says one or more, shouldn\\'t we be returning true for below testcase as it has one dictionary word which is cats in sequence?\\n\\n s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n output - false"
                    },
                    {
                        "username": "bparanj",
                        "content": "The key phrase in the problem statement is that `s` can be segmented into a \"sequence of one or more dictionary words\". \\n\\nThis doesn\\'t mean that the presence of one or more dictionary words within `s` would return True. Instead, it means that the entirety of `s` needs to be able to be segmented into a sequence of one or more dictionary words.\\n\\nIn your example:\\n\\ns = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\n\\nThough \"cats\", \"dog\", \"sand\", \"and\", \"cat\" are present within `s`, there\\'s no way to segment the entire string `s` into a sequence of one or more dictionary words without any leftover characters. The leftover characters \"an\" and \"og\" are not part of the word dictionary.\\n\\nHence, the output is False. \\n\\nIf your string was \"catsand\" and your wordDict = [\"cats\",\"and\"], the output would be True, because you can segment the entire string into dictionary words: \"cats\" and \"and\"."
                    },
                    {
                        "username": "tkwena",
                        "content": "[@ishanm](/ishanm) Yes. We need to split the string and however we decide to split it, all the words that we come up with should be in the dictionary.\\n"
                    },
                    {
                        "username": "peihao61",
                        "content": "case 1: \"cats\" + \"and\" => no \"og\" pattern\\ncase 2: \"cat\" + \"sand\" => no \"og\" pattern\\nso output - false"
                    },
                    {
                        "username": "ishanm",
                        "content": "The test case output is correct. This testcase is an illusion to our eyes. If you read carefully, \\ncatsandog = cats + and + og. \\nWe need to question ourselves if all the three strings are present in the dictionary?"
                    }
                ]
            },
            {
                "id": 1575228,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1569445,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1999133,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1570336,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1999192,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1572509,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1747347,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1572067,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1568962,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 1568963,
                "content": [
                    {
                        "username": "arunleetcode",
                        "content": "I am not sure if it is the issue with leetcode, When i submit the code, for a particular test case it gives me wrong answer but when i ran the same test from leet code, it passes. Please see attached screenshots. Please help me if anyone has any suggestion.![image](https://assets.leetcode.com/users/images/17a3be8b-3729-482b-811d-b0b0b743aa9b_1620264327.2273011.png)\\n![image](https://assets.leetcode.com/users/images/16a2f13f-df8f-4015-bb96-1ccf3bcda6c9_1620264327.2230597.png)\\n\\n"
                    },
                    {
                        "username": "Jeevan_Siddu",
                        "content": "This happens because when you compile a particular testcase only that test case will run and give output , but when you run the program all the testcases will go in a loop to the function and in your function if you store the state of previous variables the answer will change , for example avoid using static variables "
                    },
                    {
                        "username": "berserker123",
                        "content": "How it the time complexity of the solution O(n^2) for Recursion with memoization?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The time complexity of the recursive solution with memoization for this problem is O(n^2), where n is the size of the input string. Here\\'s why:\\n\\n1. **Recursion Depth / State Space**: We\\'re making a recursive call for each prefix of the string that matches a word in the dictionary, up to n. Therefore, we have up to n different states.\\n\\n2. **Work Done Per State**: For each state, i.e., for each index in the string, we\\'re doing a constant amount of work: we\\'re checking if the remaining suffix of the string is a word we\\'ve seen before (which is an O(1) operation because we\\'ve assumed that word lookup in the dictionary is constant time), and if it is, we\\'re making a recursive call. \\n\\n3. **Memoization**: Because of memoization, each state (each possible start of a suffix) is only computed once. Subsequent calls to the same state are returned in constant time from the memoization table.\\n\\n4. **Number of States**: We have n states and we\\'re doing O(n) work per state, leading to O(n^2) time complexity overall.\\n\\nHowever, note that the actual time complexity could be worse than O(n^2) if the average length of the words in the dictionary is large because string slicing in Python isn\\'t a constant-time operation. If the word lengths are small and/or roughly equal, though, it can be considered as approximately O(n^2)."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "I see a lot of people failing to notice that there is only one `\"d\"` in `\"catsandog\"`.\\n\\nThe string `\"catsandog\"` , due to having only one `\"d\"`, cannot be broken down to a combination of words taken from `wordDict` = `[\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]`.\\n\\n_Hope that helps !!_"
                    },
                    {
                        "username": "rookie92",
                        "content": "Can somebody explain this?"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "Find the recurrence relation first before thinking of any DP solutions. \n\nHint: if the current substring(contiguous) word exist in wordDict, that means it's a valid word and can be broken, then if the rest of the string is also valid then the whole string should be valid.\n\nAfter cracking the recurrence relation, try to apply memoization."
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is the recurrence relation I came up with. But I\\'m not sure how to memoize it. Can you help with this?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ZimingYuan",
                        "content": "I am wondering whether using *Trie* to hold the words in the dictionary will be faster than just using *Set*. It seems that using *Trie* will reduce the number of repetitive operations. Do anyone have tried out this data structure and got a better result?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a Trie (also known as a prefix tree) could indeed be a beneficial data structure for this problem. It allows us to efficiently find all words in the dictionary that can serve as a prefix for a given string, which aligns well with our problem requirements.\\n\\nA Trie provides O(L) lookup where L is the length of the word we are looking for. Inserting words from the dictionary into the Trie also takes O(L) time. These are roughly equivalent to the performance characteristics of a Set, but there are some key differences when considering our specific problem.\\n\\n1. **Finding All Prefixes:** Given a string s, we can use the Trie to find all the dictionary words that are prefixes of s in a single pass through s. This can be more efficient than the approach of checking each possible prefix against a Set, which would require separate checks for each prefix. \\n\\n2. **Reducing Repetition:** We can terminate early if we know a prefix of s cannot lead to a valid segmentation. With a Set, we might perform unnecessary computations for longer prefixes that share the same starting part.\\n\\nHowever, there are trade-offs:\\n\\n1. **Space Complexity:** Tries can be more space-intensive than Sets. They store a node for each character of each word, which can add up, particularly if the words in the dictionary are long.\\n\\n2. **Implementation Complexity:** Tries are more complex to implement and use than Sets. This might make your solution harder to write and debug.\\n\\nSo, if your dictionary has many long words with common prefixes, a Trie might speed up your solution. However, remember that Tries use more memory and are harder to implement than Sets. Always consider the trade-offs based on your specific use case."
                    },
                    {
                        "username": "545301030",
                        "content": "why time complexity of BFS solution is O(n^3) in the official solution?"
                    },
                    {
                        "username": "Prodogy11",
                        "content": "Because the outer while loop for your queue can iterate $$n$$ times in worst case.\nThen the for-loop inside your while loop can iterate $$n$$ times because you're looking at all substrings from the start node to the end of the n length string. \n\nThen inside the for-loop, you will need to do substring generation, which has worst cast $$O(n)$$.\n\nSo $$n*n*n = O(n^3)$$"
                    },
                    {
                        "username": "qiuhaonan_nju",
                        "content": "Hi.\\nWhich range should this problem be classified into? DP? Backtracking?\\nBy definition from web, a problem that has optimal substructure and overlapping subproblems and searches for a optimal solution should be defined as a DP problem. However, this problem seems to judge if a breaking rule exists. And backtracking seems to be an inituitive solution. How can we associate this problem with DP if we don\\'t meet it in LeetCode?\\nCan you help me for giving the DP transfer equation?\\nWelcome for discussion.\\nThanks."
                    },
                    {
                        "username": "nikhil_211",
                        "content": "[@bparanj](/bparanj) Can you help me understand why it should be s[j+1:i+1] and not s[j+1:i].\\nAs I understand, dp[i] will be true if dp[j] is true and string from index j+1 till ith exist in the dict.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "This problem can indeed be solved using both dynamic programming (DP) and backtracking. However, the dynamic programming approach is generally more efficient due to its ability to avoid re-computation of overlapping subproblems. Here\\'s how we can formulate this problem in terms of dynamic programming:\\n\\n**Step 1:** Understand the problem statement\\n\\nThe problem is asking if we can break up the input string into words that exist in the given dictionary. This suggests that we can solve smaller instances of the same problem and use them to solve the larger problem, hinting at the optimal substructure property required for DP.\\n\\n**Step 2:** Define the state\\n\\nLet\\'s define `dp[i]` to be `True` if the string up to the `i`-th index can be segmented into one or more dictionary words, and `False` otherwise. The state `dp[i]` depends on the states of all the indices before `i`.\\n\\n**Step 3:** Formulate the DP transfer equation\\n\\nFor `dp[i]` to be `True`, there needs to be an index `j` before `i` such that `dp[j]` is `True` and the string from the `(j+1)`-th index to `i`-th index is a dictionary word. Formally,\\n\\n```\\ndp[i] = True if there exists a j such that dp[j] = True and s[j+1:i+1] is a dictionary word\\ndp[i] = False otherwise\\n```\\n\\nWe initialize `dp[0]` to `True` since the empty string can always be segmented.\\n\\nThe final answer will be `dp[n]`, where `n` is the size of the input string.\\n\\nThis way, we formulate the problem as a DP problem and solve it efficiently by reusing solutions to smaller subproblems. The time complexity of this approach is O(n^2), and the space complexity is O(n) for the `dp` array."
                    },
                    {
                        "username": "tiesto1114",
                        "content": "I'm wondering what is the reason behind to switch the input parameter from set to list? Isn't the set could check contains in O(1)? But it's interesting that it takes more time if I create a hashset. I think the dictionary is probably not big enough though."
                    },
                    {
                        "username": "bparanj",
                        "content": "Indeed, set operations in Python typically have an average time complexity of O(1), while for lists it\\'s O(n). That said, the actual performance can depend on various factors, and it\\'s not always guaranteed that a set will be faster than a list.\\n\\nOne key factor is the size of the data. Sets in Python are implemented as hash tables, and their speed advantage becomes noticeable only when dealing with larger datasets. If the word dictionary is small, the overhead of hashing might outweigh the benefits of quick lookup, making a list operation faster.\\n\\nIn addition, the specific nature of the operations being performed also matters. If you\\'re doing a lot of adding and removing operations, a set will generally outperform a list, since these operations are O(1) for a set and O(n) for a list. However, if the primary operation is iterating over the elements, a list might be faster, as sets in Python are unordered and iterating over a set could potentially be slower than over a list.\\n\\nLastly, it\\'s worth noting that the time complexity measures are theoretical abstractions that describe the growth of time with respect to the input size. They don\\'t account for lower-level details like memory access patterns, CPU caching, interpreter overhead, etc., which can all influence the actual run time. Therefore, while complexity analysis provides valuable insight, it doesn\\'t always perfectly correlate with performance in practice. \\n\\nRemember, it\\'s always good practice to benchmark different approaches with realistic datasets to choose the most suitable one for a particular use case."
                    },
                    {
                        "username": "wahahaha",
                        "content": "wordDict always is a null object, waste me lots of time, god"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "how?\\n"
                    }
                ]
            },
            {
                "id": 2040318,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1999193,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1709927,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1575802,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1575291,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1574177,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1572610,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1571303,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1570216,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1574247,
                "content": [
                    {
                        "username": "sandeepmourya0720",
                        "content": "\"ccbb\"\\n[\"bc\",\"cb\"]\\n How this is false, can\\'t we use cb twice to form the word"
                    },
                    {
                        "username": "moraalejandro94",
                        "content": "tip: have a dp of size len(s)+1 with with dp[i] = True or False for wether or not you can build the substring of size i. dp[0] is always True since it represents empty string. "
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "This soln pass 33/45 test cases can you clear me that where i can make mistake in the given code in java using trie.\n\n# code \n------------------------------------------------------------------------------------------------------------------------------------------------------------------\n```\nclass Solution {\n    static class Node{\n        Node [] children = new Node[26];\n        boolean eow = false;\n        Node(){\n            for(int i=0;i<26;i++){\n                children[i] = null;\n            }\n        }\n    }\n    public static Node root = new Node();\n    public static void insert(String word){\n           Node curr = root;\n           for(int level =0;level<word.length();level++){\n            int ind = word.charAt(level) -'a';\n            if(curr.children[ind] == null){\n                curr.children[ind] = new Node(); \n            }\n            curr = curr.children[ind];\n\n           }\n           curr.eow = true;\n    }\n   public static boolean search(String key){\n    Node curr = root;\n     for(int level =0;level<key.length();level++){\n        int ind = key.charAt(level)-'a';\n        if(curr.children[ind] == null){\n            return false;\n        }\n        curr = curr.children[ind];\n     }\n    return curr.eow == true;\n   }\n  public static boolean wordBreak(String key){\n    if(key.length() == 0){\n        return true;\n    }\n    for(int i=1;i<=key.length();i++){\n      if(search(key.substring(0, i)) && wordBreak(key.substring(i))){\n          return true;\n      }\n\n    }\n    return false;\n  }\n    public boolean wordBreak(String s, List<String> wordDict) {\n        for(String str : wordDict){\n            insert(str);\n        }\n        return wordBreak(s);\n    }\n} }\n```\n\n\n------------------------------------------------------------------------------------------------------------------------------------------------------------------"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to be that your recursive function `wordBreak` is creating an exponential number of recursive calls because it doesn\\'t remember which substrings it has already checked. You are creating a substring and recursively searching for it in the trie, but you don\\'t have a way to remember if you have already checked a certain substring. Therefore, it may be rechecking the same substring multiple times leading to inefficiency.\\n\\nThis can be solved by using a technique called memoization. Memoization is an optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and reusing them when the same inputs occur again.\\n\\nBelow is your corrected code:\\n\\n```java\\nclass Solution {\\n    static class Node{\\n        Node [] children = new Node[26];\\n        boolean eow = false;\\n        Node(){\\n            for(int i=0;i<26;i++){\\n                children[i] = null;\\n            }\\n        }\\n    }\\n\\n    public static Node root = new Node();\\n    \\n    public static void insert(String word){\\n        Node curr = root;\\n        for(int level =0;level<word.length();level++){\\n            int ind = word.charAt(level) -\\'a\\';\\n            if(curr.children[ind] == null){\\n                curr.children[ind] = new Node(); \\n            }\\n            curr = curr.children[ind];\\n        }\\n        curr.eow = true;\\n    }\\n\\n    public static boolean search(String key){\\n        Node curr = root;\\n        for(int level =0;level<key.length();level++){\\n            int ind = key.charAt(level)-\\'a\\';\\n            if(curr.children[ind] == null){\\n                return false;\\n            }\\n            curr = curr.children[ind];\\n        }\\n        return curr.eow == true;\\n    }\\n\\n    public static boolean wordBreak(String key, boolean[] dp, int start){\\n        if(start == key.length()){\\n            return true;\\n        }\\n        if(dp[start] != false) return dp[start]; //returning the memoized result\\n        for(int i=start+1;i<=key.length();i++){\\n            if(search(key.substring(start, i)) && wordBreak(key, dp, i)){\\n                return dp[start] = true;  //storing the result in dp for future use\\n            }\\n        }\\n        return dp[start] = false;\\n    }\\n\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        for(String str : wordDict){\\n            insert(str);\\n        }\\n        boolean[] dp = new boolean[s.length()];  //initialize dp array\\n        return wordBreak(s, dp, 0);\\n    }\\n}\\n```\\n\\nIn this modified solution, I\\'ve added a boolean array `dp[]` to keep track of the results of subproblems. When you start a new subproblem, you first check if the result for that subproblem has already been calculated and stored in `dp[]`. If it has, you can simply return the stored result instead of calculating it again. This significantly reduces the number of recursive calls and makes the program more efficient.\\n\\nKeep in mind that the `dp[]` array should be initialized to `false` because by default in Java, boolean arrays are initialized to `false` and we are using `false` to indicate that a subproblem has not yet been solved."
                    },
                    {
                        "username": "vijaydeep",
                        "content": "Can someone please help me understand what part am missing.\\n\\n\"bb\"\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\n\\nAs per my understanding the output should be false since a is not part of the input string but in actual it is expected true.\\n\\n\"a\"\\n[\"b\"]\\n\\nIf I go by above behaviour then this should also be true but it is expected to be false.\\n\\nI am sure there is something which I am missing from the problem statement.\\nPlease help."
                    },
                    {
                        "username": "bparanj",
                        "content": "You might be misunderstanding the problem statement a bit. In the word break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. Your task is to determine if `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nSo, for your examples:\\n\\n1. The input string is \"bb\" and the word dictionary is [\"a\",\"b\",\"bbb\",\"bbbb\"]. The string \"bb\" can be segmented into \"b\" and \"b\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\n2. The input string is \"a\" and the word dictionary is [\"b\"]. The string \"a\" cannot be segmented into any word in the dictionary, so the expected output is `false`.\\n\\nThe dictionary doesn\\'t need to include all the characters from the input string, rather it should have words which can be used to segment the input string. The words in the dictionary can be reused any number of times to form the string. The segments do not need to be unique, i.e., different segmentations can produce the same string. \\n\\nFor instance, given the string \"catsanddog\" and dictionary [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"], both segmentations [\"cat\", \"sand\", \"dog\"] and [\"cats\", \"and\", \"dog\"] are valid."
                    },
                    {
                        "username": "chernopolskiy",
                        "content": "You don\\'t required to include all words from the dictionary in the string. It can be any of them and also they could repeat. In given case you have word \"b\" in the dictionary and if you use it twice, you can split string \"bb\" into two words \"b\" and \"b\", so it\\'s true "
                    },
                    {
                        "username": "tirupati",
                        "content": "I have gone through the solutions and I could see that best complexicty in n^3 with n space.\\nn^3: n^2 for all the combinations of substring (i,j) and n for slicing or substring and 1 of finding string in a set = n^2 * n * 1\\n\\nIf I have all the substring precomuted with n^2 complecity using dictionary. (cache[i][j] = substring[i:j]) and we can use one more n^2 complexicty for checking all the combinations of substring.\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach to use pre-computation to store substrings can certainly be done but it is generally not used in practice. The reasons are as follows:\\n\\n1. **Memory Usage**: The use of pre-computed substrings in a 2D array would take O(n^2) space. This is because you\\'re storing all possible substrings of the original string in the 2D array. If n is large, it may lead to a memory overflow error.\\n\\n2. **Access Time**: Accessing elements from a large 2D array can be slow and might not lead to significant speedup in practice.\\n\\n3. **Overall Time Complexity**: The overall time complexity is still O(n^3), because you\\'re still checking all possible substrings which takes O(n^2), and checking whether a substring is in the dictionary (which takes O(n), even if you use a hash set). Hence, the total time complexity will still be O(n^3).\\n\\nThe more common approach is to use dynamic programming. We maintain a boolean dp array, where dp[i] is `true` if substring from index `0` to `i` (inclusive) can be segmented into dictionary words, and `false` otherwise. The space complexity is O(n) and time complexity is O(n^2), assuming the cost to check if a word exists in the dictionary is O(1).\\n\\nHere is the approach:\\n\\n```java\\npublic class Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> wordDictSet = new HashSet(wordDict);\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n\\nThis algorithm maintains a DP table of size n+1 (for string of length n) and it fills the table in left to right manner. For filling the DP table, it breaks the given string in all possible ways and checks whether the left substring can be segmented into dictionary words using DP and right substring is present in dictionary or not."
                    },
                    {
                        "username": "rashan",
                        "content": "The catsanddog example doesn\\'t work because you can\\'t use all the words in the worddict? \\n\\nBut why does this test case equate to true? \\n\"leetcode\"\\n[\"leet\",\"can\",\"code\"]"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word break problem asks if the input string can be segmented into a sequence of one or more words from the word dictionary. The words in the word dictionary can be used as many times as required and it\\'s not necessary to use all the words from the dictionary. The goal is not to use all the words in the dictionary, but to break down the input string using the words from the dictionary.\\n\\nSo, taking your example:\\n\\nThe input string is \"leetcode\", and the word dictionary is [\"leet\",\"can\",\"code\"].\\n\\nYou can break \"leetcode\" into \"leet\" and \"code\", both of which are in the dictionary. Therefore, the expected output is `true`.\\n\\nOn the other hand, if you tried to break down \"catsanddog\" with the dictionary [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"], it would work as you can break \"catsanddog\" into \"cats\", \"and\", \"dog\" or \"cat\", \"sand\", \"dog\" which are all in the dictionary.\\n\\nRemember, the words in your dictionary can be reused any number of times to form the string. The segments do not need to be unique. So different segmentations can produce the same string. The ultimate goal is to break the given string using the words present in the dictionary."
                    },
                    {
                        "username": "Abhishekg25",
                        "content": "There is no where mention to use all words of the list.\\ncatsandog ->\\n1. cats + an + dog\\n2. cats + and + og\\n3. cat + sand + og\\nand many like that..\\nNot all words are present in the list:\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]"
                    },
                    {
                        "username": "innkeeper513",
                        "content": "Construct an epsilon-NFA of all the words in the dictionary. Starting state \"start\" is the only accepting state. Transitions will take an input character of a word and transition to the next state. \\n\\nFor example: a word \"word\" will have the NFA as\\n\\n(Start) -> W -> WO -> WOR -> WORD\\n\\nD will perform an epsilon transition back to the start state. \\n\\nThere exists algorithms in automata theory to convert any epsilon-NFA to an NFA, and NFA can be converted to a DFA.\\n\\nWe can run the target string on that DFA. If the program accepts all input characters from the target string and is on the accepting state, return true. All other cases will return false.\\n\\nThe runtime will only be based on the length of the target string which is O(n).\\n"
                    },
                    {
                        "username": "Ilkhomjon",
                        "content": "The problem\\'s structure is by itself DFA.. So no need for NFA"
                    },
                    {
                        "username": "Oliver-Ren",
                        "content": "I have tried to setting empty string as always a valid break for convenience of initializing the dynamic programming array, and the OJ passed all test cases. But I am wondering that is just because empty string is always added to the wordDict in all the test cases. So, my question is should we check if the empty sting is in the wordDict?"
                    },
                    {
                        "username": "nijhawanlakshay06",
                        "content": "see constraints it can never be empty"
                    },
                    {
                        "username": "akashnr97",
                        "content": "please explain if any idea"
                    },
                    {
                        "username": "RajeshBK",
                        "content": "![image](https://assets.leetcode.com/users/images/b9554546-b364-4c1b-b63a-25939e9dfcc4_1597922384.763042.png)\\n"
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@Rajesh B K](/RajeshBK) this case is trick for this problem. As you can see that the length of \"bb\" is 2 it is smaller than \"bbb\" with the length is 3 so in this case the return true. Because we can create \"bb\" from \"bbb\". Hope it makes sense to you \\uD83D\\uDE0E\\uD83D\\uDE0E"
                    }
                ]
            },
            {
                "id": 1568964,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 1749678,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2058348,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2044128,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2040401,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2040259,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2040237,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2035878,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2020800,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2017228,
                "content": [
                    {
                        "username": "rachelwon",
                        "content": "For the test cast, \"aaaaaaa\", [\"aaaa\",\"aa\"], the compiler deems it false, but I don't understand why. Shouldn't it be true because aaaa and aa can be made from aaaaaa?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The word \"aaaaaaa\" should indeed be breakable into \"aaaa\" and \"aaa\" or alternatively \"aa\", \"aaaa\", both of which are present in the dictionary [\"aaaa\", \"aa\"]. Therefore, the output of the function for this input should be `true`.\\n\\nIf your program is returning `false` for this test case, then there might be a bug in your code. The issue might be related to how your code is iterating through the substrings or how it\\'s managing its dynamic programming state.\\n\\nPlease note that order matters in many word break problem solutions. Your code should be able to accommodate the use of words from the dictionary in any order, and of varying lengths.\\n\\nIf you\\'re using a dynamic programming approach, a common pattern is to use a boolean array `dp` of size `n + 1` (where `n` is the size of the input string), and set `dp[0]` to `true`. Then, for each `i` from 1 to `n`, check for each `j` from 0 to `i` whether `dp[j]` is `true` and whether the substring from `j` to `i` is in the dictionary. If so, set `dp[i]` to `true`.\\n\\nIf you\\'re still having trouble with this test case, I would recommend debugging your code with this input to see exactly what\\'s going wrong."
                    },
                    {
                        "username": "tonybuidn",
                        "content": "Hi [@rachelwon](/rachelwon) just look first the length of them, \"aaaaaaa\" is 7 , \"aaaa\" is 4 and \"aa\" is 2 => so you can not create \"aaaaaaa\" from \"aaaa\" and \"aa\" in any cases. Hope it makes sense to you \\uD83D\\uDC4D"
                    },
                    {
                        "username": "peihao61",
                        "content": "test case: aaaaaaa (7 a)\\n\\ncase 1: \"aaaa\" + \"aa\" => no more \"a\" pattern\\ncase 2: \"aa\" + \"aa\" + \"aa\" => no more \"a\" pattern\\nso output - false"
                    },
                    {
                        "username": "ritik11213",
                        "content": "class Solution {\\npublic:\\n    \\n    int solve(int idx,map<string,int>&m,string &s){\\n        if(idx<0)return 1;\\n        if(dp[idx]!=-1)return dp[idx];\\n        cout<<idx<<endl;\\n        string str;\\n        int ans=0;\\n        for(int i=idx;i>=0;i--){\\n            str.push_back(s[i]);\\n            string temp=str;\\n            reverse(temp.begin(),temp.end());\\n            // cout<<temp<<endl;\\n\\n            if(m[temp]==1){\\n                ans+=solve(i-1,m,s);\\n            }\\n        }\\n       if(ans>0)return dp[idx]=1;\\n       else return dp[idx]=0;\\n    }\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        map<string,int>m;\\n        for(auto it:wordDict){\\n            m[it]=1;\\n        }\\n        vector<int>dp(s.size(),-1);\\n        return solve(s.size()-1,m,s,dp);\\n    }\\n};"
                    },
                    {
                        "username": "nitissssh",
                        "content": "if you want to similar problem , but different feel try leetcode 1043 , partition array maximum sum "
                    },
                    {
                        "username": "VanshKiit",
                        "content": "s=\"ccbb\"\\nwordDict=[\"bc\",\"cb\"]\\nexpected-false\\nbut cb can be used 2 times"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "If \nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false \nthen for:\nInput: s = \"abcd\", wordDict = [\"a\",\"abc\",\"b\",\"cd\"]\nOutput\nfalse\nExpected\ntrue\nwhy is it expected true for the 2nd case?"
                    },
                    {
                        "username": "hasseebmayo",
                        "content": "Is not that possible?\\nWe do this using regex."
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "Why is this not working for all test cases?\\nStep 1. Getting all the substring.\\nStep 2. Using hashmap, check whether all the wordDict are part of the substring.\\n\\nclass Solution {\\n    //finding all the substring\\n    void solve(string s, unordered_set<string>&set, int i, string temp ){\\n        if(i == s.length() -1){\\n            set.insert(temp);\\n            return;\\n        }\\n\\n        solve(s, set, i+1, temp+s[i]);\\n        solve(s, set, i+1, temp);\\n        \\n    }\\n\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>set;\\n        string temp =\"\";\\n        solve(s, set, 0, temp);\\n        \\n        for(auto x:wordDict){\\n            if(set.find(x) == set.end()){\\n                cout<<x<<\" \";\\n                return false;\\n            }\\n             \\n        }\\n        return true;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Anyone watched tutorials "
                    },
                    {
                        "username": "vansh22559",
                        "content": "The intuition for this problem is to partition the string into all possible substrings and then keep checking whether it is present in the dictionary or not .\\nTo be precise this question is just a variation of matrix chain multiplication question( refer aditya verma for it )"
                    },
                    {
                        "username": "Geronimo12",
                        "content": "Does anyone know why this solution doesn\\'t work? It literally works on my code editor but not in LeetCode hahaha.\\n\\n\\n`class Solution:\\n    def wordBreak(self, s: str, wordDict: List[str], memo={}) -> bool:\\n        key = s\\n        if key in memo:\\n            return memo[key]\\n        \\n        if s == \"\":\\n            return True\\n        \\n        for word in wordDict:\\n            if s[:len(word)] == word:\\n                memo[key] = self.wordBreak(s.replace(word, \"\", 1), wordDict)\\n                if memo[key] == True:\\n                    return True\\n        \\n\\n        return False\\'"
                    }
                ]
            },
            {
                "id": 2003432,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2001835,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2001701,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000266,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000217,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000214,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000209,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000199,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000197,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000149,
                "content": [
                    {
                        "username": "mavaziri",
                        "content": "Please anyone can explain, how utilizing a boolean array dp, can solve this problem using Dynamic Programming?\\nI just can\\'t understand..."
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@bparanj](/bparanj) Thanks so much for your reply. I already know the solution, but what I don\\'t understand exactly is that how this boolean array help to solve this overlapping subproblems... "
                    },
                    {
                        "username": "bparanj",
                        "content": "**Approach using Dynamic Programming**:\\nWe will utilize a boolean array `dp` of size `n+1` where `n` is the length of the string `s`. The idea is to maintain a DP table such that `dp[i]` is `True` if the substring `s[0:i]` can be segmented into dictionary words, and `False` otherwise.\\n\\n1. Initialize `dp[0]` as `True` because an empty string can always be segmented (base case).\\n\\n2. For each index `i` from `1` to `n`, check every possible word ending at `i` and starting at some `j` before `i`. If the substring `s[j:i]` is a valid word (exists in the `wordDict`) and `dp[j]` is `True` (meaning the substring `s[0:j]` can be segmented), then set `dp[i]` to `True`.\\n\\n3. If by the end, `dp[n]` is `True`, it means the entire string `s` can be segmented using words from the `wordDict`.\\n\\nLet\\'s understand with an example:\\n`s = \"leetcode\"`\\n`wordDict = [\"leet\", \"code\"]`\\n\\n1. Create a boolean array `dp` of size `9` (length of `s` + 1).\\n2. `dp[0] = True`\\n3. Start with `i=1`. Since no word in `wordDict` ends at `1`, move on.\\n4. At `i=4` (corresponding to substring \"leet\"), we find that \"leet\" is in the `wordDict` and `dp[0]` is `True`, so we set `dp[4]` to `True`.\\n5. At `i=8` (corresponding to substring \"code\"), since \"code\" is in the `wordDict` and `dp[4]` is `True`, we set `dp[8]` to `True`.\\n\\nBy the end, `dp[8]` or `dp[n]` is `True`, so the string can be segmented.\\n\\n**Python code**:\\n```python\\ndef wordBreak(s: str, wordDict: List[str]) -> bool:\\n    n = len(s)\\n    dp = [False] * (n + 1)\\n    dp[0] = True\\n    wordSet = set(wordDict)\\n    \\n    for i in range(1, n + 1):\\n        for j in range(i):\\n            if dp[j] and s[j:i] in wordSet:\\n                dp[i] = True\\n                break\\n\\n    return dp[n]\\n```\\n\\nThe inner loop iterates over all previous positions to check for valid segmentations, and the outer loop iterates over the length of the string `s`. The DP table is updated based on the segments found in the word dictionary. By the end, if the entire string can be segmented, `dp[n]` will be `True`.\\n\\nThis is a top-down approach to the problem, where you\\'re building the solution by checking smaller and smaller pieces of the string.\\n"
                    },
                    {
                        "username": "shishant_1",
                        "content": "https://www.youtube.com/watch?v=U1JGtQ6z0fg"
                    },
                    {
                        "username": "rsr88",
                        "content": "if we approach in bfs why do we need visited? when we are always moving nodes on an increasing index of the target word"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "I could come up with the following recursive approach but its giving TLE on testcase #36. I\\'m not sure how to memoize this one to improve the time. Can anyone help?\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &str, unordered_set<string> &dict) {\\n        int n = str.size();\\n        for(int i=1; i<=n; i++) {\\n            string prefix = str.substr(0, i);\\n            string suffix = str.substr(i, n-i);\\n            if(dict.find(prefix) != dict.end() && (suffix == \"\" || (dict.find(suffix) != dict.end()) || solve(suffix, dict)))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        return solve(s, dict);\\n    }\\n};\\n```\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "I attempted this for the first time on Feb 22nd, 2023. I used trie data structure, char[] but still I received TLE on \"aa..998a\", [\"a\",\"aa\"...] and kinda gave up.\nToday, after 2 weeks of daily DP problem on LeetCode, I figured out that I could cache/DP the already made combinations/segments and not compute them again, but just return the answer if I ever get to reach that downstream segment index.\nThank you Leetcode from the bottom of my heart!"
                    },
                    {
                        "username": "d2s2",
                        "content": "Think like you have given a directed graph.\\nyou can make the given string S into directed graph using wordDict.\\n\\nThen you can perform DFS on that, if you\\'re able to reach the last node (such that the size of String S) that means you can  partition the word S in given wordDict.\\ne.g.\\nS = \"cars\"\\nwordDict =[\"car\",\"ca\",\"rs\"]\\n\\n\\ngraph = [[3, 2], [], [4], [], [] ]"
                    },
                    {
                        "username": "tusharshankar1483",
                        "content": "       a=\"\"\\n        for i in range(len(s)):\\n            a = \\'\\'.join((a,s[i]))\\n            if a in wordDict:\\n                a=\"\"\\n            if s[i]==s[-1] and a==\"\":\\n                return True\\n        return False\\nwhy it is not passing all the testcases ( stuck on 36th/46 test cases ) , whats wrong with it?"
                    },
                    {
                        "username": "mbedru",
                        "content": "I think the question needs more complex answer than it seems\\n* If you stop with the first minimum word this won\\'t work =>\"aaaaaaa\" , [\"aaaa\",\"aaa\"] expected true\\n* If you continue iterating with the longest string even if you get a working word this won\\'t work => \"catsandog\" ,  [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] expected true "
                    },
                    {
                        "username": "surelax",
                        "content": "why it is always dynamic programming questions? Do i set the problem filtering wrong somewhere?\\ni dont want to spend more time on such questions as all of them comes with same pattern."
                    },
                    {
                        "username": "Ainz_Oowl_Gown",
                        "content": "# This is not a correct solution.\\n\\nI don\\'t know where is the mistake in my code it fails in the second last testcase.\\nIf someone knows plz correct me.\\n\\nclass Solution {\\nprivate:\\nunordered_map<string,bool>m;\\n\\n    bool backtrack(int curr, string&s, string sm, vector<int>&dp){\\n        if(curr>=s.size()){\\n            if(sm==\"\") return true;\\n            return false;\\n        }\\n        bool take=false,n_take=false;\\n        sm+=s[curr];\\n        if(m[sm]){\\n            if(dp[curr+1]!=-1) return dp[curr+1];\\n            take=backtrack(curr+1,s,\"\",dp);\\n            dp[curr+1] = take ? 1 : 0;\\n        }\\n        n_take=backtrack(curr+1,s,sm,dp);\\n\\n        return take||n_take ? true : false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(int i=0;i<wordDict.size();i++){\\n            m[wordDict[i]]=true;\\n        }\\n        vector<int>dp(s.size()+1,-1);\\n        string sm=\"\";\\n        return backtrack(0,s,sm,dp);\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2000128,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 2000061,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999995,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999982,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999821,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999709,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999635,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999570,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999540,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999430,
                "content": [
                    {
                        "username": "Badr_Mohamed",
                        "content": "why when i use contains function give me an error but in IDE its work \\n"
                    },
                    {
                        "username": "rdxrohit03",
                        "content": "why this  23rd testcase is wrong ;____;"
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "People, please VOTE for this PETITION to save OLD Study Plans: https://leetcode.com/discuss/feedback/3832685/petition-dont-kick-off-old-study-plans-we-love-it"
                    },
                    {
                        "username": "Da4y",
                        "content": "It would be funnier if the dict length was bigger, this way optimizing with a Trie would make sense xD."
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "s=\"aaaaaaa\"\\nwordDict=[\"aaa\",\"aaaa\"];\\noutput true \\nseriously!"
                    },
                    {
                        "username": "rajamrit_15",
                        "content": "This code is only able to pass 36/46 test case, where i did wrong?\\n```\\nclass Solution {\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        if(s.length() == 1 && !wordDict.contains(s)) return false;\\n        if(s.length() == 1 && wordDict.contains(s)) return true;\\n        String temp = \"\";\\n        int j = 0;\\n        while(j < s.length()){\\n           temp += s.charAt(j);\\n           if(wordDict.contains(temp)){\\n               temp = \"\";\\n           }\\n           j++;\\n        }\\n        System.out.println(\"Remaning -> \" + temp);\\n        return temp.length() > 0 ? false : true;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "Consider the case s=\"aaaaaaa\" and dict = [\"aaaa\", \"aaa\"]. Here your code will generate three strings \"aaa\" and \"aaa\" and \"a\". \"aaa\" is present in the array so it wont be a problem but \"a\" is not present thats why it will return false.\\n\\nTherefore we need to check all possible combination here and DP is our best resort for that."
                    },
                    {
                        "username": "SG-C",
                        "content": "That\\'s What She Does Makes My `Heart Break`. \\uD83E\\uDD72"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Very bad description. \\n\\n"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "Now my solution is stuck due to time limit, but in my local build takes only `Elapsed: 0.0004747` which is fine enough. I think this is may be related to old compiler version\n\nP.S. The `\"a*b\"` case, of course, when submitted"
                    },
                    {
                        "username": "Helltraitor",
                        "content": "UPD: I\\'m not sure what caused this issue, but it solved somehow (maybe due to internal server business). So this is not issue anymore"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I was using a DFS style recursive function to solve this, but it was too slow. Then I added a few time optimizations to cut off strings that weren\\'t matching with s (string != s[0..string.Length].ToString()), still TLE. Finally, I added memoization with a HashSet<string> to check if we\\'ve already tried the current string combination. That got me through, and with beats 80% on time no less.\\n\\nMoral of the story: Keep trying and optimizing! You\\'re probably not as far from the answer as you feel."
                    }
                ]
            },
            {
                "id": 1999401,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999359,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999317,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999308,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999300,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999275,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999253,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999188,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999177,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1999140,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Easy to solve difficult to figure time Time Complexity"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Why this isn\\'t Backtracking. I can not think of DP as of now"
                    },
                    {
                        "username": "user5400vw",
                        "content": "trie for some optimizations on time (might not be necessary as the N cap is only 300*1000=300,000)\\ni found memoization was needed to avoid MLE before i hit TLE "
                    },
                    {
                        "username": "ak_3101",
                        "content": "I got a brain freeze after attempting the question. "
                    },
                    {
                        "username": "atharva598",
                        "content": "1 <= wordDict[i].length <= 20 is an important constraint here. Enables us to write a solution better than n2."
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "Can anyone tell me the mistake I am doing?\\nSimple Recursive solution with pick or notPick concept.\\n\\n ```\\n    public static boolean fun(int ind, String s, Set<String> set) {\\n        if (s.length() == 0)\\n            return true;\\n        if (ind == s.length())\\n            return set.contains(s);\\n        boolean ans = false;\\n        for (int i = ind; i < s.length(); i++) {\\n            if (set.contains(s.substring(0, i + 1))) {\\n                ans = (fun(ind + 1, s, set) || fun(0, s.substring(i + 1, s.length()), set));\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean wordBreak(String s, List<String> wordDict) {\\n        Set<String> set = new HashSet<>();\\n        for (String str: wordDict)\\n            set.add(str);\\n        return fun(0, s, set);\\n    }"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Okay!! I got your point. Thank you for the suggestion."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Harmandeep_017](/Harmandeep_017) It return false because you didn't break out of the loop even though the ans is already true, leading to next iteration making the ans false again\n\nand i think this code is not necessary\n```\nfun(ind + 1, s, set)\n```"
                    },
                    {
                        "username": "Harmandeep_017",
                        "content": "[@EricRaw](/EricRaw) Thank you for considering but this code is giving Wrong answer for the following testcase:\\n\\ns = \"abcd\"\\ndist = {\"a\", \"abc\", \"b\", \"cd\"}\\nOutput = false\\nExpected Output = true\\n\\nBut when I tested this output by drawing the recursion tree, then it was giving the correct answer. So I\\'m not able to figure it out."
                    },
                    {
                        "username": "EricRaw",
                        "content": "the problem occur when encountering repeating substrings. When the input string 's' contains many repeating characters, the code might calculate the same substrings multiple times leading to TLE,\n\n- eg \ns = \"aaaaaaaaaaaaaaab\"\ndict = [\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\"]\n\nTo optimize the code, try implement memoization"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "It can be regarded as a graph problem, refer to the solution:\nhttps://leetcode.com/problems/word-break/solutions/3860811/c-solution-by-graph-theory-and-bfs/"
                    },
                    {
                        "username": "harshitaa_cse",
                        "content": "This should be a hard question only because of how poorly it is explained and how you fail cases, and then spend a lot of time to finally understand it."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "is Leetcode following strivers sheet :)"
                    },
                    {
                        "username": "alt909",
                        "content": "Dynamic Programming teaches us to rearrange the chaos into a sequence of known truths, a skill as valuable in code as it is in life. Take heed and accept Dynamic Programming into your heart so that one day Dynamic Programming might shine its light upon you and illuminate your world."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I\\'m trying to accept DP, but she can be very mean and hard to understand."
                    }
                ]
            },
            {
                "id": 1991499,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1990363,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1959897,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1954723,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1928096,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1904346,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1904208,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1901994,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1888946,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1869848,
                "content": [
                    {
                        "username": "_sri_hari_",
                        "content": "used dp memoization and a pure Trie class implementation to solve this problem. Struggled for an hour :) ."
                    },
                    {
                        "username": "Wabdidabdivo",
                        "content": "pen pineapple apple pen"
                    },
                    {
                        "username": "Vasu089",
                        "content": "can anyone explain that why after using recursion memorization we have O(n^2) complexity?"
                    },
                    {
                        "username": "psionl0",
                        "content": "I get O(S * N * M) where S is the length of the string, N is the number of words in the dictionary and M is the average length of each word in the dictionary. (This assumes that you use an array to memoize your results)."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, using recursion with memorization (also known as top-down dynamic programming or DP) allows us to store and reuse results of overlapping subproblems to avoid redundant computation. This significantly reduces the time complexity of the algorithm.\\n\\nHere\\'s why it becomes O(n^2):\\n\\n1. **State**: In the context of this problem, a \"state\" can be considered a suffix of the input string starting at index i. There are \\'n\\' such states corresponding to \\'n\\' indices of the input string.\\n\\n2. **State transition**: For each state, we check the possible breaks from index \\'i\\' to \\'n\\', that is, we are examining each suffix of the string starting from \\'i\\'. So for each state, we could make \\'n\\' different decisions.\\n\\nPutting the above two points together, there are \\'n\\' states and for each state, we could perform \\'n\\' operations at most (for each of the \\'n\\' decisions, in worst case). Therefore, the time complexity is O(n^2).\\n\\nThe key is that memoization ensures each state is solved only once and then the result is stored. The next time we need to solve the same state, instead of performing the computation again, we simply return the stored result. This way, we ensure that the time complexity for the computation of each state remains constant. That\\'s why the overall time complexity is proportional to the number of states times the time complexity for each state, which is O(n) * O(n) = O(n^2).\\n\\nKeep in mind that this analysis assumes that the dictionary look-up operations (i.e., checking whether a string is in the dictionary) can be done in constant time, such as by using a hash set to store the dictionary words. If dictionary look-ups take longer, that would need to be factored into the time complexity."
                    },
                    {
                        "username": "drat",
                        "content": "with lots of thinking I did this question with 2D dp.\\nBut questions like these sometimes make me think , that althoght I can do these  without cheating but still I don\\'t understand them fully.\\n#illuminati"
                    },
                    {
                        "username": "a1thapa",
                        "content": "this some bullshit"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "is it just me or is leetcode really showing bad performance to everyone? i wrote an n^2 solution and it beats only 50%, most people have n^3 solutions, maybe leetcode compares a solution with every other solution and some other languages inherently have higher performance?"
                    },
                    {
                        "username": "gandalfTheGray",
                        "content": "The question is, the word should be a space separated sequence of one or more words, the answer is true only if you can take one or more words from wordDict and repeat them(can use one word multiple times) and form s\n\nif s = \"aaa\" and wordDict = [\"a\", \"b\"]\nyou can take first word from wordDict and repeat it three times to make \"aaa\" (repetition is allowed)\n\nif s = \"abc\" and wordDict = [\"a\", \"b\"]\nno combination of words in wordDict can make \"abc\"\n\nthr third example: s = \"catsandog\" and wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n\"cats\" + \"sand\" + \"dog\" doesn't make \"catsanddog\"\nand the result is false\n"
                    },
                    {
                        "username": "michaelShingo",
                        "content": "PEN APPLE APPLE PEN"
                    },
                    {
                        "username": "warrior0331",
                        "content": "Can someone tell me why I\\'m getting a TLE in this?\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nunordered_set<string> words;\\n\\nbool sumi(int ind, string s, string str, vector<vector<bool>> &dp){\\n    if(ind==s.length()){\\n        if(str.length()==0) return true;\\n        else return false;\\n    }\\n    if(dp[ind][str.length()]) return dp[ind][str.length()];\\n    str+=s[ind];\\n    bool one=false,two=false,three=false;\\n    if(words.find(str)==words.end()){\\n        one=sumi(ind+1,s,str,dp);\\n    }\\n    else{\\n        three=sumi(ind+1,s,str,dp);\\n        str=\"\";\\n        two=sumi(ind+1,s,str,dp);\\n    }\\n    return dp[ind][str.length()]=(one or two or three);\\n}\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x:wordDict) words.insert(x);\\n        int n=s.length();\\n        vector<vector<bool>> dp(n,vector<bool> (n+1,false));\\n        return sumi(0,s,\"\",dp);\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem seems to lie in your memoization approach, and the way you\\'re using the `dp` vector to store the results of the subproblems.\\n\\nFirstly, you\\'re using `dp[ind][str.length()]` to represent whether the first \\'ind\\' characters of \\'s\\' can be broken down into words in the dictionary. However, `str.length()` doesn\\'t always correctly capture the state of the problem at position \\'ind\\'. The string `str` that you\\'re building up and breaking down during the recursion isn\\'t directly tied to the state at \\'ind\\'. This can lead to incorrect results being pulled from the `dp` table.\\n\\nA more common and reliable approach is to use a one-dimensional DP table where `dp[i]` represents whether the first \\'i\\' characters of \\'s\\' can be segmented into one or more dictionary words. Here\\'s how you could modify your code to implement this approach:\\n\\n```java\\nclass Solution {\\npublic:\\n    unordered_set<string> words;\\n    vector<int> dp;\\n\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        for(auto x: wordDict) words.insert(x);\\n        int n = s.length();\\n        dp.resize(n+1, -1); // -1 indicates that the state has not been solved yet\\n        return helper(0, s);\\n    }\\n\\n    bool helper(int start, string s){\\n        if(start == s.length()) return true;\\n        if(dp[start] != -1) return dp[start];\\n        for(int end = start+1; end <= s.length(); end++){\\n            if(words.find(s.substr(start, end-start)) != words.end() && helper(end, s)){\\n                dp[start] = 1;\\n                return true;\\n            }\\n        }\\n        dp[start] = 0;\\n        return false;\\n    }\\n};\\n```\\n\\nIn this code, we use a helper function to do the main work of the dynamic programming. The helper function checks if the substring from \\'start\\' to \\'end\\' is in the dictionary, and if the remaining part of the string can be broken down into words in the dictionary. The result for each \\'start\\' position is stored in `dp[start]`.\\n"
                    },
                    {
                        "username": "hardikpatel0245",
                        "content": "For the test case\\ns =\"cbca\"\\nwordDict = [\"bc\",\"ca\"]\\n\\nOutput = True\\nExpected = False\\n\\nSo above is right from my side?"
                    },
                    {
                        "username": "bparanj",
                        "content": "No, the output for the test case with `s = \"cbca\"` and `wordDict = [\"bc\",\"ca\"]` should be `False`, not `True`. \\n\\nHere\\'s why:\\n\\nIn order to return `True`, every character in string `s` must be part of a word in `wordDict`, with the words being contiguous (i.e., not scrambled or rearranged). The words from `wordDict` can be reused any number of times. \\n\\nIn this case, there\\'s no way to break \"cbca\" entirely into words from `wordDict`. The word \"bc\" does appear in \"cbca\", but there\\'s no way to account for the \"c\" at the beginning and the \"a\" at the end with the given `wordDict`.\\n\\nYou can try it yourself by attempting to combine the words in `wordDict` in different orders and repetitions, and you\\'ll see that it\\'s impossible to create \"cbca\" with only these words. \\n\\nSo, the output for this test case should indeed be `False`. If your solution is giving `True`, there may be a bug in your implementation."
                    }
                ]
            },
            {
                "id": 1786529,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1779789,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1779482,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1778293,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1768469,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1766927,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1713335,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1688641,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1684268,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1823077,
                "content": [
                    {
                        "username": "Gupta09041990",
                        "content": "Most efficient solution\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    let wordSet = new Set(wordDict);\\n    let last_length = Array(s.length).fill(-1);\\n    for(let i = 0; i < s.length; i++) {\\n        if(wordSet.has(s.substring(0, i+1))) {\\n            last_length[i] = i + 1;\\n            continue;\\n        }\\n        for(let j = i-1; j >= 0; j--) {\\n            if(last_length[j] !== -1 && wordSet.has(s.substring(j+1, i+1))) {\\n                last_length[i] = i - j;\\n                break;\\n            }\\n        }\\n    }\\n    return last_length[s.length-1] !== -1;\\n};"
                    },
                    {
                        "username": "codeandlove",
                        "content": "Loop each word from the dictionary, and use sliding window skill to check if the selected word is contains inside the input string. "
                    },
                    {
                        "username": "aghimanshu123",
                        "content": "why my memoziation code give tle \\n `class Solution {\\n    bool solve(string s,vector<string>&wordDict,string st,unordered_map<string,bool>&mp){\\n        if(st==s){\\n            return true;\\n        }\\n        if(st.length()>s.length()){\\n            return false;\\n        }\\n        if(mp.find(st)!=mp.end()){\\n            return mp[st];\\n        }\\n        for(int i=0;i<wordDict.size();i++){\\n            if(solve(s,wordDict,st+wordDict[i],mp)){\\n                return mp[st]=true;\\n            }\\n        }\\n        return mp[st]=false;\\n    }\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string,bool>mp;\\n       return solve(s,wordDict,\"\",mp);\\n    }\\n};`"
                    },
                    {
                        "username": "bparanj",
                        "content": "The reason your code is getting a Time Limit Exceeded (TLE) error is because the approach you\\'ve taken has a high time complexity.\\n\\nThe problem lies in the fact that you are trying all combinations of words in the wordDict to form the string \\'s\\'. This results in a lot of repeated computation as you may be constructing the same string multiple times.\\n\\nIn your recursive function \\'solve\\', you are generating all possible combinations of the words from the wordDict by appending them to \\'st\\', and for each combination, you\\'re checking if it matches \\'s\\'. Since you\\'re constructing all combinations of words, the complexity of this operation is exponential, which results in the TLE.\\n\\nA more efficient approach would be to use dynamic programming (DP) where you\\'d keep track of whether each substring of \\'s\\' can be broken down into words from wordDict. You could use a boolean DP array where `dp[i]` represents whether the substring `s[0...i]` can be broken down into words from the dictionary. This way, you avoid repeated computation and reduce the time complexity significantly.\\n\\nHere\\'s a sample implementation of this approach:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\\n        vector<bool> dp(s.size() + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.size()];\\n    }\\n};\\n```\\nIn this code, `dp[i]` is set to true if there exists a `j < i` such that `dp[j]` is true and the substring `s[j\\u2026i]` is in the word dictionary. We start with `dp[0]` as true because an empty string can always be segmented.\\n\\nThis implementation has a time complexity of O(n^2) and space complexity of O(n), where n is the length of the string \\'s\\'. This is much more efficient than the exponential time complexity of the recursive approach without DP."
                    },
                    {
                        "username": "mushu909",
                        "content": "Why is the base case\\n `            \\nif start == len(s):\\n    return True\\n`\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "THE_BMKJS_LEADER",
                        "content": "Input\ns =\"bb\"\nwordDict =[\"a\",\"b\",\"bbb\",\"bbbb\"]\nExpected: true\nwhy??? s does'nt contain  \"a\" anywhere... so how it can aspect true ??? \nam i missing somthing??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The Word Break problem asks if the given string `s` can be segmented into a space-separated sequence of one or more dictionary words, where each word is from the given `wordDict`. A word can be reused any number of times.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, the result is `True` because the string `s` can be broken down into words from `wordDict` like so: `s = \"b\" + \"b\"`. \\n\\nThe presence of \"a\" in `wordDict` doesn\\'t mean it must be used to form the string `s`. It\\'s just one of the available words that you can use. In this case, it\\'s not used at all, but that doesn\\'t affect whether `s` can be segmented into words from `wordDict`.\\n\\nSo you are correct, \\'s\\' doesn\\'t contain \\'a\\', but \\'s\\' can still be broken down entirely using other words from the `wordDict`. That\\'s why the expected output is `True`."
                    },
                    {
                        "username": "sharadbhat",
                        "content": "I think you\\'ve misunderstood the question. The aim is to find if the string \"bb\" can be built by using any elements from wordDict. \"bb\" can be built using \"b\" twice."
                    },
                    {
                        "username": "_tofu_",
                        "content": "Does anyone know why using backtracking will TLE in this problem?\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@spookie886](/spookie886) because the time complexity of backtracking is n! and above 20, that becomes a really big number, so it will always TLE, 20 is already 2 ^ 18"
                    },
                    {
                        "username": "bparanj",
                        "content": "The \"Word Break\" problem can be solved using a backtracking approach, but it often results in a time limit exceeded (TLE) error for larger inputs. Here\\'s why:\\n\\nBacktracking is a strategy for finding all (or some) solutions to computational problems, notably constraint satisfaction problems, that incrementally builds candidates for the solutions, and abandons a candidate (\"backtracks\") as soon as it determines that the candidate cannot possibly be extended to a valid solution.\\n\\nThe classic backtracking approach for this problem involves trying all possible break points and recursively checking whether each prefix can be broken using the word dictionary. If you try to solve it this way, you\\'ll end up with a solution that has a time complexity of O(2^n), where n is the length of the string. This is because in the worst-case scenario, you\\'re trying all possible partitions of the string.\\n\\nFor example, consider a string of length n containing only \\'a\\', and a dictionary containing a single word \\'a\\'. There are 2^(n-1) ways to partition this string. Given that the string length can be up to 300, it\\'s not feasible to check all these partitions in a reasonable amount of time.\\n\\nTo avoid the TLE, you should use dynamic programming (DP) which reduces the time complexity to O(n^2). The DP solution involves precomputing whether all substrings of the given string can be broken using the word dictionary, and using these precomputed results to calculate the result for the larger string.\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@XOFJO](/XOFJO) whyyy is this common sense or... is it a rule in interviews?"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Dont use backtracking when the array or string is longer than 20"
                    },
                    {
                        "username": "samandar005_xamidov",
                        "content": " @[leetcode](https://leetcode.com)\\ncan you explain why this happens\\nwordDict =\\n[\"a\",\"b\",\"bbb\",\"bbbb\"]\\ns =\\n\"bb\""
                    },
                    {
                        "username": "bparanj",
                        "content": "In the Word Break problem, you are given a non-empty string `s` and a dictionary `wordDict` containing a list of non-empty words. The problem asks whether `s` can be segmented into a space-separated sequence of one or more dictionary words.\\n\\nFor your given input `s = \"bb\"` and `wordDict = [\"a\", \"b\", \"bbb\", \"bbbb\"]`, we are asked if we can break `s` into a sequence of one or more words from `wordDict`.\\n\\nHere\\'s how we can do that:\\n\\n- Break `s` into two words: `s = \"b\" + \"b\"`\\n\\nBoth \"b\" and \"b\" are available in `wordDict`, so the output is `True`.\\n\\nNotice that even though \"a\", \"bbb\", and \"bbbb\" are in `wordDict`, we don\\'t have to use them. The problem only asks if it\\'s *possible* to break `s` into words from `wordDict`, not whether we can use *all* the words in `wordDict`.\\n\\nSo even though `s` doesn\\'t contain \"a\", \"bbb\", or \"bbbb\", we can still break it into words from `wordDict`, and therefore the output is `True`."
                    },
                    {
                        "username": "jibin_jk",
                        "content": "I think as per the question the string should be a member of worddict so I am also not very favourable with this case of testing."
                    },
                    {
                        "username": "peihao61",
                        "content": "\"b\" + \"b\"\\nso output - true"
                    },
                    {
                        "username": "noira13",
                        "content": "is bfs good enough for an interview perspective?"
                    },
                    {
                        "username": "poojaa_____",
                        "content": "bool wordBreak(char * s, char ** wordDict, int wordDictSize){\\n    int n = strlen(s);\\n    bool dp[n+1];\\n    memset(dp, false, sizeof(dp));\\n    dp[0] = true;\\n    for (int i = 1; i <= n; i++) {\\n        for (int j = 0; j < i; j++) {\\n            if (dp[j] && isInDictionary(s+j, i-j, wordDict, wordDictSize)) {\\n                dp[i] = true;\\n                break;\\n            }\\n        }\\n    }\\n    return dp[n];\\n}\\n\\nbool isInDictionary(char* s, int len, char** wordDict, int wordDictSize) {\\n    for (int i = 0; i < wordDictSize; i++) {\\n        if (strncmp(s, wordDict[i], len) == 0) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sliding Window Maximum",
        "question_content": "<p>You are given an array of integers&nbsp;<code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the max sliding window</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [3,3,5,5,6,7]\n<strong>Explanation:</strong> \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       <strong>3</strong>\n 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>\n 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>\n 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>\n 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>\n 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1], k = 1\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= nums.length</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 65884,
                "title": "java-o-n-solution-using-deque-with-explanation",
                "content": "We scan the array from 0 to n-1, keep \"promising\" elements in the deque. The algorithm is amortized O(n) as each element is put and polled once.\\n\\nAt each i, we keep \"promising\" elements, which are potentially max number in window [i-(k-1),i] or any subsequent window. This means\\n\\n1. If an element in the deque and it is out of i-(k-1), we discard them. We just need to poll from the head, as we are using a deque and elements are ordered as the sequence in the array\\n\\n2. Now only those elements within [i-(k-1),i]  are in the deque. We then discard elements smaller than a[i] from the tail. This is because if a[x] <a[i] and x<i, then a[x] has no chance to be the \"max\" in [i-(k-1),i], or any other subsequent window: a[i] would always be a better candidate. \\n\\n3. As a result elements in the deque are ordered in both sequence in array and their value. At each step the head of the deque is the max element in [i-(k-1),i]\\n\\n\\n-----------------------------------\\n    public int[] maxSlidingWindow(int[] a, int k) {\\t\\t\\n    \\t\\tif (a == null || k <= 0) {\\n    \\t\\t\\treturn new int[0];\\n    \\t\\t}\\n    \\t\\tint n = a.length;\\n    \\t\\tint[] r = new int[n-k+1];\\n    \\t\\tint ri = 0;\\n    \\t\\t// store index\\n    \\t\\tDeque<Integer> q = new ArrayDeque<>();\\n    \\t\\tfor (int i = 0; i < a.length; i++) {\\n    \\t\\t\\t// remove numbers out of range k\\n    \\t\\t\\twhile (!q.isEmpty() && q.peek() < i - k + 1) {\\n    \\t\\t\\t\\tq.poll();\\n    \\t\\t\\t}\\n    \\t\\t\\t// remove smaller numbers in k range as they are useless\\n    \\t\\t\\twhile (!q.isEmpty() && a[q.peekLast()] < a[i]) {\\n    \\t\\t\\t\\tq.pollLast();\\n    \\t\\t\\t}\\n    \\t\\t\\t// q contains index... r contains content\\n    \\t\\t\\tq.offer(i);\\n    \\t\\t\\tif (i >= k - 1) {\\n    \\t\\t\\t\\tr[ri++] = a[q.peek()];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn r;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "We scan the array from 0 to n-1, keep \"promising\" elements in the deque. The algorithm is amortized O(n) as each element is put and polled once.\\n\\nAt each i, we keep \"promising\" elements, which are potentially max number in window [i-(k-1),i] or any subsequent window. This means\\n\\n1. If an element in the deque and it is out of i-(k-1), we discard them. We just need to poll from the head, as we are using a deque and elements are ordered as the sequence in the array\\n\\n2. Now only those elements within [i-(k-1),i]  are in the deque. We then discard elements smaller than a[i] from the tail. This is because if a[x] <a[i] and x<i, then a[x] has no chance to be the \"max\" in [i-(k-1),i], or any other subsequent window: a[i] would always be a better candidate. \\n\\n3. As a result elements in the deque are ordered in both sequence in array and their value. At each step the head of the deque is the max element in [i-(k-1),i]\\n\\n\\n-----------------------------------\\n    public int[] maxSlidingWindow(int[] a, int k) {\\t\\t\\n    \\t\\tif (a == null || k <= 0) {\\n    \\t\\t\\treturn new int[0];\\n    \\t\\t}\\n    \\t\\tint n = a.length;\\n    \\t\\tint[] r = new int[n-k+1];\\n    \\t\\tint ri = 0;\\n    \\t\\t// store index\\n    \\t\\tDeque<Integer> q = new ArrayDeque<>();\\n    \\t\\tfor (int i = 0; i < a.length; i++) {\\n    \\t\\t\\t// remove numbers out of range k\\n    \\t\\t\\twhile (!q.isEmpty() && q.peek() < i - k + 1) {\\n    \\t\\t\\t\\tq.poll();\\n    \\t\\t\\t}\\n    \\t\\t\\t// remove smaller numbers in k range as they are useless\\n    \\t\\t\\twhile (!q.isEmpty() && a[q.peekLast()] < a[i]) {\\n    \\t\\t\\t\\tq.pollLast();\\n    \\t\\t\\t}\\n    \\t\\t\\t// q contains index... r contains content\\n    \\t\\t\\tq.offer(i);\\n    \\t\\t\\tif (i >= k - 1) {\\n    \\t\\t\\t\\tr[ri++] = a[q.peek()];\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn r;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 65881,
                "title": "o-n-solution-in-java-with-two-simple-pass-in-the-array",
                "content": "\\nFor Example: A = [2,1,3,4,6,3,8,9,10,12,56],  w=4\\n\\n1. partition the array in blocks of size w=4. The last block may have less then w.\\n2, 1, 3, 4 | 6, 3, 8, 9 | 10, 12, 56|\\n\\n2. Traverse the list from start to end and calculate max_so_far. Reset max after each block boundary (of w elements).\\nleft_max[] = 2, 2, 3, 4 | 6, 6, 8, 9 | 10, 12, 56\\n\\n3. Similarly calculate max in future by traversing from end to start.\\nright_max[] = 4, 4, 4, 4 | 9, 9, 9, 9 | 56, 56, 56\\n\\n4. now, sliding max at each position i in current window, sliding-max(i) = max{right_max(i), left_max(i+w-1)}\\nsliding_max = 4, 6, 6, 8, 9, 10, 12, 56\\n\\ncode:\\n   \\n\\n     public static int[] slidingWindowMax(final int[] in, final int w) {\\n        final int[] max_left = new int[in.length];\\n        final int[] max_right = new int[in.length];\\n    \\n        max_left[0] = in[0];\\n        max_right[in.length - 1] = in[in.length - 1];\\n    \\n        for (int i = 1; i < in.length; i++) {\\n            max_left[i] = (i % w == 0) ? in[i] : Math.max(max_left[i - 1], in[i]);\\n    \\n            final int j = in.length - i - 1;\\n            max_right[j] = (j % w == 0) ? in[j] : Math.max(max_right[j + 1], in[j]);\\n        }\\n    \\n        final int[] sliding_max = new int[in.length - w + 1];\\n        for (int i = 0, j = 0; i + w <= in.length; i++) {\\n            sliding_max[j++] = Math.max(max_right[i], max_left[i + w - 1]);\\n        }\\n    \\n        return sliding_max;\\n    }",
                "solutionTags": [],
                "code": "\\nFor Example: A = [2,1,3,4,6,3,8,9,10,12,56],  w=4\\n\\n1. partition the array in blocks of size w=4. The last block may have less then w.\\n2, 1, 3, 4 | 6, 3, 8, 9 | 10, 12, 56|\\n\\n2. Traverse the list from start to end and calculate max_so_far. Reset max after each block boundary (of w elements).\\nleft_max[] = 2, 2, 3, 4 | 6, 6, 8, 9 | 10, 12, 56\\n\\n3. Similarly calculate max in future by traversing from end to start.\\nright_max[] = 4, 4, 4, 4 | 9, 9, 9, 9 | 56, 56, 56\\n\\n4. now, sliding max at each position i in current window, sliding-max(i) = max{right_max(i), left_max(i+w-1)}\\nsliding_max = 4, 6, 6, 8, 9, 10, 12, 56\\n\\ncode:\\n   \\n\\n     public static int[] slidingWindowMax(final int[] in, final int w) {\\n        final int[] max_left = new int[in.length];\\n        final int[] max_right = new int[in.length];\\n    \\n        max_left[0] = in[0];\\n        max_right[in.length - 1] = in[in.length - 1];\\n    \\n        for (int i = 1; i < in.length; i++) {\\n            max_left[i] = (i % w == 0) ? in[i] : Math.max(max_left[i - 1], in[i]);\\n    \\n            final int j = in.length - i - 1;\\n            max_right[j] = (j % w == 0) ? in[j] : Math.max(max_right[j + 1], in[j]);\\n        }\\n    \\n        final int[] sliding_max = new int[in.length - w + 1];\\n        for (int i = 0, j = 0; i + w <= in.length; i++) {\\n            sliding_max[j++] = Math.max(max_right[i], max_left[i + w - 1]);\\n        }\\n    \\n        return sliding_max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 458121,
                "title": "java-all-solutions-b-f-pq-deque-dp-with-explanation-and-complexity-analysis",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/sliding-window-maximum/)\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n## Problem\\n\\n> Given an array `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.\\n\\n**Note:** You may assume `k` is always valid, 1 \\u2264 `k` \\u2264 input array\\'s size for non-empty array.\\n\\n**Example:**\\n\\n```java\\nInput: nums = [1,3,-1,-3,5,3,6,7], and k = 3\\nOutput: [3,3,5,5,6,7] \\nExplanation: \\n\\nWindow position                Max\\n---------------               -----\\n[1  3  -1] -3  5  3  6  7       3\\n 1 [3  -1  -3] 5  3  6  7       3\\n 1  3 [-1  -3  5] 3  6  7       5\\n 1  3  -1 [-3  5  3] 6  7       5\\n 1  3  -1  -3 [5  3  6] 7       6\\n 1  3  -1  -3  5 [3  6  7]      7\\n```\\n\\n**Follow up:** Could you solve it in linear time?\\n\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nCheck every sliding window and compute the maximum value.\\n\\n```java\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  if (n == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  \\n  int numOfWindow = n - k + 1;\\n  int[] result = new int[numOfWindow]; // number of windows\\n  \\n  for (int start = 0; start < numOfWindow; ++start) {\\n    int end = start + k - 1;\\n    int maxVal = nums[start];\\n    for (int i = start + 1; i <= end; ++i) {\\n      if (nums[i] > maxVal) { // update\\n        maxVal = nums[i];\\n      }\\n    }\\n    result[start] = maxVal;\\n  }\\n  \\n  return result;\\n}\\n```\\n\\n**Time:** `O(Nk)`\\n**Space:** `O(1)` not including the output array\\n\\n\\n### Priority Queue\\n\\nIn theory, we can use priority queue to achieve `O(N\\\\log{k})`. However, if we stick to the build-in `PriorityQueue` in Java, it still takes `O(Nk)`:\\n\\n```java\\npublic boolean remove(Object o) {\\n  int i = indexOf(o);\\n  if (i == -1) {\\n    return false;\\n  } else {\\n    removeAt(i);\\n    return true;\\n  }\\n}\\n\\nprivate int indexOf(Object o) {\\n  if (o != null) {\\n    final Object[] es = queue;\\n    for (int i = 0, n = size; i < n; i++) {\\n      if (o.equals(es[i])) return i;\\n    }\\n  }\\n  return -1;\\n}\\n```\\n\\nThe code in `indexOf()` shows that this naive method takes `O(N)` time in the worst case. Therefore, if we use the built-in method in Java, it takes `O(Nk)`.\\n\\nIn terms of `O(N\\\\log{k})`, the basic idea is that we are keeping the size of the heap as at most `k` by removing the elements that are out of the k-size window. If we assume that `remove()` takes `O(\\\\log{k})` time (if we implement the priority queue by ourselves), it would have that logarithmic time complexity.\\n\\n```java\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  if (nums.length == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int n = nums.length;\\n  int[] result = new int[n - k + 1]; // number of windows\\n  \\n  PriorityQueue<Integer> maxPQ = new PriorityQueue<>((o1, o2) -> (o2 - o1)); // stores values\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int start = i - k;\\n    if (start >= 0) {\\n      maxPQ.remove(nums[start]); // remove the out-of-bound value\\n    }\\n    maxPQ.offer(nums[i]);\\n    if (maxPQ.size() == k) {\\n      result[i - k + 1] = maxPQ.peek();\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\nThis is the first version I came up with. I think for this solution we can dive deeper to see how `PriorityQueue` in Java works. Consider what would happen if there are duplicates in the heap. Which one to be removed?\\n\\nAlso notice that when we are using the wrapper class `Integer` in Java we notice the caching feature.\\n\\n```java\\nInteger val1 = 1;\\nInteger val2 = 1;\\nInteger val3 = 200;\\nInteger val4 = 200;\\n// comparing the values\\nval1.equals(val2); // true\\nval3.equals(val4); // true\\n// comparing the address\\nval1 == val2;      // true\\nval3 == val4;      // false\\n```\\n\\nThis occurs because Java does caching for integers between `-128` and `127` for better performance. Here is the code in `Integer` class:\\n\\n```java\\n// Java 1.6 source code\\npublic static Integer valueOf(int i) {\\n  if (i >= -128 && i <= IntegerCache.high) { // IntegerCache.high = 127\\n    return IntegerCache.cache[i + 128];\\n  } else {\\n    return new Integer(i);\\n  }\\n}\\n```\\n\\nBack to the problem. Therefore, if there are duplicates between `-128` and `127` in the heap, we cannot delete the object that we want (the leftmost element in the sliding window).\\n\\nBut do duplicates actually matter? In other words, do we really need to consider the case where we have duplicate elements in the window and decide which one to remove?\\n\\n**The answer is NO.** We can just remove one of them. For the example `{2, 4, 2, 5}, k = 3`, removing the first or the second `2` is the same.\\n\\nHowever, we can modify the code a little bit and let the priority queue know the specific element we want to remove.\\n\\n```java\\n// Use indices since they are unique\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  if (nums.length == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int n = nums.length;\\n  int[] result = new int[n - k + 1]; // number of windows\\n  \\n  PriorityQueue<Integer> maxPQ = new PriorityQueue<>((i1, i2) -> (nums[i2] - nums[i1])); // stores values\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int start = i - k;\\n    if (start >= 0) {\\n      maxPQ.remove(start); // remove the out-of-bound value by index\\n    }\\n    maxPQ.offer(i);\\n    if (maxPQ.size() == k) {\\n      result[i - k + 1] = nums[maxPQ.peek()];\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(Nk)` (if we implement PQ by ourselves, it is `O(N\\\\log{k})`)\\n**Space:** `O(k)`\\n\\n\\n\\n\\n\\n### Deque\\n\\nIf we can add and remove elements from both sides of the sliding window, we can solve this problem in linear time. It turns out that we can use `Deque` to achieve the goal. In the `Deque`, we add and remove indices.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/dq7aw.jpg)\\n\\nBasically, for each element `nums[i]` in the array that we are about to insert, we first check whether the leftmost index in the sliding window is out of bound. If so, we remove it by `pollFirst()` in constant time.\\n\\nThen we continuously remove the rightmost indices if their corresponding elements are less than `nums[i]` (the element we are about to insert). The idea is that the elements that are less than the element we\\'ll insert won\\'t have any contributions to the maximum element of the sliding window. So it is safe to remove them.\\n\\nAfter removal `pollLast()` and insertion `offerLast(i)` (the element `nums[i]`), we can say that the leftmost element in the window is maximum. Think about it why. Notice that the maximum element could be the one we just insert.\\n\\nLast but not least, adding the maximum elements to the result array when necessary.\\n\\n```java\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  if (n == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int[] result = new int[n - k + 1]; // number of windows\\n  Deque<Integer> win = new ArrayDeque<>(); // stores indices\\n  \\n  for (int i = 0; i < n; ++i) {\\n    // remove indices that are out of bound\\n    while (win.size() > 0 && win.peekFirst() <= i - k) {\\n      win.pollFirst();\\n    }\\n    // remove indices whose corresponding values are less than nums[i]\\n    while (win.size() > 0 && nums[win.peekLast()] < nums[i]) {\\n      win.pollLast();\\n    }\\n    // add nums[i]\\n    win.offerLast(i);\\n    // add to result\\n    if (i >= k - 1) {\\n      result[i - k + 1] = nums[win.peekFirst()];\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N)` since each element is processed (add/remove) at most twice.\\n**Space:** `O(k)`\\n\\n\\n\\n\\n### DP\\n\\nThis method is very hacky. The explanation in [solution section](https://leetcode.com/problems/sliding-window-maximum/solution/) is readable.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/4hlzv.jpg)\\n\\n**Note:** Don\\'t read the code of my first attempt.\\n\\n```java\\n// my first attempt\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  if (nums.length == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int n = nums.length;\\n  int[] result = new int[n - k + 1]; // number of windows\\n  \\n  // left & right\\n  int[] left = new int[n];\\n  int[] right = new int[n];\\n\\n  for (int i = 0; i < n; ++i) {\\n    // left\\n    if (i % k == 0) { // beginning of the group\\n      left[i] = nums[i];\\n    } else {\\n      left[i] = Math.max(left[i - 1], nums[i]);\\n    }\\n    \\n    // right (* to be improved)\\n    int temp = (i / k + 1) * k - 1; // last of the group\\n    if (temp > n - 1) temp = n - 1;\\n    \\n    int j = temp - i % k;\\n    if (j % k == (k - 1) || j == n - 1) {\\n      right[j] = nums[j];\\n    } else {\\n      right[j] = Math.max(right[j + 1], nums[j]);\\n    }\\n  }\\n  \\n  // dp\\n  for (int i = 0, j = i + k - 1; j < n; ++i, ++j) {\\n    result[i] = Math.max(right[i], left[j]);\\n  }\\n  \\n  return result;\\n}\\n```\\n\\nThe better version:\\n\\n```java\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  if (nums.length == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int n = nums.length;\\n  int[] result = new int[n - k + 1]; // number of windows\\n  \\n  // left & right\\n  int[] left = new int[n];\\n  int[] right = new int[n];\\n  left[0] = nums[0]; // init\\n  right[n - 1] = nums[n - 1];\\n  \\n  for (int i = 1; i < n; ++i) {\\n    // left\\n    if (i % k == 0) left[i] = nums[i];\\n    else            left[i] = Math.max(left[i - 1], nums[i]);\\n    // right\\n    int j = n - i - 1;\\n    if (j % k == (k - 1)) right[j] = nums[j];\\n    else                  right[j] = Math.max(right[j + 1], nums[j]);\\n  }\\n  \\n  // dp\\n  for (int i = 0, j = i + k - 1; j < n; ++i, ++j) {\\n    result[i] = Math.max(right[i], left[j]);\\n  }\\n  \\n  return result;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nInput: nums = [1,3,-1,-3,5,3,6,7], and k = 3\\nOutput: [3,3,5,5,6,7] \\nExplanation: \\n\\nWindow position                Max\\n---------------               -----\\n[1  3  -1] -3  5  3  6  7       3\\n 1 [3  -1  -3] 5  3  6  7       3\\n 1  3 [-1  -3  5] 3  6  7       5\\n 1  3  -1 [-3  5  3] 6  7       5\\n 1  3  -1  -3 [5  3  6] 7       6\\n 1  3  -1  -3  5 [3  6  7]      7\\n```\n```java\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  if (n == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  \\n  int numOfWindow = n - k + 1;\\n  int[] result = new int[numOfWindow]; // number of windows\\n  \\n  for (int start = 0; start < numOfWindow; ++start) {\\n    int end = start + k - 1;\\n    int maxVal = nums[start];\\n    for (int i = start + 1; i <= end; ++i) {\\n      if (nums[i] > maxVal) { // update\\n        maxVal = nums[i];\\n      }\\n    }\\n    result[start] = maxVal;\\n  }\\n  \\n  return result;\\n}\\n```\n```java\\npublic boolean remove(Object o) {\\n  int i = indexOf(o);\\n  if (i == -1) {\\n    return false;\\n  } else {\\n    removeAt(i);\\n    return true;\\n  }\\n}\\n\\nprivate int indexOf(Object o) {\\n  if (o != null) {\\n    final Object[] es = queue;\\n    for (int i = 0, n = size; i < n; i++) {\\n      if (o.equals(es[i])) return i;\\n    }\\n  }\\n  return -1;\\n}\\n```\n```java\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  if (nums.length == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int n = nums.length;\\n  int[] result = new int[n - k + 1]; // number of windows\\n  \\n  PriorityQueue<Integer> maxPQ = new PriorityQueue<>((o1, o2) -> (o2 - o1)); // stores values\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int start = i - k;\\n    if (start >= 0) {\\n      maxPQ.remove(nums[start]); // remove the out-of-bound value\\n    }\\n    maxPQ.offer(nums[i]);\\n    if (maxPQ.size() == k) {\\n      result[i - k + 1] = maxPQ.peek();\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\nInteger val1 = 1;\\nInteger val2 = 1;\\nInteger val3 = 200;\\nInteger val4 = 200;\\n// comparing the values\\nval1.equals(val2); // true\\nval3.equals(val4); // true\\n// comparing the address\\nval1 == val2;      // true\\nval3 == val4;      // false\\n```\n```java\\n// Java 1.6 source code\\npublic static Integer valueOf(int i) {\\n  if (i >= -128 && i <= IntegerCache.high) { // IntegerCache.high = 127\\n    return IntegerCache.cache[i + 128];\\n  } else {\\n    return new Integer(i);\\n  }\\n}\\n```\n```java\\n// Use indices since they are unique\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  if (nums.length == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int n = nums.length;\\n  int[] result = new int[n - k + 1]; // number of windows\\n  \\n  PriorityQueue<Integer> maxPQ = new PriorityQueue<>((i1, i2) -> (nums[i2] - nums[i1])); // stores values\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int start = i - k;\\n    if (start >= 0) {\\n      maxPQ.remove(start); // remove the out-of-bound value by index\\n    }\\n    maxPQ.offer(i);\\n    if (maxPQ.size() == k) {\\n      result[i - k + 1] = nums[maxPQ.peek()];\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  int n = nums.length;\\n  if (n == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int[] result = new int[n - k + 1]; // number of windows\\n  Deque<Integer> win = new ArrayDeque<>(); // stores indices\\n  \\n  for (int i = 0; i < n; ++i) {\\n    // remove indices that are out of bound\\n    while (win.size() > 0 && win.peekFirst() <= i - k) {\\n      win.pollFirst();\\n    }\\n    // remove indices whose corresponding values are less than nums[i]\\n    while (win.size() > 0 && nums[win.peekLast()] < nums[i]) {\\n      win.pollLast();\\n    }\\n    // add nums[i]\\n    win.offerLast(i);\\n    // add to result\\n    if (i >= k - 1) {\\n      result[i - k + 1] = nums[win.peekFirst()];\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\n// my first attempt\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  if (nums.length == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int n = nums.length;\\n  int[] result = new int[n - k + 1]; // number of windows\\n  \\n  // left & right\\n  int[] left = new int[n];\\n  int[] right = new int[n];\\n\\n  for (int i = 0; i < n; ++i) {\\n    // left\\n    if (i % k == 0) { // beginning of the group\\n      left[i] = nums[i];\\n    } else {\\n      left[i] = Math.max(left[i - 1], nums[i]);\\n    }\\n    \\n    // right (* to be improved)\\n    int temp = (i / k + 1) * k - 1; // last of the group\\n    if (temp > n - 1) temp = n - 1;\\n    \\n    int j = temp - i % k;\\n    if (j % k == (k - 1) || j == n - 1) {\\n      right[j] = nums[j];\\n    } else {\\n      right[j] = Math.max(right[j + 1], nums[j]);\\n    }\\n  }\\n  \\n  // dp\\n  for (int i = 0, j = i + k - 1; j < n; ++i, ++j) {\\n    result[i] = Math.max(right[i], left[j]);\\n  }\\n  \\n  return result;\\n}\\n```\n```java\\npublic int[] maxSlidingWindow(int[] nums, int k) {\\n  // assume nums is not null\\n  if (nums.length == 0 || k == 0) {\\n    return new int[0];\\n  }\\n  int n = nums.length;\\n  int[] result = new int[n - k + 1]; // number of windows\\n  \\n  // left & right\\n  int[] left = new int[n];\\n  int[] right = new int[n];\\n  left[0] = nums[0]; // init\\n  right[n - 1] = nums[n - 1];\\n  \\n  for (int i = 1; i < n; ++i) {\\n    // left\\n    if (i % k == 0) left[i] = nums[i];\\n    else            left[i] = Math.max(left[i - 1], nums[i]);\\n    // right\\n    int j = n - i - 1;\\n    if (j % k == (k - 1)) right[j] = nums[j];\\n    else                  right[j] = Math.max(right[j + 1], nums[j]);\\n  }\\n  \\n  // dp\\n  for (int i = 0, j = i + k - 1; j < n; ++i, ++j) {\\n    result[i] = Math.max(right[i], left[j]);\\n  }\\n  \\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871317,
                "title": "clear-thinking-process-with-picture-brute-force-to-mono-deque-python-java-javascript",
                "content": "EDIT: See full step-by-step animation of monotonic stack in action in [this post](https://bit.ly/33d5kb1)\\n    \\n  # Brute force\\n  We can write a nested loop, the outer loop goes through each window and the inner loop finds the max within the window. This is `O(N^2)` time complexity.\\n\\n  To optimize on brute force, we can either reduce outer or inner loop complexity. Since we have to examine each element at least once (there\\'s no way to find the maximum if we don\\'t know what the values are..), there is not much we can do for outer loop. So we have to work on the inner loop. \\n\\n  ## Preserving inner elements maximum\\n  Currently, to get the max of the sliding window, we look at each element in the window and compare them. Analogous to sliding window sum problem (given an array and a window size, return the sum of each window), when a window slides, only two elements change - the leftmost gets removed and a new element gets added to the right. Everything in the middle (let\\'s call them \"inner elements\") is unchanged, and the maximum element among these inner elements are unchanged as well. The key to reducing inner loop complexity is to persist the maximum of the inner elements as we slide the window. Ideally, we want to be able to access the maximum element in less than `O(N)` time and updating it in less than `O(N)` time.\\n\\n  ## Balanced binary search tree\\n  One way to achieve this goal is to save the window elements in a [self-balancing binary search tree](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree). Because it\\'s self-balancing, the depth of the tree is guaranteed to be `O(log(N))` so lookup, getting max, insert and delete are all `O(log(N))` operations. Every time we slide the window, we remove the node that\\'s out of the window and add the one that comes into the window to the tree. Overall, this gives us `O(N log(k))` since the number of tree nodes is `k` and we slide max `N` times.\\n\\n  This is pretty good already, but can we do better?\\n\\n  ## Larger elements entering window invalidates smaller elements\\n  A question we can ask ourselves is \"do we need to keep all the window elements in our state?\".\\n  An important observation is for two elements `arr[left]` and `arr[right]`, where `left < right`, `arr[left]` leaves the window earlier as we slide. If `arr[right]` is larger than `arr[left]`, then there is no point keeping `arr[left]` in our state since `arr[right]` is always gonna be larger during the time `arr[left]` is in the window. Therefore, `arr[left]` can never be the maximum.\\n\\n  # Monotonic deque\\n  Here we introduce an interesting data structure. It\\'s a deque with an interesting property - the elements in the deque from head to tail are in decreasing order (hence the name monotonic).\\n\\n  To achieve this property, we modify the push operation so that \\n\\n  **Before we push an element into the deque, we first pop everything smaller than it out of the deque**.\\n\\n  This enforces the decreasing order.\\n  \\n![Alt Text](https://assets.leetcode.com/static_assets/posts/sliding_window_maximum.gif)\\n\\n\\n  The time complexity is `O(N)`. This is because each element in the original array can only be pushed into and popped out of the deque only *once*.\\n\\n  The key why monotonic deque works is it stores both magnitude and position information. From head to tail, the elements get smaller and further to the right of the array.\\n\\n  ## Implementation\\n  In the actual implementation, we store indices instead of actual elements in the deque. This is because we need the index to know if an element is out of the window or not and we can always get the value using the index from the array.\\n  \\n### python\\n\\n```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        from collections import deque\\n        q = deque() # stores *indices*\\n        res = []\\n        for i, cur in enumerate(nums):\\n            while q and nums[q[-1]] <= cur:\\n                q.pop()\\n            q.append(i)\\n            # remove first element if it\\'s outside the window\\n            if q[0] == i - k:\\n                q.popleft()\\n            # if window has k elements add to results (first k-1 windows have < k elements because we start from empty window and add 1 element each iteration)\\n            if i >= k - 1:\\n                res.append(nums[q[0]])\\n        return res\\n```\\t\\t\\n\\n### java\\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        Deque<Integer> q = new ArrayDeque<>();  // stores *indices*\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!q.isEmpty() && nums[q.getLast()] <= nums[i]) {\\n                q.removeLast();\\n            }\\n            q.addLast(i);\\n            // remove first element if it\\'s outside the window\\n            if (q.getFirst() == i - k) {\\n                q.removeFirst();\\n            }\\n            // if window has k elements add to results (first k-1 windows have < k elements because we start from empty window and add 1 element each iteration)\\n            if (i >= k - 1) {\\n                res.add(nums[q.peek()]);\\n            }\\n        }\\n        return res.stream().mapToInt(i->i).toArray();            \\n    }\\n}\\n\\n```\\n\\n### javascript\\n```\\nvar maxSlidingWindow = function(nums, k) {\\n    const q = [];  // stores *indices*\\n    const res = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        while (q && nums[q[q.length - 1]] <= nums[i]) {\\n            q.pop();\\n        }\\n        q.push(i);\\n        // remove first element if it\\'s outside the window\\n        if (q[0] === i - k) {\\n            q.shift();\\n        }\\n        // if window has k elements add to results (first k-1 windows have < k elements because we start from empty window and add 1 element each iteration)\\n        if (i >= k - 1) {\\n            res.push(nums[q[0]]);\\n        }\\n    }\\n    return res;    \\n};\\n```\\n\\nStill not clear? See full animations of monotonic stack in action in [this post](https://bit.ly/33d5kb1)\\n\\n## Please upvote if you found it useful!\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        from collections import deque\\n        q = deque() # stores *indices*\\n        res = []\\n        for i, cur in enumerate(nums):\\n            while q and nums[q[-1]] <= cur:\\n                q.pop()\\n            q.append(i)\\n            # remove first element if it\\'s outside the window\\n            if q[0] == i - k:\\n                q.popleft()\\n            # if window has k elements add to results (first k-1 windows have < k elements because we start from empty window and add 1 element each iteration)\\n            if i >= k - 1:\\n                res.append(nums[q[0]])\\n        return res\\n```\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        Deque<Integer> q = new ArrayDeque<>();  // stores *indices*\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            while (!q.isEmpty() && nums[q.getLast()] <= nums[i]) {\\n                q.removeLast();\\n            }\\n            q.addLast(i);\\n            // remove first element if it\\'s outside the window\\n            if (q.getFirst() == i - k) {\\n                q.removeFirst();\\n            }\\n            // if window has k elements add to results (first k-1 windows have < k elements because we start from empty window and add 1 element each iteration)\\n            if (i >= k - 1) {\\n                res.add(nums[q.peek()]);\\n            }\\n        }\\n        return res.stream().mapToInt(i->i).toArray();            \\n    }\\n}\\n\\n```\n```\\nvar maxSlidingWindow = function(nums, k) {\\n    const q = [];  // stores *indices*\\n    const res = [];\\n    for (let i = 0; i < nums.length; i++) {\\n        while (q && nums[q[q.length - 1]] <= nums[i]) {\\n            q.pop();\\n        }\\n        q.push(i);\\n        // remove first element if it\\'s outside the window\\n        if (q[0] === i - k) {\\n            q.shift();\\n        }\\n        // if window has k elements add to results (first k-1 windows have < k elements because we start from empty window and add 1 element each iteration)\\n        if (i >= k - 1) {\\n            res.push(nums[q[0]]);\\n        }\\n    }\\n    return res;    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65898,
                "title": "clean-c-o-n-solution-using-a-deque",
                "content": "The data structure used is know as Monotonic Queue. Click [here](http://abitofcs.blogspot.com/2014/11/data-structure-sliding-window-minimum.html) for more information.\\n\\nYou can also view more solution on [Github](https://github.com/flexwang/CodeTest)\\n\\n    class Solution {\\n    public:\\n        vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            deque<int> dq;\\n            vector<int> ans;\\n            for (int i=0; i<nums.size(); i++) {\\n                if (!dq.empty() && dq.front() == i-k) dq.pop_front();\\n                while (!dq.empty() && nums[dq.back()] < nums[i])\\n                    dq.pop_back();\\n                dq.push_back(i);\\n                if (i>=k-1) ans.push_back(nums[dq.front()]);\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            deque<int> dq;\\n            vector<int> ans;\\n            for (int i=0; i<nums.size(); i++) {\\n                if (!dq.empty() && dq.front() == i-k) dq.pop_front();\\n                while (!dq.empty() && nums[dq.back()] < nums[i])\\n                    dq.pop_back();\\n                dq.push_back(i);\\n                if (i>=k-1) ans.push_back(nums[dq.front()]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65885,
                "title": "this-is-a-typical-monotonic-queue-problem",
                "content": "Sliding window minimum/maximum = monotonic queue. I smelled the solution just when I read the title.\\nThis is essentially the same idea as others\\' deque solution, but this is much more standardized and modulized. If you ever need to use it in your real product, this code is definitely more preferable. \\n\\nWhat does Monoqueue do here:\\n\\nIt has three basic options:\\n\\npush: push an element into the queue;  O (1) (amortized)\\n\\npop: pop an element out of the queue; O(1) (pop = remove, it can\\'t report this element)\\n\\nmax: report the max element in queue;O(1)\\n\\nIt takes only O(n) time to process a N-size sliding window minimum/maximum problem.\\n\\nNote: different from a priority queue (which takes O(nlogk) to solve this problem),  it doesn\\'t pop the max element: It pops the first element (in original order) in queue.\\n\\n    class Monoqueue\\n    {\\n        deque<pair<int, int>> m_deque; //pair.first: the actual value, \\n                                       //pair.second: how many elements were deleted between it and the one before it.\\n        public:\\n            void push(int val)\\n            {\\n                int count = 0;\\n                while(!m_deque.empty() && m_deque.back().first < val)\\n                {\\n                    count += m_deque.back().second + 1;\\n                    m_deque.pop_back();\\n                }\\n                m_deque.emplace_back(val, count);\\n            };\\n            int max()\\n            {\\n                return m_deque.front().first;\\n            }\\n            void pop ()\\n            {\\n                if (m_deque.front().second > 0)\\n                {\\n                    m_deque.front().second --;\\n                    return;\\n                }\\n                m_deque.pop_front();\\n            }\\n    };\\n    struct Solution {\\n        vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            vector<int> results;\\n            Monoqueue mq;\\n            k = min(k, (int)nums.size());\\n            int i = 0;\\n            for (;i < k - 1; ++i) //push first k - 1 numbers;\\n            {\\n                mq.push(nums[i]);\\n            }\\n            for (; i < nums.size(); ++i)\\n            {\\n                mq.push(nums[i]);            // push a new element to queue;\\n                results.push_back(mq.max()); // report the current max in queue;\\n                mq.pop();                    // pop first element in queue;\\n            }\\n            return results;\\n        }\\n    };",
                "solutionTags": [],
                "code": "Sliding window minimum/maximum = monotonic queue. I smelled the solution just when I read the title.\\nThis is essentially the same idea as others\\' deque solution, but this is much more standardized and modulized. If you ever need to use it in your real product, this code is definitely more preferable. \\n\\nWhat does Monoqueue do here:\\n\\nIt has three basic options:\\n\\npush: push an element into the queue;  O (1) (amortized)\\n\\npop: pop an element out of the queue; O(1) (pop = remove, it can\\'t report this element)\\n\\nmax: report the max element in queue;O(1)\\n\\nIt takes only O(n) time to process a N-size sliding window minimum/maximum problem.\\n\\nNote: different from a priority queue (which takes O(nlogk) to solve this problem),  it doesn\\'t pop the max element: It pops the first element (in original order) in queue.\\n\\n    class Monoqueue\\n    {\\n        deque<pair<int, int>> m_deque; //pair.first: the actual value, \\n                                       //pair.second: how many elements were deleted between it and the one before it.\\n        public:\\n            void push(int val)\\n            {\\n                int count = 0;\\n                while(!m_deque.empty() && m_deque.back().first < val)\\n                {\\n                    count += m_deque.back().second + 1;\\n                    m_deque.pop_back();\\n                }\\n                m_deque.emplace_back(val, count);\\n            };\\n            int max()\\n            {\\n                return m_deque.front().first;\\n            }\\n            void pop ()\\n            {\\n                if (m_deque.front().second > 0)\\n                {\\n                    m_deque.front().second --;\\n                    return;\\n                }\\n                m_deque.pop_front();\\n            }\\n    };\\n    struct Solution {\\n        vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            vector<int> results;\\n            Monoqueue mq;\\n            k = min(k, (int)nums.size());\\n            int i = 0;\\n            for (;i < k - 1; ++i) //push first k - 1 numbers;\\n            {\\n                mq.push(nums[i]);\\n            }\\n            for (; i < nums.size(); ++i)\\n            {\\n                mq.push(nums[i]);            // push a new element to queue;\\n                results.push_back(mq.max()); // report the current max in queue;\\n                mq.pop();                    // pop first element in queue;\\n            }\\n            return results;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 65901,
                "title": "9-lines-ruby-11-lines-python-o-n",
                "content": "Keep indexes of good candidates in deque `d`. The indexes in `d` are from the current window, they're increasing, and their corresponding `nums` are decreasing. Then the first deque element is the index of the largest window value.\\n\\nFor each index `i`:\\n\\n1. Pop (from the end) indexes of smaller elements (they'll be useless).\\n2. Append the current index.\\n3. Pop (from the front) the index `i - k`, if it's still in the deque (it falls out of the window).\\n4. If our window has reached size `k`, append the current window maximum to the output.\\n\\n---\\n\\n**Ruby**\\n\\nApparently Ruby doesn't have a deque, so I simulate one with an array, where `s` tells the start index of the queue in the array.\\n\\n    def max_sliding_window(nums, k)\\n        d, s = [], 0\\n        out = []\\n        nums.each_index{ |i|\\n            d.pop while d[s] && nums[d[-1]] < nums[i]\\n            d << i\\n            s += 1 if d[s] == i - k\\n            out << nums[d[s]] if i >= k - 1\\n        }\\n        out\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def maxSlidingWindow(self, nums, k):\\n        d = collections.deque()\\n        out = []\\n        for i, n in enumerate(nums):\\n            while d and nums[d[-1]] < n:\\n                d.pop()\\n            d += i,\\n            if d[0] == i - k:\\n                d.popleft()\\n            if i >= k - 1:\\n                out += nums[d[0]],\\n        return out\\n\\nLast three lines could be this, but for relatively large k it would waste space:\\n\\n            out += nums[d[0]],\\n        return out[k-1:]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Keep indexes of good candidates in deque `d`. The indexes in `d` are from the current window, they're increasing, and their corresponding `nums` are decreasing. Then the first deque element is the index of the largest window value.\\n\\nFor each index `i`:\\n\\n1. Pop (from the end) indexes of smaller elements (they'll be useless).\\n2. Append the current index.\\n3. Pop (from the front) the index `i - k`, if it's still in the deque (it falls out of the window).\\n4. If our window has reached size `k`, append the current window maximum to the output.\\n\\n---\\n\\n**Ruby**\\n\\nApparently Ruby doesn't have a deque, so I simulate one with an array, where `s` tells the start index of the queue in the array.\\n\\n    def max_sliding_window(nums, k)\\n        d, s = [], 0\\n        out = []\\n        nums.each_index{ |i|\\n            d.pop while d[s] && nums[d[-1]] < nums[i]\\n            d << i\\n            s += 1 if d[s] == i - k\\n            out << nums[d[s]] if i >= k - 1\\n        }\\n        out\\n    end\\n\\n---\\n\\n**Python**\\n\\n    def maxSlidingWindow(self, nums, k):\\n        d = collections.deque()\\n        out = []\\n        for i, n in enumerate(nums):\\n            while d and nums[d[-1]] < n:\\n                d.pop()\\n            d += i,\\n            if d[0] == i - k:\\n                d.popleft()\\n            if i >= k - 1:\\n                out += nums[d[0]],\\n        return out\\n\\nLast three lines could be this, but for relatively large k it would waste space:\\n\\n            out += nums[d[0]],\\n        return out[k-1:]",
                "codeTag": "Python3"
            },
            {
                "id": 237611,
                "title": "simplest-o-n-python-solution-with-explanation",
                "content": "The solution using deque isn\\'t very intuitive but is very simple once it *\"clicks\"*\\n\\n\\nTo summarize:\\n1. We maintain a deque of the indexes of the largest elements we\\'ve seen (aka \"good candidates\")\\n2. The problem is that we need to maintain sanity of this deque. To this we need to make sure about two things:\\n\\t1. Deque should NEVER point to elements smaller than current element\\n\\t2. Deque should NEVER point to elements outside our sliding window (which can happen, for instance in above example, where the first element is actually the largest element in the whole array, and sort of \"clings\" to the deque, only until we reach an index outside the window it can stretch to, where it\\'s fate has come and it shall be removed from the throne!)\\n3. We also keep furnishing the deque with curr_element\\n4. Finally, and most importantly, we keep appending the front of the deque to our output `out`.\\n\\n\\n\\n```\\nimport collections\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        d = collections.deque()\\n        out = []\\n        for i, n in enumerate(nums):\\n            print(\"i = {}, curr element = {}, d = {} and out = {}\".format(i, n, d, out))\\n            while d and nums[d[-1]] < n:\\n                d.pop()\\n                print(\"\\\\t Popped from d because d has elements and nums[d.top] < curr element\")\\n            d.append(i)\\n            print(\"\\\\t Added i to d\")\\n            if d[0] == i - k:\\n                d.popleft()\\n                print(\"\\\\t Popped left from d because it\\'s outside the window\\'s leftmost (i-k)\")\\n            if i>=k-1:\\n                out.append(nums[d[0]])\\n\\t\\t\\t\\tprint(\"\\\\t Append nums[d[0]] = {} to out\".format(nums[d[0]]))\\n        return out\\n```\\n\\nLets run this \"self-explanatory\" code (literally!) to see what it is doing with our array `nums` step by step. The given test case isn\\'t a very good candidate to understand this solution, so I\\'ll make a small change and change the first element to `8`:\\n\\n`print(Solution().maxSlidingWindow([8,3,-1,-3,5,3,6,7], 3))`\\n\\n<pre>\\ni = 0, curr element = 8, d = deque([]) and out = []\\n\\t Added i to d\\ni = 1, curr element = 3, d = deque([0]) and out = []\\n\\t Added i to d\\ni = 2, curr element = -1, d = deque([0, 1]) and out = []\\n\\t Added i to d\\n\\t Append nums[d[0]] = 8 to out\\ni = 3, curr element = -3, d = deque([0, 1, 2]) and out = [8]\\n\\t Added i to d\\n\\t Popped left from d because it\\'s outside the window\\'s leftmost (i-k)\\n\\t Append nums[d[0]] = 3 to out\\ni = 4, curr element = 5, d = deque([1, 2, 3]) and out = [8, 3]\\n\\t Popped from d because d has elements and nums[d.top] < curr element\\n\\t Popped from d because d has elements and nums[d.top] < curr element\\n\\t Popped from d because d has elements and nums[d.top] < curr element\\n\\t Added i to d\\n\\t Append nums[d[0]] = 5 to out\\ni = 5, curr element = 3, d = deque([4]) and out = [8, 3, 5]\\n\\t Added i to d\\n\\t Append nums[d[0]] = 5 to out\\ni = 6, curr element = 6, d = deque([4, 5]) and out = [8, 3, 5, 5]\\n\\t Popped from d because d has elements and nums[d.top] < curr element\\n\\t Popped from d because d has elements and nums[d.top] < curr element\\n\\t Added i to d\\n\\t Append nums[d[0]] = 6 to out\\ni = 7, curr element = 7, d = deque([6]) and out = [8, 3, 5, 5, 6]\\n\\t Popped from d because d has elements and nums[d.top] < curr element\\n\\t Added i to d\\n\\t Append nums[d[0]] = 7 to out\\n[8, 3, 5, 5, 6, 7]\\n</pre>\\n\\n\\n**BONUS** Trying to be a strong Java Developer ? Checkout this [awesome hands-on series](https://abhinandandubey.github.io/posts/tags/Advanced-Java-Series) with illustrations!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport collections\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        d = collections.deque()\\n        out = []\\n        for i, n in enumerate(nums):\\n            print(\"i = {}, curr element = {}, d = {} and out = {}\".format(i, n, d, out))\\n            while d and nums[d[-1]] < n:\\n                d.pop()\\n                print(\"\\\\t Popped from d because d has elements and nums[d.top] < curr element\")\\n            d.append(i)\\n            print(\"\\\\t Added i to d\")\\n            if d[0] == i - k:\\n                d.popleft()\\n                print(\"\\\\t Popped left from d because it\\'s outside the window\\'s leftmost (i-k)\")\\n            if i>=k-1:\\n                out.append(nums[d[0]])\\n\\t\\t\\t\\tprint(\"\\\\t Append nums[d[0]] = {} to out\".format(nums[d[0]]))\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951683,
                "title": "python-decreasing-deque-short-explained",
                "content": "There are a big variety of different algorithms for this problem. The most difficult, but most efficient uses idea of decreasing deque: on each moment of time we will keep only decreasing numbers in it. Let us consider the following example: `nums = [1,3,-1,-3,5,3,6,7], k = 3`. Let us process numbers one by one: (I will print numbers, however we will keep **indexes** in our stack):\\n\\n1. We put `1` into emtpy deque: `[1]`.\\n2. New element is bigger, than previous, so we remove previous element and put new one:  `[3]`.\\n3. Next element is smaller than previous, put it to the end of deque: `[3, -1]`.\\n4. Similar to previous step: `[3, -1, -3]`.\\n5. Now, let us look at the first element `3`, it has index **1** in our data, what does it mean? It was to far ago, and we need to delete it: so we `popleft` it. So, now we have `[-1, -3]`. Then we check that new element is bigger than the top of our deque, so we remove two elements and have `[5]` in the end.\\n6. New element is smaller than previous, just add it to the end: `[5, 3]`.\\n7. New element is bigger, remove elements from end, until we can put it: `[6]`.\\n8. New element is bigger, remove elements from end, until we can put it: `[7]`.\\n\\nSo, once again we have the following rules:\\n1. Elements in deque are always in decreasing order.\\n2. They are always elements from last sliding window of `k` elements.\\n3. It follows from here, that biggest element in current sliding window will be the `0`-th element in it.\\n\\n**Complexity**: time complexity is `O(n)`, because we iterate over our elements and for each element it can be put inside and outside of our deque only once. Space complexity is `O(k)`, the maximum size of our deque.\\n\\n\\n```\\nclass Solution:\\n    def maxSlidingWindow(self, nums, k):\\n        deq, n, ans = deque([0]), len(nums), []\\n\\n        for i in range (n):\\n            while deq and deq[0] <= i - k:\\n                deq.popleft()\\n            while deq and nums[i] >= nums[deq[-1]] :\\n                deq.pop()\\n            deq.append(i)\\n            \\n            ans.append(nums[deq[0]])\\n            \\n        return ans[k-1:]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums, k):\\n        deq, n, ans = deque([0]), len(nums), []\\n\\n        for i in range (n):\\n            while deq and deq[0] <= i - k:\\n                deq.popleft()\\n            while deq and nums[i] >= nums[deq[-1]] :\\n                deq.pop()\\n            deq.append(i)\\n            \\n            ans.append(nums[deq[0]])\\n            \\n        return ans[k-1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 111560,
                "title": "python-o-n-solution-using-deque-with-comments",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n# Checking for base case\\n        if not nums:\\n            return []\\n        if k == 0:\\n            return nums\\n# Defining Deque and result list\\n        deq = deque()\\n        result = []\\n        \\n# First traversing through K in the nums and only adding maximum value's index to the deque.\\n# Note: We are olny storing the index and not the value.\\n# Now, Comparing the new value in the nums with the last index value from deque,\\n# and if new valus is less, we don't need it\\n\\n        for i in range(k):\\n            while len(deq) != 0:\\n                if nums[i] > nums[deq[-1]]:\\n                    deq.pop()\\n                else:\\n                    break\\n\\n            deq.append(i)\\n            \\n# Here we will have deque with index of maximum element for the first subsequence of length k.\\n\\t\\n# Now we will traverse from k to the end of array and do 4 things\\n# 1. Appending left most indexed value to the result\\n# 2. Checking if left most is still in the range of k (so it only allows valid sub sequence)\\n# 3. Checking if right most indexed element in deque is less than the new element found, if yes we will remove it\\n# 4. Append i at the end of the deque  (Not: 3rd and 4th steps are similar to previous for loop)\\n \\n        for i in range(k, len(nums)):\\n            result.append(nums[deq[0]])\\n            \\n            if deq[0] < i - k + 1:\\n                deq.popleft()\\n            \\n            while len(deq) != 0:\\n                if nums[i] > nums[deq[-1]]:\\n                    deq.pop()\\n                else:\\n                    break\\n            \\n            deq.append(i)\\n        \\n#Adding the maximum for last subsequence\\n        result.append(nums[deq[0]])\\n        \\n        return result\\n````",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n# Checking for base case\\n        if not nums:\\n            return []\\n        if k == 0:\\n            return nums\\n# Defining Deque and result list\\n        deq = deque()\\n        result = []\\n        \\n# First traversing through K in the nums and only adding maximum value's index to the deque.\\n# Note: We are olny storing the index and not the value.\\n# Now, Comparing the new value in the nums with the last index value from deque,\\n# and if new valus is less, we don't need it\\n\\n        for i in range(k):\\n            while len(deq) != 0:\\n                if nums[i] > nums[deq[-1]]:\\n                    deq.pop()\\n                else:\\n                    break\\n\\n            deq.append(i)\\n            \\n# Here we will have deque with index of maximum element for the first subsequence of length k.\\n\\t\\n# Now we will traverse from k to the end of array and do 4 things\\n# 1. Appending left most indexed value to the result\\n# 2. Checking if left most is still in the range of k (so it only allows valid sub sequence)\\n# 3. Checking if right most indexed element in deque is less than the new element found, if yes we will remove it\\n# 4. Append i at the end of the deque  (Not: 3rd and 4th steps are similar to previous for loop)\\n \\n        for i in range(k, len(nums)):\\n            result.append(nums[deq[0]])\\n            \\n            if deq[0] < i - k + 1:\\n                deq.popleft()\\n            \\n            while len(deq) != 0:\\n                if nums[i] > nums[deq[-1]]:\\n                    deq.pop()\\n                else:\\n                    break\\n            \\n            deq.append(i)\\n        \\n#Adding the maximum for last subsequence\\n        result.append(nums[deq[0]])\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951894,
                "title": "c-easy-dp-o-n-explained-no-deque-required-d",
                "content": "Like many of us, I too had a hard time time understanding the deque approach. But fortunately, there is another great solution to this problem that runs in linear time.\\n\\n**Algorithm**:\\n\\n1. N is number of elements in an array and K is window size. So, Window number = N-K+1\\n2. Now divide array into blocks of K starting from index 1.\\nHere divide into blocks of size K=3. For your sample input:\\n\\n    NUMS : 1, 3, -1, | -3, 5, 3, | 6, 7 \\n\\n3. We have divided into blocks because we will calculate maximum in 2 ways A.) by traversing from left to right B.) by traversing from right to left. \\n4. Firstly, Traversing from Left to Right. For each element ai in block we will find maximum till that element ai starting from START of Block to END of that block. So here,\\n\\n    NUMS : 1, 3, -1, | -3, 5, 3, | 6, 7 \\nLFT     : 1, 3, 3,  | -3, 5, 5, | 6, 7\\n\\n5. Secondly, traversing from Right to Left. For each element \\'ai\\' in block we will find maximum till that element \\'ai\\' starting from END of Block to START of that block. So Here,\\n\\n\\tNUMS : 1, 3, -1, | -3, 5, 3, | 6, 7 \\nRGT    : 3, 3, -1, | 5, 5,  3, | 7, 7\\n\\n6. Now we have to find maximum for each subarray or window of size K. So, starting from index = 1 to index = N-K+1 .\\n\\n\\tNUMS : 1, 3, -1, | -3, 5, 3, | 6, 7 \\n\\tLFT    : 1, 3, 3,  | -3, 5, 5, | 6, 7\\n\\tRGT    : 3, 3, -1, | 5, 5,  3, | 7, 7\\n\\nmax_val[index] = max(Rgt[index], Lft[index+k-1]);\\n\\nSo Final Answer : 3, 3, 5, 5, 6, 7\\n\\nTime Complexity: O(n)\\n\\n**WHY DOES THIS WORK?**\\nWe have divided the blocks to have same size of window. If we consider \\'|\\' as the boundary, then at any given point of time the sliding window will have atleast one boundary(\\'|\\') of blocks in it. Consider below with K=7 - \\n\\n[ ...a, b, c, d | e, f, g... ]\\n\\nLft[index+k-1] - is the maximum of the element on the right of boundary.\\nRgt[index] - is the maximum of elements on the left of boundary.\\n\\nIf we take max(Lft[index+k-1], Rgt[index]), we will get max of all elements in the current window.\\n```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> maxSlidingWindow(vector<int> &nums, int k)\\n\\t\\t{\\n\\t\\t\\tint i, j, n = nums.size(), wins;\\n\\t\\t\\twins = n - k + 1;                        // # of windows\\n\\t\\t\\tvector<int> lft(n), rgt(n);            // to store above explained lft and rgt\\n\\n\\t\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlft[i] = nums[i];\\n\\t\\t\\t\\t // If it start of block, then that element is max so far in the block\\n\\t\\t\\t\\t // Else lft[i] is max so far in the block\\n\\t\\t\\t\\tif (i % k !=0) \\n\\t\\t\\t\\t\\tlft[i] = max(lft[i - 1], lft[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\trgt[n - 1] = nums[n - 1];\\n\\t\\t\\tfor (i = n - 2; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\trgt[i] = nums[i];\\n\\t\\t\\t\\t// same as for left, but now traversing from right\\n\\t\\t\\t\\tif (i % k != (k - 1))\\n\\t\\t\\t\\t\\trgt[i] = max(rgt[i], rgt[i + 1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> ans;\\n\\n\\t\\t\\tfor (i = 0; i < wins; i++)\\n\\t\\t\\t\\tans.push_back(max(rgt[i], lft[i + k - 1]));\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n```\\nFeel free to ask if anything is not clear.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tpublic:\\n\\t\\tvector<int> maxSlidingWindow(vector<int> &nums, int k)\\n\\t\\t{\\n\\t\\t\\tint i, j, n = nums.size(), wins;\\n\\t\\t\\twins = n - k + 1;                        // # of windows\\n\\t\\t\\tvector<int> lft(n), rgt(n);            // to store above explained lft and rgt\\n\\n\\t\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlft[i] = nums[i];\\n\\t\\t\\t\\t // If it start of block, then that element is max so far in the block\\n\\t\\t\\t\\t // Else lft[i] is max so far in the block\\n\\t\\t\\t\\tif (i % k !=0) \\n\\t\\t\\t\\t\\tlft[i] = max(lft[i - 1], lft[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\trgt[n - 1] = nums[n - 1];\\n\\t\\t\\tfor (i = n - 2; i >= 0; i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\trgt[i] = nums[i];\\n\\t\\t\\t\\t// same as for left, but now traversing from right\\n\\t\\t\\t\\tif (i % k != (k - 1))\\n\\t\\t\\t\\t\\trgt[i] = max(rgt[i], rgt[i + 1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> ans;\\n\\n\\t\\t\\tfor (i = 0; i < wins; i++)\\n\\t\\t\\t\\tans.push_back(max(rgt[i], lft[i + k - 1]));\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66026,
                "title": "important-to-talk-about-the-solution-brute-force-vs-deque-method-in-java",
                "content": "Perhaps most of the people here are practicing coding skills to land a job. It is fairly important to talk about your process of thought to the interviewer. You can't just jump in and give the best and most optimal solution though , because that seems like you have already seen the problems and memorized it thoroughly. Best approach is to give a brute force solution first, if interviewer asks for further optimization, then only you talk about using deque and other better solution. \\n\\nAlways start with brute-force method has a good advantage. Most of the time, in a 45 mins technical interview, the interviewer only prepares 1 - 2 coding questions and if you finish too early, they will probably start asking about other trivia questions or knowledge-based questions, which will put you in a disadvantageous position if you are a person who is not very good at talking. So starting with brute force (even though the question is listed as hard problem, but it isn't that hard to solve after all) , then get to optimal part, and bam! You nail a 45 mins technical interview with flying colors !\\n\\nAnyway, here is the brute force approach:\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums == null || k <= 0) return new int [0];\\n        int [] arr = new int[nums.length - k + 1];\\n        for(int i = 0; i < nums.length - k + 1; i++){\\n            int max = Integer.MIN_VALUE;\\n            for(int j = i; j < i + k; j++)\\n               max = Math.max(max, nums[j]);\\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n\\nUsing deque :\\n\\nThe idea is to use deque to hold the index of maximum element and restrict deque size to k. In first while loop, we make sure that we remove the elements which are not longer in the sliding k range. In second loop is we make sure that the elements in the deque is not smaller than the current element. Then we add the element to the deque. \\n\\nThe `if(i >= k - 1)` is just to skip the first few elements that is less than k. For example, if `k = 3`, then we don't want the first two elements added to the array. Also notice that our array is `arr = new int[nums.length - k + 1]` , as for the fact that when we have k as the size of sliding windows, then the end result of sliding windows array will be `nums.length - k + 1`.\\n\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums == null || k <= 0) return new int [0];\\n        int [] arr = new int[nums.length - k + 1];\\n        int in = 0;\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        for(int i = 0; i < nums.length; i++){\\n            while(!dq.isEmpty() && dq.peek() < i - k + 1) dq.poll();\\n            while(!dq.isEmpty() && nums[dq.peekLast()] < nums[i]) dq.pollLast();\\n            dq.offer(i);\\n            if(i >= k - 1) arr[in++] = nums[dq.peek()];\\n        }\\n        return arr;\\n    }",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "Perhaps most of the people here are practicing coding skills to land a job. It is fairly important to talk about your process of thought to the interviewer. You can't just jump in and give the best and most optimal solution though , because that seems like you have already seen the problems and memorized it thoroughly. Best approach is to give a brute force solution first, if interviewer asks for further optimization, then only you talk about using deque and other better solution. \\n\\nAlways start with brute-force method has a good advantage. Most of the time, in a 45 mins technical interview, the interviewer only prepares 1 - 2 coding questions and if you finish too early, they will probably start asking about other trivia questions or knowledge-based questions, which will put you in a disadvantageous position if you are a person who is not very good at talking. So starting with brute force (even though the question is listed as hard problem, but it isn't that hard to solve after all) , then get to optimal part, and bam! You nail a 45 mins technical interview with flying colors !\\n\\nAnyway, here is the brute force approach:\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums == null || k <= 0) return new int [0];\\n        int [] arr = new int[nums.length - k + 1];\\n        for(int i = 0; i < nums.length - k + 1; i++){\\n            int max = Integer.MIN_VALUE;\\n            for(int j = i; j < i + k; j++)\\n               max = Math.max(max, nums[j]);\\n            arr[i] = max;\\n        }\\n        return arr;\\n    }\\n\\nUsing deque :\\n\\nThe idea is to use deque to hold the index of maximum element and restrict deque size to k. In first while loop, we make sure that we remove the elements which are not longer in the sliding k range. In second loop is we make sure that the elements in the deque is not smaller than the current element. Then we add the element to the deque. \\n\\nThe `if(i >= k - 1)` is just to skip the first few elements that is less than k. For example, if `k = 3`, then we don't want the first two elements added to the array. Also notice that our array is `arr = new int[nums.length - k + 1]` , as for the fact that when we have k as the size of sliding windows, then the end result of sliding windows array will be `nums.length - k + 1`.\\n\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums == null || k <= 0) return new int [0];\\n        int [] arr = new int[nums.length - k + 1];\\n        int in = 0;\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        for(int i = 0; i < nums.length; i++){\\n            while(!dq.isEmpty() && dq.peek() < i - k + 1) dq.poll();\\n            while(!dq.isEmpty() && nums[dq.peekLast()] < nums[i]) dq.pollLast();\\n            dq.offer(i);\\n            if(i >= k - 1) arr[in++] = nums[dq.peek()];\\n        }\\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65956,
                "title": "my-c-o-n-deque-based-solution-with-explanation",
                "content": "The basic idea is to use a deque (buffer) to save all currently potential \"maximum\" elements (i.e. the element in the current k-element window [i-k+1, i], and it is larger than the elements after  itself). So for each i, we first pop up the elements  that are no larger than nums[i] from buffer until we find one that is larger than nums[i] or the buffer is empty since those elements will be covered by nums[i] and can not be a maximum of any k-element window. Then we put nums[i] in the buffer. If i>=k-1, we need to ouput the maximum for window [i-k+1, i], which is the front element of buffer. At last, we will check if the front element is nums[i-k+1], if so, we have to pop it up since it will be out of the window [i-k+2, i+1] in the next iteration. Since all the elements will be pushed into/ popped out of the buffer only once, so the time complexity is O(N).\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            deque<int> buffer;\\n            vector<int> res;\\n    \\n            for(auto i=0; i<nums.size();++i)\\n            {\\n                while(!buffer.empty() && nums[i]>=nums[buffer.back()]) buffer.pop_back();\\n                buffer.push_back(i);\\n    \\n                if(i>=k-1) res.push_back(nums[buffer.front()]);\\n                if(buffer.front()<= i-k + 1) buffer.pop_front();\\n            }\\n            return res;\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            deque<int> buffer;\\n            vector<int> res;\\n    \\n            for(auto i=0; i<nums.size();++i)\\n            {\\n                while(!buffer.empty() && nums[i]>=nums[buffer.back()]) buffer.pop_back();\\n                buffer.push_back(i);\\n    \\n                if(i>=k-1) res.push_back(nums[buffer.front()]);\\n                if(buffer.front()<= i-k + 1) buffer.pop_front();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65999,
                "title": "3-c-solutions",
                "content": "    1. O(NlogK)\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> result;\\n        if (k == 0) return result;\\n        multiset<int> w;\\n        for (int i = 0, n = (int)nums.size(); i < n; i++) {\\n            if (i >= k)\\n                w.erase(w.find(nums[i-k]));\\n            w.insert(nums[i]);\\n            if (i >= k-1)\\n                result.push_back(*w.rbegin());\\n        }\\n        return result;\\n    }\\n    \\n    2. O(NlogN)\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> result;\\n        if (k == 0) return result;\\n        priority_queue<pair<int, int>> w;\\n        for (int i = 0, n = (int)nums.size(); i < n; i++) {\\n            while (!w.empty() && w.top().second <= i-k)\\n                w.pop();\\n            w.push(make_pair(nums[i],i));\\n            if (i >= k-1)\\n                result.push_back(w.top().first);\\n        }\\n        return result;\\n    }\\n    \\n    3. O(N)\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> result;\\n        if (k == 0) return result;\\n        deque<int> w;\\n        for (int i = 0, n = (int)nums.size(); i < n; i++) {\\n            while (!w.empty() && w.front() <= i-k)\\n                w.pop_front();\\n            while (!w.empty() && nums[w.back()] <= nums[i])\\n                w.pop_back();\\n            w.push_back(i);\\n            if (i >= k-1)\\n                result.push_back(nums[w.front()]);\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    1. O(NlogK)\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> result;\\n        if (k == 0) return result;\\n        multiset<int> w;\\n        for (int i = 0, n = (int)nums.size(); i < n; i++) {\\n            if (i >= k)\\n                w.erase(w.find(nums[i-k]));\\n            w.insert(nums[i]);\\n            if (i >= k-1)\\n                result.push_back(*w.rbegin());\\n        }\\n        return result;\\n    }\\n    \\n    2. O(NlogN)\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> result;\\n        if (k == 0) return result;\\n        priority_queue<pair<int, int>> w;\\n        for (int i = 0, n = (int)nums.size(); i < n; i++) {\\n            while (!w.empty() && w.top().second <= i-k)\\n                w.pop();\\n            w.push(make_pair(nums[i],i));\\n            if (i >= k-1)\\n                result.push_back(w.top().first);\\n        }\\n        return result;\\n    }\\n    \\n    3. O(N)\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> result;\\n        if (k == 0) return result;\\n        deque<int> w;\\n        for (int i = 0, n = (int)nums.size(); i < n; i++) {\\n            while (!w.empty() && w.front() <= i-k)\\n                w.pop_front();\\n            while (!w.empty() && nums[w.back()] <= nums[i])\\n                w.pop_back();\\n            w.push_back(i);\\n            if (i >= k-1)\\n                result.push_back(nums[w.front()]);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 598751,
                "title": "java-python-maxheap-bst-decreasing-deque-solutions-clean-code",
                "content": "**\\u2714\\uFE0F Solution 1: MaxHeap**\\n```java\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] arr, int k) {\\n        int n = arr.length, j = 0;\\n        int[] ans = new int[n - k + 1];\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        for (int i = 0; i < n; i++) {\\n            maxHeap.add(new int[]{arr[i], i});\\n            if (i + 1 >= k) {\\n                ans[j++] = maxHeap.peek()[0];\\n            }\\n            while (maxHeap.size() > 0 && i - maxHeap.peek()[1] + 1 >= k) { // discard max elements of heap that out of range k\\n                maxHeap.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(NlogN)`, each operation of maxHeap of size N costs `O(logN)`\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Binary Search Tree - TreeMap**\\n```java\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] arr, int k) {\\n        int n = arr.length, j = 0;\\n        int[] ans = new int[n - k + 1];\\n        TreeMap<Integer, Integer> bst = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            bst.put(arr[i], bst.getOrDefault(arr[i], 0) + 1);\\n            if (i + 1 >= k) {\\n                ans[j++] = bst.lastKey(); // return max element in BST\\n                removeElement(bst, arr[i+1-k]);\\n            }\\n        }\\n        return ans;\\n    }\\n    void removeElement(TreeMap<Integer, Integer> bst, int x) {\\n        bst.put(x, bst.getOrDefault(x, 0) - 1);\\n        if (bst.get(x) == 0) bst.remove(x);\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(NlogK)`, each operation of BST of size K costs `O(logK)`\\n- Space: `O(K)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Decreasing Deque**\\n<iframe src=\"https://leetcode.com/playground/WAz8LdrK/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(K)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] arr, int k) {\\n        int n = arr.length, j = 0;\\n        int[] ans = new int[n - k + 1];\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        for (int i = 0; i < n; i++) {\\n            maxHeap.add(new int[]{arr[i], i});\\n            if (i + 1 >= k) {\\n                ans[j++] = maxHeap.peek()[0];\\n            }\\n            while (maxHeap.size() > 0 && i - maxHeap.peek()[1] + 1 >= k) { // discard max elements of heap that out of range k\\n                maxHeap.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] arr, int k) {\\n        int n = arr.length, j = 0;\\n        int[] ans = new int[n - k + 1];\\n        TreeMap<Integer, Integer> bst = new TreeMap<>();\\n        for (int i = 0; i < n; i++) {\\n            bst.put(arr[i], bst.getOrDefault(arr[i], 0) + 1);\\n            if (i + 1 >= k) {\\n                ans[j++] = bst.lastKey(); // return max element in BST\\n                removeElement(bst, arr[i+1-k]);\\n            }\\n        }\\n        return ans;\\n    }\\n    void removeElement(TreeMap<Integer, Integer> bst, int x) {\\n        bst.put(x, bst.getOrDefault(x, 0) - 1);\\n        if (bst.get(x) == 0) bst.remove(x);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782320,
                "title": "c-deque-solution-explained",
                "content": "The solution is quite easy if you understand monotonic queue. Monotonic queue maintains our queue in increasing or decreasing order. Deque data structure gives us the best way to implement them.\\nAs we want the max value, we need to maintain our queue in such a way such that we can get the maximum value in O(1).\\nEg. the given order is 5 4 3 6 7. The queue in each step will be:\\n1) 5\\n2) 5 4\\n3) 5 4 3\\nNow 6 is >3 so pop_back till we get a number greater than 6. In this case whole of the queue gets popped.\\n4) 6\\n5) 7\\n\\nNow as we want our window to be of a particular size k, whenever the difference in current index and the top element\\'s index is >=k , remove that element from the front.\\nComment for any doubt.\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector <int> ans;\\n        int n=nums.size();\\n        deque <int> q; //only indexes are stored\\n        for(int i=0;i<n;i++)\\n        {   \\n            while(!q.empty() && i-q.front()>=k)\\n                q.pop_front(); //only window size of k is allowed\\n            while(!q.empty() && nums[q.back()]<nums[i])\\n                q.pop_back();\\n            q.push_back(i);\\n            if(i>=k-1)ans.push_back(nums[q.front()]); //our max value in O(1)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector <int> ans;\\n        int n=nums.size();\\n        deque <int> q; //only indexes are stored\\n        for(int i=0;i<n;i++)\\n        {   \\n            while(!q.empty() && i-q.front()>=k)\\n                q.pop_front(); //only window size of k is allowed\\n            while(!q.empty() && nums[q.back()]<nums[i])\\n                q.pop_back();\\n            q.push_back(i);\\n            if(i>=k-1)ans.push_back(nums[q.front()]); //our max value in O(1)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135919,
                "title": "clean-javascript-solution-using-monotonic-queue",
                "content": "**Monotonic queue**\\n\\n**Complexity**\\ntime O(n)\\nspace O(k)\\n\\n**Idea**\\nUsing monotonic queue to push an element in the queue will pop all elements smaller than it.\\n\\n**Example**\\n```\\n# nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3\\n#\\n# i  Window position             Monotonic queue  max\\n# 0                              [1]              -\\n# 1                              [3]              -\\n# 2  [1  3  -1] -3  5  3  6  7   [3, -1]          3\\n# 3   1 [3  -1  -3] 5  3  6  7   [3, -1, -3]      3\\n# 4   1  3 [-1  -3  5] 3  6  7   [5]              5\\n# 5   1  3  -1 [-3  5  3] 6  7   [5, 3]           5\\n# 6   1  3  -1  -3 [5  3  6] 7   [6]              6\\n# 7   1  3  -1  -3  5 [3  6  7]  [7]              7\\n\\n# nums = [1, 3, -1, 8, 5, 3, 6, 7], k = 3\\n#\\n# i  Window position            Monotonic queue  max\\n# 0                             [1]              -\\n# 1                             [3]              -\\n# 2  [1  3  -1] 8  5  3  6  7   [3, -1]          3\\n# 3   1 [3  -1  8] 5  3  6  7   [8]              8\\n# 4   1  3 [-1  8  5] 3  6  7   [8, 5]           5\\n# 5   1  3  -1 [8  5  3] 6  7   [8, 5, 3]        5\\n# 6   1  3  -1  8 [5  3  6] 7   [6]              6\\n# 7   1  3  -1  8  5 [3  6  7]  [7]              7\\n```\\n\\n```js\\nconst maxSlidingWindow = (nums, k) => {\\n  const res = [];\\n  const q = [];\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    while (q.length - 1 >= 0 && nums[i] > q[q.length - 1]) q.pop();\\n    q.push(nums[i]);\\n\\n    // When i + 1 - k >= 0, the window is fully overlapping nums\\n    const j = i + 1 - k;\\n    if (j >= 0) {\\n      res.push(q[0]);\\n      if (nums[j] === q[0]) q.shift(); // If the biggest element in q is about to exit window, remove it from q\\n    }\\n  }\\n  return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\n# nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3\\n#\\n# i  Window position             Monotonic queue  max\\n# 0                              [1]              -\\n# 1                              [3]              -\\n# 2  [1  3  -1] -3  5  3  6  7   [3, -1]          3\\n# 3   1 [3  -1  -3] 5  3  6  7   [3, -1, -3]      3\\n# 4   1  3 [-1  -3  5] 3  6  7   [5]              5\\n# 5   1  3  -1 [-3  5  3] 6  7   [5, 3]           5\\n# 6   1  3  -1  -3 [5  3  6] 7   [6]              6\\n# 7   1  3  -1  -3  5 [3  6  7]  [7]              7\\n\\n# nums = [1, 3, -1, 8, 5, 3, 6, 7], k = 3\\n#\\n# i  Window position            Monotonic queue  max\\n# 0                             [1]              -\\n# 1                             [3]              -\\n# 2  [1  3  -1] 8  5  3  6  7   [3, -1]          3\\n# 3   1 [3  -1  8] 5  3  6  7   [8]              8\\n# 4   1  3 [-1  8  5] 3  6  7   [8, 5]           5\\n# 5   1  3  -1 [8  5  3] 6  7   [8, 5, 3]        5\\n# 6   1  3  -1  8 [5  3  6] 7   [6]              6\\n# 7   1  3  -1  8  5 [3  6  7]  [7]              7\\n```\n```js\\nconst maxSlidingWindow = (nums, k) => {\\n  const res = [];\\n  const q = [];\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    while (q.length - 1 >= 0 && nums[i] > q[q.length - 1]) q.pop();\\n    q.push(nums[i]);\\n\\n    // When i + 1 - k >= 0, the window is fully overlapping nums\\n    const j = i + 1 - k;\\n    if (j >= 0) {\\n      res.push(q[0]);\\n      if (nums[j] === q[0]) q.shift(); // If the biggest element in q is about to exit window, remove it from q\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65936,
                "title": "my-java-solution-using-priorityqueue",
                "content": "Not a linear solution, instead, it is of O(nlogk) complexity, since add, pop and remove operation of PriorityQueue cost O(logk) time.\\n\\nWhat we need to do is just maintain a heap, that heap top gets the maximal value of the k elements.\\nSince we know which element is removed and which is added to the queue, the solution seems easy to understand.\\n\\n    public class Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int len = nums.length;\\n        int[] result = new int[len - k + 1];\\n        if(nums.length == 0) return new int[0];\\n        Queue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>(){\\n            @Override\\n            public int compare(Integer i1, Integer i2){\\n                return Integer.compare(i2, i1);\\n            }\\n        });\\n        \\n        for(int i = 0; i < k; i ++){\\n            queue.add(nums[i]);\\n        }\\n        result[0] = queue.peek();\\n        for(int i = k; i < len; i ++){\\n            queue.remove(nums[i - k]);\\n            queue.add(nums[i]);\\n            result[i - k + 1] = queue.peek();\\n        }\\n       \\n        return result;\\n    }\\n\\n\\nCould somebody suggest some linear solutions? The hint of using deque seems not that reasonable. We still need to maintain the k elements in the window in order.\\n\\nThank you\\n\\nUpdate: as some comments suggested, this algo does take O(nk) instead because of the remove operation actually takes O(k) instead of O(1) or O(logk).",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int len = nums.length;\\n        int[] result = new int[len - k + 1];\\n        if(nums.length == 0) return new int[0];\\n        Queue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>(){\\n            @Override\\n            public int compare(Integer i1, Integer i2){\\n                return Integer.compare(i2, i1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 170002,
                "title": "c-optimal-solution-using-dequeue",
                "content": "Sept. 13, 2018\\n239. Sliding Window Maximum\\n\\nIt is a hard level algorithm. I did write an optimal solution in August, 2015,  more than three years ago. I like to share my C# code here. \\nThis June 2018, I was asked to work on the algorithm but I did not come out the optimal solution using dequeue, where ascending numbers are kept only. \\n\\nIt is much better for me to constantly review what I have practiced and learn from my own experience. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _239_Sliding_window_maximum\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = MaxSlidingWindow(new int[] { 1, 3, -1, -3, 5, 3, 6, 7 }, 3);\\n        }\\n\\n        /// <summary>\\n        /// code was submitted by Jianmin Chen August 2015\\n        /// Time complexity: O(N), N is is the length of the array\\n        /// </summary>\\n        /// <param name=\"nums\"></param>\\n        /// <param name=\"k\"></param>\\n        /// <returns></returns>\\n        public static int[] MaxSlidingWindow(int[] nums, int k)\\n        {\\n\\n            if (k == 0) return nums;\\n\\n            int len = nums.Length;\\n            int maxArrayLen = len - k + 1;\\n            int[] ans = new int[maxArrayLen];\\n\\n            LinkedList<int> q = new LinkedList<int>();\\n\\n            // Queue stores indices of array, and \\n            // values are in decreasing order.\\n            // So, the first node in queue is the max in window\\n            for (int i = 0; i < len; i++)\\n            {\\n                // 1. remove element from head until first number within window\\n                if (q.Count > 0 && q.First.Value + k <= i)\\n                {\\n                    q.RemoveFirst();\\n                }\\n\\n                // 2. before inserting i into queue, remove from the tail of the\\n                // queue indices with smaller value they array[i]\\n                while (q.Count > 0 && nums[q.Last.Value] <= nums[i])\\n                {\\n                    q.RemoveLast();\\n                }\\n\\n                q.AddLast(i);\\n\\n                // 3. set the max value in the window (always the top number in\\n                // queue)\\n                int index = i + 1 - k;\\n                if (index >= 0)\\n                {\\n                    ans[index] = nums[q.First.Value];\\n                }\\n            }\\n\\n            return ans;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _239_Sliding_window_maximum\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = MaxSlidingWindow(new int[] { 1, 3, -1, -3, 5, 3, 6, 7 }, 3);\\n        }\\n\\n        /// <summary>\\n        /// code was submitted by Jianmin Chen August 2015\\n        /// Time complexity: O(N), N is is the length of the array\\n        /// </summary>\\n        /// <param name=\"nums\"></param>\\n        /// <param name=\"k\"></param>\\n        /// <returns></returns>\\n        public static int[] MaxSlidingWindow(int[] nums, int k)\\n        {\\n\\n            if (k == 0) return nums;\\n\\n            int len = nums.Length;\\n            int maxArrayLen = len - k + 1;\\n            int[] ans = new int[maxArrayLen];\\n\\n            LinkedList<int> q = new LinkedList<int>();\\n\\n            // Queue stores indices of array, and \\n            // values are in decreasing order.\\n            // So, the first node in queue is the max in window\\n            for (int i = 0; i < len; i++)\\n            {\\n                // 1. remove element from head until first number within window\\n                if (q.Count > 0 && q.First.Value + k <= i)\\n                {\\n                    q.RemoveFirst();\\n                }\\n\\n                // 2. before inserting i into queue, remove from the tail of the\\n                // queue indices with smaller value they array[i]\\n                while (q.Count > 0 && nums[q.Last.Value] <= nums[i])\\n                {\\n                    q.RemoveLast();\\n                }\\n\\n                q.AddLast(i);\\n\\n                // 3. set the max value in the window (always the top number in\\n                // queue)\\n                int index = i + 1 - k;\\n                if (index >= 0)\\n                {\\n                    ans[index] = nums[q.First.Value];\\n                }\\n            }\\n\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915621,
                "title": "c-using-priority-queue-vs-deque-vs-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1st solution uses priority_queue (max-heap) for pair (nums[i], i)!\\n2nd solution uses double-ended queue.\\n3rd solution uses just array and is what you have never seen before with very high probabilty.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution using priority_queue (max-heap) might not be very fast, but more intuitive.\\n\\nSecond approach uses double-ended queue storing index for max. It is fast with a linear time.\\n\\nIf the second approach is fully understood, Why not using the easier data structure? Not just double-ended queue. Third approach uses just an array storing index for max with a pointer named left. This solution is fast and run also in a linear time.\\n\\nConsider the concrete example\\n```\\n[1,3,1,2,0,5]\\n3\\n```\\nThe states for the max_idx[left:] in 3rd approach( or max_idx in 2nd approach)  and ans[i] within the loop are as follows:\\n```\\n[0]\\n[1]\\n[1,2]->ans[0]=3\\n[1,3]->ans[1]=3\\n[3,4]->ans[2]=2\\n[5]->ans[3]=5\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log(n))\\\\to O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\\\to O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\n    using int2=pair<int, int>; //(nums[i], i)\\npublic:\\n\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<int2> pq;\\n\\n        vector<int> ans(n-k+1);\\n        for (int i=0; i<k; i++)\\n            pq.push({nums[i], i});\\n        \\n        ans[0]=pq.top().first;\\n        for(int i=k; i<n; i++){\\n            while(!pq.empty() && pq.top().second<=(i-k))\\n                pq.pop(); //Pop up element not in the window\\n            pq.push({nums[i], i});\\n            ans[i-k+1]=pq.top().first;//Max element for this window\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code using Deque\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        deque<int> max_idx;//Double-ended queue storing index for max\\n        vector<int> ans(n-k+1);\\n\\n        for(int i=0; i<n; i++){\\n            while(!max_idx.empty() && nums[i]>=nums[max_idx.back()]) \\n                max_idx.pop_back();// pop back the indexes for smaller ones\\n            max_idx.push_back(i);  // push back the index for larger one\\n\\n            if (max_idx.front()==i-k) // index=i-k should not in the window\\n                max_idx.pop_front(); \\n            if (i>=k-1)\\n                ans[i-k+1]=nums[max_idx.front()]; //Max element for this window\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code using just array with a left pointer TC:O(n) SC:O(n)\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> max_idx;//array storing index for max\\n    int left=0;\\n    void print(){\\n        cout<<\"[\";\\n        for(int i=left; i<max_idx.size(); i++) \\n            cout<<max_idx[i]<<\",\";\\n        cout<<\"]\\\\n\";\\n    }\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        n=nums.size();       \\n        vector<int> ans(n-k+1);\\n\\n        for(int i=0; i<n; i++){\\n            // max_idx using elements from index=left on \\n            while(max_idx.size()>left && nums[i]>=nums[max_idx.back()]) \\n                max_idx.pop_back();// pop back the indexes for smaller ones\\n            max_idx.push_back(i);  // push back the index for larger one\\n\\n            if (max_idx[left]==i-k) // index=i-k should not in the window\\n                left++;  //move left\\n        //    cout<<left;\\n        //    print();\\n            if (i>=k-1){\\n                ans[i-k+1]=nums[max_idx[left]]; //Max element for this window\\n        //        cout<<\"->\"<<ans[i-k+1]<<endl;\\n            }        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n[1,3,1,2,0,5]\\n3\\n```\n```\\n[0]\\n[1]\\n[1,2]->ans[0]=3\\n[1,3]->ans[1]=3\\n[3,4]->ans[2]=2\\n[5]->ans[3]=5\\n```\n```\\nclass Solution {\\n    using int2=pair<int, int>; //(nums[i], i)\\npublic:\\n\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<int2> pq;\\n\\n        vector<int> ans(n-k+1);\\n        for (int i=0; i<k; i++)\\n            pq.push({nums[i], i});\\n        \\n        ans[0]=pq.top().first;\\n        for(int i=k; i<n; i++){\\n            while(!pq.empty() && pq.top().second<=(i-k))\\n                pq.pop(); //Pop up element not in the window\\n            pq.push({nums[i], i});\\n            ans[i-k+1]=pq.top().first;//Max element for this window\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        deque<int> max_idx;//Double-ended queue storing index for max\\n        vector<int> ans(n-k+1);\\n\\n        for(int i=0; i<n; i++){\\n            while(!max_idx.empty() && nums[i]>=nums[max_idx.back()]) \\n                max_idx.pop_back();// pop back the indexes for smaller ones\\n            max_idx.push_back(i);  // push back the index for larger one\\n\\n            if (max_idx.front()==i-k) // index=i-k should not in the window\\n                max_idx.pop_front(); \\n            if (i>=k-1)\\n                ans[i-k+1]=nums[max_idx.front()]; //Max element for this window\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> max_idx;//array storing index for max\\n    int left=0;\\n    void print(){\\n        cout<<\"[\";\\n        for(int i=left; i<max_idx.size(); i++) \\n            cout<<max_idx[i]<<\",\";\\n        cout<<\"]\\\\n\";\\n    }\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        n=nums.size();       \\n        vector<int> ans(n-k+1);\\n\\n        for(int i=0; i<n; i++){\\n            // max_idx using elements from index=left on \\n            while(max_idx.size()>left && nums[i]>=nums[max_idx.back()]) \\n                max_idx.pop_back();// pop back the indexes for smaller ones\\n            max_idx.push_back(i);  // push back the index for larger one\\n\\n            if (max_idx[left]==i-k) // index=i-k should not in the window\\n                left++;  //move left\\n        //    cout<<left;\\n        //    print();\\n            if (i>=k-1){\\n                ans[i-k+1]=nums[max_idx[left]]; //Max element for this window\\n        //        cout<<\"->\"<<ans[i-k+1]<<endl;\\n            }        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1301881,
                "title": "c-solution-priority-queue-with-explanation",
                "content": "## Using MaxHeap\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        \\n        // create a priority queue (Max Heap) of pair of int\\n        // first of the pair is the element of the array\\n        // and second is the index\\n        priority_queue<pair<int,int>> p;\\n        // create a vector to store the result\\n        vector<int>res;\\n        // add all the elements in the first window to the PQ\\n        for(int i = 0; i < k; i++)\\n            p.push({arr[i],i});\\n        // add the max element of first window to the res vector\\n        res.push_back(p.top().first);\\n        // start iteration from the second window\\n        for(int i = k; i < arr.size(); i++)\\n        {\\n            // add the element into the PQ\\n            p.push({arr[i],i});\\n            // remove all the elments which are not in the current window\\n            // current window is from [i-k+1 , i]\\n            while(!(p.top().second > i-k))\\n                p.pop();\\n            // add the max element in the PQ to the res\\n            res.push_back(p.top().first);\\n        }\\n        // return the result\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n\\n**Same logic... Just different more readable.**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        \\n     priority_queue<pair<int,int>> pq; // element -> index\\n    // vec to store the results\\n    vector<int> res;\\n    // left and right bound of our window\\n    int right = 0, left = 0;\\n\\n    // outer loop\\n    while(right < arr.size())\\n    {\\n        // add every element into the PQ\\n        pq.push({arr[right] , right});\\n        // window is not full... expand it\\n        if(right - left + 1 < k)\\n            right++;\\n        // window is full\\n        else if(right - left + 1 == k)\\n        {\\n            // remove the element not in the window from the PQ\\n            while(pq.top().second < left)\\n                pq.pop();\\n            // push the max elemnet from the window into the PQ\\n            res.push_back(pq.top().first);\\n            // slide the window\\n            left++; right++;\\n        }\\n    }\\n    return res;\\n    }\\n};\\n```\\n\\n### Complexity: \\nThe TC should be O(n*logK). Here is why-\\n\\nMax size of heap at any time is K.\\nWe are inserting every element in the heap once which will cost us O(n*logK)\\nThe inner loop is used to remove elements from the heap. So it will also run N times in total which will cost us O(n*logK)\\nHence total TC will be 2O(nlogK) == O(n*logk)\\n\\nAnd space complexity will be O(k) for maxheap.\\n\\n## Using Deque [Most Efficient]\\nIntuition behind this is very simple. In previous solution, we were pushing every element into the heap. Here we push only the elements which are candidate for becoming the answer.\\n```\\n// using deque\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        deque<int> dq;\\n        vector<int> res;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            // insert current element\\n\\t\\t\\t// insert current element only when the back of the deque is greater than cur\\n            int cur = arr[i];\\n            while(dq.empty() == false and arr[dq.back()] < cur)\\n                dq.pop_back();\\n            dq.push_back(i);\\n            \\n            // remove out of bound elements\\n            while(dq.empty() == false and dq.front() < i-k+1)\\n                dq.pop_front();\\n            \\n\\t\\t\\t// max element of the window will be the front of the deque\\n            if(i >= k-1)\\n                res.push_back(arr[dq.front()]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n### Complexity\\nHere we are pushing and poping every element into the deque only once. So the inner loops will have tc= O(n) amortized.\\nSo TC: O(n)\\nSC: O(k)",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        \\n        // create a priority queue (Max Heap) of pair of int\\n        // first of the pair is the element of the array\\n        // and second is the index\\n        priority_queue<pair<int,int>> p;\\n        // create a vector to store the result\\n        vector<int>res;\\n        // add all the elements in the first window to the PQ\\n        for(int i = 0; i < k; i++)\\n            p.push({arr[i],i});\\n        // add the max element of first window to the res vector\\n        res.push_back(p.top().first);\\n        // start iteration from the second window\\n        for(int i = k; i < arr.size(); i++)\\n        {\\n            // add the element into the PQ\\n            p.push({arr[i],i});\\n            // remove all the elments which are not in the current window\\n            // current window is from [i-k+1 , i]\\n            while(!(p.top().second > i-k))\\n                p.pop();\\n            // add the max element in the PQ to the res\\n            res.push_back(p.top().first);\\n        }\\n        // return the result\\n        return res;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        \\n     priority_queue<pair<int,int>> pq; // element -> index\\n    // vec to store the results\\n    vector<int> res;\\n    // left and right bound of our window\\n    int right = 0, left = 0;\\n\\n    // outer loop\\n    while(right < arr.size())\\n    {\\n        // add every element into the PQ\\n        pq.push({arr[right] , right});\\n        // window is not full... expand it\\n        if(right - left + 1 < k)\\n            right++;\\n        // window is full\\n        else if(right - left + 1 == k)\\n        {\\n            // remove the element not in the window from the PQ\\n            while(pq.top().second < left)\\n                pq.pop();\\n            // push the max elemnet from the window into the PQ\\n            res.push_back(pq.top().first);\\n            // slide the window\\n            left++; right++;\\n        }\\n    }\\n    return res;\\n    }\\n};\\n```\n```\\n// using deque\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        deque<int> dq;\\n        vector<int> res;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            // insert current element\\n\\t\\t\\t// insert current element only when the back of the deque is greater than cur\\n            int cur = arr[i];\\n            while(dq.empty() == false and arr[dq.back()] < cur)\\n                dq.pop_back();\\n            dq.push_back(i);\\n            \\n            // remove out of bound elements\\n            while(dq.empty() == false and dq.front() < i-k+1)\\n                dq.pop_front();\\n            \\n\\t\\t\\t// max element of the window will be the front of the deque\\n            if(i >= k-1)\\n                res.push_back(arr[dq.front()]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65957,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Sliding Window Maximum** https://leetcode.com/problems/sliding-window-maximum/\\n\\n**Brute Force**: O(n * k)\\n```\\nclass Solution(object):\\n    def get_max(self, nums, start, end):\\n        answer = -2**31\\n        for i in range(start, end+1):\\n            answer = max(answer, nums[i])\\n        return answer\\n    \\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start,end = 0,k-1\\n        result = []\\n        while end < len(nums) and len(nums):\\n            result.append(self.get_max(nums, start, end))\\n            start, end = start+1, end+1\\n        return result\\n```\\n\\n**Max Heap Solution**: O(NlogN)\\n* Add k elements and their indices to heap. Python has min-heap. So for max-heap, multiply by -1.\\n* Set start = 0 and end = k-1 as the current range.\\n* Extract the max from heap which is in range i.e. >= start. Add the max to the result list. Now add the max back to the heap - it could be relevant to other ranges.\\n* Move the range by 1. Add the new last number to heap.\\n* This is an O(NlgN) solution.\\n* Note that we need not invest into thinking about deleting the obsolete entry every time the window slides.That would be very hard to implement. Instead we maintain the index in heap and \"delete\" when the maximum number is out of bounds.\\n\\n```\\nimport heapq as h\\nclass Solution(object):\\n    def get_next_max(self, heap, start):\\n        while True:\\n            x,idx = h.heappop(heap)\\n            if idx >= start:\\n                return x*-1, idx\\n    \\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return []\\n        heap = []\\n        for i in range(k):\\n            h.heappush(heap, (nums[i]*-1, i))\\n        result, start, end = [], 0, k-1\\n        while end < len(nums):\\n            x, idx = self.get_next_max(heap, start)\\n            result.append(x)\\n            h.heappush(heap, (x*-1, idx)) \\n            start, end = start + 1, end + 1\\n            if end < len(nums):\\n                h.heappush(heap, (nums[end]*-1, end))\\n        return result\\n```\\n\\n**Solution Using Dequeue**: O(N)\\n* Very similar code structure to heap solution\\n* http://yuanhsh.iteye.com/blog/2190852\\n* https://docs.python.org/2/library/collections.html#collections.deque\\n* Add to dequeue at tail using the rule where you pop all numbers from tail which are less than equal to the number. Think why? 300->50->27 and say 100 comes. 50 and/or 27 can never be the maximum in any range.\\n* When you do the above, the largest number is at head. But you still need to test if front is within the range or not.\\n* Pop or push each element at-max once. O(N)\\n\\n*So, to maintain the queue in order,\\n* When moves to a new number, iterate through back of the queue, removes all numbers that are not greater than the new one, and then insert the new one to the back.\\n* findMax only need to take the first one of the queue.\\n* To remove a number outside the window, only compare whether the current index is greater than the front of queue. If so, remove it.*\\n\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def add_to_dq(self, dq, nums, i):\\n        while len(dq) and nums[dq[-1]] <= nums[i]:\\n            dq.pop()\\n        dq.append(i)\\n        return\\n\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return []\\n        dq = deque()\\n        for i in range(k):\\n            self.add_to_dq(dq, nums, i)\\n        result, start, end = [], 0, k-1\\n        while end < len(nums):\\n            while True:\\n                if dq[0] >= start:\\n                    result.append(nums[dq[0]])\\n                    break\\n                else:\\n                    dq.popleft()\\n            start, end = start+1,end+1\\n            if end < len(nums):\\n                self.add_to_dq(dq, nums, end)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def get_max(self, nums, start, end):\\n        answer = -2**31\\n        for i in range(start, end+1):\\n            answer = max(answer, nums[i])\\n        return answer\\n    \\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        start,end = 0,k-1\\n        result = []\\n        while end < len(nums) and len(nums):\\n            result.append(self.get_max(nums, start, end))\\n            start, end = start+1, end+1\\n        return result\\n```\n```\\nimport heapq as h\\nclass Solution(object):\\n    def get_next_max(self, heap, start):\\n        while True:\\n            x,idx = h.heappop(heap)\\n            if idx >= start:\\n                return x*-1, idx\\n    \\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return []\\n        heap = []\\n        for i in range(k):\\n            h.heappush(heap, (nums[i]*-1, i))\\n        result, start, end = [], 0, k-1\\n        while end < len(nums):\\n            x, idx = self.get_next_max(heap, start)\\n            result.append(x)\\n            h.heappush(heap, (x*-1, idx)) \\n            start, end = start + 1, end + 1\\n            if end < len(nums):\\n                h.heappush(heap, (nums[end]*-1, end))\\n        return result\\n```\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def add_to_dq(self, dq, nums, i):\\n        while len(dq) and nums[dq[-1]] <= nums[i]:\\n            dq.pop()\\n        dq.append(i)\\n        return\\n\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return []\\n        dq = deque()\\n        for i in range(k):\\n            self.add_to_dq(dq, nums, i)\\n        result, start, end = [], 0, k-1\\n        while end < len(nums):\\n            while True:\\n                if dq[0] >= start:\\n                    result.append(nums[dq[0]])\\n                    break\\n                else:\\n                    dq.popleft()\\n            start, end = start+1,end+1\\n            if end < len(nums):\\n                self.add_to_dq(dq, nums, end)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506048,
                "title": "java-tc-o-n-sc-o-k-using-deque-as-sliding-window",
                "content": "```java\\n/**\\n * Using Deque as Sliding Window\\n *\\n * Time Complexity: O(N). Each number is added once to the queue and then\\n * removed once from the queue\\n *\\n * Space Complexity: O(K) -> Excluding the space taken by result array.\\n *\\n * N = Length of input array. K = Window size.\\n */\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if (nums == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n        int len = nums.length;\\n        if (len == 0 || k == 1) {\\n            return Arrays.copyOf(nums, len);\\n        }\\n        if (len <= k) {\\n            return new int[] { getMaxVal(nums) };\\n        }\\n\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        int[] result = new int[len - k + 1];\\n\\n        for (int i = 0; i < len; i++) {\\n            if (!deque.isEmpty() && deque.peekFirst() == i - k) {\\n                deque.pollFirst();\\n            }\\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\\n                deque.pollLast();\\n            }\\n            deque.offerLast(i);\\n\\n            if (i >= k - 1) {\\n                result[i - k + 1] = nums[deque.peekFirst()];\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private int getMaxVal(int[] nums) {\\n        int max = nums[0];\\n        for (int n : nums) {\\n            max = Math.max(max, n);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Sliding Window questions on LeetCode:\\n- [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/1496754/Java-or-TC:-O(S+T)-or-SC:-O(T)-or-Space-optimized-Sliding-Window-using-Two-Pointers)\\n- [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1496838/Java-or-TC:-O(N)-or-SC:-O(K)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1496840/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/1500039/Java-or-TC:-O(S+P)-or-SC:-O(1)-or-Sliding-window-solution)\\n- [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1500874/Java-or-TC:-O(N)-or-SC:-O(1)-or-Sliding-Window-using-HashMap-and-Two-Pointers)\\n- [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/1500877/Java-or-Both-O(N)-and-O(N-logN)-solutions-with-O(1)-space-or-Sliding-Window-and-Binary-Search-solutions)\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n- [220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/discuss/1500895/Java-or-TC:-O(N)-or-SC:-O(min(NK))-or-Sliding-Window-using-Buckets)\\n- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/discuss/1500902/Java-or-TC:-O(S2)-or-SC:-O(1)-or-Constant-space-Sliding-Window-solution)\\n- [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/discuss/1507981/Java-or-TC:-O(N*logK)-or-SC:-(K)-or-Optimized-sliding-window-using-TreeSet)\\n- [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1508045/Java-or-TC:-O(N)-or-SC:-O(1)-or-Four-solutions-with-Follow-up-handled)\\n- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1508044/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Optimized-Sliding-Window)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```java\\n/**\\n * Using Deque as Sliding Window\\n *\\n * Time Complexity: O(N). Each number is added once to the queue and then\\n * removed once from the queue\\n *\\n * Space Complexity: O(K) -> Excluding the space taken by result array.\\n *\\n * N = Length of input array. K = Window size.\\n */\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if (nums == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n        int len = nums.length;\\n        if (len == 0 || k == 1) {\\n            return Arrays.copyOf(nums, len);\\n        }\\n        if (len <= k) {\\n            return new int[] { getMaxVal(nums) };\\n        }\\n\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        int[] result = new int[len - k + 1];\\n\\n        for (int i = 0; i < len; i++) {\\n            if (!deque.isEmpty() && deque.peekFirst() == i - k) {\\n                deque.pollFirst();\\n            }\\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\\n                deque.pollLast();\\n            }\\n            deque.offerLast(i);\\n\\n            if (i >= k - 1) {\\n                result[i - k + 1] = nums[deque.peekFirst()];\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private int getMaxVal(int[] nums) {\\n        int max = nums[0];\\n        for (int n : nums) {\\n            max = Math.max(max, n);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918847,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nUsing two pointers\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 245 videos as of August 16th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/VYfy0VGa0_0\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings.\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. **Initialize Variables:**\\n   - Initialize an empty list `res` to store the result.\\n   - Initialize two pointers `left` and `right` to represent the sliding window.\\n   - Initialize an empty deque `q` to maintain indices of potentially maximum elements.\\n\\n2. **Sliding Window Loop:**\\n   - While the `right` pointer is within the range of `nums`:\\n     - Compare `nums[right]` with the elements at the back of the deque `q`.\\n       - If `q` is not empty and `nums[right]` is greater than `nums[q[-1]]`, remove the back element of `q` since it cannot be the maximum for the current window.\\n     - Append the current `right` index to the back of the deque `q`.\\n\\n3. **Adjust Left Pointer:**\\n   - If the index at the front of `q` (maximum element index) is less than the `left` pointer, remove the front element of `q` since it\\'s no longer relevant for the current window.\\n\\n4. **Calculate and Store Maximum Element:**\\n   - If the current window size is equal to or larger than `k`:\\n     - Append the maximum element of the current window (the element at index `q[0]`) to the `res` list.\\n\\n5. **Adjust Left Pointer and Move Right Pointer:**\\n   - Increment the `left` pointer by 1.\\n\\n6. **Move Right Pointer:**\\n   - Increment the `right` pointer by 1.\\n\\n7. **Return Result:**\\n   - Return the `res` list containing the maximum elements for each sliding window.\\n\\nHere\\'s the step-by-step breakdown of the algorithm for the given Python code. Each step explains the purpose and actions taken in that part of the code.\\n\\n# Complexity\\n- Time complexity: O(N)\\nN is the length of the input nums list. This is because both the left and right pointers traverse the nums list once, and each element is processed only once when added to or removed from the deque q.\\n\\n- Space complexity: O(K)\\nK is the size of the sliding window. The deque q can store at most K indices representing the maximum elements within the sliding window. The res list also requires O(K) space to store the maximum elements for each window.\\n\\n```python []\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n\\n        res = []\\n        left = right = 0\\n        q = deque()\\n\\n        while right < len(nums):\\n            while q and nums[right] > nums[q[-1]]:\\n                q.pop()\\n            q.append(right)\\n\\n            if left > q[0]:\\n                q.popleft()\\n            \\n            if right + 1 >= k:\\n                res.append(nums[q[0]])\\n                left += 1\\n            right += 1\\n        \\n        return res\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSlidingWindow = function(nums, k) {\\n    const res = [];\\n    let left = 0;\\n    let right = 0;\\n    const q = [];\\n\\n    while (right < nums.length) {\\n        while (q.length > 0 && nums[right] > nums[q[q.length - 1]]) {\\n            q.pop();\\n        }\\n        q.push(right);\\n\\n        if (left > q[0]) {\\n            q.shift();\\n        }\\n\\n        if (right + 1 >= k) {\\n            res.push(nums[q[0]]);\\n            left++;\\n        }\\n        right++;\\n    }\\n\\n    return res;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        List<Integer> res = new ArrayList<>();\\n        int left = 0;\\n        int right = 0;\\n        Deque<Integer> q = new ArrayDeque<>();\\n\\n        while (right < nums.length) {\\n            while (!q.isEmpty() && nums[right] > nums[q.peekLast()]) {\\n                q.pollLast();\\n            }\\n            q.offerLast(right);\\n\\n            if (left > q.peekFirst()) {\\n                q.pollFirst();\\n            }\\n\\n            if (right + 1 >= k) {\\n                res.add(nums[q.peekFirst()]);\\n                left++;\\n            }\\n            right++;\\n        }\\n\\n        return res.stream().mapToInt(Integer::intValue).toArray();        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res;\\n        int left = 0;\\n        int right = 0;\\n        deque<int> q;\\n\\n        while (right < nums.size()) {\\n            while (!q.empty() && nums[right] > nums[q.back()]) {\\n                q.pop_back();\\n            }\\n            q.push_back(right);\\n\\n            if (left > q.front()) {\\n                q.pop_front();\\n            }\\n\\n            if (right + 1 >= k) {\\n                res.push_back(nums[q.front()]);\\n                left++;\\n            }\\n            right++;\\n        }\\n\\n        return res;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n\\n        res = []\\n        left = right = 0\\n        q = deque()\\n\\n        while right < len(nums):\\n            while q and nums[right] > nums[q[-1]]:\\n                q.pop()\\n            q.append(right)\\n\\n            if left > q[0]:\\n                q.popleft()\\n            \\n            if right + 1 >= k:\\n                res.append(nums[q[0]])\\n                left += 1\\n            right += 1\\n        \\n        return res\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSlidingWindow = function(nums, k) {\\n    const res = [];\\n    let left = 0;\\n    let right = 0;\\n    const q = [];\\n\\n    while (right < nums.length) {\\n        while (q.length > 0 && nums[right] > nums[q[q.length - 1]]) {\\n            q.pop();\\n        }\\n        q.push(right);\\n\\n        if (left > q[0]) {\\n            q.shift();\\n        }\\n\\n        if (right + 1 >= k) {\\n            res.push(nums[q[0]]);\\n            left++;\\n        }\\n        right++;\\n    }\\n\\n    return res;    \\n};\\n```\n```java []\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        List<Integer> res = new ArrayList<>();\\n        int left = 0;\\n        int right = 0;\\n        Deque<Integer> q = new ArrayDeque<>();\\n\\n        while (right < nums.length) {\\n            while (!q.isEmpty() && nums[right] > nums[q.peekLast()]) {\\n                q.pollLast();\\n            }\\n            q.offerLast(right);\\n\\n            if (left > q.peekFirst()) {\\n                q.pollFirst();\\n            }\\n\\n            if (right + 1 >= k) {\\n                res.add(nums[q.peekFirst()]);\\n                left++;\\n            }\\n            right++;\\n        }\\n\\n        return res.stream().mapToInt(Integer::intValue).toArray();        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res;\\n        int left = 0;\\n        int right = 0;\\n        deque<int> q;\\n\\n        while (right < nums.size()) {\\n            while (!q.empty() && nums[right] > nums[q.back()]) {\\n                q.pop_back();\\n            }\\n            q.push_back(right);\\n\\n            if (left > q.front()) {\\n                q.pop_front();\\n            }\\n\\n            if (right + 1 >= k) {\\n                res.push_back(nums[q.front()]);\\n                left++;\\n            }\\n            right++;\\n        }\\n\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915830,
                "title": "python-java-c-simple-solution",
                "content": "# Video Solution \\n\\n# Search \\uD83D\\uDC49` Sliding Window Maximum By ErraK`\\n\\n# or \\n\\n# Click the Link in my Profile\\n\\n# An UPVOTE will be encouraging \\uD83D\\uDC4D\\n\\n```Python []\\nclass Solution:\\n    def maxSlidingWindow(self, nums, k):\\n        result = []\\n        window = deque()\\n\\n        for i, num in enumerate(nums):\\n            while window and window[0] < i - k + 1:\\n                window.popleft()\\n\\n            while window and nums[window[-1]] < num:\\n                window.pop()\\n\\n            window.append(i)\\n\\n            if i >= k - 1:\\n                result.append(nums[window[0]])\\n\\n        return result\\n\\n```\\n```Java []\\n\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n        Deque<Integer> window = new ArrayDeque<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            while (!window.isEmpty() && window.peekFirst() < i - k + 1) {\\n                window.pollFirst();\\n            }\\n\\n            while (!window.isEmpty() && nums[window.peekLast()] < nums[i]) {\\n                window.pollLast();\\n            }\\n\\n            window.offerLast(i);\\n\\n            if (i >= k - 1) {\\n                result[i - k + 1] = nums[window.peekFirst()];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> result;\\n        deque<int> window;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (!window.empty() && window.front() < i - k + 1) {\\n                window.pop_front();\\n            }\\n\\n            while (!window.empty() && nums[window.back()] < nums[i]) {\\n                window.pop_back();\\n            }\\n\\n            window.push_back(i);\\n\\n            if (i >= k - 1) {\\n                result.push_back(nums[window.front()]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```Python []\\nclass Solution:\\n    def maxSlidingWindow(self, nums, k):\\n        result = []\\n        window = deque()\\n\\n        for i, num in enumerate(nums):\\n            while window and window[0] < i - k + 1:\\n                window.popleft()\\n\\n            while window and nums[window[-1]] < num:\\n                window.pop()\\n\\n            window.append(i)\\n\\n            if i >= k - 1:\\n                result.append(nums[window[0]])\\n\\n        return result\\n\\n```\n```Java []\\n\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n        Deque<Integer> window = new ArrayDeque<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            while (!window.isEmpty() && window.peekFirst() < i - k + 1) {\\n                window.pollFirst();\\n            }\\n\\n            while (!window.isEmpty() && nums[window.peekLast()] < nums[i]) {\\n                window.pollLast();\\n            }\\n\\n            window.offerLast(i);\\n\\n            if (i >= k - 1) {\\n                result[i - k + 1] = nums[window.peekFirst()];\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\n```C++ []\\n\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> result;\\n        deque<int> window;\\n\\n        for (int i = 0; i < n; i++) {\\n            while (!window.empty() && window.front() < i - k + 1) {\\n                window.pop_front();\\n            }\\n\\n            while (!window.empty() && nums[window.back()] < nums[i]) {\\n                window.pop_back();\\n            }\\n\\n            window.push_back(i);\\n\\n            if (i >= k - 1) {\\n                result.push_back(nums[window.front()]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122916,
                "title": "swift-sliding-window-maximum",
                "content": "#### Approach:\\nThe idea is very basic run a loop, the which will mark the starting point of the subarray of length k, the loop will run from the starting index to end index+k. \\n\\n#### Algorithm: \\n1. Create a nested loop, the outer loop from starting index to n \\u2013 k th elements.\\n2. The inner loop will run for k iterations.\\n3. Create a variable to store the maximum of k elements traversed by the inner loop.\\n4. Find the maximum of k elements traversed by the inner loop.\\n5. And find the end element in every iteration of outer loop\\n\\n```swift\\nimport Foundation\\n\\nclass Solution {\\n    func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {\\n        guard nums.isEmpty == false else { return [] }\\n        \\n        var left = [Int]()\\n        var right = [Int]()\\n        \\n        for i in 0..<nums.count {\\n            while (left.count > 0) && (nums[left.last!] < nums[i]) {\\n                left.removeLast()\\n            }\\n            left.append(i)\\n            \\n            if i >= k - 1 {\\n                if left.first! + k == i { left.removeFirst() }\\n                right.append(nums[left.first!])\\n            }\\n        }\\n        return right\\n    }\\n}\\n\\nfunc tests() {\\n    let s = Solution()\\n    assert(s.maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7])\\n    assert(s.maxSlidingWindow([1], 1) == [1])\\n    assert(s.maxSlidingWindow([1,-1], 1) == [1,-1])\\n    assert(s.maxSlidingWindow([9,11], 2) == [11])\\n    assert(s.maxSlidingWindow([4,-2], 2) == [4])\\n}\\n\\ntests()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nimport Foundation\\n\\nclass Solution {\\n    func maxSlidingWindow(_ nums: [Int], _ k: Int) -> [Int] {\\n        guard nums.isEmpty == false else { return [] }\\n        \\n        var left = [Int]()\\n        var right = [Int]()\\n        \\n        for i in 0..<nums.count {\\n            while (left.count > 0) && (nums[left.last!] < nums[i]) {\\n                left.removeLast()\\n            }\\n            left.append(i)\\n            \\n            if i >= k - 1 {\\n                if left.first! + k == i { left.removeFirst() }\\n                right.append(nums[left.first!])\\n            }\\n        }\\n        return right\\n    }\\n}\\n\\nfunc tests() {\\n    let s = Solution()\\n    assert(s.maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [3,3,5,5,6,7])\\n    assert(s.maxSlidingWindow([1], 1) == [1])\\n    assert(s.maxSlidingWindow([1,-1], 1) == [1,-1])\\n    assert(s.maxSlidingWindow([9,11], 2) == [11])\\n    assert(s.maxSlidingWindow([4,-2], 2) == [4])\\n}\\n\\ntests()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953259,
                "title": "c-deque-vs-array-solution-compared-and-explained-100-time-100-space",
                "content": "Tricky one, I went for a naive solution (see at the bottom) that was TLEing for more complex/edge cases).\\n\\nAnd then I moved on with the deque one, with a logic somehow similar to [this problem](https://leetcode.com/problems/daily-temperatures/) - one I would highly recommend as a warm up and feel free to check [my solution](https://leetcode.com/problems/daily-temperatures/discuss/844524/) on that one too.\\n\\nIn order to work with deques, we need to consider how it is unnecessary to store in the queue anything more than a reference/poointer/index to the bigger values in the current window, stored in the order as they appear - more of it in an example later, to clarify.\\n\\nFirst of all we start with the usual declarations of your support variables:\\n* `len` is going to be the measure of how much we need to loop and also the size of our answer, measuring `nums.size() - k + 1` elements;\\n* `res` is our solution vector, that we will create already of the right size, to avoid reallocations;\\n* `dq` is the deque that will allow us to deal efficiently (enough) with the need to store the higher values in each specific window.\\n\\nFirst of all we will prepare `dq` to contain the first `k - 1` elements (decreasing `k` right before it and restoring it immediately after).\\n\\nOur loop invariant is going to assume that we will always have in `dq` the indexes referring to values greater than or equal to the values reached until that point.\\n\\nI will explain more about how it works in the next bit, the one about the main loop. For now, let\\'s help ourselves with an example and assume our initial input is `nums == {2, 3, 0, 5, 4, 8, 7, 8, 10, 0, 11}` with `k == 6`.\\n\\n`dq` will at each iteration here the following values stored inside:\\n\\n```cpp\\n// first iteration\\n{0} // index of 2\\n\\n// second iteration\\n{1} // index of 3, replacing the pervious since 3 > 2\\n\\n// third iteration\\n{1, 2} // index of 0 added, since it is the next bigger value after 3\\n\\n// fourth iteration\\n{3} // index of 5, since 5 is. bigger than anything seen before\\n\\n// fifth iteration\\n{3, 4} // index of 4, since it is not bigger than 5, but still the bigger value after 5, so far.\\n```\\n\\nAnd now that we have successfully populated `dq`, we are ready to go with our main loop, that:\\n* will initially declare `i = 0` and `n = k - 1`, increasing them both by `1` at each iteration, as long as `i < len`, since `i` will be the index of which value of `res` we are going to update;\\n* similarly to the previous step, we will keep popping back from `dq` as long as the current element `n` is greater than or equal to the the values of the elements referenced by the previously stored indexes, to keep our loop invariant alive;\\n* once we have cleared `dq` of values made obsolete by the one we are currently parsing, we can push `n` to the back of it;\\n* now we can finally update `res`, knowing that its `i`th element has to be the value referenced by the index stored in the front of our queue - ie: the bigger value found so far;\\n* last step - we clean up `dq`, removing the current front of it stores an index equal to `i` (note: not equal to `n`, since `n` is the value of the currently parsed element and thus `i` was the index at the beginning of the currently parsed window).\\n\\nLet\\'s keep our previous example and check what happens with `nums == {2, 3, 0, 5, 4, 8, 7, 8, 10, 0, 11}` with `k == 6`:\\n\\n```cpp\\n// previous state of dq, as computed before\\n{3, 4}\\n// res\\n{0, 0, 0, 0, 0, 0}\\n\\n// after parsing element 8 - at index 5\\n{5} since 8 is the biggest element seen so far\\n// res\\n{8, 0, 0, 0, 0, 0}\\n// we would flush out the front of dq if it was == 0\\n\\n// after parsing element 7 - at index 6\\n{5, 6} since 8 is the biggest element seen so far\\n// res\\n{8, 8, 0, 0, 0, 0}\\n// we would flush out the front of dq if it was == 1\\n\\n// after parsing element 8 - at index 7\\n{7} since the current 8 is the equal to the biggest element seen so far, it replaces it\\n// res\\n{8, 8, 8, 0, 0, 0}\\n// we would flush out the front of dq if it was == 2\\n\\n// after parsing element 10 - at index 8\\n{8} since 10 is the biggest element seen so far\\n// res\\n{8, 8, 8, 10, 0, 0}\\n// we would flush out the front of dq if it was == 3\\n\\n// after parsing element 0 - at index 9\\n{8, 9} since 0 is the biggest element seen after 10 in the previous position\\n// res\\n{8, 8, 8, 10, 10, 0}\\n// we would flush out the front of dq if it was == 4\\n\\n// after parsing element 11 - at index 10\\n{10} since 11 is the biggest element seen so far\\n// res\\n{8, 8, 8, 10, 10, 11}\\n// we would flush out the front of dq if it was == 5\\n```\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        // support variables\\n        int len = nums.size() - k + 1;\\n        vector<int> res(len);\\n        deque<int> dq;\\n        // preparing dq with the first k - 1 elements\\n        k--;\\n        for (int i = 0; i < k; i++) {\\n            while (dq.size() && nums[dq.back()] < nums[i]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        k++;\\n        // parsing through nums\\n        for (int i = 0, n = k - 1; i < len; i++, n++) {\\n            // popping smaller values\\n            while (dq.size() && nums[dq.back()] <= nums[n]) dq.pop_back();\\n            // adding the current index n\\n            dq.push_back(n);\\n            // updating res\\n            res[i] = nums[dq.front()];\\n            // popping the first element out\\n            if (dq.front() == i) dq.pop_front();\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNow, if you know me well enough, you might have realised I am a sucker for optimisation, so I refactored my code to replace the deque with an array of just `k` elements, that I will handly as a very cheap deque thanks to the `startPos` and `endPos` pointers.\\n\\nThe first loop does not even need extra logic, since `endPos` will never exceed `k`, where the the main loop will have both pointers turned to `0` when they reach `k`, since by definition we will never have to store more than `k` different indexes at a time.\\n\\nThe improved code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        // support variables\\n        int len = nums.size() - k + 1, higherValues[k], startPos = 0, endPos = 0;\\n        vector<int> res(len);\\n        // preparing dq with the first k - 1 elements\\n        k--;\\n        for (int i = 0; i < k; i++) {\\n            while (endPos != startPos && nums[higherValues[endPos - 1]] <= nums[i]) endPos = endPos - 1;\\n            higherValues[endPos++] = i;\\n        }\\n        k++;\\n        // parsing through nums\\n        for (int i = 0, n = k - 1; i < len; i++, n++) {\\n            // popping smaller values\\n            while (endPos != startPos && nums[higherValues[endPos ? endPos - 1 : k - 1]] <= nums[n]) endPos = endPos ? endPos - 1 : k - 1;\\n            // adding the current index n\\n            higherValues[endPos++] = n;\\n            if (endPos == k) endPos = 0;\\n            // updating res\\n            res[i] = nums[higherValues[startPos]];\\n            // popping the first element out\\n            if (higherValues[startPos] == i) startPos = (startPos + 1) % k;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd I am proud to announce it gave me the long-longed 100% in time and almost 100% in space too :)\\n\\n![image](https://assets.leetcode.com/users/images/bcf18d49-9c36-410b-8030-d3534ecf5f20_1606654650.4349158.png)\\n\\n![image](https://assets.leetcode.com/users/images/54911a80-dfc1-4ce0-8bd6-89d66131d23b_1606654663.0229445.png)\\n\\n\\nExtra goodie, my first attempt - failing code which was running fine, but just TLEs for larger sets - it optimised recomputing the maximum element linearly, only when needed:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        // support variables\\n        int len = nums.size() - k + 1, currMax = *max_element(begin(nums), begin(nums) + k);\\n        vector<int> res(len);\\n        res[0] = currMax;\\n        for (int i = 1; i < len; i++) {\\n            // replacing currMax if it matches the last element\\n            if (nums[i - 1] == currMax) currMax = *max_element(begin(nums) + i, begin(nums) + i + k);\\n            // updating currMax\\n            currMax = max(currMax, nums[i + k - 1]);\\n            // updating res\\n            res[i] = currMax;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```cpp\\n// first iteration\\n{0} // index of 2\\n\\n// second iteration\\n{1} // index of 3, replacing the pervious since 3 > 2\\n\\n// third iteration\\n{1, 2} // index of 0 added, since it is the next bigger value after 3\\n\\n// fourth iteration\\n{3} // index of 5, since 5 is. bigger than anything seen before\\n\\n// fifth iteration\\n{3, 4} // index of 4, since it is not bigger than 5, but still the bigger value after 5, so far.\\n```\n```cpp\\n// previous state of dq, as computed before\\n{3, 4}\\n// res\\n{0, 0, 0, 0, 0, 0}\\n\\n// after parsing element 8 - at index 5\\n{5} since 8 is the biggest element seen so far\\n// res\\n{8, 0, 0, 0, 0, 0}\\n// we would flush out the front of dq if it was == 0\\n\\n// after parsing element 7 - at index 6\\n{5, 6} since 8 is the biggest element seen so far\\n// res\\n{8, 8, 0, 0, 0, 0}\\n// we would flush out the front of dq if it was == 1\\n\\n// after parsing element 8 - at index 7\\n{7} since the current 8 is the equal to the biggest element seen so far, it replaces it\\n// res\\n{8, 8, 8, 0, 0, 0}\\n// we would flush out the front of dq if it was == 2\\n\\n// after parsing element 10 - at index 8\\n{8} since 10 is the biggest element seen so far\\n// res\\n{8, 8, 8, 10, 0, 0}\\n// we would flush out the front of dq if it was == 3\\n\\n// after parsing element 0 - at index 9\\n{8, 9} since 0 is the biggest element seen after 10 in the previous position\\n// res\\n{8, 8, 8, 10, 10, 0}\\n// we would flush out the front of dq if it was == 4\\n\\n// after parsing element 11 - at index 10\\n{10} since 11 is the biggest element seen so far\\n// res\\n{8, 8, 8, 10, 10, 11}\\n// we would flush out the front of dq if it was == 5\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        // support variables\\n        int len = nums.size() - k + 1;\\n        vector<int> res(len);\\n        deque<int> dq;\\n        // preparing dq with the first k - 1 elements\\n        k--;\\n        for (int i = 0; i < k; i++) {\\n            while (dq.size() && nums[dq.back()] < nums[i]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        k++;\\n        // parsing through nums\\n        for (int i = 0, n = k - 1; i < len; i++, n++) {\\n            // popping smaller values\\n            while (dq.size() && nums[dq.back()] <= nums[n]) dq.pop_back();\\n            // adding the current index n\\n            dq.push_back(n);\\n            // updating res\\n            res[i] = nums[dq.front()];\\n            // popping the first element out\\n            if (dq.front() == i) dq.pop_front();\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        // support variables\\n        int len = nums.size() - k + 1, higherValues[k], startPos = 0, endPos = 0;\\n        vector<int> res(len);\\n        // preparing dq with the first k - 1 elements\\n        k--;\\n        for (int i = 0; i < k; i++) {\\n            while (endPos != startPos && nums[higherValues[endPos - 1]] <= nums[i]) endPos = endPos - 1;\\n            higherValues[endPos++] = i;\\n        }\\n        k++;\\n        // parsing through nums\\n        for (int i = 0, n = k - 1; i < len; i++, n++) {\\n            // popping smaller values\\n            while (endPos != startPos && nums[higherValues[endPos ? endPos - 1 : k - 1]] <= nums[n]) endPos = endPos ? endPos - 1 : k - 1;\\n            // adding the current index n\\n            higherValues[endPos++] = n;\\n            if (endPos == k) endPos = 0;\\n            // updating res\\n            res[i] = nums[higherValues[startPos]];\\n            // popping the first element out\\n            if (higherValues[startPos] == i) startPos = (startPos + 1) % k;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        // support variables\\n        int len = nums.size() - k + 1, currMax = *max_element(begin(nums), begin(nums) + k);\\n        vector<int> res(len);\\n        res[0] = currMax;\\n        for (int i = 1; i < len; i++) {\\n            // replacing currMax if it matches the last element\\n            if (nums[i - 1] == currMax) currMax = *max_element(begin(nums) + i, begin(nums) + i + k);\\n            // updating currMax\\n            currMax = max(currMax, nums[i + k - 1]);\\n            // updating res\\n            res[i] = currMax;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585149,
                "title": "intuitive-javascript-solution-with-monotonic-queue",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSlidingWindow = function(nums, k) {\\n    // Decreasing monotonic queue so the maximum value is at the front\\n    const dequeue = []; \\n    const output = [];\\n    /*\\n     * The goal is to maintain a decreasing monotonic queue and register \\n     * max value as the window shifts.\\n     * \\n     * nums = [1,3,-1,-3,5,3,6,7], k = 3\\n     * \\n     * i        queue           output\\n     * 0        [1]             []\\n     * 1        [3]             []\\n     * 2        [3, -1]         [3]\\n     * 3        [3, -1, -3]     [3, 3]\\n     * 4        [5]             [3, 3, 5]\\n     * 5        [5, 3]          [3, 3, 5, 5]\\n     * 6        [6]             [3, 3, 5, 5, 6]\\n     * 7        [7]             [3, 3, 5, 5, 6, 7]\\n     */\\n    for (let i = 0; i < nums.length; i++) {\\n        // add the number at the right position queue\\n        while (nums[i] > dequeue[dequeue.length - 1]) {\\n            dequeue.pop();\\n        }\\n        dequeue.push(nums[i]);\\n        /**\\n         * once the window fully overlaps the array, we can start register\\n         * the maximum values in each iteration. \\n         */\\n        if (i >= k - 1) {\\n            output.push(dequeue[0]);\\n            // remove maximum value when it\\'s moving outside of the window\\n            if (nums[i - k + 1] === dequeue[0]) {\\n                dequeue.shift();\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSlidingWindow = function(nums, k) {\\n    // Decreasing monotonic queue so the maximum value is at the front\\n    const dequeue = []; \\n    const output = [];\\n    /*\\n     * The goal is to maintain a decreasing monotonic queue and register \\n     * max value as the window shifts.\\n     * \\n     * nums = [1,3,-1,-3,5,3,6,7], k = 3\\n     * \\n     * i        queue           output\\n     * 0        [1]             []\\n     * 1        [3]             []\\n     * 2        [3, -1]         [3]\\n     * 3        [3, -1, -3]     [3, 3]\\n     * 4        [5]             [3, 3, 5]\\n     * 5        [5, 3]          [3, 3, 5, 5]\\n     * 6        [6]             [3, 3, 5, 5, 6]\\n     * 7        [7]             [3, 3, 5, 5, 6, 7]\\n     */\\n    for (let i = 0; i < nums.length; i++) {\\n        // add the number at the right position queue\\n        while (nums[i] > dequeue[dequeue.length - 1]) {\\n            dequeue.pop();\\n        }\\n        dequeue.push(nums[i]);\\n        /**\\n         * once the window fully overlaps the array, we can start register\\n         * the maximum values in each iteration. \\n         */\\n        if (i >= k - 1) {\\n            output.push(dequeue[0]);\\n            // remove maximum value when it\\'s moving outside of the window\\n            if (nums[i - k + 1] === dequeue[0]) {\\n                dequeue.shift();\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998795,
                "title": "python-monotonic-queue-solution-with-explanation",
                "content": "A monotonic Queue is a data structure the elements from the front to the end is strictly either increasing or decreasing. For this problem, we gonna use the queue with the decreasing order.\\n\\n# Window and Queue\\n![image](https://assets.leetcode.com/users/images/9bc84997-2667-4e3f-9b30-b5e6202b831e_1609624629.6404312.png)\\n**Note: Yellow part is the window**.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        \\n\\t\\t# Construct the Monotonic decreasing queue\\n        queue = collections.deque()\\n        for i in range(k-1):\\n\\t\\t    # When queue[-1] < nums[i], pop queue[-1] to keep decreasing order\\n\\t\\t\\t# Cannot use <= here, since it will fail when run against cases like [2,2,1,2], k=2\\n            while queue and queue[-1] < nums[i]:\\n                queue.pop()\\n            queue.append(nums[i])\\n        \\n        res = []\\n        for i in range(k-1, len(nums)):\\n\\t\\t    # Add the new element of the window \\n            while queue and queue[-1] < nums[i]:\\n                queue.pop()\\n            queue.append(nums[i])\\n\\t\\t\\t\\n\\t\\t\\t# Append the max value (queue[0]) to the result\\n            res.append(queue[0])\\n            \\n\\t\\t\\t# Pop the old element of the window\\n\\t\\t\\t# Pop only when queue[0] == nums[i-k+1], since it may already be popped \\n            if queue[0] == nums[i-k+1]:\\n                queue.popleft()\\n        \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        \\n\\t\\t# Construct the Monotonic decreasing queue\\n        queue = collections.deque()\\n        for i in range(k-1):\\n\\t\\t    # When queue[-1] < nums[i], pop queue[-1] to keep decreasing order\\n\\t\\t\\t# Cannot use <= here, since it will fail when run against cases like [2,2,1,2], k=2\\n            while queue and queue[-1] < nums[i]:\\n                queue.pop()\\n            queue.append(nums[i])\\n        \\n        res = []\\n        for i in range(k-1, len(nums)):\\n\\t\\t    # Add the new element of the window \\n            while queue and queue[-1] < nums[i]:\\n                queue.pop()\\n            queue.append(nums[i])\\n\\t\\t\\t\\n\\t\\t\\t# Append the max value (queue[0]) to the result\\n            res.append(queue[0])\\n            \\n\\t\\t\\t# Pop the old element of the window\\n\\t\\t\\t# Pop only when queue[0] == nums[i-k+1], since it may already be popped \\n            if queue[0] == nums[i-k+1]:\\n                queue.popleft()\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694119,
                "title": "python-detailed-explanation-with-example-very-simple-code-o-n-using-deque",
                "content": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : DEQUE ##\\n        \"\"\"\\n            ## LOGIC ##\\n            1. For the First k numbers we can directly find maximum and store, but the when the window slides by one position, the first element is removed. \\n                What if the first number is the maximum of 0 to K ? How do we know the second maximum when first element is removed ? ( consider this example: [5, 2, 3, -1] and k = 3 ans = [5, 3] )\\n                So, For that we need to maintain some storage, here we use deque.\\n            2. Our Deque will always have the maximum at the start and we append small elements next to it. \\n                ( if deque(for now, say we have numbers in it) is [4,1,0] and incoming curr num is 2, pop all nums smaller from backside i.e deque will be [4, 2] )\\n            3. And when the window slides, we remove all the numbers from front of deque if they donot fall under this window size.\\n\\n            Example : [1,3,1,2,0,5] 3\\n            deque([0])              [1]\\n            deque([1])              [1, 3]\\n            deque([1, 2])           [1, 3, 3]\\n            deque([1, 3])           [1, 3, 3, 3]\\n            deque([3, 4])           [1, 3, 3, 3, 2]\\n            deque([5])              [1, 3, 3, 3, 2, 5]\\n\\n            ## TIME COMPLEXITY : O(N) ##\\n            ## SPACE COMPLEXITY : O(k) ##\\n        \"\"\"\\n        deque = collections.deque()\\n        res = []\\n        for i, num in enumerate(nums):\\n            while(deque and nums[deque[-1]] < num):\\n                deque.pop()     # 2\\n            if(deque and i - deque[0] >= k):\\n                deque.popleft() # 3\\n            deque.append(i)\\n            res.append(nums[deque[0]])\\n            # print(deque, res)\\n        return res[k-1:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : DEQUE ##\\n        \"\"\"\\n            ## LOGIC ##\\n            1. For the First k numbers we can directly find maximum and store, but the when the window slides by one position, the first element is removed. \\n                What if the first number is the maximum of 0 to K ? How do we know the second maximum when first element is removed ? ( consider this example: [5, 2, 3, -1] and k = 3 ans = [5, 3] )\\n                So, For that we need to maintain some storage, here we use deque.\\n            2. Our Deque will always have the maximum at the start and we append small elements next to it. \\n                ( if deque(for now, say we have numbers in it) is [4,1,0] and incoming curr num is 2, pop all nums smaller from backside i.e deque will be [4, 2] )\\n            3. And when the window slides, we remove all the numbers from front of deque if they donot fall under this window size.\\n\\n            Example : [1,3,1,2,0,5] 3\\n            deque([0])              [1]\\n            deque([1])              [1, 3]\\n            deque([1, 2])           [1, 3, 3]\\n            deque([1, 3])           [1, 3, 3, 3]\\n            deque([3, 4])           [1, 3, 3, 3, 2]\\n            deque([5])              [1, 3, 3, 3, 2, 5]\\n\\n            ## TIME COMPLEXITY : O(N) ##\\n            ## SPACE COMPLEXITY : O(k) ##\\n        \"\"\"\\n        deque = collections.deque()\\n        res = []\\n        for i, num in enumerate(nums):\\n            while(deque and nums[deque[-1]] < num):\\n                deque.pop()     # 2\\n            if(deque and i - deque[0] >= k):\\n                deque.popleft() # 3\\n            deque.append(i)\\n            res.append(nums[deque[0]])\\n            # print(deque, res)\\n        return res[k-1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916298,
                "title": "c-sparse-table-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the query is on static data (i.e. **nums** array is not changing), we can use Sparse table for _Constant time_ Query.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn sparse table we precompute values of all subarrays of size $$2^j$$ where $$j$$ varies from 0 to logN.\\n\\nCreate a sparse table for $$max$$ type query.\\n\\nhttps://www.geeksforgeeks.org/sparse-table/\\n\\n$$Note:$$  \\n- This concept can alse be used for **min**  and **gcd** query over the given range.\\n- Can be solved using **Segment tree**.\\n\\n# Query function explaination\\nFind highest power of 2 that is smaller than or equal to count of elements in given range.\\n\\n_For [2, 10], j = 3_  \\n\\n# Complexity\\n- Time complexity:$$O(N*logN + N)$$\\n    - $$O(N*logN)$$  to build Sparse table and $$O(N)$$ for query\\n    \\n- Space complexity: $$O(N*logN)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // SPARSE TABLE\\n    int sparse[100005][30];\\n    // Size of sparse table N X log N\\n    void buildSparseTable(int n,vector<int>& nums) {\\n        for(int i = 0; i < n; i++) \\n            sparse[i][0] = nums[i]; \\n\\n        for (int j = 1; (1 << j) <= n; j++) { \\n            for (int i = 0; (i + (1 << j) - 1) < n; i++){\\n                sparse[i][j] = max(sparse[i][j - 1], \\n                            sparse[i + (1 << (j - 1))][j - 1]);\\n            } \\n        } \\n    }\\n    int query(int L, int R) { \\n        int len = R - L + 1;\\n        int j = (int)log2(len); \\n        return max(sparse[L][j], sparse[R - (1 << j) + 1][j]);\\n    }\\n\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        buildSparseTable(n,nums);\\n\\n        vector<int> res;\\n        for(int i=0;i+k<=n;i++)\\n            res.push_back(query(i,i+k-1));\\n\\n        return res;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Indexed Tree",
                    "Segment Tree",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // SPARSE TABLE\\n    int sparse[100005][30];\\n    // Size of sparse table N X log N\\n    void buildSparseTable(int n,vector<int>& nums) {\\n        for(int i = 0; i < n; i++) \\n            sparse[i][0] = nums[i]; \\n\\n        for (int j = 1; (1 << j) <= n; j++) { \\n            for (int i = 0; (i + (1 << j) - 1) < n; i++){\\n                sparse[i][j] = max(sparse[i][j - 1], \\n                            sparse[i + (1 << (j - 1))][j - 1]);\\n            } \\n        } \\n    }\\n    int query(int L, int R) { \\n        int len = R - L + 1;\\n        int j = (int)log2(len); \\n        return max(sparse[L][j], sparse[R - (1 << j) + 1][j]);\\n    }\\n\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        buildSparseTable(n,nums);\\n\\n        vector<int> res;\\n        for(int i=0;i+k<=n;i++)\\n            res.push_back(query(i,i+k-1));\\n\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651701,
                "title": "naive-to-efficient-3-approaches-simple-easy-c",
                "content": "Implementation\\n\\n**1st Approach\\nNaive Approach\\nTLE will come\\nTime Complexity = O(N*K), Space Complexity = O(1), we are not considering output vector for space**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res;\\n        for(int itr = 0; itr <= nums.size()-k; itr++){\\n            int maxWindowValue = INT_MIN;\\n            for(int jtr = itr; jtr < itr+k; jtr++){\\n                maxWindowValue = max(maxWindowValue, nums[jtr]);\\n            }\\n            res.push_back(maxWindowValue);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**2nd Approach\\nEfficient Approach\\nusing stack\\nTraversing 2 times\\nTime Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n                \\n        // we are finding the next greater element for all elements in the given array\\n        stack<int> s;\\n        vector<int> nextGreaterElementArr(n);        \\n        for(int itr = n-1; itr >= 0; itr--){\\n            while(!s.empty() && nums[s.top()] <= nums[itr]){\\n                s.pop();\\n            }\\n            \\n            if(s.empty()) nextGreaterElementArr[itr] = n;\\n            else nextGreaterElementArr[itr] = s.top();\\n            s.push(itr);\\n        }\\n        \\n        vector<int> res;\\n        \\n        int jtr = 0;\\n        for(int itr = 0; itr <= n-k; itr++){\\n            // this (jtr < itr) condition is very important to keep the time complexity O(n) otherwise\\n            // in case of ascending order array the time complexity will be O(n*k).\\n            // I.E nums = [1,2,3]\\n            if(jtr < itr){\\n                jtr = itr;\\n            }\\n            while(nextGreaterElementArr[jtr] < itr+k){\\n                jtr = nextGreaterElementArr[jtr];\\n            }\\n            res.push_back(nums[jtr]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n**3rd Approach\\nMost Efficient Approach\\nusing dequeue\\nTraversing 1 time\\nTime Complexity : (O(N) + O(N)) => O(N),  N elements we are iterating, and N element we are inserting & deleting in queue\\nSpace Complexity : O(K), max to max only K elements we are putting into dequeue**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res;\\n        deque<int> dq;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // removing the index which is going out of our window\\n            if(!dq.empty() && dq.front() == itr-k) dq.pop_front();\\n            \\n            // pop till the coming element is greater\\n            while(!dq.empty() && nums[dq.back()] < nums[itr]){\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(itr);\\n            \\n            // since we are iterating from 0th index that\\'s why this if condition\\n            if(itr >= k-1) res.push_back(nums[dq.front()]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res;\\n        for(int itr = 0; itr <= nums.size()-k; itr++){\\n            int maxWindowValue = INT_MIN;\\n            for(int jtr = itr; jtr < itr+k; jtr++){\\n                maxWindowValue = max(maxWindowValue, nums[jtr]);\\n            }\\n            res.push_back(maxWindowValue);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n                \\n        // we are finding the next greater element for all elements in the given array\\n        stack<int> s;\\n        vector<int> nextGreaterElementArr(n);        \\n        for(int itr = n-1; itr >= 0; itr--){\\n            while(!s.empty() && nums[s.top()] <= nums[itr]){\\n                s.pop();\\n            }\\n            \\n            if(s.empty()) nextGreaterElementArr[itr] = n;\\n            else nextGreaterElementArr[itr] = s.top();\\n            s.push(itr);\\n        }\\n        \\n        vector<int> res;\\n        \\n        int jtr = 0;\\n        for(int itr = 0; itr <= n-k; itr++){\\n            // this (jtr < itr) condition is very important to keep the time complexity O(n) otherwise\\n            // in case of ascending order array the time complexity will be O(n*k).\\n            // I.E nums = [1,2,3]\\n            if(jtr < itr){\\n                jtr = itr;\\n            }\\n            while(nextGreaterElementArr[jtr] < itr+k){\\n                jtr = nextGreaterElementArr[jtr];\\n            }\\n            res.push_back(nums[jtr]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res;\\n        deque<int> dq;\\n        \\n        for(int itr = 0; itr < nums.size(); itr++){\\n            // removing the index which is going out of our window\\n            if(!dq.empty() && dq.front() == itr-k) dq.pop_front();\\n            \\n            // pop till the coming element is greater\\n            while(!dq.empty() && nums[dq.back()] < nums[itr]){\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(itr);\\n            \\n            // since we are iterating from 0th index that\\'s why this if condition\\n            if(itr >= k-1) res.push_back(nums[dq.front()]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690998,
                "title": "this-is-how-i-did-using-priority-queue-wasen-t-aware-of-dequeue",
                "content": "this is how i did it using priority_queue , i wasn\\'t aware of inbuilt deque data structure\\ndefinitely not O(n)\\n```\\nvector<int> maxSlidingWindow(vector<int>& a, int k) {\\n        \\n        auto comp = [&a](int &p, int &q)       // custom comparator fuction\\n        {\\n            return !(a[p] > a[q]);\\n        };\\n       priority_queue<int, vector<int> , decltype(comp)> pq(comp);\\n       vector<int> ans;\\n       for(int i=0 ; i<a.size() ; i++)\\n            {\\n                pq.push(i);\\n                if(pq.size() >=k )\\n                {\\n                    while(pq.size() and pq.top()<i-k+1)\\n                        pq.pop();\\n                    ans.push_back(a[pq.top()]);\\n                }\\n            }\\n   return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvector<int> maxSlidingWindow(vector<int>& a, int k) {\\n        \\n        auto comp = [&a](int &p, int &q)       // custom comparator fuction\\n        {\\n            return !(a[p] > a[q]);\\n        };\\n       priority_queue<int, vector<int> , decltype(comp)> pq(comp);\\n       vector<int> ans;\\n       for(int i=0 ; i<a.size() ; i++)\\n            {\\n                pq.push(i);\\n                if(pq.size() >=k )\\n                {\\n                    while(pq.size() and pq.top()<i-k+1)\\n                        pq.pop();\\n                    ans.push_back(a[pq.top()]);\\n                }\\n            }\\n   return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66077,
                "title": "a-clear-solution-using-deque-c",
                "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n      \\n        deque<int> q;\\n        vector<int> maxs;\\n        if(nums.empty()||k<=0) return maxs;\\n\\n        for(int i=0;i<nums.size();i++){\\n            while(!q.empty()&&nums[q.back()]<=nums[i]) \\n                q.pop_back();\\n            q.push_back(i);\\n            if(q.front()<=i-k) q.pop_front();\\n            \\n            if(i>=k-1) maxs.push_back(nums[q.front()]);\\n        }\\n        return maxs;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n      \\n        deque<int> q;\\n        vector<int> maxs;\\n        if(nums.empty()||k<=0) return maxs;\\n\\n        for(int i=0;i<nums.size();i++){\\n            while(!q.empty()&&nums[q.back()]<=nums[i]) \\n                q.pop_back();\\n            q.push_back(i);\\n            if(q.front()<=i-k) q.pop_front();\\n            \\n            if(i>=k-1) maxs.push_back(nums[q.front()]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3916410,
                "title": "c-priority-queue-day-16",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n      priority_queue<pair<int,int>>pq;\\n      vector<int>ans;\\n      for(int i=0;i<nums.size();i++){\\n          pq.push({nums[i],i});\\n          if(i>=(k-1)){\\n              while(i - pq.top().second >= k){\\n                  pq.pop();\\n              }\\n              ans.push_back(pq.top().first);\\n          }\\n      }  \\n      return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/7133a637-8aeb-47ec-a7e4-a0d46dd3aac5_1692165159.9464674.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n      priority_queue<pair<int,int>>pq;\\n      vector<int>ans;\\n      for(int i=0;i<nums.size();i++){\\n          pq.push({nums[i],i});\\n          if(i>=(k-1)){\\n              while(i - pq.top().second >= k){\\n                  pq.pop();\\n              }\\n              ans.push_back(pq.top().first);\\n          }\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523670,
                "title": "clean-c-solution-using-deque",
                "content": "**Please do upvote if you liked the approach as it motivates me to create such post**\\n```\\nclass Solution {\\npublic:\\n    //Idea here to use deque data structure efficintly.. In this question we \\n    //have to find the maxinum element in the fixed sized sliding window..\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int>res;\\n        deque<int>dq;\\n        int n = nums.size();\\n        int i=0,j=0;\\n        \\n        while(j<n){\\n            /* till the last element in deque is smaller than the current number\\nwe remove that element from deque because we want to find the maximum element \\nin that window... Now just think we have greater element than the element \\nwhich is at the end of deque then that smaller element is of no use for us\\nso simply we remove it from the back of deque*/\\n            while(dq.size()>0 && dq.back()<nums[j]){\\n                dq.pop_back();\\n            }\\n            //after removing all the smaller elements we push the larger element\\n            // into the queue\\n            dq.push_back(nums[j]);\\n            \\n            /* now we know this is fixed sized sliding window so until our \\n            window size reaches k we should increase our j */\\n            if(j-i+1<k)j++;\\n            \\n            /*as soon as our window becomes k sized then the front element \\n            of deque is our maximum element from that particular window */\\n            else if(j-i+1 == k){\\n                res.push_back(dq.front());\\n                \\n                //if our i is pointing to the same element which is present \\n                // at the front of deque then we should remove it\\n                if(nums[i] == dq.front())dq.pop_front();\\n                \\n                //this is the point where we slide our window\\n                i++;j++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Idea here to use deque data structure efficintly.. In this question we \\n    //have to find the maxinum element in the fixed sized sliding window..\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int>res;\\n        deque<int>dq;\\n        int n = nums.size();\\n        int i=0,j=0;\\n        \\n        while(j<n){\\n            /* till the last element in deque is smaller than the current number\\nwe remove that element from deque because we want to find the maximum element \\nin that window... Now just think we have greater element than the element \\nwhich is at the end of deque then that smaller element is of no use for us\\nso simply we remove it from the back of deque*/\\n            while(dq.size()>0 && dq.back()<nums[j]){\\n                dq.pop_back();\\n            }\\n            //after removing all the smaller elements we push the larger element\\n            // into the queue\\n            dq.push_back(nums[j]);\\n            \\n            /* now we know this is fixed sized sliding window so until our \\n            window size reaches k we should increase our j */\\n            if(j-i+1<k)j++;\\n            \\n            /*as soon as our window becomes k sized then the front element \\n            of deque is our maximum element from that particular window */\\n            else if(j-i+1 == k){\\n                res.push_back(dq.front());\\n                \\n                //if our i is pointing to the same element which is present \\n                // at the front of deque then we should remove it\\n                if(nums[i] == dq.front())dq.pop_front();\\n                \\n                //this is the point where we slide our window\\n                i++;j++;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070869,
                "title": "simple-o-n-deque-solution-c",
                "content": "Before going through the code I would recommend understanding the working of [monotonic deque](https://github.com/xiaoylu/leetcode_category/tree/master/MonotonicQueue). Sovling [this](https://leetcode.com/problems/monotonic-array/) helped me. I couldn\\'t solved this in my first attempt, so I solved [this](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/), read [this](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/204290/Monotonic-Queue-Summary) and [this](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque) and finally solved this. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\t\\tvector<int> res;\\n        deque<int> mq;\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\n            // If the mq head in out of the window --> pop head\\n            if (mq.size() > 0 && mq.front() <= i - k) mq.pop_front();\\n            \\n            // If mq is non empty and current val >= last element of mq\\n            // --> remove all elements that are <= from back \\n            while (mq.size() > 0 && nums[i] >= nums[mq.back()]) \\n                mq.pop_back();\\n            \\n            // Takes care of inserting into the end\\n            mq.push_back(i);\\n            \\n            // Store results from the end of the first window\\n            if (i + 1 >= k) res.push_back(nums[mq.front()]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nI took me 5 days to solve this. Yet I solved!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\t\\tvector<int> res;\\n        deque<int> mq;\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\n            // If the mq head in out of the window --> pop head\\n            if (mq.size() > 0 && mq.front() <= i - k) mq.pop_front();\\n            \\n            // If mq is non empty and current val >= last element of mq\\n            // --> remove all elements that are <= from back \\n            while (mq.size() > 0 && nums[i] >= nums[mq.back()]) \\n                mq.pop_back();\\n            \\n            // Takes care of inserting into the end\\n            mq.push_back(i);\\n            \\n            // Store results from the end of the first window\\n            if (i + 1 >= k) res.push_back(nums[mq.front()]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951753,
                "title": "python-min-deque-and-heap-solutions",
                "content": "We can keep the running window of elements and their positions in a heap and get the largest one at every timestep, cleaning up the heap lazily as we see stale elements in there. This would give us `O(NlogN)` solution:\\n```\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n\\tif k == 1: return nums\\n\\trwindow = [(-val, i) for i, val in enumerate(nums[:k])]\\n\\theapq.heapify(rwindow)\\n\\tres = [-rwindow[0][0]]\\n\\n\\tfor i in range(k, len(nums)):\\n\\t\\twhile rwindow[0][1] <= i - k: heapq.heappop(rwindow)\\n\\t\\theapq.heappush(rwindow, (-nums[i], i))\\n\\t\\tres.append(-rwindow[0][0])\\n\\n\\treturn res\\n```\\n\\nTo achieve the `O(N)` solution we can use a deque of indices of up to k last observed elements as a window. While iterating over the array:\\n1. We clean up the stale elements from the tail of the deque, and\\n2. If we see a new element which is larger than or equal to the one at the head, it kicks out smaller elements since they can no longer be max value in the current window.\\n```\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n\\tminqueue = deque()\\n\\n\\t# initialize the window\\n\\tfor i in range(min(k, len(nums))):\\n\\t\\twhile minqueue and nums[minqueue[-1]] <= nums[i]: minqueue.pop()\\n\\t\\tminqueue.append(i)\\n\\n\\tres = [nums[minqueue[0]]]  # results\\n\\n\\tfor i in range(k, len(nums)):\\n\\t\\twhile minqueue and minqueue[0] <= i - k:  # clean up stale elements\\n\\t\\t\\tminqueue.popleft()\\n\\t\\twhile minqueue and nums[minqueue[-1]] <= nums[i]:  # kick out smaller ones\\n\\t\\t\\tminqueue.pop()\\n\\t\\tminqueue.append(i)\\n\\t\\tres.append(nums[minqueue[0]])  # guaranteed to be the max\\n\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n\\tif k == 1: return nums\\n\\trwindow = [(-val, i) for i, val in enumerate(nums[:k])]\\n\\theapq.heapify(rwindow)\\n\\tres = [-rwindow[0][0]]\\n\\n\\tfor i in range(k, len(nums)):\\n\\t\\twhile rwindow[0][1] <= i - k: heapq.heappop(rwindow)\\n\\t\\theapq.heappush(rwindow, (-nums[i], i))\\n\\t\\tres.append(-rwindow[0][0])\\n\\n\\treturn res\\n```\n```\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n\\tminqueue = deque()\\n\\n\\t# initialize the window\\n\\tfor i in range(min(k, len(nums))):\\n\\t\\twhile minqueue and nums[minqueue[-1]] <= nums[i]: minqueue.pop()\\n\\t\\tminqueue.append(i)\\n\\n\\tres = [nums[minqueue[0]]]  # results\\n\\n\\tfor i in range(k, len(nums)):\\n\\t\\twhile minqueue and minqueue[0] <= i - k:  # clean up stale elements\\n\\t\\t\\tminqueue.popleft()\\n\\t\\twhile minqueue and nums[minqueue[-1]] <= nums[i]:  # kick out smaller ones\\n\\t\\t\\tminqueue.pop()\\n\\t\\tminqueue.append(i)\\n\\t\\tres.append(nums[minqueue[0]])  # guaranteed to be the max\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 66037,
                "title": "a-concise-solution-using-deque",
                "content": "    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        if (k <= 0) return {};\\n        \\n        vector<int> ans(nums.size() - k + 1);\\n        deque<int> dq;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // delete those nodes whose value less than the current value\\n            while (!dq.empty() && nums[i] > nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            // delete the node pass the start of the window\\n            if (i - dq.front() + 1 > k) dq.pop_front();\\n            // assign result value\\n            if (i >= k - 1) ans[i - k + 1] = nums[dq.front()];\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        if (k <= 0) return {};\\n        \\n        vector<int> ans(nums.size() - k + 1);\\n        deque<int> dq;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            // delete those nodes whose value less than the current value\\n            while (!dq.empty() && nums[i] > nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            // delete the node pass the start of the window\\n            if (i - dq.front() + 1 > k) dq.pop_front();\\n            // assign result value\\n            if (i >= k - 1) ans[i - k + 1] = nums[dq.front()];\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3231782,
                "title": "239-time-93-21-and-space-81-39-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We use a deque (double-ended queue) to store the indices of the elements in the current sliding window, with the front of the deque being the index of the maximum element.\\n- We iterate through the array nums, removing elements from the deque that are outside the current sliding window and removing elements from the deque that are smaller than the current element, since they cannot be the maximum element in the window.\\n- We add the index of the current element to the deque and append the maximum element in the window to the result list if we have a complete window.\\n- Finally, we return the result list.\\n\\n# Complexity\\n- Time complexity:\\n93.21%\\n\\n- Space complexity:\\n81.39%\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        # create a deque to hold the indices of the elements in the sliding window\\n        window = deque()\\n        result = []\\n        \\n        # iterate through the array\\n        for i in range(len(nums)):\\n            # remove elements from the deque that are outside the window\\n            while window and window[0] <= i - k:\\n                window.popleft()\\n            \\n            # remove elements from the deque that are smaller than the current element\\n            while window and nums[window[-1]] < nums[i]:\\n                window.pop()\\n            \\n            # add the index of the current element to the deque\\n            window.append(i)\\n            \\n            # add the maximum element in the window to the result list\\n            if i >= k - 1:\\n                result.append(nums[window[0]])\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        # create a deque to hold the indices of the elements in the sliding window\\n        window = deque()\\n        result = []\\n        \\n        # iterate through the array\\n        for i in range(len(nums)):\\n            # remove elements from the deque that are outside the window\\n            while window and window[0] <= i - k:\\n                window.popleft()\\n            \\n            # remove elements from the deque that are smaller than the current element\\n            while window and nums[window[-1]] < nums[i]:\\n                window.pop()\\n            \\n            # add the index of the current element to the deque\\n            window.append(i)\\n            \\n            # add the maximum element in the window to the result list\\n            if i >= k - 1:\\n                result.append(nums[window[0]])\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689311,
                "title": "java-priority-queue-intuitive-approach-o-nlogn",
                "content": "```\\nclass Solution {\\n\\t// To keep the track of number and index in nums array\\n    class Num {\\n        int data;\\n        int index;\\n        public Num(int data, int index){\\n            this.data = data;\\n            this.index = index;\\n        }\\n    }\\n    \\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        Queue<Num> queue = new PriorityQueue<>((a,b) -> Integer.compare(b.data, a.data));\\n        int left = 0;\\n        int right = 0;\\n        int[] ans = new int[nums.length - k + 1];\\n        while(right < nums.length){\\n\\t\\t\\t// Add elements in queue if window size is less than k \\n            if(right-left < k){\\n                queue.add(new Num(nums[right], right));\\n                right++;\\n            } \\n\\t\\t\\t// If reached at window size k, check the largest number\\n            if(right-left == k) {\\n                ans[left++] = queue.peek().data;\\n            }\\n\\t\\t\\t// Remove the highest number if goes out of window\\n            while(!queue.isEmpty() && queue.peek().index < left){\\n                queue.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nTime Complexity : *O(nlogn)*\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\t// To keep the track of number and index in nums array\\n    class Num {\\n        int data;\\n        int index;\\n        public Num(int data, int index){\\n            this.data = data;\\n            this.index = index;\\n        }\\n    }\\n    \\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        Queue<Num> queue = new PriorityQueue<>((a,b) -> Integer.compare(b.data, a.data));\\n        int left = 0;\\n        int right = 0;\\n        int[] ans = new int[nums.length - k + 1];\\n        while(right < nums.length){\\n\\t\\t\\t// Add elements in queue if window size is less than k \\n            if(right-left < k){\\n                queue.add(new Num(nums[right], right));\\n                right++;\\n            } \\n\\t\\t\\t// If reached at window size k, check the largest number\\n            if(right-left == k) {\\n                ans[left++] = queue.peek().data;\\n            }\\n\\t\\t\\t// Remove the highest number if goes out of window\\n            while(!queue.isEmpty() && queue.peek().index < left){\\n                queue.poll();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578323,
                "title": "brain-dead-easy-o-n-python-3-solution-beats-92",
                "content": "This problem has a few tricky parts that you can learn for other problems:\\n\\nQ: How to pop elements from both sides of the window in O(1) time?\\nA: Double-ended queue (deque)\\n\\nQ. How to always grab the maximum element in O(1) time?\\nA. Keep a version of the window sorted descending (using deque). That way, the left element is always the maximum. If we want the 2nd maximum element, we can just pop the first one.\\n\\nQ. How can we sync the fixed sliding window size with a queue that is always changing in size?\\nA. Compare the left (first) element of the queue with the left boundary element of the window. If we detect that they are the same, then remove that element as it is out-of-bounds.\\n\\nThanks for reading! Leave an upvote if you found this useful.\\n\\n```python\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n    q = collections.deque()\\n    output = []\\n    for i in range(len(nums)):\\n        # if the queue\\'s left element is out of bounds, pop it to maintain size\\n        if i-k >= 0 and nums[i-k] == q[0]:\\n                q.popleft()\\n\\n        # ensure array is DECREASING by right-popping elements that are smaller\\n        while q and q[-1] < nums[i]: \\n            q.pop()\\n\\n        # add the element itself\\n        q.append(nums[i])\\n\\n        # append to output list if we have full window\\n        if i >= k-1:\\n            output.append(q[0])\\n\\n    return output\\n```            \\n\\n![image](https://assets.leetcode.com/users/willye/image_1586832518.png)\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n    q = collections.deque()\\n    output = []\\n    for i in range(len(nums)):\\n        # if the queue\\'s left element is out of bounds, pop it to maintain size\\n        if i-k >= 0 and nums[i-k] == q[0]:\\n                q.popleft()\\n\\n        # ensure array is DECREASING by right-popping elements that are smaller\\n        while q and q[-1] < nums[i]: \\n            q.pop()\\n\\n        # add the element itself\\n        q.append(nums[i])\\n\\n        # append to output list if we have full window\\n        if i >= k-1:\\n            output.append(q[0])\\n\\n    return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1235475,
                "title": "aditya-verma-explanation",
                "content": "// If any one wants to do DSA and competitive coding from scratch you can visit my Github Repository\\n// https://github.com/skjha1/Data-Structure-Algorithm-Programs\\n// https://github.com/skjha1/Competitive-Coding\\n// access notes by aditya verma in this repo : https://github.com/skjha1/Aditya-verma-youtube-playlist-code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n       vector<int> ans;\\n        list<int> l;\\n        int i=0;\\n        int j=0;\\n        \\n        if (k>nums.size()) // edge case\\n        {\\n            ans.push_back(*max_element(nums.begin(),nums.end()));\\n            return ans;\\n        }\\n        \\n        while (j<nums.size())\\n        {\\n            while(l.size()>0 && l.back() <nums[j])\\n            {\\n                l.pop_back();\\n            }\\n            l.push_back(nums[j]);\\n            if ((j-i+1)<k)\\n                j++;\\n            else if (j-i+1==k)\\n            {\\n                ans.push_back(l.front());\\n                if (l.front()==nums[i])\\n                    l.pop_front();\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n       vector<int> ans;\\n        list<int> l;\\n        int i=0;\\n        int j=0;\\n        \\n        if (k>nums.size()) // edge case\\n        {\\n            ans.push_back(*max_element(nums.begin(),nums.end()));\\n            return ans;\\n        }\\n        \\n        while (j<nums.size())\\n        {\\n            while(l.size()>0 && l.back() <nums[j])\\n            {\\n                l.pop_back();\\n            }\\n            l.push_back(nums[j]);\\n            if ((j-i+1)<k)\\n                j++;\\n            else if (j-i+1==k)\\n            {\\n                ans.push_back(l.front());\\n                if (l.front()==nums[i])\\n                    l.pop_front();\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264390,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        opt = []\\n        q = collections.deque()\\n        for i in xrange(len(nums)):\\n            n = nums[i]\\n            \\n            #move the window\\n            if q and q[0]<=i-k: q.popleft()\\n\\n            #pop the right if the element in queue is not greater than the in-coming one\\n            #by doing this, we can always keep the max in the current window at left most\\n            while q and nums[q[-1]]<=n: q.pop()\\n\\n            q.append(i)\\n\\n            #add the max to the output array after the first kth element\\n            if 1+i>=k: opt.append(nums[q[0]])\\n        return opt\\n\"\"\"\\nI really take time to explain my solution, because I wanted to help people understand.\\nIf you like my answer, a star on GitHub I will really appreciated.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        opt = []\\n        q = collections.deque()\\n        for i in xrange(len(nums)):\\n            n = nums[i]\\n            \\n            #move the window\\n            if q and q[0]<=i-k: q.popleft()\\n\\n            #pop the right if the element in queue is not greater than the in-coming one\\n            #by doing this, we can always keep the max in the current window at left most\\n            while q and nums[q[-1]]<=n: q.pop()\\n\\n            q.append(i)\\n\\n            #add the max to the output array after the first kth element\\n            if 1+i>=k: opt.append(nums[q[0]])\\n        return opt\\n\"\"\"\\nI really take time to explain my solution, because I wanted to help people understand.\\nIf you like my answer, a star on GitHub I will really appreciated.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66080,
                "title": "accepted-104ms-c-solution-with-maxqueue",
                "content": "Do you remember the [Min Stack][1] problem? In this problem, a similar `Max Queue` is needed!\\n\\nHere is my 104ms c++ solution.\\n\\n    class Solution {\\n    public:\\n    \\tstd::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\\n    \\t\\tstd::vector<int> res;\\n    \\t\\tif (k < 1)\\n    \\t\\t\\treturn res;\\n    \\t\\tMaxQueue mq;\\n    \\t\\tfor (int i = 0; i != k; ++i)\\n    \\t\\t\\tmq.push(nums[i]);\\n    \\t\\tres.push_back(mq.getMax());\\n    \\t\\tfor (int i = k; i != nums.size(); ++i) {\\n    \\t\\t\\tmq.pop();\\n    \\t\\t\\tmq.push(nums[i]);\\n    \\t\\t\\tres.push_back(mq.getMax());\\n    \\t\\t}\\n    \\t\\treturn res;\\n    \\t}\\n    private:\\n    \\tclass MaxQueue {\\n    \\tpublic:\\n    \\t\\tvoid push(int x) {\\n    \\t\\t\\tnums.push(x);\\n    \\t\\t\\twhile (!maxs.empty() && maxs.back() < x)\\n    \\t\\t\\t\\tmaxs.pop_back();\\n    \\t\\t\\tmaxs.push_back(x);\\n    \\t\\t}\\n    \\t\\tvoid pop() {\\n    \\t\\t\\tif (nums.front() == maxs.front())\\n    \\t\\t\\t\\tmaxs.pop_front();\\n    \\t\\t\\tnums.pop();\\n    \\t\\t}\\n    \\t\\tint getMax() {\\n    \\t\\t\\treturn maxs.front();\\n    \\t\\t}\\n    \\tprivate:\\n    \\t\\tstd::queue<int> nums;\\n    \\t\\tstd::deque<int> maxs;\\n    \\t};\\n    };\\n\\n\\n\\n  [1]: https://leetcode.com/problems/min-stack/",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tstd::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\\n    \\t\\tstd::vector<int> res;\\n    \\t\\tif (k < 1)\\n    \\t\\t\\treturn res;\\n    \\t\\tMaxQueue mq;\\n    \\t\\tfor (int i = 0; i != k; ++i)\\n    \\t\\t\\tmq.push(nums[i]);\\n    \\t\\tres.push_back(mq.getMax());\\n    \\t\\tfor (int i = k; i != nums.size(); ++i) {\\n    \\t\\t\\tmq.pop();\\n    \\t\\t\\tmq.push(nums[i]);\\n    \\t\\t\\tres.push_back(mq.getMax());\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 66120,
                "title": "1-liner-brute-force",
                "content": "Linear time is only the follow-up question, so... here's an accepted Python O(kn) one-liner:\\n\\n    def maxSlidingWindow(self, nums, k):\\n        return nums and [max(nums[i:i+k]) for i in range(len(nums)-k+1)]\\n\\nIn Ruby it's even shorter, but unfortunately too slow to get accepted.\\n\\n    def max_sliding_window(nums, k)\\n        k > 0 ? nums.each_cons(k).map(&:max) : []\\n    end\\n\\nOf course I also wrote [normal O(n) solutions](https://leetcode.com/discuss/46584/9-lines-ruby-11-lines-python-o-n). I'm wondering, though, whether the above could be made fast with still simple code. I'm particularly interested in Ruby, as the above isn't accepted. Here's a sketch:\\n\\nLet's say we have 1000 numbers and k is 500. The above brute force method finds the maximum of each window simply by looking at the window's 500 elements. What if we instead split the 1000 numbers into 50 streaks of 20 numbers each, and precompute the maximum of each streak? Then for each window, we only have to maximize over ~25 streak maximums and 20 elements.",
                "solutionTags": [
                    "Python"
                ],
                "code": "Linear time is only the follow-up question, so... here's an accepted Python O(kn) one-liner:\\n\\n    def maxSlidingWindow(self, nums, k):\\n        return nums and [max(nums[i:i+k]) for i in range(len(nums)-k+1)]\\n\\nIn Ruby it's even shorter, but unfortunately too slow to get accepted.\\n\\n    def max_sliding_window(nums, k)\\n        k > 0 ? nums.each_cons(k).map(&:max) : []\\n    end\\n\\nOf course I also wrote [normal O(n) solutions](https://leetcode.com/discuss/46584/9-lines-ruby-11-lines-python-o-n). I'm wondering, though, whether the above could be made fast with still simple code. I'm particularly interested in Ruby, as the above isn't accepted. Here's a sketch:\\n\\nLet's say we have 1000 numbers and k is 500. The above brute force method finds the maximum of each window simply by looking at the window's 500 elements. What if we instead split the 1000 numbers into 50 streaks of 20 numbers each, and precompute the maximum of each streak? Then for each window, we only have to maximize over ~25 streak maximums and 20 elements.",
                "codeTag": "Python3"
            },
            {
                "id": 3491147,
                "title": "python3-decreasing-queue-beats-95-1296ms",
                "content": "```python3 []\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        q, res = deque(), [] # save index in q (decreasing order)\\n        for r in range(len(nums)):\\n            # remove from the right side all items less than current\\n            while q and nums[q[-1]] < nums[r]:\\n                q.pop()\\n            q.append(r)\\n            # while window not full (size =k) do nothing\\n            if r+1 < k: continue\\n            # if most left index out of window [r+1-k, r] we need remove it\\n            if q[0] < r+1-k:\\n                q.popleft()\\n            # because deque is decreasing the left value is highest\\n            res.append(nums[q[0]])\\n\\n        return res\\n```\\n![Screenshot 2023-08-16 at 03.45.25.png](https://assets.leetcode.com/users/images/7061e3e8-ae47-4b53-a275-ac6e85d2eb57_1692146770.9367666.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        q, res = deque(), [] # save index in q (decreasing order)\\n        for r in range(len(nums)):\\n            # remove from the right side all items less than current\\n            while q and nums[q[-1]] < nums[r]:\\n                q.pop()\\n            q.append(r)\\n            # while window not full (size =k) do nothing\\n            if r+1 < k: continue\\n            # if most left index out of window [r+1-k, r] we need remove it\\n            if q[0] < r+1-k:\\n                q.popleft()\\n            # because deque is decreasing the left value is highest\\n            res.append(nums[q[0]])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65926,
                "title": "java-3-solutions-deque-o-n-heap-o-n-k-k-heap-o-n-k-logn",
                "content": "I wrote 3 methods I can come up with.\\n\\n1. Deque Method: use deque to record the index, remove elements out of window in the head, and remove the smaller elements in the tail which have no change to become max.\\n```\\n    // O(n)\\n    public int[] maxSlidingWindow_deque(int[] nums, int k) {\\n        if(nums==null || k>nums.length || k<0) return null;\\n        if(k==0 || nums.length==0) return new int[0];\\n        Deque<Integer> dq = new LinkedList<>();\\n        int[] res = new int[nums.length-k+1];\\n        int index = 0; // index in r is equal to the left side of window\\n        for(int i=0; i<nums.length; i++){\\n            // remove elements out of window\\n            index = i-k+1;\\n            while(!dq.isEmpty() && dq.peek()<index){\\n                dq.poll();\\n            }\\n            // remove smaller elements, which have no change to become max\\n            while(!dq.isEmpty() && nums[dq.peek()]<nums[i]){\\n                dq.pollLast();\\n            }\\n            dq.offer(i);\\n            if(index>=0){\\n                res[index] = nums[dq.peek()];\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n2. Max Heap Method: a naive method. Build a max heap for a window, and remove the element out of window.\\n```    \\n    //O((n-k)(lgk+k)) = O((n-k)k)\\n    public int[] maxSlidingWindow_heap1(int[] nums, int k) {\\n        if(nums==null || k>nums.length || k<0) return null;\\n        if(k==0 || nums.length==0) return new int[0];\\n        PriorityQueue<Integer> heap = new PriorityQueue<>( k, Collections.reverseOrder() );\\n        int[] res = new int[nums.length - k + 1];\\n        for(int i=0; i<k; i++)\\n            heap.offer(nums[i]);\\n        for(int p=0; p<res.length; p++){\\n            res[p] = heap.peek();\\n            heap.remove(nums[p]);\\n            if(p+k < nums.length)\\n                heap.offer(nums[p+k]);\\n        }\\n        return res;\\n    }\\n```\\n3. Max Heap Method 2: Using a class Tuple to record index info.\\n```\\n    // worst case O((n-k)logn) increasing order, best case O((n-k)logk) decreasing order\\n    public int[] maxSlidingWindow_heap2(int[] nums, int k) {\\n        if(nums==null || k>nums.length || k<0) return null;\\n        if(k==0 || nums.length==0) return new int[0];\\n        PriorityQueue<Tuple> heap = new PriorityQueue<>( k, Collections.reverseOrder() );\\n        int[] res = new int[nums.length - k + 1];\\n        for(int i=0; i<k; i++)\\n            heap.offer(new Tuple(nums[i], i));\\n        Tuple tup = null;\\n        for(int p=0; p<res.length; p++){\\n            tup = heap.peek();\\n            while(tup.idx<p) {\\n                heap.poll();\\n                tup = heap.peek();\\n            }\\n            res[p] = tup.val;\\n            if(p+k < nums.length)\\n                heap.offer(new Tuple(nums[p+k], p+k));\\n        }\\n        return res;\\n    }\\n    class Tuple implements Comparable<Tuple>{\\n        int val;\\n        int idx;\\n        public Tuple(int value, int index){\\n            val = value;\\n            idx = index;\\n        }\\n        @Override\\n        public int compareTo(Tuple tup){\\n            return (val - tup.val);\\n        }\\n    }\\n\\n```\\n\\n I came up with the second one first, then the third one. Then I looked at the discuss, and found people used deque with O(n). I did the first one.",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    // O(n)\\n    public int[] maxSlidingWindow_deque(int[] nums, int k) {\\n        if(nums==null || k>nums.length || k<0) return null;\\n        if(k==0 || nums.length==0) return new int[0];\\n        Deque<Integer> dq = new LinkedList<>();\\n        int[] res = new int[nums.length-k+1];\\n        int index = 0; // index in r is equal to the left side of window\\n        for(int i=0; i<nums.length; i++){\\n            // remove elements out of window\\n            index = i-k+1;\\n            while(!dq.isEmpty() && dq.peek()<index){\\n                dq.poll();\\n            }\\n            // remove smaller elements, which have no change to become max\\n            while(!dq.isEmpty() && nums[dq.peek()]<nums[i]){\\n                dq.pollLast();\\n            }\\n            dq.offer(i);\\n            if(index>=0){\\n                res[index] = nums[dq.peek()];\\n            }\\n        }\\n        return res;\\n    }\\n```\n```    \\n    //O((n-k)(lgk+k)) = O((n-k)k)\\n    public int[] maxSlidingWindow_heap1(int[] nums, int k) {\\n        if(nums==null || k>nums.length || k<0) return null;\\n        if(k==0 || nums.length==0) return new int[0];\\n        PriorityQueue<Integer> heap = new PriorityQueue<>( k, Collections.reverseOrder() );\\n        int[] res = new int[nums.length - k + 1];\\n        for(int i=0; i<k; i++)\\n            heap.offer(nums[i]);\\n        for(int p=0; p<res.length; p++){\\n            res[p] = heap.peek();\\n            heap.remove(nums[p]);\\n            if(p+k < nums.length)\\n                heap.offer(nums[p+k]);\\n        }\\n        return res;\\n    }\\n```\n```\\n    // worst case O((n-k)logn) increasing order, best case O((n-k)logk) decreasing order\\n    public int[] maxSlidingWindow_heap2(int[] nums, int k) {\\n        if(nums==null || k>nums.length || k<0) return null;\\n        if(k==0 || nums.length==0) return new int[0];\\n        PriorityQueue<Tuple> heap = new PriorityQueue<>( k, Collections.reverseOrder() );\\n        int[] res = new int[nums.length - k + 1];\\n        for(int i=0; i<k; i++)\\n            heap.offer(new Tuple(nums[i], i));\\n        Tuple tup = null;\\n        for(int p=0; p<res.length; p++){\\n            tup = heap.peek();\\n            while(tup.idx<p) {\\n                heap.poll();\\n                tup = heap.peek();\\n            }\\n            res[p] = tup.val;\\n            if(p+k < nums.length)\\n                heap.offer(new Tuple(nums[p+k], p+k));\\n        }\\n        return res;\\n    }\\n    class Tuple implements Comparable<Tuple>{\\n        int val;\\n        int idx;\\n        public Tuple(int value, int index){\\n            val = value;\\n            idx = index;\\n        }\\n        @Override\\n        public int compareTo(Tuple tup){\\n            return (val - tup.val);\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66044,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "Priority-queue based solution\\n\\n    class Solution {\\n    public:\\n        vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            vector<int> result;\\n            /*** use the multiset to get the max-value ***/\\n            multiset<int> w;\\n            for(int i=0; i<nums.size(); i++){\\n                /*** erase the previous top element ***/\\n                if(i>=k)  w.erase(w.find(nums[i-k]));\\n                w.insert(nums[i]);\\n                /*** insert the max-value of the window ***/\\n                if(i>=k-1) result.push_back(*w.rbegin());\\n            }\\n            return result;\\n        }\\n    };\\n\\nO(N)   deque-monotical-queue-solution\\n\\n    class Solution {\\n    public:\\n        vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            vector<int> result;\\n            deque<int> q;\\n            for(int i=0; i<nums.size(); i++){\\n                /*** remove the top element **/\\n                if(!q.empty() && q.front()==i-k)  q.pop_front();\\n                /*** keep the element in the queue is monotically-decreasing ***/\\n                while(!q.empty() && nums[q.back()] < nums[i])  q.pop_back();\\n                q.push_back(i);\\n                if(i>=k-1)  result.push_back(nums[q.front()]);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            vector<int> result;\\n            /*** use the multiset to get the max-value ***/\\n            multiset<int> w;\\n            for(int i=0; i<nums.size(); i++){\\n                /*** erase the previous top element ***/\\n                if(i>=k)  w.erase(w.find(nums[i-k]));\\n                w.insert(nums[i]);\\n                /*** insert the max-value of the window ***/\\n                if(i>=k-1) result.push_back(*w.rbegin());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1533037,
                "title": "java-o-n-solution-using-deque-and-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;\\n        int res[]=new int[n-k+1];\\n        Deque<Integer> dq=new LinkedList<>();\\n        int i=0,j=0;\\n        int t=0;\\n        while(j<n)\\n        {\\n            // Calculation\\n            while(!dq.isEmpty() && nums[dq.peekLast()]<nums[j])\\n            {\\n                dq.pollLast();\\n            }\\n            dq.offerLast(j);\\n            \\n            // when  the window size is equal to K\\n            if(j-i+1==k)\\n            {\\n                // Using the Calculation to take out the ans\\n                res[t++]=nums[dq.peekFirst()];\\n                i++;\\n                if(dq.peekFirst()<i)\\n                    dq.pollFirst();\\n            }\\n            //when we don\\'t reach the window size just increment j\\n            if((j-i+1)<k)\\n                j++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n// If any doubts write in the comment section",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;\\n        int res[]=new int[n-k+1];\\n        Deque<Integer> dq=new LinkedList<>();\\n        int i=0,j=0;\\n        int t=0;\\n        while(j<n)\\n        {\\n            // Calculation\\n            while(!dq.isEmpty() && nums[dq.peekLast()]<nums[j])\\n            {\\n                dq.pollLast();\\n            }\\n            dq.offerLast(j);\\n            \\n            // when  the window size is equal to K\\n            if(j-i+1==k)\\n            {\\n                // Using the Calculation to take out the ans\\n                res[t++]=nums[dq.peekFirst()];\\n                i++;\\n                if(dq.peekFirst()<i)\\n                    dq.pollFirst();\\n            }\\n            //when we don\\'t reach the window size just increment j\\n            if((j-i+1)<k)\\n                j++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193149,
                "title": "fixed-size-sliding-window-deque",
                "content": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        from collections import deque\\n        q = deque() ;res = []\\n        j = 0 ; i = 0\\n        while j<len(nums):\\n            while q and nums[j]>q[-1]:\\n                q.pop()\\n            q.append(nums[j])\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                res.append(q[0])\\n                if q[0]==nums[i]:\\n                    q.popleft()\\n                i+=1\\n                j+=1\\n        return res\\n        #aditya verma sliding window format\\n\\t\\t```\\n            \\n                \\n                \\n            \\n        \\n                    \\n                    \\n",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        from collections import deque\\n        q = deque() ;res = []\\n        j = 0 ; i = 0\\n        while j<len(nums):\\n            while q and nums[j]>q[-1]:\\n                q.pop()\\n            q.append(nums[j])\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                res.append(q[0])\\n                if q[0]==nums[i]:\\n                    q.popleft()\\n                i+=1\\n                j+=1\\n        return res\\n        #aditya verma sliding window format\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 379706,
                "title": "python-o-n-monoqueue-with-detailed-explanation",
                "content": "This is one of the best problems for illustration of monotone queue usage. So the invariant is that we alwasy keep a monotone decreasing queue from left to right that contains the candidates within the current sliding window, and we always add new elements from right.\\n\\nFor each new element from `nums`, we first check left head of deque to judge if this oldest candidate should be eliminated if it is out of the current window. To do so, we should be able to read the index of the candidate, thus deque contains `(index, num)` pair. Now all elements in queue should be possible candidates. The observation is that all candidates `c\\'` with a value smaller than the current candidate `c` just added in should be eliminated, because `c\\'` will never be the biggest element from now on as they will always be in the same window as `c` from now on till they are out of the window. Another observation is that since the queue contains all the candidates and is monotonically decreasing, max element is simply the left head.\\n\\n```\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        from collections import deque\\n        queue = deque([])\\n        res = []\\n        for i, num in enumerate(nums):\\n            if queue and queue[0][0] <= i - k:\\n                queue.popleft()\\n            while queue and queue[-1][1] < num:\\n                queue.pop()\\n            queue.append((i,num))\\n            if i >= k-1:\\n                res.append(queue[0][1])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Monotonic Queue"
                ],
                "code": "```\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        from collections import deque\\n        queue = deque([])\\n        res = []\\n        for i, num in enumerate(nums):\\n            if queue and queue[0][0] <= i - k:\\n                queue.popleft()\\n            while queue and queue[-1][1] < num:\\n                queue.pop()\\n            queue.append((i,num))\\n            if i >= k-1:\\n                res.append(queue[0][1])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 66053,
                "title": "concise-java-solution-based-on-deque",
                "content": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: use two-ends deque to make the first element in the deque is the largest number in the window, and keep the above steps recursively.\\n\\n**Time complexity is O(n)**, as each number in the array is only offered or polled once.\\n\\nCode is as the following:\\n\\n    public int[] maxSlidingWindow(int[] a, int k) {\\n    \\t if (a == null || k <= 0) return new int[0];\\t\\t \\n    \\t int[] res = new int[a.length - k + 1];\\n    \\t ArrayDeque<Integer> deque = new ArrayDeque<Integer>(); \\n    \\t \\n    \\t int index  = 0;\\n    \\t for (int i = 0; i < a.length; i++) { \\n    \\t\\t while (!deque.isEmpty() && deque.peek() < i - k + 1) // Ensure deque's size doesn't exceed k\\n    \\t\\t\\t deque.poll();\\n    \\t\\t \\n    \\t\\t// Remove numbers smaller than a[i] from right(a[i-1]) to left, to make the first number in the deque the largest one in the window\\t\\t \\n    \\t\\t while (!deque.isEmpty() && a[deque.peekLast()] < a[i]) \\n    \\t\\t\\t deque.pollLast();\\n    \\t\\t \\n    \\t\\t deque.offer(i);// Offer the current index to the deque's tail\\n    \\t\\t \\n    \\t\\t if (i >= k - 1)// Starts recording when i is big enough to make the window has k elements \\n    \\t\\t\\t res[index++] = a[deque.peek()];\\n    \\t }\\t\\t \\n    \\t return res;\\n     }\\n\\n\\n  [1]: https://leetcode.com/discuss/46578/java-o-n-solution-using-deque-with-explanation",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nThe basic idea is referred from [here][1]: use two-ends deque to make the first element in the deque is the largest number in the window, and keep the above steps recursively.\\n\\n**Time complexity is O(n)**, as each number in the array is only offered or polled once.\\n\\nCode is as the following:\\n\\n    public int[] maxSlidingWindow(int[] a, int k) {\\n    \\t if (a == null || k <= 0) return new int[0];\\t\\t \\n    \\t int[] res = new int[a.length - k + 1];\\n    \\t ArrayDeque<Integer> deque = new ArrayDeque<Integer>(); \\n    \\t \\n    \\t int index  = 0;\\n    \\t for (int i = 0; i < a.length; i++) { \\n    \\t\\t while (!deque.isEmpty() && deque.peek() < i - k + 1) // Ensure deque's size doesn't exceed k\\n    \\t\\t\\t deque.poll();\\n    \\t\\t \\n    \\t\\t// Remove numbers smaller than a[i] from right(a[i-1]) to left, to make the first number in the deque the largest one in the window\\t\\t \\n    \\t\\t while (!deque.isEmpty() && a[deque.peekLast()] < a[i]) \\n    \\t\\t\\t deque.pollLast();\\n    \\t\\t \\n    \\t\\t deque.offer(i);// Offer the current index to the deque's tail\\n    \\t\\t \\n    \\t\\t if (i >= k - 1)// Starts recording when i is big enough to make the window has k elements \\n    \\t\\t\\t res[index++] = a[deque.peek()];\\n    \\t }\\t\\t \\n    \\t return res;\\n     }\\n\\n\\n  [1]: https://leetcode.com/discuss/46578/java-o-n-solution-using-deque-with-explanation",
                "codeTag": "Unknown"
            },
            {
                "id": 3918502,
                "title": "java-nlogn-explanation-priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem completely says that one need to make a valid window and extract the maxm out of it. So the first approach is to use PriorityQueue.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are storing indices rather than the numbers in PriorityQueue because we need to check that number is valid for our window first before making it the answer of that window and extracting the maxm value using the comparator which compares both the indices on the bases of the nums[value].\\nFor a array of length n we will be having n-k+1 total windows.\\nThe first while loop eleminates all the indices which can not be a part of decision making window. For example let take example we are given k=3 and we are at index 3 so first window would be considered for number 0,1,2 and now as we are at index 3, so window would be 1,2,3 as we do i-k that would be 0 and if by chance 0 is having the maxm value then it would be remove else it would be in priortyQueue and doesnt contribute for the answer\\nLast if() is for creating the first valid window.\\n\\nOne can store a pair in priorityQueue and then check the  valid indices but for a better approach just compare the numbers in the comparator which makes it much easy to use and clean.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->Worst Case - O(nlogn)\\nFor the best case it would be (nlogk) \\n                                                    \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$\\xA0-->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n       PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->{\\n           return nums[b]-nums[a];\\n       });\\n       int n = nums.length;\\n       int [] ans = new int[n-k+1];\\n       int idx=0;\\n       for(int i=0;i<n;i++){\\n           while(pq.size()>0 && pq.peek()<=i-k){\\n               pq.remove();\\n           }\\n           pq.add(i);\\n           if(i>=k-1){\\n               ans[idx++]=nums[pq.peek()];\\n           }\\n       }\\n       return ans;\\n    }\\n}\\n```\\n![please upvote me.jpg](https://assets.leetcode.com/users/images/e2abed58-8b4f-4d2e-8130-51bff8adc8a9_1692198539.9632075.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n       PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->{\\n           return nums[b]-nums[a];\\n       });\\n       int n = nums.length;\\n       int [] ans = new int[n-k+1];\\n       int idx=0;\\n       for(int i=0;i<n;i++){\\n           while(pq.size()>0 && pq.peek()<=i-k){\\n               pq.remove();\\n           }\\n           pq.add(i);\\n           if(i>=k-1){\\n               ans[idx++]=nums[pq.peek()];\\n           }\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627185,
                "title": "easy-simple-o-n-solution-using-deque-c",
                "content": "# Intuition\\nwe need to pop the element from front as well as back so we can use deque for this as it is a data structure which allow you to insert and delete from any side of it.\\n\\n# Approach\\nwe have to make a k size window and find the max in it. so we will first push starting k elements with few rules:\\n\\n1)the first element of the dequwe should always be the largest.(for making this we will pop all smaller element from front if we encounter a large value until if comes to the start)\\n\\n2)if a smaller element is encounter then it is push back after the larger making a decreasing ordered deque.(this is done because a element smaller now can be largest for other k windows)\\n\\n3)if the front element index is out of the kth window range then we if pop it.(because in that window it will not exist so the next largest would come to first again)\\n\\n4)after pushing k element now we will push to ans the front of the deque as it will always have largest element in that kth window so just push it.\\n\\nby this we could solve the problem in O(n) time.\\n\\nEXPLAIN CODE BY  TEST CASE 1 \\n\\nexample: [1,3,-1,-3,5,3,6,7]\\n1) 1,3,-1 as 3 is larger than 1 so 1 will be pop.\\n2) 3,-1 now as k element have come we will starting pushing the values. ans : [3].\\n3) now we push the other element -3. 3,-1,-3 again 3 is the largest hence push to ans : [3,3].\\n4) now we push 5 the other all element are small hence removed [5].largest value is now push i.e 5. ans : [3,3,5]\\n5) 3 is push 5,3 no change as it is in correct order.5 is push again. ans : [3,3,5,5]\\n6) now 6 is push and remove all the element from start [6]. 6 is push in ans : [3,3,5,5,6]\\n7) now 7 is push and remove all the element form start [7]. 7 is now push in ans. ans : [3,3,5,5,6,7].\\n\\nhence answer would be : [3,3,5,5,6,7]\\n\\n**NOTE: we are performing all the operation on value but we need the index too so we will store the index of these element as by it we can access value as well.**\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n    vector<int> ans;\\n    deque<int> q;\\n    for(int i=0;i<nums.size();i++){\\n        if(q.empty())   q.push_back(i);\\n        else{\\n            if(q.front()<=i-k)  q.pop_front();\\n            while(!q.empty() and nums[i]>nums[q.back()])q.pop_back();\\n            q.push_back(i);\\n            }\\n        if(i>=k-1){\\n            ans.push_back(nums[q.front()]);\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```\\n\\n**IF YOU HAVE ANY DOUBT FEEL FREE TO ASK IN COMMENT\\nAND IF YOU LIKED THE ANSWER PLEASE DO UPVOTE :)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n    vector<int> ans;\\n    deque<int> q;\\n    for(int i=0;i<nums.size();i++){\\n        if(q.empty())   q.push_back(i);\\n        else{\\n            if(q.front()<=i-k)  q.pop_front();\\n            while(!q.empty() and nums[i]>nums[q.back()])q.pop_back();\\n            q.push_back(i);\\n            }\\n        if(i>=k-1){\\n            ans.push_back(nums[q.front()]);\\n        }\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565755,
                "title": "python-sliding-window-deque-explained",
                "content": "Lets first understand why we used a Deque here.\\n\\n## **WHAT IF WE TRY TO KEEP TRACK OF MAX ELEMENT IN EACH WINDOW?**\\n\\nWill this work? Lets see.\\n\\n\\t\\tnums = [1,3,-1,-3,5,3,6,7], k = 3\\n\\t\\t\\t\\ti\\n\\t\\t\\t\\tj\\n\\t\\t\\t\\tWindow Size = 1\\n\\t\\t\\t\\tmax = 1\\n\\nSo, i and j are both 0. So we have a max variable that keeps track of maximum in current window. Initially, max = first element = 1\\n\\nNow, since window size is not yet k, we increment j. In next iteration, jth element is 3. Because 3 > max, max = 3. Window size is 2\\n\\n\\t\\tnums = [1,3,-1,-3,5,3,6,7], k = 3\\n\\t\\t\\t\\ti\\n\\t\\t\\t      j\\n\\t\\t\\t\\tWindow Size = 2\\n\\t\\t\\t\\tmax = 3\\n\\nSince window size not yet k, increment j. Now, jth element is -1. Because -1 is not > max, max remains 3. \\n\\n\\t\\tnums = [1,3,-1,-3,5,3,6,7], k = 3\\n\\t\\t\\t\\ti\\n\\t\\t\\t         j\\n\\t\\t\\t\\tWindow Size = 3\\n\\t\\t\\t\\tmax = 3\\n\\nAnd now, the size of the window has become 3. It means, we can now put the max element for this window in output array. So we push 3 in output array.\\n\\nWe now want to slide the window i.e., increment i and j. Before incrementing i, we see if ith element is max element or not. Since it is not, we do nothing.\\n\\t\\t\\n\\t\\tnums = [1,3,-1,-3,5,3,6,7], k = 3\\n\\t\\t\\t\\t  i\\n\\t\\t\\t            j\\n\\t\\t\\t\\tWindow Size = 3\\n\\t\\t\\t\\tmax = 3\\n\\nSo, now, j points to index 3 i.e., element = -3. Since - 3 is not > 3 max remains 3. \\n\\nAgain, we push 3 into output.\\n\\nBut here comes the interesting part. Because now we are going to slide the window and i will be incremented. Since ith element = max. What to do now? We have to remove this max now but what is the new max? How to keep track of that? \\n\\nThis means, a single value variable will not be sufficient to keep track of maximum.\\n\\n## **USING A DEQUE TO KEEP TRACK OF MAXIMUM ELEMENTS IN A WINDOW?**\\n\\nA Deque allows insertion and deletion from both ends - left and right. We can use this data structure to keep all those values that \"might\" be useful in next windows. So, we not only keep the maximum but also the values after the maximum value because if the maximum value is to be removed when we slide the window, then when we remove that value from deque, then we have all the values after that maximum value in the window. \\n\\n\\tnums = [3,2,1,5] k = 3\\n\\n\\nAt jth index, we have 3. Since deque is empty, just push it in deque. deque right now is [3]\\n\\n\\t\\tnums = [3,2,1,5]\\n\\t\\t\\t    i\\n\\t\\t\\t\\tj\\n\\t\\t\\t\\tdeque = [3]\\n\\nSince window size is now 3 yet, increment j. \\n\\nAt j = 1 index we have 2. Here, 2 is not bigger than 3 but, 2 might be useful in the future windows.  So for this reason, we will put 2 in the deque. THIS IS IMPORTANT! We will put all the numbers in the deque that may be useful in future windows. \\n\\n\\t\\tnums = [3,2,1,5]\\n\\t\\t\\t    i\\n\\t\\t\\t\\t  j\\n\\t\\t\\t\\tdeque = [3,2]\\n\\nAgain, j is incremented. At j = 2, we have 1. For same reason as above, push 1 to deque. \\n\\n\\t\\tnums = [3,2,1,5]\\n\\t\\t\\t    i\\n\\t\\t\\t\\t    j\\n\\t\\t\\t\\tdeque = [3,2,1]\\n\\nAnd because we now found the window of length = k, For this window, the maximum is the first element in deque = 3. So push 3 in the output array.\\n\\nNow comes the interesting part. \\n\\nWe are going to slide this window which means i will be incremented to 1. But at i = 0, we have the max element of current window. So, that means, if this window is going to slide, this max element is also going to be removed from deque. And that\\'s why, if nums[i] == deque[0] before sliding the window, then remove deque[0] i.e., dequeue.popleft()\\n\\n\\t\\tnums = [3,2,1,5]\\n\\t\\t\\t      i\\n\\t\\t\\t\\t      j\\n\\t\\t\\t\\tdeque = [2,1]\\n\\nAt j, we have 5. Because 5 is bigger than all the elements in deque, it means now, no existing element in deque is useful for us since we found a bigger value in this window itself. This will be the case for all the windows where such situation occurs. So, before pushing 5 to deque, remove all the elements before it that are smaller than it. Only then push 5. \\n\\n\\t\\tnums = [3,2,1,5]\\n\\t\\t\\t      i\\n\\t\\t\\t\\t      j\\n\\t\\t\\t\\tdeque = [5]\\n\\nSo, before pushing 5 to the deque, remove all the numbers that are smaller than 5 from the deque from the right to left direction. i.e., from the rear of deque.\\n\\nAnd since window size is k, we take this first element of deque and push it into output array.\\n\\nAnd since j is now length of array. We break out of loop.\\n\\n\\n\\t\\tSo, for nums = [3,2,1,5] and k = 3, output is [3,5]\\n\\t\\t\\n## **WHY A DEQUE AND NOT A SIMPLE QUEUE?**\\nIf you are thinking why using a Queue will result in some test cases to fail, then here is the reason.\\n\\nIf you analyze what are we doing above, then you will see that when we are sliding the window, and in case the ith element is the first element in the deque, then we are removing it from the front of deque. i.e., popleft()\\n\\nAt the same time, when we are checking if jth element is bigger than the elements in Queue, then we are deleting the elements from the rear of the queue. i.e., pop()\\n\\nThis means, we are doing deletion from both ends and queue won\\'t be able to handle that because it allows deletion from only one end. \\n\\nThat is why, we use a deque here instead of a queue.\\n\\n\\n```\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        output = []\\n        maxQueue = deque()\\n\\n        i,j = 0,0\\n        n = len(nums)\\n\\n        while(j < n):\\n            #Remove all elements from deque that are smaller than current element at index j\\n            while(len(maxQueue) > 0 and nums[j] > maxQueue[-1]): maxQueue.pop()  \\n                \\n            #And once removed, then put the j index element in the Queue\\n            maxQueue.append(nums[j])\\n\\n            #Check Window size\\n            if(j - i + 1 < k): j += 1\\n            #If Window size = k\\n            else:\\n                #Put the maximum element in this window in the output\\n                output.append(maxQueue[0])\\n                \\n                #Before sliding the window, check if the element we are not going to include in next window is max element or not\\n                # It it is the max element, that means we remove it from deQue as well\\n                if(nums[i] == maxQueue[0]): maxQueue.popleft()\\n                #Slide the window\\n                i += 1\\n                j += 1\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        output = []\\n        maxQueue = deque()\\n\\n        i,j = 0,0\\n        n = len(nums)\\n\\n        while(j < n):\\n            #Remove all elements from deque that are smaller than current element at index j\\n            while(len(maxQueue) > 0 and nums[j] > maxQueue[-1]): maxQueue.pop()  \\n                \\n            #And once removed, then put the j index element in the Queue\\n            maxQueue.append(nums[j])\\n\\n            #Check Window size\\n            if(j - i + 1 < k): j += 1\\n            #If Window size = k\\n            else:\\n                #Put the maximum element in this window in the output\\n                output.append(maxQueue[0])\\n                \\n                #Before sliding the window, check if the element we are not going to include in next window is max element or not\\n                # It it is the max element, that means we remove it from deQue as well\\n                if(nums[i] == maxQueue[0]): maxQueue.popleft()\\n                #Slide the window\\n                i += 1\\n                j += 1\\n\\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2059348,
                "title": "maximum-of-minimum-for-every-window-size",
                "content": "```\\n// O(n) \\n\\nvector<int> previousSmaller(vector<int> &arr, int n) {\\n    vector<int> prev(n);\\n    stack<int> s;\\n    for (int i = 0; i < n; i++) {\\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\\n            s.pop();\\n        }\\n        if (s.empty()) {\\n            prev[i] = -1;\\n        } \\n        else {\\n            prev[i] = s.top();\\n        }\\n        s.push(i);\\n    }\\n    return prev;\\n}\\n\\nvector<int> nextSmaller(vector<int> &arr, int n) {\\n    stack<int> s;\\n    vector<int> next(n);\\n    for (int i = n - 1; i >= 0; i--) {\\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\\n            s.pop();\\n        }   \\n        if (s.empty()) {\\n            next[i] = n;\\n        } \\n        else {\\n            next[i] = s.top();\\n        }\\n        s.push(i);\\n    }\\n    return next;\\n}\\n\\nvector<int> maxMinWindow(vector<int> &arr, int n) {\\n    // answer[i] will store the maximum of minimum for every window size \\n    vector<int> answer(n, INT_MIN);\\n\\t\\n    // next[i] will store the index of next smaller element which lie on the right hand side of it\\n    vector<int> next = nextSmaller(arr, n);\\n\\n   //prev[i] will store the index of previous smaller element which lie on the left hand side of it\\n    vector<int> prev = previousSmaller(arr, n);\\n\\n    for (int i = 0; i < n; i++) {\\n        // Length of the window in which a[i] is minimum\\n        int length = next[i] - prev[i] - 1;\\n\\n        // Update the answer\\n        answer[length - 1] = max(answer[length - 1], arr[i]);\\n    }\\n\\n\\t// Some places in answer[] may not be filled yet.\\n\\t// so fill them by taking maximum \\n    for (int i = n - 2; i >= 0; i--) \\n    {\\n        answer[i] = max(answer[i], answer[i + 1]);\\n    }\\n    return answer;\\n}\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\n// O(n) \\n\\nvector<int> previousSmaller(vector<int> &arr, int n) {\\n    vector<int> prev(n);\\n    stack<int> s;\\n    for (int i = 0; i < n; i++) {\\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\\n            s.pop();\\n        }\\n        if (s.empty()) {\\n            prev[i] = -1;\\n        } \\n        else {\\n            prev[i] = s.top();\\n        }\\n        s.push(i);\\n    }\\n    return prev;\\n}\\n\\nvector<int> nextSmaller(vector<int> &arr, int n) {\\n    stack<int> s;\\n    vector<int> next(n);\\n    for (int i = n - 1; i >= 0; i--) {\\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\\n            s.pop();\\n        }   \\n        if (s.empty()) {\\n            next[i] = n;\\n        } \\n        else {\\n            next[i] = s.top();\\n        }\\n        s.push(i);\\n    }\\n    return next;\\n}\\n\\nvector<int> maxMinWindow(vector<int> &arr, int n) {\\n    // answer[i] will store the maximum of minimum for every window size \\n    vector<int> answer(n, INT_MIN);\\n\\t\\n    // next[i] will store the index of next smaller element which lie on the right hand side of it\\n    vector<int> next = nextSmaller(arr, n);\\n\\n   //prev[i] will store the index of previous smaller element which lie on the left hand side of it\\n    vector<int> prev = previousSmaller(arr, n);\\n\\n    for (int i = 0; i < n; i++) {\\n        // Length of the window in which a[i] is minimum\\n        int length = next[i] - prev[i] - 1;\\n\\n        // Update the answer\\n        answer[length - 1] = max(answer[length - 1], arr[i]);\\n    }\\n\\n\\t// Some places in answer[] may not be filled yet.\\n\\t// so fill them by taking maximum \\n    for (int i = n - 2; i >= 0; i--) \\n    {\\n        answer[i] = max(answer[i], answer[i + 1]);\\n    }\\n    return answer;\\n}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2014576,
                "title": "c-easy-solution-efficient-solution-using-deque-o-n",
                "content": "**Best Approach C++**\\n**Solved this using deque Data Structure In deque we have ( pop_front(),pop_back(),push_back(),push_front() ) and more.**\\n**I Recommend Dry Run a Example for Better Understanding of Code**\\n**If you have any doubt comment down**\\n**If you find it helpful kindly UPVOTE**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& v, int k) {\\n        // Here we are taking example 1 where v=[1,3,-1,-3,5,3,6,7] and k=3\\n        int n=v.size();\\n        vector<int> ans;\\n        deque<int>dq; // Double ended queue (push_back,push_front,front,back)\\n        \\n        dq.push_front(v[0]); //dq={1}\\n\\t    for(int i=1;i<k;i++)\\n\\t    {\\n\\t\\t    while(!dq.empty() && dq.back()<v[i])   // we will pop back element until it is empty or greater element of v[i] found \\n\\t\\t    dq.pop_back();\\t\\n                                                    \\n\\t    \\tdq.push_back(v[i]);                     \\n\\t    }\\n        //after this we will have dq={3,-1}\\n        ans.push_back(dq.front());                  //ans={3};\\n    \\tfor(int i=k;i<n;i++)    \\n\\t    {\\n\\t\\t    if(dq.front()==v[i-k])  // if front element of deque is equal to previous element of last window then we\\'ll pop it\\n    \\t\\tdq.pop_front();\\n    \\t\\t\\n    \\t\\twhile(!dq.empty() && dq.back()<v[i])    // Same thing we are doing here which we have done earlier in this code\\n    \\t\\tdq.pop_back();\\t\\t\\n            \\n    \\t\\tdq.push_back(v[i]); \\n            \\n            ans.push_back(dq.front());\\n    \\t}\\n        return ans;\\n    }\\n};\\n```\\n**If you find it helpful kindly UPVOTE**\\n[First Bad Version Solution](https://leetcode.com/problems/first-bad-version/discuss/1968674/binary-search-o-logn-startend-start2-c-0ms-faster-than-100-easy-solution)",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& v, int k) {\\n        // Here we are taking example 1 where v=[1,3,-1,-3,5,3,6,7] and k=3\\n        int n=v.size();\\n        vector<int> ans;\\n        deque<int>dq; // Double ended queue (push_back,push_front,front,back)\\n        \\n        dq.push_front(v[0]); //dq={1}\\n\\t    for(int i=1;i<k;i++)\\n\\t    {\\n\\t\\t    while(!dq.empty() && dq.back()<v[i])   // we will pop back element until it is empty or greater element of v[i] found \\n\\t\\t    dq.pop_back();\\t\\n                                                    \\n\\t    \\tdq.push_back(v[i]);                     \\n\\t    }\\n        //after this we will have dq={3,-1}\\n        ans.push_back(dq.front());                  //ans={3};\\n    \\tfor(int i=k;i<n;i++)    \\n\\t    {\\n\\t\\t    if(dq.front()==v[i-k])  // if front element of deque is equal to previous element of last window then we\\'ll pop it\\n    \\t\\tdq.pop_front();\\n    \\t\\t\\n    \\t\\twhile(!dq.empty() && dq.back()<v[i])    // Same thing we are doing here which we have done earlier in this code\\n    \\t\\tdq.pop_back();\\t\\t\\n            \\n    \\t\\tdq.push_back(v[i]); \\n            \\n            ans.push_back(dq.front());\\n    \\t}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746739,
                "title": "c-beats-99-o-n-time-o-n-space-no-deque-used-explained",
                "content": "Explaining with the help of this example:\\n\\n`` nums= [1,3,-1,-3,5,3,6,7], k = 3 ``\\n\\nWe shall be creating prefixMax and suffixMax arrays of n size each. These are made for our \\'partitions\\' of k size as shown:\\n```\\n//direction of finding max for prefixMax ----->\\n\\n\\t\\t\\t\\t\\t\\t\\t|       |\\n\\tprefixMaxArray= [1,3,3, |-3,5,5,|3,6,7]\\n\\t\\t\\t\\t\\t\\t\\t|       |\\n\\tsuffixMaxArray= [3,3,-1,| 5,5,3,|7,7,7]\\n\\t\\t\\t\\t\\t\\t\\t|       |\\n\\t\\t\\t\\t\\t\\t\\t\\n//direction of finding max for suffixMax <-----\\n\\n// \\'|\\' denotes \\'partitions\\' in array made to divide into boxes of k nums each (last box could have less nums)\\n```\\n\\nThen to find out max in a window of k size (required ans):\\n```\\n/*\\n\\t\\t\\t\\t |\\n\\t\\t\\t\\t | \\nfrom ith num <---|---> till (i+k-1)th num\\n\\t\\t\\t\\t |\\n\\t\\t\\t\\t |\\n\\t\\t\\t\\t \\nBasically just find max of all nos in the shown directions which can be done in O(1) time using our pre-created arrays. \\nCarry out this operation for all nums ie:-\\n*/\\t\\n\\n        vector<int> ans(n-k+1, 0);\\n        for(int i=0; i<n-k+1; i++){\\n            ans[i]= max(prefixMax[i+k-1], suffixMax[i]);\\n        }\\n```        \\n\\n**C++ code :**\\n```\\nvector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        \\n        int n= nums.size();\\n       \\n        vector<int> prefixMax(n, 0), suffixMax(n, 0);\\n        \\n        //creating the prefixMax array\\n        for(int i=0; i<n; i++){\\n            if(i%k==0) prefixMax[i]= nums[i]; //reset value \\n            else prefixMax[i]= max(prefixMax[i-1], nums[i]);      \\n        }\\n        \\n        //creating the suffixMax array\\n        suffixMax[n-1]= nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            if((i+1)%k==0) suffixMax[i]= nums[i]; //reset value\\n            else suffixMax[i]= max(suffixMax[i+1], nums[i]);\\n        }\\n        \\n        vector<int> ans(n-k+1, 0);\\n        \\n        for(int i=0; i<n-k+1; i++){\\n            ans[i]= max(prefixMax[i+k-1], suffixMax[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**Time complexity: O(n)\\nSpace complexity: O(n)**\\n\\nHope this helps :))\\n",
                "solutionTags": [],
                "code": "```\\n//direction of finding max for prefixMax ----->\\n\\n\\t\\t\\t\\t\\t\\t\\t|       |\\n\\tprefixMaxArray= [1,3,3, |-3,5,5,|3,6,7]\\n\\t\\t\\t\\t\\t\\t\\t|       |\\n\\tsuffixMaxArray= [3,3,-1,| 5,5,3,|7,7,7]\\n\\t\\t\\t\\t\\t\\t\\t|       |\\n\\t\\t\\t\\t\\t\\t\\t\\n//direction of finding max for suffixMax <-----\\n\\n// \\'|\\' denotes \\'partitions\\' in array made to divide into boxes of k nums each (last box could have less nums)\\n```\n```\\n/*\\n\\t\\t\\t\\t |\\n\\t\\t\\t\\t | \\nfrom ith num <---|---> till (i+k-1)th num\\n\\t\\t\\t\\t |\\n\\t\\t\\t\\t |\\n\\t\\t\\t\\t \\nBasically just find max of all nos in the shown directions which can be done in O(1) time using our pre-created arrays. \\nCarry out this operation for all nums ie:-\\n*/\\t\\n\\n        vector<int> ans(n-k+1, 0);\\n        for(int i=0; i<n-k+1; i++){\\n            ans[i]= max(prefixMax[i+k-1], suffixMax[i]);\\n        }\\n```\n```\\nvector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        \\n        int n= nums.size();\\n       \\n        vector<int> prefixMax(n, 0), suffixMax(n, 0);\\n        \\n        //creating the prefixMax array\\n        for(int i=0; i<n; i++){\\n            if(i%k==0) prefixMax[i]= nums[i]; //reset value \\n            else prefixMax[i]= max(prefixMax[i-1], nums[i]);      \\n        }\\n        \\n        //creating the suffixMax array\\n        suffixMax[n-1]= nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            if((i+1)%k==0) suffixMax[i]= nums[i]; //reset value\\n            else suffixMax[i]= max(suffixMax[i+1], nums[i]);\\n        }\\n        \\n        vector<int> ans(n-k+1, 0);\\n        \\n        for(int i=0; i<n-k+1; i++){\\n            ans[i]= max(prefixMax[i+k-1], suffixMax[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1681529,
                "title": "heap",
                "content": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        maxHeap, res = [], []\\n        for i in range(len(nums)):\\n            heappush(maxHeap, (-nums[i], i))\\n            if i >= k - 1:\\n                while maxHeap[0][1] <= i-k : #this is because the highest one is not in the window range\\n                    heappop(maxHeap)\\n                res.append(-maxHeap[0][0])\\n        return res\\n                \\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        maxHeap, res = [], []\\n        for i in range(len(nums)):\\n            heappush(maxHeap, (-nums[i], i))\\n            if i >= k - 1:\\n                while maxHeap[0][1] <= i-k : #this is because the highest one is not in the window range\\n                    heappop(maxHeap)\\n                res.append(-maxHeap[0][0])\\n        return res\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1054583,
                "title": "explanation-intuition-with-comments-and-code-c-priority-queue-approach",
                "content": "**Approach:**\\n1. We try using priority queue, which stores the maximum element at the top of the queue.\\n2. Our job is to find the maximum element from all possible windows of given size *k*, and store it in an answer vector to output it.\\n\\nExample: \\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [3,3,5,5,6,7]\\nExplanation: \\n```\\nWindow position                Max\\n---------------               -----\\n[1  3  -1] -3  5  3  6  7       3\\n 1 [3  -1  -3] 5  3  6  7       3\\n 1  3 [-1  -3  5] 3  6  7       5\\n 1  3  -1 [-3  5  3] 6  7       5\\n 1  3  -1  -3 [5  3  6] 7       6\\n 1  3  -1  -3  5 [3  6  7]      7\\n```\\nFrom the above example, we observe few hints to solve and get the output vector.\\n1. We make a window of given size k, and put it into out priority queue (pq). The top element of this pq, gives us the maximum of the 1st window.\\n2. Now, its observable in the example above, that the next window is obtained by sliding the window by one place.\\n3. Now, we need to find the maximum of this window. To get this, **we push the immediate next element of the last element of the previous window,** into pq. \\n4. But now, size of the window is k+1 (k size of prev window and the next element adds 1 more to it).\\n Hence we need to keep in consideration to check whether the largest element of the pq, is with the range of (i-k) to k.\\n \\n  *point no. 4 will become more clear, from the code*\\n  .\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& a, int k)\\n    {\\n        vector<int> ans;\\n        int n = a.size();\\n        priority_queue<pair<int, int>> pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!pq.empty() && pq.top().second<=(i-k)) //step no. 4\\n                pq.pop(); // if the top of the pq( the max element value of the window), is from an element outside of the k-sized window, we pop it\\n            \\n            pq.push({a[i], i}); // a priority queue, which stores elements of the array, with its corresponding index number.\\n            \\n            if(i >= k-1) // k sized window obtained, so we push the max element of it, into answer vector.\\n                ans.push_back(pq.top().first); \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nWindow position                Max\\n---------------               -----\\n[1  3  -1] -3  5  3  6  7       3\\n 1 [3  -1  -3] 5  3  6  7       3\\n 1  3 [-1  -3  5] 3  6  7       5\\n 1  3  -1 [-3  5  3] 6  7       5\\n 1  3  -1  -3 [5  3  6] 7       6\\n 1  3  -1  -3  5 [3  6  7]      7\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& a, int k)\\n    {\\n        vector<int> ans;\\n        int n = a.size();\\n        priority_queue<pair<int, int>> pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(!pq.empty() && pq.top().second<=(i-k)) //step no. 4\\n                pq.pop(); // if the top of the pq( the max element value of the window), is from an element outside of the k-sized window, we pop it\\n            \\n            pq.push({a[i], i}); // a priority queue, which stores elements of the array, with its corresponding index number.\\n            \\n            if(i >= k-1) // k sized window obtained, so we push the max element of it, into answer vector.\\n                ans.push_back(pq.top().first); \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959345,
                "title": "c-aditya-verma-guy-who-made-dp-easy-video-implementation",
                "content": "Main idea is..\\nwhen we are jth position the smaller number less than jth are useless but after jth is a possible candidate for max in the window...\\nalso popping from behind makes sense because ...suppose we are adding 0 and the window is 1 3 2... it will not pop because  0 < 1 ... i hope it clears.. thats what i faced when I was popping from front... i think by example you will not get it unless you intentionally pop from front and dry run...then  you will see ...\\nAnd also there should not be less than equal to in while condtion when popping...otherwise if there are two same numbers in that window it will pop out and it will store next value and that would be incorrect...\\nThese problems I faced when coding... feel free to share yours...\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        vector<int> res;\\n        deque<int> list;\\n        int n = arr.size();\\n        int i = 0;\\n        int j = 0;\\n\\n        while(j < n){\\n\\n            while(!list.empty() && list.back() < arr[j]){\\n                // cout << \"popping from the list... \" << list.back() << endl;\\n                list.pop_back();\\n            }\\n            \\n            // cout << \"pushing to the list... \" << arr[j] << endl;\\n            list.push_back(arr[j]);\\n            // cout << \"front of the list... \" << list.front() << endl;\\n            \\n            if(j-i+1 < k){\\n                j++;\\n            }\\n\\n            else if(j-i+1 == k){ //actual window\\n                res.push_back(list.front());\\n                if(list.front() == arr[i]){ \\n                    //just checking \\'going to be popped\\' element is not the maximum of \\n                    //the subarray of the current window before sliding it\\n                    list.pop_front();\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n        }\\n        // cout << \"j went to \" << j << endl;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        vector<int> res;\\n        deque<int> list;\\n        int n = arr.size();\\n        int i = 0;\\n        int j = 0;\\n\\n        while(j < n){\\n\\n            while(!list.empty() && list.back() < arr[j]){\\n                // cout << \"popping from the list... \" << list.back() << endl;\\n                list.pop_back();\\n            }\\n            \\n            // cout << \"pushing to the list... \" << arr[j] << endl;\\n            list.push_back(arr[j]);\\n            // cout << \"front of the list... \" << list.front() << endl;\\n            \\n            if(j-i+1 < k){\\n                j++;\\n            }\\n\\n            else if(j-i+1 == k){ //actual window\\n                res.push_back(list.front());\\n                if(list.front() == arr[i]){ \\n                    //just checking \\'going to be popped\\' element is not the maximum of \\n                    //the subarray of the current window before sliding it\\n                    list.pop_front();\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n        }\\n        // cout << \"j went to \" << j << endl;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 864529,
                "title": "java-deque-visualization-with-code",
                "content": "```\\n\\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [3,3,5,5,6,7]\\n\\nUsing Deque: \\nWindow position\\t\\t\\t\\t Max   Deque\\n---------------\\t\\t\\t\\t ---   \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n i=0\\n[1] 3  -1  -3  5  3  6  7\\t\\t    -\\t        1. if first index in Q(deque) < i-k+1 ? no-> so no poll()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t-\\t\\t\\t2. loop: nums[i] > last element of the Q(Deque)? no -> so no pollLast()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1(0)\\t\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  -\\t\\t1(0)\\t\\t4. (i >= k - 1) no -> [window is incomplete].\\n\\ti=1\\t\\t\\t\\t\\t\\t\\t\\t\\n[1  3] -1  -3  5  3  6  7\\t\\t\\t1(0)\\t\\t1. if first index in Q(deque) < i-k+1 ? no-> so no poll) \\n\\t   \\t\\t\\t\\t\\t\\t\\t\\t-\\t\\t\\t2. loop: nums[i] > last element of the Q(Deque)? yes->so pollLast() -> 1(0) polled\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1)    \\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  -\\t\\t3(1)\\t    4. (i >= k - 1) no -> [window is incomplete]. \\n\\t   i=2\\n[1  3  -1] -3  5  3  6  7\\t\\t\\t3(1)\\t\\t1. if first index in Q(deque) < i-k+1 ? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1)\\t\\t2. loop : nums[i] > last element of the Q(Deque)? no -> so no pollLast()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1),-1(2)\\t3. offer (i)\\t\\n\\t\\t\\t\\t\\t\\t\\t  3\\t\\t3(1),-1(2)\\t4. (i >= k - 1) yes -> output q.peek();\\n\\t\\t  i=3\\t\\t\\t\\t\\t    \\t\\n 1 [3  -1  -3] 5  3  6  7 \\t\\t\\t3(1),-1(2)  1. if first index in Q(deque) < i-k+1 ? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1),-1(2)\\t2. loop: nums[i] > last element of the Q(Deque)? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1),-1(2),-3(3)\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  3\\t\\t3(1),-1(2),-3(3)\\t4. (i >= k - 1) yes -> output q.peek();\\n\\t\\t\\t  i=4\\n 1  3 [-1  -3  5] 3  6  7\\t\\t\\t-1(2),-3(3)   \\t1. if first index in Q(deque) < i-k+1 ? yes-> so poll() -> 3(1) polled \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t-\\t\\t\\t2. loop: nums[i] > last element of the Q(Deque)? yes -> so pollLast() -> -3(3) polled, -1(2) polled\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t5(4)\\t\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  5\\t\\t5(4)\\t\\t4. (i >= k - 1) yes -> output q.peek();\\n\\t\\t\\t     i=5\\t\\n 1  3  -1 [-3  5  3] 6  7\\t\\t\\t5(4)\\t\\t1. if first index in Q(deque) < i-k+1 ? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t5(4)\\t\\t2. loop: nums[i] > last element of the Q(Deque)? no -> so no pollLast()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t5(4),3(5)\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  5\\t\\t5(4),3(5)\\t4. (i >= k - 1) yes -> output q.peek();\\n\\t\\t\\t        i=6\\t\\t\\n 1  3  -1  -3 [5  3  6] 7\\t\\t\\t5(4),3(5)\\t1. if first index in Q(deque) < i-k+1 ? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\u2014\\t\\t\\t2. loop: nums[i] > last element of the Q(Deque)? yes -> so pollLast() -> 3(5) & 5(4) polled\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t6(6)\\t\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  6\\t\\t6(6)\\t\\t4. (i >= k - 1) yes -> output q.peek();\\n\\n 1  3  -1  -3  5 [3  6  7]    7\\t\\t...\\n\\n\\nclass Solution {\\n    \\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        \\n        if(nums==null||nums.length==0 ) \\n            return new int[0];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n    \\n        int[] ans = new int[nums.length-k+1];\\n        int ians=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            // 1. if first index in  Q(Deque) < i-k+1\\n            if(!queue.isEmpty() && queue.peek() < i-k+1){\\n                queue.poll();\\n            }    \\n            \\n            // 2. loop: nums[i] > last element of the Q(Deque)?\\n            while(!queue.isEmpty() && nums[i] > nums[queue.peekLast()]){\\n                queue.pollLast();\\n            }\\n            \\n            // 3. offer(i)\\n            queue.offer(i);\\n            \\n            // 4. if window is complete then ouput nums[peek()]\\n            if(i>= k-1){ // OR   i-k+1 >= 0\\n                ans[ians++] = nums[queue.peek()];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n\\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [3,3,5,5,6,7]\\n\\nUsing Deque: \\nWindow position\\t\\t\\t\\t Max   Deque\\n---------------\\t\\t\\t\\t ---   \\u2014\\u2014\\u2014\\u2014\\u2014\\u2014\\n i=0\\n[1] 3  -1  -3  5  3  6  7\\t\\t    -\\t        1. if first index in Q(deque) < i-k+1 ? no-> so no poll()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t-\\t\\t\\t2. loop: nums[i] > last element of the Q(Deque)? no -> so no pollLast()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1(0)\\t\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  -\\t\\t1(0)\\t\\t4. (i >= k - 1) no -> [window is incomplete].\\n\\ti=1\\t\\t\\t\\t\\t\\t\\t\\t\\n[1  3] -1  -3  5  3  6  7\\t\\t\\t1(0)\\t\\t1. if first index in Q(deque) < i-k+1 ? no-> so no poll) \\n\\t   \\t\\t\\t\\t\\t\\t\\t\\t-\\t\\t\\t2. loop: nums[i] > last element of the Q(Deque)? yes->so pollLast() -> 1(0) polled\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1)    \\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  -\\t\\t3(1)\\t    4. (i >= k - 1) no -> [window is incomplete]. \\n\\t   i=2\\n[1  3  -1] -3  5  3  6  7\\t\\t\\t3(1)\\t\\t1. if first index in Q(deque) < i-k+1 ? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1)\\t\\t2. loop : nums[i] > last element of the Q(Deque)? no -> so no pollLast()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1),-1(2)\\t3. offer (i)\\t\\n\\t\\t\\t\\t\\t\\t\\t  3\\t\\t3(1),-1(2)\\t4. (i >= k - 1) yes -> output q.peek();\\n\\t\\t  i=3\\t\\t\\t\\t\\t    \\t\\n 1 [3  -1  -3] 5  3  6  7 \\t\\t\\t3(1),-1(2)  1. if first index in Q(deque) < i-k+1 ? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1),-1(2)\\t2. loop: nums[i] > last element of the Q(Deque)? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t3(1),-1(2),-3(3)\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  3\\t\\t3(1),-1(2),-3(3)\\t4. (i >= k - 1) yes -> output q.peek();\\n\\t\\t\\t  i=4\\n 1  3 [-1  -3  5] 3  6  7\\t\\t\\t-1(2),-3(3)   \\t1. if first index in Q(deque) < i-k+1 ? yes-> so poll() -> 3(1) polled \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t-\\t\\t\\t2. loop: nums[i] > last element of the Q(Deque)? yes -> so pollLast() -> -3(3) polled, -1(2) polled\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t5(4)\\t\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  5\\t\\t5(4)\\t\\t4. (i >= k - 1) yes -> output q.peek();\\n\\t\\t\\t     i=5\\t\\n 1  3  -1 [-3  5  3] 6  7\\t\\t\\t5(4)\\t\\t1. if first index in Q(deque) < i-k+1 ? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t5(4)\\t\\t2. loop: nums[i] > last element of the Q(Deque)? no -> so no pollLast()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t5(4),3(5)\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  5\\t\\t5(4),3(5)\\t4. (i >= k - 1) yes -> output q.peek();\\n\\t\\t\\t        i=6\\t\\t\\n 1  3  -1  -3 [5  3  6] 7\\t\\t\\t5(4),3(5)\\t1. if first index in Q(deque) < i-k+1 ? no-> so no poll() \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\u2014\\t\\t\\t2. loop: nums[i] > last element of the Q(Deque)? yes -> so pollLast() -> 3(5) & 5(4) polled\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t6(6)\\t\\t3. offer(i)\\n\\t\\t\\t\\t\\t\\t\\t  6\\t\\t6(6)\\t\\t4. (i >= k - 1) yes -> output q.peek();\\n\\n 1  3  -1  -3  5 [3  6  7]    7\\t\\t...\\n\\n\\nclass Solution {\\n    \\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        \\n        if(nums==null||nums.length==0 ) \\n            return new int[0];\\n        \\n        Deque<Integer> queue = new ArrayDeque<>();\\n    \\n        int[] ans = new int[nums.length-k+1];\\n        int ians=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            // 1. if first index in  Q(Deque) < i-k+1\\n            if(!queue.isEmpty() && queue.peek() < i-k+1){\\n                queue.poll();\\n            }    \\n            \\n            // 2. loop: nums[i] > last element of the Q(Deque)?\\n            while(!queue.isEmpty() && nums[i] > nums[queue.peekLast()]){\\n                queue.pollLast();\\n            }\\n            \\n            // 3. offer(i)\\n            queue.offer(i);\\n            \\n            // 4. if window is complete then ouput nums[peek()]\\n            if(i>= k-1){ // OR   i-k+1 >= 0\\n                ans[ians++] = nums[queue.peek()];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777481,
                "title": "step-by-step-explanation-optimized-approach-using-deque-brute-force",
                "content": "# Brute-Force Solution\\nWe can solve this problem using a simple and straightforward approach called brute force. It involves using two loops: an outer loop that goes through the entire array and an inner loop that keeps track of a window size, focusing on the portion of the array where the maximum element is found.\"\\n\\nIn this approach, we systematically examine each element of the array using the outer loop. The inner loop helps us maintain a specific window or subset of elements, which is centered around the location of the maximum element\\n\\n# Code \\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n      int max=0;\\n      int arr[] = new int[nums.length-k+1];\\n      int r=0;\\n      for(int i=0;i<=nums.length-k;i++)\\n      {\\n         max=nums[i];\\n         for(int j =1;j<k;j++)\\n          {\\n            if(nums[i+j]>max)\\n             {\\n                max = nums[i+j];\\n             }\\n          }\\n         arr[r++] = max;\\n      }  \\n      return arr;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n\\n# Optimized Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe second optimized approach involves using a data structure called deque, which allows us to easily add and remove elements from both ends of the structure. We choose deque because it provides the functionality we need for this problem.\\n\\nThere are four main steps involved in this approach:\\n\\n1. In each iteration, we check the size of the window. If it is greater than the given size, we remove the last entered element from the deque.\\n\\n2. In each iteration, we attempt to remove all the smallest elements that are unnecessary from the deque. We do this by checking a condition, specifically if the element at the last position of the deque is smaller than the current element being processed, denoted as nums[dq.peekLast()] < nums[i].\\n\\n3. We add the current element to the deque.\\n\\n4. Finally, we add the maximum element in the resultant array if it exists within the given window.\"\\n\\nBy following these steps and utilizing the deque data structure, we can optimize our solution to efficiently handle the problem at hand.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        // 1 2 3 1 4 5 2 3 6\\n        Deque<Integer> dq = new LinkedList<Integer>();\\n        int res[] = new int[nums.length-k+1];\\n        int r=0;\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            //check window size\\n            //2==0 iteration 4\\n            if(!dq.isEmpty() && dq.peek()==i-k)\\n            {\\n                dq.poll();\\n               //remove 5 iteration 8\\n            }\\n\\n           //remove small element exist in the window\\n           while(!dq.isEmpty() && nums[dq.peekLast()]<nums[i])\\n             {\\n                dq.pollLast();\\n                //remove 1(index =0) || iteration 2\\n                //remove 2(index =1) || iteration 3\\n                //remove 1,3(index =3,2) || iteration 5 \\n                //remove 4(index =4) || iteration 6\\n                //remove 3,4 (index =7,6) iteration 9\\n             }\\n          //add element index\\n          dq.offer(i);\\n           //add 1 || iteration 1 [0]\\n            //add 2 || iteration 2 [1]\\n            //add 3 || iteration 3 [2]\\n            //add 1 || iteration 4 [2,3]\\n            //add 4 || iteration 5 [4]\\n             //add 5 || iteration 6 [5]\\n             // add 2 || iteration 7 [5,6]\\n             //add 3 ||. iteration 8 [5,6,7]\\n             //add 6|| iteration 9 [8]\\n\\n          // add largest element which exist into k window into the result array \\n          if(i>=k-1)\\n          {\\n              res[r++]=nums[dq.peek()];\\n               //add 3 || iteration 3\\n              //add 3 || iteration 4\\n              //add 4 || iteration 5\\n              //add 5 || iteration 6\\n              //add 5 || iteration 7\\n              //add 5 || iteration 8\\n              //add 6 || iteration 9\\n          }\\n        \\n        }\\n  return arr;  \\n}}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n      int max=0;\\n      int arr[] = new int[nums.length-k+1];\\n      int r=0;\\n      for(int i=0;i<=nums.length-k;i++)\\n      {\\n         max=nums[i];\\n         for(int j =1;j<k;j++)\\n          {\\n            if(nums[i+j]>max)\\n             {\\n                max = nums[i+j];\\n             }\\n          }\\n         arr[r++] = max;\\n      }  \\n      return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        // 1 2 3 1 4 5 2 3 6\\n        Deque<Integer> dq = new LinkedList<Integer>();\\n        int res[] = new int[nums.length-k+1];\\n        int r=0;\\n        for(int i =0;i<nums.length;i++)\\n        {\\n            //check window size\\n            //2==0 iteration 4\\n            if(!dq.isEmpty() && dq.peek()==i-k)\\n            {\\n                dq.poll();\\n               //remove 5 iteration 8\\n            }\\n\\n           //remove small element exist in the window\\n           while(!dq.isEmpty() && nums[dq.peekLast()]<nums[i])\\n             {\\n                dq.pollLast();\\n                //remove 1(index =0) || iteration 2\\n                //remove 2(index =1) || iteration 3\\n                //remove 1,3(index =3,2) || iteration 5 \\n                //remove 4(index =4) || iteration 6\\n                //remove 3,4 (index =7,6) iteration 9\\n             }\\n          //add element index\\n          dq.offer(i);\\n           //add 1 || iteration 1 [0]\\n            //add 2 || iteration 2 [1]\\n            //add 3 || iteration 3 [2]\\n            //add 1 || iteration 4 [2,3]\\n            //add 4 || iteration 5 [4]\\n             //add 5 || iteration 6 [5]\\n             // add 2 || iteration 7 [5,6]\\n             //add 3 ||. iteration 8 [5,6,7]\\n             //add 6|| iteration 9 [8]\\n\\n          // add largest element which exist into k window into the result array \\n          if(i>=k-1)\\n          {\\n              res[r++]=nums[dq.peek()];\\n               //add 3 || iteration 3\\n              //add 3 || iteration 4\\n              //add 4 || iteration 5\\n              //add 5 || iteration 6\\n              //add 5 || iteration 7\\n              //add 5 || iteration 8\\n              //add 6 || iteration 9\\n          }\\n        \\n        }\\n  return arr;  \\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551030,
                "title": "easy-c-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**HERE WE USE SLIDING WINDOW CONCEPT:**\\n*Sliding window is used when:-\\n1.If array/string/vector is given \\n2.If window size is given\\n3.If target/max/min/sum/product etc are asked for all windows or any window*\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*We take a list . Add all possible max elements for the current window in a list. and get the answer from it. Each time we add a new element into the list , we remove all smaller elements than that new element from the list .*\\n ***PROPER EXPLANATION WITH CODE IS GIVEN BELOW:***\\n*use sliding window:*\\n\\n# Complexity\\n- **Time complexity:**\\n- O(n)\\n- *n = size of given vector/array*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n-**Space complexity:**\\n- O(k) \\n- *k = size of window*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n//taking two pointers i and j\\n//At the beginning both i and j with point at first index\\n        int i = 0;\\n        int j = 0;\\n        int size = nums.size();\\n//creating a list to store all possible max elements temporarily \\n        list<int>l;\\n        vector<int>ans;\\n        while(j<size){\\n//removing all elements from list which are lesser than the element we are going to add\\n            while(!l.empty() && l.back()<nums[j]){\\n                l.pop_back();\\n            }\\n//pushing new element into the list\\n            l.push_back(nums[j]);\\n            if(j-i+1<k){\\n//taking j pointer to end of the first window\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n//if window size reached then push the front element of list into the answer vector\\n              ans.push_back(l.front());\\n//if front of list is equal to front element of sliding window \\n//then we need to remove that element from list \\n//because it is exiting out of current window \\n// so we have no use of that element\\n//hence we remove that element\\n              if(l.front()==nums[i]){\\n                  l.pop_front();\\n              }\\n//sliding the window by one index\\n              i++;\\n              j++;\\n            }\\n        }\\n//returning the answer vector consisting of all max elements\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n//taking two pointers i and j\\n//At the beginning both i and j with point at first index\\n        int i = 0;\\n        int j = 0;\\n        int size = nums.size();\\n//creating a list to store all possible max elements temporarily \\n        list<int>l;\\n        vector<int>ans;\\n        while(j<size){\\n//removing all elements from list which are lesser than the element we are going to add\\n            while(!l.empty() && l.back()<nums[j]){\\n                l.pop_back();\\n            }\\n//pushing new element into the list\\n            l.push_back(nums[j]);\\n            if(j-i+1<k){\\n//taking j pointer to end of the first window\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n//if window size reached then push the front element of list into the answer vector\\n              ans.push_back(l.front());\\n//if front of list is equal to front element of sliding window \\n//then we need to remove that element from list \\n//because it is exiting out of current window \\n// so we have no use of that element\\n//hence we remove that element\\n              if(l.front()==nums[i]){\\n                  l.pop_front();\\n              }\\n//sliding the window by one index\\n              i++;\\n              j++;\\n            }\\n        }\\n//returning the answer vector consisting of all max elements\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340960,
                "title": "c-java-python-easy-to-understand-with-deque-and-sliding-window",
                "content": "Let me make it easier for you to understand. We\\'ll use a deque here in order to keep track of elements that we can consider in our answer and a sliding window with a starting and an ending index. The approach goes like this:\\n1. **Starting index of our window is `start index + 1`** and  **end index of answer lies in the range: `[k - 1, n - 1]`** where `start index + 1 = end index - k` simply because `size of window = end index - start index + 1`.\\n2. Check if we should not consider `start index` and **remove** it from the **front of the deque** while moving the window as we will be standing at `start index + 1`.\\n3. Check if we can **remove more elements from the back of the deque** if the **current element is greater** than it. This is done as to make sure **we consider the greater one in our answer**. \\n4. After these considerations, you can **add element\\'s index** (or the element) inside the deque **from the back**.\\n5. Add the element whose index is at the **front of the deque into the max sliding window answer**.\\n\\n1  ,  3,  -1,   -3,   5,   3,   6,   7   <- at the start\\ne\\n\\n1  ,  3,  -1,   -3,   5,   3,   6,   7    <- from here we\\'ll start adding elements into answer\\ns _____e\\n\\n*\\u2714 Time complexity: O(n)\\n\\u2714 Space complexity: O(k)*\\n  \\nImplementations:\\n\\n\\u2611 C++:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1 or k == 1) return nums;\\n        \\n        vector<int> maxInWindow;\\n        deque<int> dq;\\n        \\n        // our sliding window exists in the range [startIdx + 1, endIdx]\\n        for(int endIdx = 0; endIdx < n; ++endIdx) {\\n            int startIdx = endIdx - k;\\n            // slide the window forward and hence remove it from the front of the deque\\n            if(!dq.empty() and dq.front() == startIdx)\\n                dq.pop_front();\\n            // before adding any index check if we can remove some elements in the deque from the end which \\n            // are smaller than this element that is to be added and can be a potential entry in our array\\n            while(!dq.empty() and nums[endIdx] > nums[dq.back()])\\n                dq.pop_back();\\n            // having taken all the above conditions into account now we can add the index inside our deque\\n            dq.push_back(endIdx);\\n            // start adding the candidates as answer \\n            // whichever element\\'s index is there on the front in deque is our answer now\\n            if(endIdx >= k - 1) \\n                maxInWindow.push_back(nums[dq.front()]);\\n        }\\n        \\n        return maxInWindow;\\n    }\\n};\\n```\\n\\n\\u2611 Java:\\n\\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n == 1 || k == 1) return nums;\\n        \\n        int[] maxInWindow = new int[n - k + 1];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        \\n        // our sliding window exists in the range [startIdx + 1, endIdx]\\n        for(int endIdx = 0; endIdx < n; ++endIdx) {\\n            int startIdx = endIdx - k;\\n            // slide the window forward and hence remove it from the front of the deque\\n            if(!dq.isEmpty() && dq.getFirst() == startIdx)\\n                dq.removeFirst();\\n            // before adding any index check if we can remove some elements in the deque from the end which \\n            // are smaller than this element that is to be added and can be a potential entry in our array\\n            while(!dq.isEmpty() && nums[endIdx] > nums[dq.getLast()])\\n                dq.removeLast();\\n            // having taken all the above conditions into account now we can add the index inside our deque\\n            dq.add(endIdx);\\n            // start adding the candidates as answer \\n            // whichever element\\'s index is there on the front in deque is our answer now\\n            if(endIdx >= k - 1)\\n                maxInWindow[endIdx - k + 1] = nums[dq.getFirst()];\\n        }\\n        return maxInWindow;\\n    }\\n}\\n```\\n\\n\\u2611 Python:\\n\\n```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if n == 1 or k == 1: return nums\\n        \\n        maxInWindow = [0] * (n - k + 1)\\n        dq = deque()\\n        \\n        # our sliding window exists in the range [startIdx + 1, endIdx]\\n        for endIdx in range (0, n):\\n            startIdx = endIdx - k\\n            # slide the window forward and hence remove it from the front of the deque\\n            if dq and dq[0] == startIdx:\\n                dq.popleft()\\n            # before adding any index check if we can remove some elements in the deque from the end which \\n            # are smaller than this element that is to be added and can be a potential entry in our array\\n            while dq and nums[endIdx] > nums[dq[-1]]:\\n                dq.pop()\\n            # having taken all the above conditions into account now we can add the index inside our deque\\n            dq.append(endIdx)\\n            # start adding the candidates as answer \\n            # whichever element\\'s index is there on the front in deque is our answer now\\n            if endIdx >= k - 1:\\n                maxInWindow[endIdx - k + 1] = nums[dq[0]]\\n                \\n        return maxInWindow\\n```\\n\\n\\uD83D\\uDCAF Thanks a lot for reading.\\nAn upvote would be appreciated!  ^_^",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(n == 1 or k == 1) return nums;\\n        \\n        vector<int> maxInWindow;\\n        deque<int> dq;\\n        \\n        // our sliding window exists in the range [startIdx + 1, endIdx]\\n        for(int endIdx = 0; endIdx < n; ++endIdx) {\\n            int startIdx = endIdx - k;\\n            // slide the window forward and hence remove it from the front of the deque\\n            if(!dq.empty() and dq.front() == startIdx)\\n                dq.pop_front();\\n            // before adding any index check if we can remove some elements in the deque from the end which \\n            // are smaller than this element that is to be added and can be a potential entry in our array\\n            while(!dq.empty() and nums[endIdx] > nums[dq.back()])\\n                dq.pop_back();\\n            // having taken all the above conditions into account now we can add the index inside our deque\\n            dq.push_back(endIdx);\\n            // start adding the candidates as answer \\n            // whichever element\\'s index is there on the front in deque is our answer now\\n            if(endIdx >= k - 1) \\n                maxInWindow.push_back(nums[dq.front()]);\\n        }\\n        \\n        return maxInWindow;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        if(n == 1 || k == 1) return nums;\\n        \\n        int[] maxInWindow = new int[n - k + 1];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        \\n        // our sliding window exists in the range [startIdx + 1, endIdx]\\n        for(int endIdx = 0; endIdx < n; ++endIdx) {\\n            int startIdx = endIdx - k;\\n            // slide the window forward and hence remove it from the front of the deque\\n            if(!dq.isEmpty() && dq.getFirst() == startIdx)\\n                dq.removeFirst();\\n            // before adding any index check if we can remove some elements in the deque from the end which \\n            // are smaller than this element that is to be added and can be a potential entry in our array\\n            while(!dq.isEmpty() && nums[endIdx] > nums[dq.getLast()])\\n                dq.removeLast();\\n            // having taken all the above conditions into account now we can add the index inside our deque\\n            dq.add(endIdx);\\n            // start adding the candidates as answer \\n            // whichever element\\'s index is there on the front in deque is our answer now\\n            if(endIdx >= k - 1)\\n                maxInWindow[endIdx - k + 1] = nums[dq.getFirst()];\\n        }\\n        return maxInWindow;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if n == 1 or k == 1: return nums\\n        \\n        maxInWindow = [0] * (n - k + 1)\\n        dq = deque()\\n        \\n        # our sliding window exists in the range [startIdx + 1, endIdx]\\n        for endIdx in range (0, n):\\n            startIdx = endIdx - k\\n            # slide the window forward and hence remove it from the front of the deque\\n            if dq and dq[0] == startIdx:\\n                dq.popleft()\\n            # before adding any index check if we can remove some elements in the deque from the end which \\n            # are smaller than this element that is to be added and can be a potential entry in our array\\n            while dq and nums[endIdx] > nums[dq[-1]]:\\n                dq.pop()\\n            # having taken all the above conditions into account now we can add the index inside our deque\\n            dq.append(endIdx)\\n            # start adding the candidates as answer \\n            # whichever element\\'s index is there on the front in deque is our answer now\\n            if endIdx >= k - 1:\\n                maxInWindow[endIdx - k + 1] = nums[dq[0]]\\n                \\n        return maxInWindow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309219,
                "title": "c-solved-my-first-ever-leetcode-hard-question",
                "content": "```\\n// It\\'s been a great journey on leetcode \\n// from not being able to do an easy array question 6 months ago \\n// to this day. more to go ;)\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) \\n    {\\n        vector<int> result;\\n        deque<int> dq;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while (j < nums.size()) {\\n            while (dq.size() > 0 && dq.back() < nums[j]) {\\n                dq.pop_back();\\n            }   \\n            dq.push_back(nums[j]);\\n            if (j - i + 1 < k) {\\n                j++;\\n            }\\n            else if (j - i + 1 == k) {\\n                result.push_back(dq.front());\\n                if (nums[i] == dq.front()) {\\n                    dq.pop_front();\\n                }\\n                i++;\\n                j++;\\n            }\\n        }      \\n    \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n// It\\'s been a great journey on leetcode \\n// from not being able to do an easy array question 6 months ago \\n// to this day. more to go ;)\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) \\n    {\\n        vector<int> result;\\n        deque<int> dq;\\n        \\n        int i = 0;\\n        int j = 0;\\n        \\n        while (j < nums.size()) {\\n            while (dq.size() > 0 && dq.back() < nums[j]) {\\n                dq.pop_back();\\n            }   \\n            dq.push_back(nums[j]);\\n            if (j - i + 1 < k) {\\n                j++;\\n            }\\n            else if (j - i + 1 == k) {\\n                result.push_back(dq.front());\\n                if (nums[i] == dq.front()) {\\n                    dq.pop_front();\\n                }\\n                i++;\\n                j++;\\n            }\\n        }      \\n    \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66027,
                "title": "python-simple-solution",
                "content": "    def maxSlidingWindow(self, nums, k):\\n        ans = []\\n        queue = []\\n        for i, v in enumerate(nums):\\n            if queue and queue[0] <= i - k:\\n                queue = queue[1:]\\n            while queue and nums[queue[-1]] < v:\\n                queue.pop()\\n            queue.append(i)\\n            if i + 1 >= k:\\n                ans.append(nums[queue[0]])\\n        return ans",
                "solutionTags": [],
                "code": "    def maxSlidingWindow(self, nums, k):\\n        ans = []\\n        queue = []\\n        for i, v in enumerate(nums):\\n            if queue and queue[0] <= i - k:\\n                queue = queue[1:]\\n            while queue and nums[queue[-1]] < v:\\n                queue.pop()\\n            queue.append(i)\\n            if i + 1 >= k:\\n                ans.append(nums[queue[0]])\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 66132,
                "title": "10-lines-c-o-n-log-k-using-multiset",
                "content": "    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> out;\\n        multiset<int> window;\\n        for (int i=0; i<nums.size(); i++) {\\n            window.insert(nums[i]);\\n            if (i >= k - 1) {\\n                out.push_back(*window.rbegin());\\n                window.erase(window.find(nums[i-k+1]));\\n            }\\n        }\\n        return out;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> out;\\n        multiset<int> window;\\n        for (int i=0; i<nums.size(); i++) {\\n            window.insert(nums[i]);\\n            if (i >= k - 1) {\\n                out.push_back(*window.rbegin());\\n                window.erase(window.find(nums[i-k+1]));\\n            }\\n        }\\n        return out;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3918317,
                "title": "monotonic-deque-c-java-python-linear-solution-with-explanation",
                "content": "# Intuition\\nA working solution can be to maintain a max-heap of size k for each window and get solution from it. But we can maintain this ordering with only the elements which can be answer and remove the logarithmic factor & get the desired solution in linear time.\\n\\n# Approach\\n1. Process each element in array from left to right.\\n2. First remove all smaller elements that are smaller than current element and can not be answer for any incoming window from back of deque.\\n3. Push current element to deque.\\n4. Remove if there is out of window element at front of the deque.\\n5. If the current element marks end of any k size window then add the front element of deque which is answer for the window to the answer.\\n\\n---\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            // remove all smaller elements from cur element\\n            while(!dq.empty() && nums[dq.back()] <= nums[i]) {\\n                dq.pop_back();\\n            }\\n\\n            // push cur element\\n            dq.push_back(i);\\n\\n            // check if there is out of window element at front\\n            if(dq.front() == i - k) {\\n                dq.pop_front();\\n            }\\n\\n            // Get max element for cur window\\n            if(i >= k - 1) {\\n                ans.push_back(nums[dq.front()]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        ArrayDeque<Integer> dq = new ArrayDeque<>();\\n        int[] ans = new int[n - k + 1];\\n\\n        for (int i = 0; i < n; i++) {\\n            // Remove all elements from the deque that are smaller than nums[i].\\n            while (!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]) {\\n                dq.pollLast();\\n            }\\n\\n            // Add nums[i] to the deque.\\n            dq.addLast(i);\\n\\n            // If the element at the front of the deque is out of the window, remove it.\\n            if (dq.peekFirst() == i - k) {\\n                dq.pollFirst();\\n            }\\n\\n            // If the window is large enough, add the maximum element in the window to the ans array.\\n            if (i >= k - 1) {\\n                ans[i - k + 1] = nums[dq.peekFirst()];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        dq = deque()\\n        ans = []\\n        for i in range(n):\\n            # Remove all smaller elements from cur element\\n            while dq and nums[dq[-1]] <= nums[i]:\\n                dq.pop()\\n\\n            # Push cur element\\n            dq.append(i)\\n\\n            # Check if there is out of window element at front\\n            if dq[0] == i - k:\\n                dq.popleft()\\n\\n            # Get max element for cur window\\n            if i >= k - 1:\\n                ans.append(nums[dq[0]])\\n\\n        return ans\\n```\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, As every element in array gets pushed or removed to deque exactly once.\\n\\n- Space complexity:\\n$$O(k)$$, As there can be at most k elements at any point of time in the deque.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Monotonic Queue"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            // remove all smaller elements from cur element\\n            while(!dq.empty() && nums[dq.back()] <= nums[i]) {\\n                dq.pop_back();\\n            }\\n\\n            // push cur element\\n            dq.push_back(i);\\n\\n            // check if there is out of window element at front\\n            if(dq.front() == i - k) {\\n                dq.pop_front();\\n            }\\n\\n            // Get max element for cur window\\n            if(i >= k - 1) {\\n                ans.push_back(nums[dq.front()]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        ArrayDeque<Integer> dq = new ArrayDeque<>();\\n        int[] ans = new int[n - k + 1];\\n\\n        for (int i = 0; i < n; i++) {\\n            // Remove all elements from the deque that are smaller than nums[i].\\n            while (!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]) {\\n                dq.pollLast();\\n            }\\n\\n            // Add nums[i] to the deque.\\n            dq.addLast(i);\\n\\n            // If the element at the front of the deque is out of the window, remove it.\\n            if (dq.peekFirst() == i - k) {\\n                dq.pollFirst();\\n            }\\n\\n            // If the window is large enough, add the maximum element in the window to the ans array.\\n            if (i >= k - 1) {\\n                ans[i - k + 1] = nums[dq.peekFirst()];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        dq = deque()\\n        ans = []\\n        for i in range(n):\\n            # Remove all smaller elements from cur element\\n            while dq and nums[dq[-1]] <= nums[i]:\\n                dq.pop()\\n\\n            # Push cur element\\n            dq.append(i)\\n\\n            # Check if there is out of window element at front\\n            if dq[0] == i - k:\\n                dq.popleft()\\n\\n            # Get max element for cur window\\n            if i >= k - 1:\\n                ans.append(nums[dq[0]])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915849,
                "title": "fast-o-n-deque",
                "content": "# Intuition\\nAt first glance, the problem seems to be a simple maximum calculation problem within a range. However, as the range, or the window, slides through the array, recalculating the maximum for each new window seems inefficient. Our goal is to find an approach where we can leverage the previous window\\'s information for the current window, making the process more efficient.\\n\\n---\\n\\n# Approach\\nInstead of recalculating the maximum for each window, we can utilize a double-ended queue (deque). The beauty of deques is their ability to add or remove elements from both ends in constant time, making them perfect for this scenario.\\n\\nHere\\'s a step-by-step breakdown:\\n\\n1. **Initialization**: Begin by defining an empty deque and a result list.\\n2. **Iterate over nums**:\\n    - For each number, remove indices from the front of the deque if they are out of the current window\\'s bounds.\\n    - Next, remove indices from the back if the numbers they point to are smaller than the current number. This ensures our deque always has the maximum of the current window at its front.\\n    - Add the current index to the deque.\\n    - If the current index indicates that we\\'ve seen at least `k` numbers, add the front of the deque (i.e., the current window\\'s maximum) to the result list.\\n3. Return the result list.\\n\\n---\\n\\n# Complexity\\n\\n- **Time complexity**: $$ O(n) $$. Although there are two while loops inside the for loop, each element is processed only once either by being added to the deque or being removed from it.\\n  \\n- **Space complexity**: $$ O(k) $$ where $$ k $$ is the size of the deque, which stores indices.\\n\\n---\\n\\n# Code\\n\\n``` Python []\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n            return []\\n        if k == 1:\\n            return nums\\n        deq = deque()\\n        result = []\\n\\n        for i in range(len(nums)):\\n            while deq and deq[0] < i - k + 1:\\n                deq.popleft()\\n            while deq and nums[i] > nums[deq[-1]]:\\n                deq.pop()\\n            deq.append(i)\\n            if i >= k - 1:\\n                result.append(nums[deq[0]])      \\n  \\n        return result\\n``` \\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\\n        if (nums.empty() || k == 0) {\\n            return {};\\n        }\\n        if (k == 1) {\\n            return nums;\\n        }\\n\\n        std::deque<int> deq;\\n        std::vector<int> result;\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (!deq.empty() && deq.front() < i - k + 1) {\\n                deq.pop_front();\\n            }\\n            while (!deq.empty() && nums[i] > nums[deq.back()]) {\\n                deq.pop_back();\\n            }\\n            \\n            deq.push_back(i);\\n            if (i >= k - 1) {\\n                result.push_back(nums[deq.front()]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nBy using a deque, this solution provides a more efficient and elegant approach to the sliding window problem.",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n            return []\\n        if k == 1:\\n            return nums\\n        deq = deque()\\n        result = []\\n\\n        for i in range(len(nums)):\\n            while deq and deq[0] < i - k + 1:\\n                deq.popleft()\\n            while deq and nums[i] > nums[deq[-1]]:\\n                deq.pop()\\n            deq.append(i)\\n            if i >= k - 1:\\n                result.append(nums[deq[0]])      \\n  \\n        return result\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\\n        if (nums.empty() || k == 0) {\\n            return {};\\n        }\\n        if (k == 1) {\\n            return nums;\\n        }\\n\\n        std::deque<int> deq;\\n        std::vector<int> result;\\n\\n        for (int i = 0; i < nums.size(); ++i) {\\n            while (!deq.empty() && deq.front() < i - k + 1) {\\n                deq.pop_front();\\n            }\\n            while (!deq.empty() && nums[i] > nums[deq.back()]) {\\n                deq.pop_back();\\n            }\\n            \\n            deq.push_back(i);\\n            if (i >= k - 1) {\\n                result.push_back(nums[deq.front()]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131580,
                "title": "c-easy-to-understand-with-o-n-complexity",
                "content": "\\n\\n# Approach\\nThe approach of the code is to use a double-ended queue (deque) to maintain the maximum elements in the current sliding window.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n    vector<int> result;\\n    deque<int> dq;\\n    for (int i = 0; i < nums.size(); i++) {\\n        // remove indices that are out of the current window\\n        while (!dq.empty() && dq.front() < i - k + 1) {\\n            dq.pop_front();\\n        }\\n        // remove indices with smaller values from the back\\n        while (!dq.empty() && nums[dq.back()] < nums[i]) {\\n            dq.pop_back();\\n        }\\n        dq.push_back(i);\\n        if (i >= k - 1) {\\n            result.push_back(nums[dq.front()]);\\n        }\\n    }\\n    return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n    vector<int> result;\\n    deque<int> dq;\\n    for (int i = 0; i < nums.size(); i++) {\\n        // remove indices that are out of the current window\\n        while (!dq.empty() && dq.front() < i - k + 1) {\\n            dq.pop_front();\\n        }\\n        // remove indices with smaller values from the back\\n        while (!dq.empty() && nums[dq.back()] < nums[i]) {\\n            dq.pop_back();\\n        }\\n        dq.push_back(i);\\n        if (i >= k - 1) {\\n            result.push_back(nums[dq.front()]);\\n        }\\n    }\\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912234,
                "title": "c-deque-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe brute force solution exceeds the time limit. We can mimic the max heap behaviour by maintaining a descending dequeue.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Deque to solve this problem. We store the index in the deque so that we can easily remove the outdated items from the window. We need to make sure the queue is in descending order to get the max item of the window by getting the first item of the dequeue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe process each item only once, so the time complexity would be $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use a queue to store the items in the window, the max size of the window would be k. So the space complexity would be $$O(k)$$\\n\\n# Code\\n```csharp\\npublic class Solution {\\n    public int[] MaxSlidingWindow(int[] nums, int k)\\n    {\\n        LinkedList<int> queue = new LinkedList<int>(); // we store the index in the queue\\n        List<int> res = new List<int>();\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            while (queue.Count > 0 && queue.First.Value < i - k + 1)\\n            {\\n                // if the largest value in the queue is out of window, we remove it\\n                queue.RemoveFirst();\\n            }\\n\\n            var currentVal = nums[i];\\n\\n            // we need to make sure that the queue is in descending order, we achieve this by removing all the item in the queue that is smaller than the current val\\n            // we only need to track the largest value, so removing the smaller item does not matter.\\n            while (queue.Count > 0 && nums[queue.Last.Value] < currentVal)\\n                queue.RemoveLast();\\n\\n            queue.AddLast(i);\\n            \\n            // we start to add max item to the result set when i = k-1.\\n            if (i >= k-1)\\n                res.Add(nums[queue.First.Value]);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution {\\n    public int[] MaxSlidingWindow(int[] nums, int k)\\n    {\\n        LinkedList<int> queue = new LinkedList<int>(); // we store the index in the queue\\n        List<int> res = new List<int>();\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            while (queue.Count > 0 && queue.First.Value < i - k + 1)\\n            {\\n                // if the largest value in the queue is out of window, we remove it\\n                queue.RemoveFirst();\\n            }\\n\\n            var currentVal = nums[i];\\n\\n            // we need to make sure that the queue is in descending order, we achieve this by removing all the item in the queue that is smaller than the current val\\n            // we only need to track the largest value, so removing the smaller item does not matter.\\n            while (queue.Count > 0 && nums[queue.Last.Value] < currentVal)\\n                queue.RemoveLast();\\n\\n            queue.AddLast(i);\\n            \\n            // we start to add max item to the result set when i = k-1.\\n            if (i >= k-1)\\n                res.Add(nums[queue.First.Value]);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560961,
                "title": "cpp-o-n-next-greater-element-approach",
                "content": "We will find the next greater element and will store its index in a vector(you can also take array). Then we will check the index where the next greater element lies is inside the window or not if yes we will take it as our ans. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElement(vector<int> nums)\\n    {\\n        stack<int> st;\\n        vector<int> Index(nums.size(), 0);\\n        \\n        for(int idx = nums.size() - 1; idx >= 0; idx--)\\n        {\\n            while(!st.empty() and nums[idx] > nums[st.top()])\\n                st.pop();\\n            \\n            if(st.empty()) Index[idx] = nums.size();\\n            else Index[idx] = st.top();\\n            \\n            st.push(idx);\\n        }\\n        \\n        return Index;\\n    }\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) \\n    {\\n         vector<int> Index = nextGreaterElement(nums);\\n         vector<int> ans;\\n        \\n         int curr = 0;\\n        \\n         for(int idx = 0; idx <= nums.size() - k; idx++)\\n         {\\n             if(curr < idx) curr = idx;\\n             \\n             while(Index[curr] < idx + k)\\n                 curr = Index[curr];             //updating index\\n             \\n             ans.push_back(nums[curr]);\\n         }\\n        \\n         return ans;\\n    }\\n};\\n```\\n\\nSame implementation using array runtime becomes more faster i.e from 80% to 99.98%\\n\\n```\\nclass Solution {\\npublic:\\n    int* nextGreaterElement(vector<int> nums)\\n    {\\n        stack<int> st;\\n        int* Index = new int[nums.size()];\\n        \\n        for(int idx = 0; idx < nums.size(); idx++)\\n            Index[idx] = 0;\\n        \\n        for(int idx = nums.size() - 1; idx >= 0; idx--)\\n        {\\n            while(!st.empty() and nums[idx] > nums[st.top()])\\n                st.pop();\\n            \\n            if(st.empty()) Index[idx] = nums.size();\\n            else Index[idx] = st.top();\\n            \\n            st.push(idx);\\n        }\\n        \\n        return Index;\\n    }\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) \\n    {\\n          ios::sync_with_stdio(false);\\n          cin.tie(nullptr);         //these two lines take the sol\\'n to 99.98% faster\\n\\t\\t \\n\\t\\t int* Index = new int[nums.size()];\\n         vector<int> ans;\\n        \\n         Index = nextGreaterElement(nums);\\n        \\n         int curr = 0;\\n        \\n         for(int idx = 0; idx <= nums.size() - k; idx++)\\n         {\\n             if(curr < idx) curr = idx;\\n             \\n             while(Index[curr] < idx + k)\\n                 curr = Index[curr];\\n             \\n             ans.push_back(nums[curr]);\\n         }\\n        \\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nextGreaterElement(vector<int> nums)\\n    {\\n        stack<int> st;\\n        vector<int> Index(nums.size(), 0);\\n        \\n        for(int idx = nums.size() - 1; idx >= 0; idx--)\\n        {\\n            while(!st.empty() and nums[idx] > nums[st.top()])\\n                st.pop();\\n            \\n            if(st.empty()) Index[idx] = nums.size();\\n            else Index[idx] = st.top();\\n            \\n            st.push(idx);\\n        }\\n        \\n        return Index;\\n    }\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) \\n    {\\n         vector<int> Index = nextGreaterElement(nums);\\n         vector<int> ans;\\n        \\n         int curr = 0;\\n        \\n         for(int idx = 0; idx <= nums.size() - k; idx++)\\n         {\\n             if(curr < idx) curr = idx;\\n             \\n             while(Index[curr] < idx + k)\\n                 curr = Index[curr];             //updating index\\n             \\n             ans.push_back(nums[curr]);\\n         }\\n        \\n         return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int* nextGreaterElement(vector<int> nums)\\n    {\\n        stack<int> st;\\n        int* Index = new int[nums.size()];\\n        \\n        for(int idx = 0; idx < nums.size(); idx++)\\n            Index[idx] = 0;\\n        \\n        for(int idx = nums.size() - 1; idx >= 0; idx--)\\n        {\\n            while(!st.empty() and nums[idx] > nums[st.top()])\\n                st.pop();\\n            \\n            if(st.empty()) Index[idx] = nums.size();\\n            else Index[idx] = st.top();\\n            \\n            st.push(idx);\\n        }\\n        \\n        return Index;\\n    }\\n    \\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) \\n    {\\n          ios::sync_with_stdio(false);\\n          cin.tie(nullptr);         //these two lines take the sol\\'n to 99.98% faster\\n\\t\\t \\n\\t\\t int* Index = new int[nums.size()];\\n         vector<int> ans;\\n        \\n         Index = nextGreaterElement(nums);\\n        \\n         int curr = 0;\\n        \\n         for(int idx = 0; idx <= nums.size() - k; idx++)\\n         {\\n             if(curr < idx) curr = idx;\\n             \\n             while(Index[curr] < idx + k)\\n                 curr = Index[curr];\\n             \\n             ans.push_back(nums[curr]);\\n         }\\n        \\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358630,
                "title": "simple-c-solution-priority-queue-hashing-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        \\n        vector<int>res;\\n        \\n        unordered_map<int,int>mp;\\n        priority_queue<int>pq;\\n        int n=nums.size();\\n        \\n\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n           mp[nums[i]]++;\\n           pq.push(nums[i]);\\n        }\\n        \\n        res.push_back(pq.top());\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            mp[nums[i-k]]--;\\n            pq.push(nums[i]);\\n            mp[nums[i]]++;\\n            while(mp[pq.top()]==0)\\n                 pq.pop();\\n            \\n            res.push_back(pq.top());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        \\n        vector<int>res;\\n        \\n        unordered_map<int,int>mp;\\n        priority_queue<int>pq;\\n        int n=nums.size();\\n        \\n\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n           mp[nums[i]]++;\\n           pq.push(nums[i]);\\n        }\\n        \\n        res.push_back(pq.top());\\n        \\n        for(int i=k;i<n;i++)\\n        {\\n            mp[nums[i-k]]--;\\n            pq.push(nums[i]);\\n            mp[nums[i]]++;\\n            while(mp[pq.top()]==0)\\n                 pq.pop();\\n            \\n            res.push_back(pq.top());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289112,
                "title": "using-priority-queue-c",
                "content": "Using Prioirty Queue, inserting into priority queue with the index upto they are acessible. \\nif the top of proirity queue is not accessible removing it until accessible number is at top in priority queue.\\n```\\nclass Solution {\\npublic:\\n\\t\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int sum = 0;\\n        priority_queue<pair<int, int>> heap;\\n       // pushing first k-1 nums to heap with the index until they are accessible\\n\\t   for(int i = 0; i < k-1;i++){\\n            heap.push({nums[i], i + k - 1});\\n        }\\n        vector<int> ans;\\n        for(int i = k-1;i < nums.size();i++){\\n            heap.push({nums[i], i + k - 1});\\n\\t\\t\\t// removing non accessible nums\\n            while(heap.top().second < i){\\n                heap.pop();\\n            }\\n            ans.push_back(heap.top().first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int sum = 0;\\n        priority_queue<pair<int, int>> heap;\\n       // pushing first k-1 nums to heap with the index until they are accessible\\n\\t   for(int i = 0; i < k-1;i++){\\n            heap.push({nums[i], i + k - 1});\\n        }\\n        vector<int> ans;\\n        for(int i = k-1;i < nums.size();i++){\\n            heap.push({nums[i], i + k - 1});\\n\\t\\t\\t// removing non accessible nums\\n            while(heap.top().second < i){\\n                heap.pop();\\n            }\\n            ans.push_back(heap.top().first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814163,
                "title": "max-heap-solution-with-o-n-log-k-time",
                "content": "As noted by the solution, it is possible to approach the problem using max heap.\\n\\nThe idea is to keep a max heap of size `k` while iterating through the sliding window. When a window slides, we need to remove the element no longer in the window from the heap, and add a new element to the heap.\\n\\nDoing so would not work with the built-in `PriorityQueue` implementation. The reason is that, deleting an element from a heap would require a linear time. Because a binary heap is implemented using an array, we would need to sequentially search the array to find the element to be deleted.\\n\\nTherefore, we need to build a priority queue which allows us to look up an element based on some unique reference. We can use the index in `nums` as the unique reference. Once we can locate the element in the binary heap array, deleting it would take `O(log(N))` time because we simply need to exchange it with the last element, decrease the size, and sift up and down to re-heapify.\\n\\nThe following solution implemented `IndexMaxPQ` to achieve that. (Based on https://algs4.cs.princeton.edu/24pq/IndexMinPQ.java.html)\\n\\n\\n```java\\nclass Solution {\\n    private class IndexMaxPQ<Key extends Comparable<Key>> {\\n        private int maxN;\\n        private int n;\\n        private int[] pq; // maps an index in the binary heap to the unique index for a key\\n        private int[] qp; // maps a unique index for a key to an index in the binary heap\\n        private Key[] keys; // keys indexed by unique indices\\n        \\n        public IndexMaxPQ(int maxN) {\\n            this.maxN = maxN;\\n            n = 0;\\n            keys = (Key[]) new Comparable[maxN+1];\\n            pq = new int[maxN+1];\\n            qp = new int[maxN+1];\\n            for (int i = 0; i <= maxN; i++) {\\n                qp[i] = -1;\\n            }\\n        }\\n        \\n        public void insert(int i, Key key) {\\n            n++;\\n            qp[i] = n;\\n            pq[n] = i;\\n            keys[i] = key;\\n            swim(n);\\n        }\\n        \\n        public void delete(int i) {\\n            int index = qp[i];\\n            exch(index, n--);\\n            swim(index);\\n            sink(index);\\n            keys[i] = null;\\n            qp[i] = -1;\\n        }\\n        \\n        public Key peek() {\\n            int max = pq[1];\\n            return keys[max];\\n        }\\n\\n        private boolean less(int i, int j) {\\n            return keys[pq[i]].compareTo(keys[pq[j]]) < 0;\\n        }\\n\\n        private void exch(int i, int j) {\\n            int swap = pq[i];\\n            pq[i] = pq[j];\\n            pq[j] = swap;\\n            qp[pq[i]] = i;\\n            qp[pq[j]] = j;\\n        }\\n\\n        private void swim(int k) {\\n            while (k > 1 && less(k/2, k)) {\\n                exch(k, k/2);\\n                k = k/2;\\n            }\\n        }\\n\\n        private void sink(int k) {\\n            while (2*k <= n) {\\n                int j = 2*k;\\n                if (j < n && less(j, j+1)) j++;\\n                if (!less(k, j)) break;\\n                exch(k, j);\\n                k = j;\\n            }\\n        }\\n    }\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] ans = new int[n-k+1];\\n\\n        IndexMaxPQ<Integer> maxheap = new IndexMaxPQ(n);\\n\\n        for (int i = 0; i < k; i++) {\\n            maxheap.insert(i, nums[i]);\\n        }\\n        ans[0] = maxheap.peek();\\n        \\n        for (int i = 1; i <= n-k; i++) {\\n            maxheap.delete(i-1);\\n            maxheap.insert(i+k-1, nums[i+k-1]);\\n            ans[i] = maxheap.peek();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**analysis**\\n\\n* The time complexity is `O(N*log(K))` as we re-heapify the max heap roughly N times.\\n* The space complexity is `O(N)` for the size of `keys` array in the PQ.",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    private class IndexMaxPQ<Key extends Comparable<Key>> {\\n        private int maxN;\\n        private int n;\\n        private int[] pq; // maps an index in the binary heap to the unique index for a key\\n        private int[] qp; // maps a unique index for a key to an index in the binary heap\\n        private Key[] keys; // keys indexed by unique indices\\n        \\n        public IndexMaxPQ(int maxN) {\\n            this.maxN = maxN;\\n            n = 0;\\n            keys = (Key[]) new Comparable[maxN+1];\\n            pq = new int[maxN+1];\\n            qp = new int[maxN+1];\\n            for (int i = 0; i <= maxN; i++) {\\n                qp[i] = -1;\\n            }\\n        }\\n        \\n        public void insert(int i, Key key) {\\n            n++;\\n            qp[i] = n;\\n            pq[n] = i;\\n            keys[i] = key;\\n            swim(n);\\n        }\\n        \\n        public void delete(int i) {\\n            int index = qp[i];\\n            exch(index, n--);\\n            swim(index);\\n            sink(index);\\n            keys[i] = null;\\n            qp[i] = -1;\\n        }\\n        \\n        public Key peek() {\\n            int max = pq[1];\\n            return keys[max];\\n        }\\n\\n        private boolean less(int i, int j) {\\n            return keys[pq[i]].compareTo(keys[pq[j]]) < 0;\\n        }\\n\\n        private void exch(int i, int j) {\\n            int swap = pq[i];\\n            pq[i] = pq[j];\\n            pq[j] = swap;\\n            qp[pq[i]] = i;\\n            qp[pq[j]] = j;\\n        }\\n\\n        private void swim(int k) {\\n            while (k > 1 && less(k/2, k)) {\\n                exch(k, k/2);\\n                k = k/2;\\n            }\\n        }\\n\\n        private void sink(int k) {\\n            while (2*k <= n) {\\n                int j = 2*k;\\n                if (j < n && less(j, j+1)) j++;\\n                if (!less(k, j)) break;\\n                exch(k, j);\\n                k = j;\\n            }\\n        }\\n    }\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] ans = new int[n-k+1];\\n\\n        IndexMaxPQ<Integer> maxheap = new IndexMaxPQ(n);\\n\\n        for (int i = 0; i < k; i++) {\\n            maxheap.insert(i, nums[i]);\\n        }\\n        ans[0] = maxheap.peek();\\n        \\n        for (int i = 1; i <= n-k; i++) {\\n            maxheap.delete(i-1);\\n            maxheap.insert(i+k-1, nums[i+k-1]);\\n            ans[i] = maxheap.peek();\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693349,
                "title": "golang-deque-with-explanation",
                "content": "```\\ntype deque struct {\\n\\tindexes []int\\n}\\n\\nfunc (d *deque) push(i int) {\\n\\td.indexes = append(d.indexes, i)\\n}\\n\\nfunc (d *deque) getFirst() int {\\n\\treturn d.indexes[0]\\n}\\n\\nfunc (d *deque) popFirst() {\\n\\td.indexes = d.indexes[1:]\\n}\\n\\nfunc (d *deque) getLast() int {\\n\\treturn d.indexes[len(d.indexes)-1]\\n}\\n\\nfunc (d *deque) popLast() {\\n\\td.indexes = d.indexes[:len(d.indexes)-1]\\n}\\n\\nfunc (d *deque) empty() bool {\\n\\treturn 0 == len(d.indexes)\\n}\\n\\n// This problem can be solved nicely using a deque. A deque is a queue that allows to systematically access and/or\\n// remove elements from either the top or the bottom of it.\\n// Now, first of all, we will have n-k+1 results as the number of windows. If input has length 3 and k is 1, we\\'ll have\\n// 3 - 1 + 1 = 3 windows. Now, for the approach, we use a deque that will store the index of the numbers. We store\\n// the index rather than the value to understand if an element is out of the current i-k window. We loop through the\\n// numbers, for each one of them, we remove from the queue the top if it\\'s outside the current window - we do this only\\n// once per iteration as the index increases linearly. After that, we remove every element from the deque that is\\n// smaller than the current analysed element. This will leave the current maximum at the top of the queue. We push the\\n// current element into the deque for future iterations. Finally, if we reached the first window end, we add our current\\n// result, this will be at the top of the deque.\\n//\\n// This video by Jessica Lin has an amazing explanation - https://www.youtube.com/watch?v=fbkvdWUS5Ic\\n//\\n// T: O(n)\\n// S: O(n-k+1)\\nfunc maxSlidingWindow(nums []int, k int) []int {\\n\\tif len(nums) < k || 0 == k {\\n\\t\\treturn make([]int, 0)\\n\\t} else if 1 == k {\\n\\t\\treturn nums\\n\\t}\\n\\n\\tvar (\\n\\t\\t// len(nums)-k+1 this is the number of windows.\\n\\t\\t// If input has length 3 and k is 1, we\\'ll have 3 - 1 + 1 = 3 windows.\\n\\t\\tres = make([]int, len(nums)-k+1)\\n\\t\\tdq  = &deque{}\\n\\t)\\n\\n\\tfor i := range nums {\\n\\t\\t// we pop the first element if it\\'s outside of the current window.\\n\\t\\tif false == dq.empty() && (i-k == dq.getFirst()) {\\n\\t\\t\\tdq.popFirst()\\n\\t\\t}\\n\\n\\t\\t// we pop all the elements that are smaller than the current one.\\n\\t\\tfor false == dq.empty() && nums[dq.getLast()] < nums[i] {\\n\\t\\t\\tdq.popLast()\\n\\t\\t}\\n\\n\\t\\t// we push the current one to the window.\\n\\t\\tdq.push(i)\\n\\n\\t\\t// if we reached at least the first window end.\\n\\t\\tif i >= k-1 {\\n\\t\\t\\t// we add the current result that is the first in the deque.\\n\\t\\t\\tres[i-k+1] = nums[dq.getFirst()]\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Queue"
                ],
                "code": "```\\ntype deque struct {\\n\\tindexes []int\\n}\\n\\nfunc (d *deque) push(i int) {\\n\\td.indexes = append(d.indexes, i)\\n}\\n\\nfunc (d *deque) getFirst() int {\\n\\treturn d.indexes[0]\\n}\\n\\nfunc (d *deque) popFirst() {\\n\\td.indexes = d.indexes[1:]\\n}\\n\\nfunc (d *deque) getLast() int {\\n\\treturn d.indexes[len(d.indexes)-1]\\n}\\n\\nfunc (d *deque) popLast() {\\n\\td.indexes = d.indexes[:len(d.indexes)-1]\\n}\\n\\nfunc (d *deque) empty() bool {\\n\\treturn 0 == len(d.indexes)\\n}\\n\\n// This problem can be solved nicely using a deque. A deque is a queue that allows to systematically access and/or\\n// remove elements from either the top or the bottom of it.\\n// Now, first of all, we will have n-k+1 results as the number of windows. If input has length 3 and k is 1, we\\'ll have\\n// 3 - 1 + 1 = 3 windows. Now, for the approach, we use a deque that will store the index of the numbers. We store\\n// the index rather than the value to understand if an element is out of the current i-k window. We loop through the\\n// numbers, for each one of them, we remove from the queue the top if it\\'s outside the current window - we do this only\\n// once per iteration as the index increases linearly. After that, we remove every element from the deque that is\\n// smaller than the current analysed element. This will leave the current maximum at the top of the queue. We push the\\n// current element into the deque for future iterations. Finally, if we reached the first window end, we add our current\\n// result, this will be at the top of the deque.\\n//\\n// This video by Jessica Lin has an amazing explanation - https://www.youtube.com/watch?v=fbkvdWUS5Ic\\n//\\n// T: O(n)\\n// S: O(n-k+1)\\nfunc maxSlidingWindow(nums []int, k int) []int {\\n\\tif len(nums) < k || 0 == k {\\n\\t\\treturn make([]int, 0)\\n\\t} else if 1 == k {\\n\\t\\treturn nums\\n\\t}\\n\\n\\tvar (\\n\\t\\t// len(nums)-k+1 this is the number of windows.\\n\\t\\t// If input has length 3 and k is 1, we\\'ll have 3 - 1 + 1 = 3 windows.\\n\\t\\tres = make([]int, len(nums)-k+1)\\n\\t\\tdq  = &deque{}\\n\\t)\\n\\n\\tfor i := range nums {\\n\\t\\t// we pop the first element if it\\'s outside of the current window.\\n\\t\\tif false == dq.empty() && (i-k == dq.getFirst()) {\\n\\t\\t\\tdq.popFirst()\\n\\t\\t}\\n\\n\\t\\t// we pop all the elements that are smaller than the current one.\\n\\t\\tfor false == dq.empty() && nums[dq.getLast()] < nums[i] {\\n\\t\\t\\tdq.popLast()\\n\\t\\t}\\n\\n\\t\\t// we push the current one to the window.\\n\\t\\tdq.push(i)\\n\\n\\t\\t// if we reached at least the first window end.\\n\\t\\tif i >= k-1 {\\n\\t\\t\\t// we add the current result that is the first in the deque.\\n\\t\\t\\tres[i-k+1] = nums[dq.getFirst()]\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 620707,
                "title": "sliding-window-template",
                "content": "Most sliding window questions uses this same template all the time. The only difference is the data structure used for the window. \\nIf the question asks about the unique element in window -> use set\\nIf the question asks about the frequency of element in window -> use hash table/ dictionary\\nIf the question asks about window sum -> use prefix sum array\\nIf the question asks about min/max element -> use monoque/sortedlist (this question) \\nUsing sorted list\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        ans = []\\n        left = right = 0\\n        window = SortedList()\\n        while right < len(nums):            #stop when right pointer reaches the end of array\\n            window.add(nums[right])         #add stuff from the right to window\\n            if len(window) >= k:            #window limit exceededed, remove stuff from the left\\n                ans.append(window[-1])\\n                window.remove(nums[left])\\n                left += 1\\n\\t\\t\\tright += 1\\n        return ans\\n```\\nUsing max mono queue\\n```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        ans = []\\n        left = right = 0\\n        window = collections.deque()\\n        while right < len(nums):\\n            while len(window) and nums[right] > window[-1]: window.pop()\\n            window.append(nums[right])\\n            while right - left + 1 >= k:\\n                ans.append(window[0])\\n                if window[0] == nums[left]: window.popleft()\\n                left += 1\\n            right += 1\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        ans = []\\n        left = right = 0\\n        window = SortedList()\\n        while right < len(nums):            #stop when right pointer reaches the end of array\\n            window.add(nums[right])         #add stuff from the right to window\\n            if len(window) >= k:            #window limit exceededed, remove stuff from the left\\n                ans.append(window[-1])\\n                window.remove(nums[left])\\n                left += 1\\n\\t\\t\\tright += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        ans = []\\n        left = right = 0\\n        window = collections.deque()\\n        while right < len(nums):\\n            while len(window) and nums[right] > window[-1]: window.pop()\\n            window.append(nums[right])\\n            while right - left + 1 >= k:\\n                ans.append(window[0])\\n                if window[0] == nums[left]: window.popleft()\\n                left += 1\\n            right += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 521112,
                "title": "c-solution-using-left-maximum-and-right-maximum-arrays",
                "content": "The approach used here is that first, we create two arrays, one for left maximum in a particular window and another for right maximum in a particular window. And then, the maximum in a particular window is the maximum of (rightMax[i], leftMax[i + k - 1]), where i and i + k - 1 are the end points of a window.\\n\\nExample of left maximum and right maximum arrays:\\n**Input**: [1,3,-1,-3,5,3,6,7]\\n**Left max**: [1,3,3,-3,5,5,6,7]\\n**Right max**: [3,3,-1,5,5,3,7,7] \\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        if (nums.empty()) return {};\\n        \\n        int n = nums.size();\\n        int leftMax[n], rightMax[n];\\n        \\n        vector<int> result;\\n        \\n\\t\\t// Creates left maximum and right maximum arrays\\n        for (int i = 0, j = n - 1; i < n, j >= 0; i++, j--) {\\n            if (i % k == 0) leftMax[i] = nums[i];\\n            else leftMax[i] = max(leftMax[i - 1], nums[i]);\\n            \\n            if (j == n - 1 || (j + 1) % k == 0)\\n                rightMax[j] = nums[j];\\n            else rightMax[j] = max(rightMax[j + 1], nums[j]);\\n        }\\n        \\n\\t\\t// Pushes the maximum of each window in the result\\n        for (int i = 0; i < n - k + 1; i++)\\n            result.push_back(max(leftMax[i + k - 1], rightMax[i]));\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        if (nums.empty()) return {}",
                "codeTag": "Java"
            },
            {
                "id": 142193,
                "title": "python-o-n-logn-heap-and-counter-solution",
                "content": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums, k):\\n        cnt, heap, res = collections.Counter(), [], []\\n        for i, num in enumerate(nums):\\n            heapq.heappush(heap, -num)\\n            cnt[num] += 1\\n            while not cnt[-heap[0]]:\\n                heapq.heappop(heap)\\n            if i >= k - 1:\\n                res.append(-heap[0])\\n                cnt[nums[i - k + 1]] -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums, k):\\n        cnt, heap, res = collections.Counter(), [], []\\n        for i, num in enumerate(nums):\\n            heapq.heappush(heap, -num)\\n            cnt[num] += 1\\n            while not cnt[-heap[0]]:\\n                heapq.heappop(heap)\\n            if i >= k - 1:\\n                res.append(-heap[0])\\n                cnt[nums[i - k + 1]] -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66016,
                "title": "javascript-solution-detailed-walkthrough-of-solving-process",
                "content": "*I've written up my step-by-step solve of this problem, as well as rationale and thinking process. I solved this problem \"offline\" to simulate an interview-like environment. Any comments welcome!*\\n\\n**Initial Analysis**\\n\\nIt's trivial to get max in a window, which is an array of integers (from here on, k = # of integers int he window). However, you can't do better than O(k) when finding the max in an array of k integers.\\n\\nThe difficulty of this problem is figuring out a more efficient way than O(n * k) - because you're finding the max of k integers, n times. We need to find a data structure that efficiently does these three operations:\\n\\n* **RemoveOldest** - remove the oldest inserted integer\\n* **Add** - new integer\\n* **ComputeMax** - amongst all integers in data structure\\n\\nUsing a simple array, the costs are:\\n\\n* **RemoveOldest**: O(1)\\n* **Add**: O(1)\\n* **ComputeMax**: O(k)\\n\\nNow we hunt for something that does compute max better than O(k)\\n\\n**Data Structures - Priority Queue**\\n\\nWhen thinking about problems dealing with maximum numbers, my first thought usually goes to [Priority Queues](https://en.wikipedia.org/wiki/Priority_queue), which gives us O(logn) inserts and removals and gives us the current max for free. But this doesn't really work here - as we move the window, we're not removing the max number, but instead we need to remove the oldest number in the window. We'll have to search through the entire queue and remove it, which costs k. \\n\\n* **RemoveOldest**: O(k)\\n* **Add**: O(logk)\\n* **ComputeMax**: O(1)\\n\\n\\n**Sorting**\\n\\nAnother line of thought, since we need an efficient ComputeMax, is to sort the numbers in the window. The challenge here is to have a reasonable RemoveOldest and Add. I think this is a pretty deep rabbit hole, since you can come up with a number of convoluted data structures which will be hard to implement in the time of an interview. One example would be:\\n\\nBST (binary search trees) gives us O(logk) for all the operations we need. The tricky thing is we'll need to keep the BST in sync with the window. Say k = 4 for the window:\\n\\n```\\n[0, 5, 2, -1], 3, 3\\n```\\n\\nOur tree would be\\n \\n```\\n    0\\n  /   \\\\\\n -1    5\\n      /\\n     2\\n```\\nMoving the window to the right, we'll have\\n\\n```\\n0, [5, 2, -1, 3], 3\\n```\\n\\nWe'll need to remove 0 and add 3. \\n\\n```\\n    2\\n  /   \\\\\\n -1    5\\n      /\\n     3\\n```\\n\\nThe max will always be the right most node (5 in both these windows), and we can compute that in O(logk) - assuming the tree is balanced. \\n\\nThe catch here is we'll have to also keep track of which number to remove from the BST and account for duplicate numbers. In an interview, at this point I'd present this solution but also keep searching for something cleaner and more efficient. \\n\\n**Digging Deeper**\\n\\nSince we can't find an off-the-shelf data structure to \"hole-in-one\" this problem, we'll have to dig in a little more. The nice thing about this problem is we can safely assume we're going to be iterating through the array one way or another, so let's play out a few iterations. \\n\\n```\\n[0, 5, 2], -1, 3, 3\\n// ComputeMax (0, 5, 2): 5\\n```\\n\\n```\\n0, [5, 2, -1], 3, 3\\n// Remove 0\\n// ComputeMax (5, 2, -1): 5\\n```\\n\\n```\\n0, 5, [2, -1, 3], 3\\n// Remove 5\\n// ComputeMax (2, -1, 3): 3\\n```\\n\\nHere we make a crucial observation. Certain numbers can never be a maximum, because they're surrounded by bigger numbers. For example, for -1 above, we know it doesn't need to be considered, because the windows it's in are [5, 2, -1], [2, -1, 3] and [-1, 3, 3]. When do we know for sure that -1 doesn't need to be considered and what's the rule?\\n\\n-1 won't be a max because it's followed by a larger value, 3. By the time we spot 3, we know -1 will never be a consideration. What happens if we keep a running tally of possible candidates?\\n\\n```\\n0, 5, 2, -1, 3, 3\\n^\\n# [0]\\n\\n0, 5, 2, -1, 3, 3 \\n   ^\\n# [5], we can discard 0 since 5 > 0\\n\\n\\n0, 5, 2, -1, 3, 3 \\n      ^\\n# [5, 2]\\n\\n0, 5, 2, -1, 3, 3 \\n          ^\\n# [5, 2, -1]\\n\\n0, 5, 2, -1, 3, 3 \\n             ^\\n# [5, 3] we discard 2 and -1 since 3 is greater than both of them \\n\\n0, 5, 2, -1, 3, 3 \\n                ^\\n# [5, 3, 3] we discard 2 and -1 since 3 is greater than both of them\\n```\\nIf we take the first element of the possible max candidates, it looks pretty close to the result; except when the window moves past -1 and we're still stuck with 5 as our max. What we need to do is ensure our candidates array keeps within the window. \\n\\nA straightforward way to do this is keep two values in the array, one for the index and the other the value.\\n\\n```\\ni = 0\\n0, 5, 2, -1, 3, 3\\n^\\n# [{ index: 0, v: 0 }]\\n\\ni = 1\\n0, 5, 2, -1, 3, 3 \\n   ^\\n# [{ index: 1, v: 5 }]\\n\\ni = 2\\n0, 5, 2, -1, 3, 3 \\n      ^\\n# [{ index: 1, v: 5 }, { index: 2, v: 2 }]\\n\\ni = 3\\n0, 5, 2, -1, 3, 3 \\n          ^\\n# [{ index: 1, v: 5 }, { index: 2, v: 2 }, { index: 3, v: -1}]\\n\\ni = 4\\n0, 5, 2, -1, 3, 3 \\n             ^\\n# [{ index: 1, v: 5 }, { index: 4, v: 3 }]\\n```\\n\\nA cleaner way would be to store only the indexes, and lookup the corresponding value from our input array, since that lookup is O(1).  \\n\\nOur window size is k = 3. Since the window contains the current element, we'll be looking back 3 - 1 = 2 elements, i.e. if the current index is 4, the furthest we'll look back is i - (k - 1) = i - k + 1 = 2. Any indexes less than that need to be discarded. Accordingly, we drop 5 as a potential max. \\n\\nIn pseudo code, our algorithm would be:\\n\\n```\\ngiven input and k\\n\\nlet candidates = new Deque()\\nlet windowMax = []\\n\\nfor num, i in input\\n   # make sure candidates is in window\\n   while candidates.first() < i - k + 1\\n     candidates.removeFirst()\\n   \\n   # remove candidates smaller than the current item\\n   while candidates.last() < input[i]\\n     candidates.removeLast()\\n\\n   candidates.addLast(input[i])\\n   \\n  # need at least k items to calculate a window \\n   if (i + 1 >= k) windowMax.add(candidates[0])\\n\\nreturn windowMax\\n```\\n\\nWe need at least k items to calculate a window. At each i we have i + 1 items, so we add to windowMax if i + 1 >= k\\n\\nNote that candidates is a Deque, which is a double-ended queue. This means we can remove and add items to either the front or back of the list in O(1). Basically a doubly-linked list. \\n\\n**Complexity**\\n\\nLooking at our original requirements, the way we're using a Deque gives us the following:\\n* **RemoveOldest** O(1)\\n* **Add** O(1)\\n* **ComputeMax** O(1)* (first element)\\n\\nNow I put a * next to the O(1) compute max, since it's only \"free\" because of our additional logic. The good news is that additional logic is bounded by n, since we insert/remove each element of the input at most once. So overall, this solution is O(n).\\n\\n\\nFull solution for JavaScript below. \\n\\n```\\n\\nvar maxSlidingWindow = function(nums, k) {\\n    var candidates = new Deque()\\n    var windowMax = []\\n\\n    for (var i = 0; i < nums.length; i++) {\\n       //  make sure candidates is in window\\n       while (candidates.first() && candidates.first().val < i - k + 1) {\\n         candidates.removeFirst()\\n       }\\n       \\n       // remove candidates smaller than the current item\\n       while (candidates.last() && nums[candidates.last().val] < nums[i]) {\\n         candidates.removeLast()\\n       }\\n    \\n       candidates.addLast(i)\\n       \\n      // need at least k items to calculate a window\\n      if (i + 1 >= k) windowMax.push(nums[candidates.first().val])\\n    }\\n    \\n    return windowMax\\n}\\n\\n// Data Structures\\nfunction LinkItem(val) {\\n    this.val = val\\n}\\n\\nfunction Deque() {\\n    var _first = null\\n    var _last = null\\n    \\n    this.first = function() {\\n        return _first\\n    }\\n    \\n    this.last = function() {\\n        return _last\\n    }\\n    \\n    this.addLast = function(val) {\\n        if (!_first) {\\n            _first = new LinkItem(val)\\n            _last = _first\\n        } else {\\n            var newItem = new LinkItem(val)\\n            _last.next = newItem\\n            newItem.prev = _last\\n            \\n            _last = newItem\\n        }\\n    }\\n    \\n    this.removeFirst = function() {\\n        if (!_first) return\\n        \\n        _first = _first.next\\n        if (!_first) {\\n            _last = null\\n        } else {\\n            _first.prev = null\\n        }\\n    }\\n    \\n    this.removeLast = function() {\\n        if (!_last) return\\n        \\n        _last = _last.prev\\n        if (!_last) {\\n            _first = null\\n        } else {\\n            _last.next = null\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n[0, 5, 2, -1], 3, 3\\n```\n```\\n    0\\n  /   \\\\\\n -1    5\\n      /\\n     2\\n```\n```\\n0, [5, 2, -1, 3], 3\\n```\n```\\n    2\\n  /   \\\\\\n -1    5\\n      /\\n     3\\n```\n```\\n[0, 5, 2], -1, 3, 3\\n// ComputeMax (0, 5, 2): 5\\n```\n```\\n0, [5, 2, -1], 3, 3\\n// Remove 0\\n// ComputeMax (5, 2, -1): 5\\n```\n```\\n0, 5, [2, -1, 3], 3\\n// Remove 5\\n// ComputeMax (2, -1, 3): 3\\n```\n```\\n0, 5, 2, -1, 3, 3\\n^\\n# [0]\\n\\n0, 5, 2, -1, 3, 3 \\n   ^\\n# [5], we can discard 0 since 5 > 0\\n\\n\\n0, 5, 2, -1, 3, 3 \\n      ^\\n# [5, 2]\\n\\n0, 5, 2, -1, 3, 3 \\n          ^\\n# [5, 2, -1]\\n\\n0, 5, 2, -1, 3, 3 \\n             ^\\n# [5, 3] we discard 2 and -1 since 3 is greater than both of them \\n\\n0, 5, 2, -1, 3, 3 \\n                ^\\n# [5, 3, 3] we discard 2 and -1 since 3 is greater than both of them\\n```\n```\\ni = 0\\n0, 5, 2, -1, 3, 3\\n^\\n# [{ index: 0, v: 0 }]\\n\\ni = 1\\n0, 5, 2, -1, 3, 3 \\n   ^\\n# [{ index: 1, v: 5 }]\\n\\ni = 2\\n0, 5, 2, -1, 3, 3 \\n      ^\\n# [{ index: 1, v: 5 }, { index: 2, v: 2 }]\\n\\ni = 3\\n0, 5, 2, -1, 3, 3 \\n          ^\\n# [{ index: 1, v: 5 }, { index: 2, v: 2 }, { index: 3, v: -1}]\\n\\ni = 4\\n0, 5, 2, -1, 3, 3 \\n             ^\\n# [{ index: 1, v: 5 }, { index: 4, v: 3 }]\\n```\n```\\ngiven input and k\\n\\nlet candidates = new Deque()\\nlet windowMax = []\\n\\nfor num, i in input\\n   # make sure candidates is in window\\n   while candidates.first() < i - k + 1\\n     candidates.removeFirst()\\n   \\n   # remove candidates smaller than the current item\\n   while candidates.last() < input[i]\\n     candidates.removeLast()\\n\\n   candidates.addLast(input[i])\\n   \\n  # need at least k items to calculate a window \\n   if (i + 1 >= k) windowMax.add(candidates[0])\\n\\nreturn windowMax\\n```\n```\\n\\nvar maxSlidingWindow = function(nums, k) {\\n    var candidates = new Deque()\\n    var windowMax = []\\n\\n    for (var i = 0; i < nums.length; i++) {\\n       //  make sure candidates is in window\\n       while (candidates.first() && candidates.first().val < i - k + 1) {\\n         candidates.removeFirst()\\n       }\\n       \\n       // remove candidates smaller than the current item\\n       while (candidates.last() && nums[candidates.last().val] < nums[i]) {\\n         candidates.removeLast()\\n       }\\n    \\n       candidates.addLast(i)\\n       \\n      // need at least k items to calculate a window\\n      if (i + 1 >= k) windowMax.push(nums[candidates.first().val])\\n    }\\n    \\n    return windowMax\\n}\\n\\n// Data Structures\\nfunction LinkItem(val) {\\n    this.val = val\\n}\\n\\nfunction Deque() {\\n    var _first = null\\n    var _last = null\\n    \\n    this.first = function() {\\n        return _first\\n    }\\n    \\n    this.last = function() {\\n        return _last\\n    }\\n    \\n    this.addLast = function(val) {\\n        if (!_first) {\\n            _first = new LinkItem(val)\\n            _last = _first\\n        } else {\\n            var newItem = new LinkItem(val)\\n            _last.next = newItem\\n            newItem.prev = _last\\n            \\n            _last = newItem\\n        }\\n    }\\n    \\n    this.removeFirst = function() {\\n        if (!_first) return\\n        \\n        _first = _first.next\\n        if (!_first) {\\n            _last = null\\n        } else {\\n            _first.prev = null\\n        }\\n    }\\n    \\n    this.removeLast = function() {\\n        if (!_last) return\\n        \\n        _last = _last.prev\\n        if (!_last) {\\n            _first = null\\n        } else {\\n            _last.next = null\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66023,
                "title": "o-n-solution-cutting-the-array-into-segments-explanation-and-c-implementation",
                "content": " 1. Define left cumulative maximum and right cumulative maximum of an array **nums** to be another array such that<br>\\n**lcm[x] = max(nums[0], nums[1] , ..., nums[x])**<br>\\n**rcm[x] = max(nums[x], nums[x + 1], ..., num[N - 1])**<br><br>\\n 2. Cumulative maximums can be calculated recursively within **O(N)**<br>\\n**lcm[0] = nums[0]**\\n**lcm[x] = max(lcm[x - 1], nums[x])**<br>\\n**rcm[N - 1] = nums[N - 1]**\\n**rcm[x] = max(rcm[x + 1], nums[x])**<br><br>\\n 3. Cut the original array and the answer into segments with length **seg_len = k - 1**, and let them be **nums_seg[i]** and **ans_seg[i]**. \\nNote that the element **nums_seg[i][j]** is mapped to **nums[i * seg_len + j]**. That means we don't create a new array of array **nums_seg** and **ans_seg** in implemetation, they are exactly the same thing as **nums** and **ans**.\\n*The sliding window is always covered by 2 segments.*<br><br>\\n 4. Let the left cumulative maximums of **nums_seg[i]** be **lcm[i]** and  the right cumulative maximums be **rcm[i]**.<br><br>\\n 5. Then<br>\\n**ans_seg[i][j] = max(lcm[i + 1][j], rcm[i][j])**<br>\\nNote that we don't create array of array **lcm** and **rcm** in implementation, only **lcm[i + 1]** and **rcm[i]** are required to calculate **ans_seg[i]**, and after finishing **ans_seg[i]**, their storage is reused for  **lcm[i + 2]** and **rcm[i  + 1]**.\\n*3 comparisons are performed for each number in the answer.*<br>\\n\\nreference:<br>\\nMarcel van Herk, A Fast Algorithm for Local Minimum and Maximum Filters on Rectangular and Octogonal Kernels, *Pattern Recgonition Letters*, vol.13, pp.517-521, 1992\\n```C++\\nvector<int> maxSlidingWindow(vector<int>& nums, int k) \\n{\\n    int n_nums = nums.size();\\n    if (n_nums < k || k < 1) {\\n        return vector<int>(0);\\n    } else if (k == 1) { // special case that would lead seg_len to be 0\\n        return nums;\\n    } else {\\n        int seg_len = k - 1;\\n        int n_ans = n_nums - seg_len;\\n\\n        vector<int> lcm(seg_len);\\n        vector<int> rcm(seg_len);\\n        vector<int> ans(n_ans);\\n            \\n        for (int start_2 = seg_len; start_2 < n_nums; start_2 += seg_len) {\\n            // if n_nums % seg_len != 0, the last segment is shorter\\n            // current_seg_len = last_iteration? (n_nums - start_2): seg_len;\\n            // unrolling the last iteration may increase performance\\n            int current_seg_len = min(n_nums - start_2, seg_len);\\n\\n            int start_1 = start_2 - seg_len;\\n\\n            lcm[0] = nums[start_2];\\n            rcm[seg_len - 1] = nums[start_2 - 1];\\n\\n            for(int x_1 = seg_len - 2; x_1 >= 0; --x_1){\\n                rcm[x_1] = max(rcm[x_1 + 1], nums[start_1 + x_1]);\\n            }\\n\\n            for(int x_2 = 1; x_2 < current_seg_len; ++x_2){\\n                lcm[x_2] = max(lcm[x_2 - 1], nums[start_2 + x_2]);\\n            }\\n\\n            for(int x = 0; x < current_seg_len; ++x){\\n                ans[start_1 + x] = max(lcm[x], rcm[x]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C++\\nvector<int> maxSlidingWindow(vector<int>& nums, int k) \\n{\\n    int n_nums = nums.size();\\n    if (n_nums < k || k < 1) {\\n        return vector<int>(0);\\n    } else if (k == 1) { // special case that would lead seg_len to be 0\\n        return nums;\\n    } else {\\n        int seg_len = k - 1;\\n        int n_ans = n_nums - seg_len;\\n\\n        vector<int> lcm(seg_len);\\n        vector<int> rcm(seg_len);\\n        vector<int> ans(n_ans);\\n            \\n        for (int start_2 = seg_len; start_2 < n_nums; start_2 += seg_len) {\\n            // if n_nums % seg_len != 0, the last segment is shorter\\n            // current_seg_len = last_iteration? (n_nums - start_2): seg_len;\\n            // unrolling the last iteration may increase performance\\n            int current_seg_len = min(n_nums - start_2, seg_len);\\n\\n            int start_1 = start_2 - seg_len;\\n\\n            lcm[0] = nums[start_2];\\n            rcm[seg_len - 1] = nums[start_2 - 1];\\n\\n            for(int x_1 = seg_len - 2; x_1 >= 0; --x_1){\\n                rcm[x_1] = max(rcm[x_1 + 1], nums[start_1 + x_1]);\\n            }\\n\\n            for(int x_2 = 1; x_2 < current_seg_len; ++x_2){\\n                lcm[x_2] = max(lcm[x_2 - 1], nums[start_2 + x_2]);\\n            }\\n\\n            for(int x = 0; x < current_seg_len; ++x){\\n                ans[start_1 + x] = max(lcm[x], rcm[x]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66034,
                "title": "python-solution-with-deque",
                "content": "\\n     class Solution(object):\\n            def maxSlidingWindow(self, nums, k):\\n                \"\"\"\\n                :type nums: List[int]\\n                :type k: int\\n                :rtype: List[int]\\n                \"\"\"\\n                queue = [] # like PriorityQueue, remain the top k value\\n                result = []\\n        \\n                for i in xrange(len(nums)):\\n                    # judge whether the first item is in window\\n                    if queue and queue[0] < i - k + 1:\\n                        queue.pop(0)\\n        \\n                    # update the queue \\n                    while queue and nums[queue[-1]] < nums[i]:\\n                        queue.pop()\\n        \\n                    queue.append(i)\\n                    \\n                    #after i > k - 1, output the max value\\n                    if queue and i >= k - 1:\\n                        result.append(nums[queue[0]])\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n     class Solution(object):\\n            def maxSlidingWindow(self, nums, k):\\n                \"\"\"\\n                :type nums: List[int]\\n                :type k: int\\n                :rtype: List[int]\\n                \"\"\"\\n                queue = [] # like PriorityQueue, remain the top k value\\n                result = []\\n        \\n                for i in xrange(len(nums)):\\n                    # judge whether the first item is in window\\n                    if queue and queue[0] < i - k + 1:\\n                        queue.pop(0)\\n        \\n                    # update the queue \\n                    while queue and nums[queue[-1]] < nums[i]:\\n                        queue.pop()\\n        \\n                    queue.append(i)\\n                    \\n                    #after i > k - 1, output the max value\\n                    if queue and i >= k - 1:\\n                        result.append(nums[queue[0]])\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 66054,
                "title": "java-o-n-with-comments-using-deque",
                "content": "        public int[] maxSlidingWindow(int[] nums, int k) {\\n       \\n        if(nums == null || nums.length <= 0 )\\n            return new int[0];\\n        if(k>nums.length)\\n            return new int[0];\\n        \\n        // store results \\n        int result[] = new int[nums.length-k+1];\\n        \\n        Deque<Integer> q = new LinkedList<Integer>();\\n        \\n        // First of all we will enqueue k elements result in deque.\\n        int index = 0;\\n        for(index=0;index<k;index++)\\n        {\\n            // For every element, the previous smaller elements are useless so\\n            // remove them from queue.\\n            \\n            while(!q.isEmpty() && nums[q.getLast()] <= nums[index])\\n                q.removeLast();\\n                \\n            // now push them in queue.\\n            q.addLast(index);\\n        }\\n        \\n        \\n        int n = nums.length;\\n        // now start from k+1 to length n.\\n        for(;index<n;index++)\\n        {\\n            // The element at the front of the queue is the largest element of\\n            // previous window, so save in results.\\n            result[index-k] = nums[q.getFirst()];\\n            \\n            // need to remove unnecessary elements, which are now not part of sliding window.\\n             \\n            while(!q.isEmpty() && q.getFirst() <= (index-k))\\n                q.removeFirst();\\n            \\n            // calculate and insert again for current item as like above we did in for loop.\\n            // Remove all elements smaller than the currently\\n            // being added element (remove useless elements)   \\n            while(!q.isEmpty() && nums[q.getLast()] <= nums[index])\\n                q.removeLast();\\n                \\n            // Add current element at last of queue.\\n            q.addLast(index);\\n        }\\n        \\n        // store last window result.\\n        result[index-k] = nums[q.getFirst()];\\n        return result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "        public int[] maxSlidingWindow(int[] nums, int k) {\\n       \\n        if(nums == null || nums.length <= 0 )\\n            return new int[0];\\n        if(k>nums.length)\\n            return new int[0];\\n        \\n        // store results \\n        int result[] = new int[nums.length-k+1];\\n        \\n        Deque<Integer> q = new LinkedList<Integer>();\\n        \\n        // First of all we will enqueue k elements result in deque.\\n        int index = 0;\\n        for(index=0;index<k;index++)\\n        {\\n            // For every element, the previous smaller elements are useless so\\n            // remove them from queue.\\n            \\n            while(!q.isEmpty() && nums[q.getLast()] <= nums[index])\\n                q.removeLast();\\n                \\n            // now push them in queue.\\n            q.addLast(index);\\n        }\\n        \\n        \\n        int n = nums.length;\\n        // now start from k+1 to length n.\\n        for(;index<n;index++)\\n        {\\n            // The element at the front of the queue is the largest element of\\n            // previous window, so save in results.\\n            result[index-k] = nums[q.getFirst()];\\n            \\n            // need to remove unnecessary elements, which are now not part of sliding window.\\n             \\n            while(!q.isEmpty() && q.getFirst() <= (index-k))\\n                q.removeFirst();\\n            \\n            // calculate and insert again for current item as like above we did in for loop.\\n            // Remove all elements smaller than the currently\\n            // being added element (remove useless elements)   \\n            while(!q.isEmpty() && nums[q.getLast()] <= nums[index])\\n                q.removeLast();\\n                \\n            // Add current element at last of queue.\\n            q.addLast(index);\\n        }\\n        \\n        // store last window result.\\n        result[index-k] = nums[q.getFirst()];\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66122,
                "title": "java-o-n-solution-with-two-stacks",
                "content": "The idea of the solution is to maintain two stacks: s1 and s2.   We hope s1's peek  is always to keep the largest value in the current k numbers. So we use s1 to store the numbers whose index is in increasing order and values is in decreasing order. For example give k=4 numbers  1, 3 ,9, 6.  s1 only need to store 9 and 6 with 9 is on the peek of the stack. \\n\\nWhen we slide the window, we need to keep dumping the numbers at the left end of the window and adding new numbers on the right end of the window. When we have a new number in the window, we push just the new number in stack s2. Also, we keep record the largest value in s2. If the peek of s1 is smaller than the largest value in s2, it means the largest value in the current k numbers is in s2. Thus, we need to empty s1 and move the elements stored in s2 to s1. Note that we do not need to move all the elements in s2 to s1. Only the numbers whose index is in increasing order and values is in decreasing order are pushed into s1. \\n\\nFor example,\\n1,3,9,6,7,1, 2 , 5      given k=4\\n\\nstep 1:  window  1,3,9,6          s1:  9, 6     s2:empty    maxInStack2=Integer.MIN_VALUE;\\n\\nstep 2:  window  3,9,6,7          s1:  9,6      s2:7         maxInStack2=7\\n\\nstep3:   window  9,6,7,1          s1: 9, 6      s2:7,1      maxInStack2=7\\n\\nstep4:   window  6,7,1, 2    note 9 is removed from window, so  s1: 6   s2: 7, 1 ,2   maxInStack2=7\\n            Then we find that maxInStack2> s1.peek().  update s1.\\n            After updating s1, we have    s1: 7, 2     s2: empty maxInStack2=Integer.MIN_VALUE;\\n\\nstep5:   window 7,1,2,5   s1:7,2  s2:5,   maxInStack2=5;\\nIn worst case, every number in the array is visited twice. Thus the complexity is O(n)\\n\\n    public class Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums==null||nums.length==0) return nums;\\n        int [] result= new int[nums.length-k+1];\\n        int maxInStack2=Integer.MIN_VALUE;\\n        Stack<Integer> s1 =new Stack<Integer>();\\n        Stack<Integer> s2 =new Stack<Integer>();\\n        for(int i=k-1;i>=0;i--){\\n            if(s1.isEmpty()){\\n                s1.push(nums[i]);\\n            }else if(nums[i]>=s1.peek()){\\n                s1.push(nums[i]);\\n            }\\n        }\\n        result[0]=s1.peek();\\n        for(int i=1;i<result.length;i++){\\n            int newItem=nums[i+k-1];\\n            int removeItem=nums[i-1];\\n            if(removeItem==s1.peek()){\\n                s1.pop();\\n            }\\n            if(newItem>maxInStack2){\\n                maxInStack2=newItem;\\n            }\\n            s2.push(newItem);\\n            if(s1.isEmpty()||maxInStack2>s1.peek()){\\n                while(s1.isEmpty()==false){\\n                    s1.pop();\\n                }\\n                while(s2.isEmpty()==false){\\n                    int temp=s2.pop();\\n                    if(s1.isEmpty()||temp>=s1.peek()){\\n                        s1.push(temp);\\n                    }\\n                }\\n                result[i]=maxInStack2;\\n                maxInStack2=Integer.MIN_VALUE;\\n            }else{\\n                result[i]=s1.peek();\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums==null||nums.length==0) return nums;\\n        int [] result= new int[nums.length-k+1];\\n        int maxInStack2=Integer.MIN_VALUE;\\n        Stack<Integer> s1 =new Stack<Integer>();\\n        Stack<Integer> s2 =new Stack<Integer>();\\n        for(int i=k-1;i>=0;i--){\\n            if(s1.isEmpty()){\\n                s1.push(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3916116,
                "title": "biblical-rust-code-eligible-for-pr-into-templeos-blessed",
                "content": "![image.png](https://assets.leetcode.com/users/images/5a6645b2-0807-4d2e-825d-74ae76d9536a_1692160837.3047426.png)\\n\\n# Complexity\\n- Time complexity:\\n- O(small)\\n\\n- Space complexity:\\nO(little)\\n\\n# Code\\n```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    // \"Then the LORD said to Moses, \\'I will rain down bread from heaven for you. The people are to go out each day \\n    // and gather enough for that day.\\'\" (Exodus 16:4)\\n    // \\'manna\\' represents sustenance, each item to be gathered and measured. In this case, items in the vector represent tasks to be measured.\\n    pub fn max_sliding_window(manna: Vec<i32>, k: i32) -> Vec<i32> {\\n        // The Ark was the vessel that saved Noah and his family during the Flood, preserving life. Here \\'ark\\' represents the data \\n        // structure that preserves the elements within the sliding window.\\n        let mut ark = VecDeque::new();\\n        \\n        // \"For no matter how many promises God has made, they are \\'Yes\\' in Christ. And so through him the \\'Amen\\' \\n        // is spoken by us to the glory of God.\" (2 Corinthians 1:20)\\n        // \\'promises\\' here represents the results or responses, likened to God\\'s promises being fulfilled.\\n        let mut promises = vec![];\\n\\n        // \"Then the LORD said to Moses, \\'See, I have made you like God to Pharaoh.\\'\" (Exodus 7:1)\\n        // \\'moses\\' is the iterator through \\'manna\\'. Like Moses in the Bible, he leads the way, accessing \\n        // each element of \\'manna\\' and making critical decisions.\\n        for moses in 0..manna.len() {\\n            // \"Abraham was first of all, by faith, obedient to God.\" (Hebrews 11:8)\\n            // \\'abraham\\' refers to the first index in the \\'ark\\'. When Abraham\\'s faith was tested, he was obedient, \\n            // known as the father of all those having faith.\\n            if let Some(&abraham) = ark.front() {\\n                if abraham as i32 <= moses as i32 - k {\\n                    ark.pop_front(); // Represents obedience to God\\'s command, by making space for the next.\\n                }\\n            }\\n\\n            // \"Then I will take away my hand, and you shall see my back, but my face shall not be seen.\" (Exodus 33:23)\\n            // Like how God showed Jacob his back, we use \\'jacob\\' to refer to the last index in our \\'ark\\'. This resembles Jacob\\'s struggle in the bible.\\n            while let Some(&jacob) = ark.back() {\\n                if manna[jacob] < manna[moses] {\\n                    ark.pop_back(); // Like releasing burdens, we release the smaller elements.\\n                } else {\\n                    break;\\n                }\\n            }\\n\\n            // Moses is being pushed, or rather \\'leads\\', into the ark.\\n            ark.push_back(moses); \\n\\n            // \"Be strong and courageous. Do not be afraid or terrified because of them, for the LORD your God \\n            // goes with you; he will never leave you nor forsake you.\" (Deuteronomy 31:6)\\n            // Moses was not alone in his journey towards the Promised Land. Similarly, our \\'ark\\' will never be empty as \\n            // the front will always have the largest element of the window.\\n            if moses as usize >= (k - 1) as usize {\\n                promises.push(manna[*ark.front().unwrap()]); // We extract the max element, the promise fulfilled.\\n            }\\n        } \\n\\n        promises // Return the fulfilled promises.\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    // \"Then the LORD said to Moses, \\'I will rain down bread from heaven for you. The people are to go out each day \\n    // and gather enough for that day.\\'\" (Exodus 16:4)\\n    // \\'manna\\' represents sustenance, each item to be gathered and measured. In this case, items in the vector represent tasks to be measured.\\n    pub fn max_sliding_window(manna: Vec<i32>, k: i32) -> Vec<i32> {\\n        // The Ark was the vessel that saved Noah and his family during the Flood, preserving life. Here \\'ark\\' represents the data \\n        // structure that preserves the elements within the sliding window.\\n        let mut ark = VecDeque::new();\\n        \\n        // \"For no matter how many promises God has made, they are \\'Yes\\' in Christ. And so through him the \\'Amen\\' \\n        // is spoken by us to the glory of God.\" (2 Corinthians 1:20)\\n        // \\'promises\\' here represents the results or responses, likened to God\\'s promises being fulfilled.\\n        let mut promises = vec![];\\n\\n        // \"Then the LORD said to Moses, \\'See, I have made you like God to Pharaoh.\\'\" (Exodus 7:1)\\n        // \\'moses\\' is the iterator through \\'manna\\'. Like Moses in the Bible, he leads the way, accessing \\n        // each element of \\'manna\\' and making critical decisions.\\n        for moses in 0..manna.len() {\\n            // \"Abraham was first of all, by faith, obedient to God.\" (Hebrews 11:8)\\n            // \\'abraham\\' refers to the first index in the \\'ark\\'. When Abraham\\'s faith was tested, he was obedient, \\n            // known as the father of all those having faith.\\n            if let Some(&abraham) = ark.front() {\\n                if abraham as i32 <= moses as i32 - k {\\n                    ark.pop_front(); // Represents obedience to God\\'s command, by making space for the next.\\n                }\\n            }\\n\\n            // \"Then I will take away my hand, and you shall see my back, but my face shall not be seen.\" (Exodus 33:23)\\n            // Like how God showed Jacob his back, we use \\'jacob\\' to refer to the last index in our \\'ark\\'. This resembles Jacob\\'s struggle in the bible.\\n            while let Some(&jacob) = ark.back() {\\n                if manna[jacob] < manna[moses] {\\n                    ark.pop_back(); // Like releasing burdens, we release the smaller elements.\\n                } else {\\n                    break;\\n                }\\n            }\\n\\n            // Moses is being pushed, or rather \\'leads\\', into the ark.\\n            ark.push_back(moses); \\n\\n            // \"Be strong and courageous. Do not be afraid or terrified because of them, for the LORD your God \\n            // goes with you; he will never leave you nor forsake you.\" (Deuteronomy 31:6)\\n            // Moses was not alone in his journey towards the Promised Land. Similarly, our \\'ark\\' will never be empty as \\n            // the front will always have the largest element of the window.\\n            if moses as usize >= (k - 1) as usize {\\n                promises.push(manna[*ark.front().unwrap()]); // We extract the max element, the promise fulfilled.\\n            }\\n        } \\n\\n        promises // Return the fulfilled promises.\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3473812,
                "title": "easy-understanding-sliding-solution-using-priority-queue",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlog(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        priority_queue<pair<int,int>>pq;\\n        vector<int>ans;\\n        while(j<nums.size())\\n        {\\n            pq.push({nums[j],j});\\n           if(j-i+1<k)\\n           j++;\\n           else if(j-i+1==k)\\n           {\\n               while(pq.top().second<i)\\n               pq.pop();\\n               ans.push_back(pq.top().first);\\n               i++;\\n               j++;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        priority_queue<pair<int,int>>pq;\\n        vector<int>ans;\\n        while(j<nums.size())\\n        {\\n            pq.push({nums[j],j});\\n           if(j-i+1<k)\\n           j++;\\n           else if(j-i+1==k)\\n           {\\n               while(pq.top().second<i)\\n               pq.pop();\\n               ans.push_back(pq.top().first);\\n               i++;\\n               j++;\\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275508,
                "title": "c-easy-to-understand-sliding-window",
                "content": "# Intuition\\nThis is a straight forward sliding window(fixed window size) question in which the trick is to use a datastr which can be accessed from front as well as from back.\\n\\n# Approach\\nWe will maintain a list  and push every element in the list while popping every element which is smaller than the current element(because we have to give the maximum element present in the window size).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n       vector<int>ans;\\n       list<int>l;\\n       int i=0;\\n       int j=0;\\n       while(j<nums.size()){\\n     // if the current element that is nums[j] is   greater than  \\n     //previous elements present in the list then pop all  elements\\n      //till we encouter an element which is greater than nums[j]\\n\\n   while(l.size()>0&&l.back()<nums[j]){\\n    l.pop_back();\\n    }\\n \\n   l.push_back(nums[j]);\\n   // if the window size is not met move j.\\n   if(j-i+1<k){\\n    j++;\\n   }\\n  // when the size is me \\n  else if(j-i+1==k){\\n   // front wala maximum hoga toh usko push\\n                ans.push_back(l.front());\\n   //to move the window remove ith element from list\\n                if(nums[i] == l.front()){\\n                    l.pop_front();\\n                }\\n   //increment i as well as j\\n                i++;\\n                j++;\\n            }\\n\\n       }\\n    return ans;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n       vector<int>ans;\\n       list<int>l;\\n       int i=0;\\n       int j=0;\\n       while(j<nums.size()){\\n     // if the current element that is nums[j] is   greater than  \\n     //previous elements present in the list then pop all  elements\\n      //till we encouter an element which is greater than nums[j]\\n\\n   while(l.size()>0&&l.back()<nums[j]){\\n    l.pop_back();\\n    }\\n \\n   l.push_back(nums[j]);\\n   // if the window size is not met move j.\\n   if(j-i+1<k){\\n    j++;\\n   }\\n  // when the size is me \\n  else if(j-i+1==k){\\n   // front wala maximum hoga toh usko push\\n                ans.push_back(l.front());\\n   //to move the window remove ith element from list\\n                if(nums[i] == l.front()){\\n                    l.pop_front();\\n                }\\n   //increment i as well as j\\n                i++;\\n                j++;\\n            }\\n\\n       }\\n    return ans;\\n         \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2746874,
                "title": "python-heap-solution",
                "content": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        ans,heap=[],[] \\n        for i in range(k): heapq.heappush(heap,[-nums[i],i]); # to create max heap in python with indices value \\n        ans.append(-(heap[0][0]))#top will be maxmum\\n        j=k\\n        while j<len(nums):\\n            heapq.heappush(heap,[-nums[j],j]) \\n            while heap[0][1] < j-k+1:\\n                heapq.heappop(heap) #if index in range of k  append top else keep popping till  the top get in range\\n            ans.append(-(heap[0][0]))\\n            j+=1\\n        return ans\\n\\tupvote it if you liked it.",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        ans,heap=[],[] \\n        for i in range(k): heapq.heappush(heap,[-nums[i],i]); # to create max heap in python with indices value \\n        ans.append(-(heap[0][0]))#top will be maxmum\\n        j=k\\n        while j<len(nums):\\n            heapq.heappush(heap,[-nums[j],j]) \\n            while heap[0][1] < j-k+1:\\n                heapq.heappop(heap) #if index in range of k  append top else keep popping till  the top get in range\\n            ans.append(-(heap[0][0]))\\n            j+=1\\n        return ans\\n\\tupvote it if you liked it.",
                "codeTag": "Java"
            },
            {
                "id": 2048181,
                "title": "python-easy-monotonic-queue-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        q = deque() # store inices\\n        res = []\\n        for i in range(len(nums)) :\\n            while q and nums[q[-1]] < nums[i] :\\n                q.pop()\\n            q.append(i)\\n            if q[0] == i - k : # remove first element if it\\'s outside the window\\n                q.popleft()\\n            if q and i >= k-1 : # we will append if window has k elements because we start from empty window and add 1 element each iteration \\n                res.append(nums[q[0]])\\n        return res\\n```\\n\\n**Feel free to ask any question**\\n**Pls do upvote if it helps :-)**",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        q = deque() # store inices\\n        res = []\\n        for i in range(len(nums)) :\\n            while q and nums[q[-1]] < nums[i] :\\n                q.pop()\\n            q.append(i)\\n            if q[0] == i - k : # remove first element if it\\'s outside the window\\n                q.popleft()\\n            if q and i >= k-1 : # we will append if window has k elements because we start from empty window and add 1 element each iteration \\n                res.append(nums[q[0]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790175,
                "title": "javascript-three-js-solutions",
                "content": "## Binary Search Solution\\nTime Complexity: n(log(n))\\nSpace Complexity: O(n)\\n```\\nconst maxSlidingWindow = function(nums, k) {\\n    const window = [], out = [];\\n    const findIndex = target => {\\n        // Using Binary Search to find the index\\n        let low = 0, high = window.length - 1;\\n        while(low <= high) {\\n            const mid = Math.floor((low + high) / 2);\\n            if(window[mid] < target) low = mid + 1;\\n            else if (window[mid] > target) high = mid - 1;\\n            else return mid;\\n        }\\n        return low;\\n    }\\n    const insertSorted = (num) => { // Inserts a number to the window and keeps the window sorted\\n        window.splice(findIndex(num), 0, num);\\n    }\\n    for(let i = 0; i < nums.length; i++) {\\n        insertSorted(nums[i]);\\n        if(window.length < k) continue; // Insert all first k Elements\\n        if(window.length == k) out.push(window[window.length - 1]) // Now that window has all k elements, we add max to output while window is moving\\n        else window.splice(findIndex(nums[i - k + 1]), 1); // Remove the number that\\'s exiting the window\\n    }\\n    return out;\\n};\\n```\\n\\n## Array (Double Ended) Solution\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\nconst maxSlidingWindow = function(nums, k) {\\n    const n = nums.length;\\n    if(n * k == 0) return [];\\n    if(k == 1) return nums;\\n\\n    const deq = []; // deq[0] will be oldest and d[last] will be newest index in the window\\n    const clean_deque = (i) => {\\n       // Remove indexes of elements not from sliding window\\n       if(deq.length && deq[0] == i - k) deq.shift();\\n\\n       // Remove from deq indexes of all elements which are smaller than current element\\n       while(deq.length && nums[i] > nums[deq[deq.length - 1]]) deq.pop();\\n    } \\n    let max_idx = 0;\\n    for(let i = 0; i < k; i++) {\\n        clean_deque(i, k);\\n        deq.push(i);\\n        // Compute max in nums[:k]\\n        if(nums[i] > nums[max_idx]) max_idx = i;\\n    }\\n\\n    const output = [];\\n    output[0] = nums[max_idx];\\n\\n    for(let i = k; i < n; i++) {\\n        clean_deque(i);\\n        deq.push(i);\\n        output.push(nums[deq[0]]);\\n    }\\n\\n    return output;\\n};\\n```\\n\\n\\n# Dynamic Programming Solution\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```\\nconst maxSlidingWindow = function(nums, k) {\\n    const n = nums.length;\\n    if(n * k == 0) return [];\\n    if(k == 1) return nums;\\n    // \"left\" array represents the maximum number in the window up to i from the left side\\n    // \"right\" array represents the maximum number in the window up to i from the right side\\n    const left = [nums[0]], right = [], out = [];\\n    right[n - 1] = nums[n - 1];\\n\\t\\n    for(let i = 1; i < n; i++) {\\n        left[i] = (i % k) ? Math.max(left[i - 1], nums[i]) : nums[i];\\n        const j = n - i - 1;\\n        right[j] = ((j + 1) % k) ? Math.max(right[j + 1], nums[j]) : nums[j];\\n    }\\n    \\n    for(let i = k - 1; i < n; i++) out.push(Math.max(left[i], right[i - k + 1]));\\n    \\n    return out;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxSlidingWindow = function(nums, k) {\\n    const window = [], out = [];\\n    const findIndex = target => {\\n        // Using Binary Search to find the index\\n        let low = 0, high = window.length - 1;\\n        while(low <= high) {\\n            const mid = Math.floor((low + high) / 2);\\n            if(window[mid] < target) low = mid + 1;\\n            else if (window[mid] > target) high = mid - 1;\\n            else return mid;\\n        }\\n        return low;\\n    }\\n    const insertSorted = (num) => { // Inserts a number to the window and keeps the window sorted\\n        window.splice(findIndex(num), 0, num);\\n    }\\n    for(let i = 0; i < nums.length; i++) {\\n        insertSorted(nums[i]);\\n        if(window.length < k) continue; // Insert all first k Elements\\n        if(window.length == k) out.push(window[window.length - 1]) // Now that window has all k elements, we add max to output while window is moving\\n        else window.splice(findIndex(nums[i - k + 1]), 1); // Remove the number that\\'s exiting the window\\n    }\\n    return out;\\n};\\n```\n```\\nconst maxSlidingWindow = function(nums, k) {\\n    const n = nums.length;\\n    if(n * k == 0) return [];\\n    if(k == 1) return nums;\\n\\n    const deq = []; // deq[0] will be oldest and d[last] will be newest index in the window\\n    const clean_deque = (i) => {\\n       // Remove indexes of elements not from sliding window\\n       if(deq.length && deq[0] == i - k) deq.shift();\\n\\n       // Remove from deq indexes of all elements which are smaller than current element\\n       while(deq.length && nums[i] > nums[deq[deq.length - 1]]) deq.pop();\\n    } \\n    let max_idx = 0;\\n    for(let i = 0; i < k; i++) {\\n        clean_deque(i, k);\\n        deq.push(i);\\n        // Compute max in nums[:k]\\n        if(nums[i] > nums[max_idx]) max_idx = i;\\n    }\\n\\n    const output = [];\\n    output[0] = nums[max_idx];\\n\\n    for(let i = k; i < n; i++) {\\n        clean_deque(i);\\n        deq.push(i);\\n        output.push(nums[deq[0]]);\\n    }\\n\\n    return output;\\n};\\n```\n```\\nconst maxSlidingWindow = function(nums, k) {\\n    const n = nums.length;\\n    if(n * k == 0) return [];\\n    if(k == 1) return nums;\\n    // \"left\" array represents the maximum number in the window up to i from the left side\\n    // \"right\" array represents the maximum number in the window up to i from the right side\\n    const left = [nums[0]], right = [], out = [];\\n    right[n - 1] = nums[n - 1];\\n\\t\\n    for(let i = 1; i < n; i++) {\\n        left[i] = (i % k) ? Math.max(left[i - 1], nums[i]) : nums[i];\\n        const j = n - i - 1;\\n        right[j] = ((j + 1) % k) ? Math.max(right[j + 1], nums[j]) : nums[j];\\n    }\\n    \\n    for(let i = k - 1; i < n; i++) out.push(Math.max(left[i], right[i - k + 1]));\\n    \\n    return out;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668973,
                "title": "super-optimized-segment-tree-solution-and-easy-to-understand",
                "content": "\\nThe overall complexity of the solution is O(NlogK) hence, bit slower than the O(N) deque solution. But, this solution is very easy to come up with if the person knows how to code a segment tree and its queries. Here, instead of sum just take maximum of the different segment in the nodes of the segment tree and you are good to go. \\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int size=nums.size();\\n        vector<int> st(2*size);\\n        for(int i=size,j=0;i<2*size && j<size;i++,j++)\\n        {\\n            st[i]=nums[j];\\n        }\\n        for(int i=size-1;i>0;i--)\\n        {\\n            st[i]=max(st[2*i],st[(2*i)+1]);\\n        }\\n        vector<int> v;\\n        for(int i=0,j=k-1;i<size && j<size;i++,j++)\\n        {\\n            int left=i+size,right=j+size;\\n            int maximum=INT_MIN;\\n            while(left<=right)\\n            {\\n                if(left%2==1) maximum=max(maximum,st[left++]);\\n                if(right%2==0) maximum=max(maximum,st[right--]);\\n                left/=2;\\n                right/=2;\\n            }\\n            v.push_back(maximum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int size=nums.size();\\n        vector<int> st(2*size);\\n        for(int i=size,j=0;i<2*size && j<size;i++,j++)\\n        {\\n            st[i]=nums[j];\\n        }\\n        for(int i=size-1;i>0;i--)\\n        {\\n            st[i]=max(st[2*i],st[(2*i)+1]);\\n        }\\n        vector<int> v;\\n        for(int i=0,j=k-1;i<size && j<size;i++,j++)\\n        {\\n            int left=i+size,right=j+size;\\n            int maximum=INT_MIN;\\n            while(left<=right)\\n            {\\n                if(left%2==1) maximum=max(maximum,st[left++]);\\n                if(right%2==0) maximum=max(maximum,st[right--]);\\n                left/=2;\\n                right/=2;\\n            }\\n            v.push_back(maximum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237649,
                "title": "java-priority-queue",
                "content": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        \\n    \\tint result[] = new int[nums.length - k + 1];\\n\\t\\tPriorityQueue<Pair> pq = new PriorityQueue<>();\\n\\t\\tint i = 0;\\n\\t\\tint j = 0;\\n\\t\\twhile (j < nums.length) {\\n\\t\\t\\tPair p = new Pair(j, nums[j]);\\n\\t\\t\\tpq.add(p);\\n\\t\\t\\tif (j - i + 1 < k) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult[i] = pq.peek().val;\\n\\t\\t\\t\\twhile (!pq.isEmpty() && pq.peek().key < i+1) {\\n\\t\\t\\t\\t\\tpq.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t}\\n        \\n        return result;\\n        \\n    }\\n    \\n    static class Pair implements Comparable<Pair> {\\n\\n\\t\\tint key;\\n\\t\\tint val;\\n\\n\\t\\tPair(int key, int val) {\\n\\t\\t\\tthis.key = key;\\n\\t\\t\\tthis.val = val;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic int compareTo(Pair o) {\\n\\t\\t\\treturn o.val - this.val;\\n\\t\\t}\\n\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        \\n    \\tint result[] = new int[nums.length - k + 1];\\n\\t\\tPriorityQueue<Pair> pq = new PriorityQueue<>();\\n\\t\\tint i = 0;\\n\\t\\tint j = 0;\\n\\t\\twhile (j < nums.length) {\\n\\t\\t\\tPair p = new Pair(j, nums[j]);\\n\\t\\t\\tpq.add(p);\\n\\t\\t\\tif (j - i + 1 < k) {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult[i] = pq.peek().val;\\n\\t\\t\\t\\twhile (!pq.isEmpty() && pq.peek().key < i+1) {\\n\\t\\t\\t\\t\\tpq.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\n\\t\\t}\\n        \\n        return result;\\n        \\n    }\\n    \\n    static class Pair implements Comparable<Pair> {\\n\\n\\t\\tint key;\\n\\t\\tint val;\\n\\n\\t\\tPair(int key, int val) {\\n\\t\\t\\tthis.key = key;\\n\\t\\t\\tthis.val = val;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic int compareTo(Pair o) {\\n\\t\\t\\treturn o.val - this.val;\\n\\t\\t}\\n\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823635,
                "title": "python-intuitive-solution",
                "content": "In my opinion, the official solution is too verbose and complex. Here is a simple, easy to read, and easy to understand solution with the same runtime complexity. Great thing about this is if in case you want the sliding window minimum, you just change the first comparator that is a \\'<=\\' or a \\'>=\\'.\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if k > len(nums) or not nums:\\n            return []\\n        \\n        ret = []\\n        q = deque()\\n        \\n        for i in range(len(nums)):\\n            # remove everything from the back that is <= the current num\\n            while q and q[-1][0] <= nums[i]:\\n                q.pop()\\n            # add the new num to the back\\n            q.append((nums[i], i))\\n            # remove everything from the front if it\\'s not in the window\\n            while q[0][1] <= i - k:\\n                q.popleft()\\n            # start adding results to output array once we have our first size k window\\n            if i >= k - 1:\\n                ret.append(q[0][0])\\n        \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if k > len(nums) or not nums:\\n            return []\\n        \\n        ret = []\\n        q = deque()\\n        \\n        for i in range(len(nums)):\\n            # remove everything from the back that is <= the current num\\n            while q and q[-1][0] <= nums[i]:\\n                q.pop()\\n            # add the new num to the back\\n            q.append((nums[i], i))\\n            # remove everything from the front if it\\'s not in the window\\n            while q[0][1] <= i - k:\\n                q.popleft()\\n            # start adding results to output array once we have our first size k window\\n            if i >= k - 1:\\n                ret.append(q[0][0])\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772773,
                "title": "time-o-n-log-k-space-o-k-using-set",
                "content": "```\\n// tc : O(nlogk)\\n// sc : O(k)\\nvector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n    int n = nums.size();\\n\\n    vector<int> result;\\n    set<pair<int, int>, greater<pair<int,int>>> s;\\n\\n    for(int i = 0; i < k; i++){\\n        s.insert(make_pair(nums[i], i));\\n    }\\n\\n    auto i = s.begin();\\n    result.push_back(i->first);\\n\\n    for(int i = 0, j = k; j < n; i++, j++){\\n        s.erase(make_pair(nums[i], i));\\n        s.insert(make_pair(nums[j], j));\\n        result.push_back(s.begin()->first);\\n    }\\n\\n    return result;\\n}\\n```\\n\\nthanks",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\n// tc : O(nlogk)\\n// sc : O(k)\\nvector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n    int n = nums.size();\\n\\n    vector<int> result;\\n    set<pair<int, int>, greater<pair<int,int>>> s;\\n\\n    for(int i = 0; i < k; i++){\\n        s.insert(make_pair(nums[i], i));\\n    }\\n\\n    auto i = s.begin();\\n    result.push_back(i->first);\\n\\n    for(int i = 0, j = k; j < n; i++, j++){\\n        s.erase(make_pair(nums[i], i));\\n        s.insert(make_pair(nums[j], j));\\n        result.push_back(s.begin()->first);\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653738,
                "title": "c-solution-with-explanation-deque-double-pointer",
                "content": "Solution is easy, which I try to explain in the attached photo. As I pass the address of the Node through the function, I used double pointer.\\nNote that, I save the index number of value in the dequeue.\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nstruct Node{\\n    int val;\\n    struct Node* prev;\\n    struct Node* next;\\n};\\n\\nint* maxSW(int* res, int* n, int nsize, int k);\\nvoid push(int i, int* n, struct Node** q, struct Node** head);\\nvoid pop(struct Node** head);\\n\\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){\\n\\n    int l=numsSize-k+1;\\n    int* res= malloc(l*sizeof(int));\\n    *returnSize= l;\\n    return maxSW(res,nums,numsSize,k);    \\n\\n}\\nint* maxSW(int* res, int* n, int nsize, int k)\\n{\\n    struct Node* queue=(struct Node*) malloc(sizeof(struct Node));\\n    queue->val=0;\\n    queue->prev=NULL;\\n    queue->next=NULL;\\n    struct Node* head=queue;\\n    int i=0;\\n    for(i=1; i<k; i++)  // generate dequeue(maximum to minimum) for first window(for the size of k)\\n    {\\n        push(i,n,&queue,&head);\\n    }\\n    res[0]=n[head->val]; //result for 1st sliding window.\\n    \\n    if(head->val==0)    //check if 1st value of dequeue (max) is the position which we will left(while sliding window)\\n        pop(&head);\\n        \\n        \\n    int j=1;    // using as index of result\\n    for(i=k; i<nsize; i++)  //slide window\\n    {\\n        push(i,n,&queue,&head); //push each value(index)\\n\\n        res[j]=n[head->val];    //result generating\\n        j++;\\n\\n        if((i-k+1)==head->val)  //pop max, if we left the position\\n            pop(&head);\\n    }\\n    \\n    return res;\\n    \\n}\\n\\nvoid push(int i, int* n, struct Node** q, struct Node** head)\\n{\\n    if(n[i]<n[(*q)->val])\\n    {\\n        (*q)->next=(struct Node*) malloc(sizeof(struct Node));\\n        (*q)->next->prev=(*q);\\n        (*q)=(*q)->next;\\n        (*q)->val=i;\\n        (*q)->next=NULL;\\n    }\\n    if(n[i]>=n[(*q)->val])\\n    {\\n        while((*q)!=NULL && n[i]>=n[(*q)->val] )!\\n\\n            (*q)=(*q)->prev;\\n       \\n        if((*q)==NULL)\\n        {\\n            (*q)=(struct Node*) malloc(sizeof(struct Node));\\n            (*head)=(*q);\\n            (*q)->val=i;\\n            (*q)->prev=NULL;\\n            (*q)->next=NULL;    \\n        }\\n        else\\n        {\\n            (*q)->next=(struct Node*) malloc(sizeof(struct Node));\\n            (*q)->next->prev=(*q);\\n            if((*head)!=NULL && (*head)->val>(*q)->val)\\n                (*head)=(*q)->next;\\n            (*q)=(*q)->next;\\n            (*q)->val=i;\\n            (*q)->next=NULL;\\n            \\n        }\\n    }\\n    \\n    if((*head)==NULL)\\n    {\\n        (*head)=(*q);\\n    }\\n}\\n\\nvoid pop(struct Node** head)\\n{\\n    \\n    *head=(*head)->next;\\n    \\n}\\n```\\n![image](https://assets.leetcode.com/users/zerin2645/image_1590513692.png)\\n",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nstruct Node{\\n    int val;\\n    struct Node* prev;\\n    struct Node* next;\\n};\\n\\nint* maxSW(int* res, int* n, int nsize, int k);\\nvoid push(int i, int* n, struct Node** q, struct Node** head);\\nvoid pop(struct Node** head);\\n\\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){\\n\\n    int l=numsSize-k+1;\\n    int* res= malloc(l*sizeof(int));\\n    *returnSize= l;\\n    return maxSW(res,nums,numsSize,k);    \\n\\n}\\nint* maxSW(int* res, int* n, int nsize, int k)\\n{\\n    struct Node* queue=(struct Node*) malloc(sizeof(struct Node));\\n    queue->val=0;\\n    queue->prev=NULL;\\n    queue->next=NULL;\\n    struct Node* head=queue;\\n    int i=0;\\n    for(i=1; i<k; i++)  // generate dequeue(maximum to minimum) for first window(for the size of k)\\n    {\\n        push(i,n,&queue,&head);\\n    }\\n    res[0]=n[head->val]; //result for 1st sliding window.\\n    \\n    if(head->val==0)    //check if 1st value of dequeue (max) is the position which we will left(while sliding window)\\n        pop(&head);\\n        \\n        \\n    int j=1;    // using as index of result\\n    for(i=k; i<nsize; i++)  //slide window\\n    {\\n        push(i,n,&queue,&head); //push each value(index)\\n\\n        res[j]=n[head->val];    //result generating\\n        j++;\\n\\n        if((i-k+1)==head->val)  //pop max, if we left the position\\n            pop(&head);\\n    }\\n    \\n    return res;\\n    \\n}\\n\\nvoid push(int i, int* n, struct Node** q, struct Node** head)\\n{\\n    if(n[i]<n[(*q)->val])\\n    {\\n        (*q)->next=(struct Node*) malloc(sizeof(struct Node));\\n        (*q)->next->prev=(*q);\\n        (*q)=(*q)->next;\\n        (*q)->val=i;\\n        (*q)->next=NULL;\\n    }\\n    if(n[i]>=n[(*q)->val])\\n    {\\n        while((*q)!=NULL && n[i]>=n[(*q)->val] )!\\n\\n            (*q)=(*q)->prev;\\n       \\n        if((*q)==NULL)\\n        {\\n            (*q)=(struct Node*) malloc(sizeof(struct Node));\\n            (*head)=(*q);\\n            (*q)->val=i;\\n            (*q)->prev=NULL;\\n            (*q)->next=NULL;    \\n        }\\n        else\\n        {\\n            (*q)->next=(struct Node*) malloc(sizeof(struct Node));\\n            (*q)->next->prev=(*q);\\n            if((*head)!=NULL && (*head)->val>(*q)->val)\\n                (*head)=(*q)->next;\\n            (*q)=(*q)->next;\\n            (*q)->val=i;\\n            (*q)->next=NULL;\\n            \\n        }\\n    }\\n    \\n    if((*head)==NULL)\\n    {\\n        (*head)=(*q);\\n    }\\n}\\n\\nvoid pop(struct Node** head)\\n{\\n    \\n    *head=(*head)->next;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532182,
                "title": "javascript-deque-o-n",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSlidingWindow = function(nums, k) {\\n    if (k === 0) return [];\\n    const deque = new Deque();\\n    for (let i = 0; i < k - 1; i++) {\\n        while (!deque.isEmpty() && deque.last().val <= nums[i]) deque.pop();\\n        deque.enqueue({ val: nums[i], idx: i });\\n    }\\n    const result = [];\\n    for (let i = k - 1; i < nums.length; i++) {\\n        if (!deque.isEmpty() && deque.first().idx <= i - k) deque.dequeue();\\n        while (!deque.isEmpty() && deque.last().val <= nums[i]) deque.pop();\\n        deque.enqueue({ val: nums[i], idx: i });\\n        result.push(deque.first().val);\\n    }\\n    return result;\\n};\\n\\nclass Deque {\\n    constructor() {\\n        this.head = new Node();\\n        this.tail = this.head;\\n    }\\n    \\n    isEmpty() {\\n        return this.head.next === null;\\n    }\\n    \\n    first() {\\n        return this.head.next.value;\\n    }\\n    \\n    last() {\\n        return this.tail.value;\\n    }\\n    \\n    dequeue() {\\n        this.head = this.head.next;\\n        this.head.prev = null;\\n    }\\n    \\n    enqueue(value) {\\n        this.tail.next = new Node(value);\\n        this.tail.next.prev = this.tail;\\n        this.tail = this.tail.next;\\n    }\\n    \\n    pop() {\\n        this.tail = this.tail.prev;\\n        this.tail.next = null;\\n    }\\n}\\n\\nclass Node {\\n    constructor(value) {\\n        this.value = value;\\n        this.next = null;\\n        this.prev = null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar maxSlidingWindow = function(nums, k) {\\n    if (k === 0) return [];\\n    const deque = new Deque();\\n    for (let i = 0; i < k - 1; i++) {\\n        while (!deque.isEmpty() && deque.last().val <= nums[i]) deque.pop();\\n        deque.enqueue({ val: nums[i], idx: i });\\n    }\\n    const result = [];\\n    for (let i = k - 1; i < nums.length; i++) {\\n        if (!deque.isEmpty() && deque.first().idx <= i - k) deque.dequeue();\\n        while (!deque.isEmpty() && deque.last().val <= nums[i]) deque.pop();\\n        deque.enqueue({ val: nums[i], idx: i });\\n        result.push(deque.first().val);\\n    }\\n    return result;\\n};\\n\\nclass Deque {\\n    constructor() {\\n        this.head = new Node();\\n        this.tail = this.head;\\n    }\\n    \\n    isEmpty() {\\n        return this.head.next === null;\\n    }\\n    \\n    first() {\\n        return this.head.next.value;\\n    }\\n    \\n    last() {\\n        return this.tail.value;\\n    }\\n    \\n    dequeue() {\\n        this.head = this.head.next;\\n        this.head.prev = null;\\n    }\\n    \\n    enqueue(value) {\\n        this.tail.next = new Node(value);\\n        this.tail.next.prev = this.tail;\\n        this.tail = this.tail.next;\\n    }\\n    \\n    pop() {\\n        this.tail = this.tail.prev;\\n        this.tail.next = null;\\n    }\\n}\\n\\nclass Node {\\n    constructor(value) {\\n        this.value = value;\\n        this.next = null;\\n        this.prev = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389594,
                "title": "share-3-solutions-priority-queue-monotone-queue-dynamic-programming",
                "content": "##### Priority Queue\\nTime: roughly O(nlogk)\\nSpace: roughly O(k)\\n```py\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n            return []\\n\\n        rst = []\\n        pq = []\\n\\n        # iterate through nums\\n        for idx, num in enumerate(nums):\\n            heapq.heappush(pq, (-num, idx))\\n\\n            if idx >= k:\\n                # remove elements which are already out of window\\n                while pq and pq[0][1] <= idx - k:\\n                    heapq.heappop(pq)\\n\\n            if idx >= k - 1:\\n                rst.append(-pq[0][0])\\n\\n        return rst\\n```\\n##### Monotone Queue\\nTime: O(n)\\nSpace: O(k)\\n```py\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n        \\treturn []\\n\\n        l = len(nums)\\n        if k > l:\\n        \\tk = l\\n\\n        # monotonously decreasing queue\\n        mono_queue = collections.deque()\\n        rst = []\\n\\n        for idx, num in enumerate(nums):\\n            # maintain the monotonously decreasing property\\n            while mono_queue and nums[mono_queue[-1]] <= num:\\n                mono_queue.pop()\\n\\n            # push current index onto the queue\\n            mono_queue.append(idx)\\n\\n            # check whether currently the largest element in the queue (element\\n            # at the front) is within the window or not\\n            while mono_queue and mono_queue[0] <= idx - k:\\n                mono_queue.popleft()\\n\\n            if idx >= k - 1:\\n                rst.append(nums[mono_queue[0]])\\n\\n        return rst\\n```\\n\\n##### Dynamic Programming\\nTime: O(n)\\nSpace: O(n)\\n```py\\nclass Solution:\\n    # idea from: https://leetcode.com/problems/sliding-window-maximum/solution/\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n            return []\\n\\n        len_ = len(nums)\\n        block_left_max = [0] * len_\\n        block_right_max = [0] * len_\\n        rst = []\\n\\n        # O(n)\\n        for i in range(0, len_, k):\\n            # left: start index of current block\\n            # right: end index of current block\\n            left, right = i, min(len_ -  1, i + k - 1)\\n            # fill block_left_max from the start of block\\n            block_left_max[left] = nums[left]\\n            for j in range(left + 1, right + 1):\\n                block_left_max[j] = max(block_left_max[j - 1], nums[j])\\n            # fill block_right_max from the end of block\\n            block_right_max[right] = nums[right]\\n            for j in range(right - 1, left - 1, -1):\\n                block_right_max[j] = max(block_right_max[j + 1], nums[j])\\n\\n        # iterate through nums, O(n)\\n        for left in range(0, len_ - k + 1):\\n            right = left + k - 1\\n            # situation 1: left and right are both in the block\\n            if left % k == 0:\\n                rst.append(block_left_max[right])\\n            # situation 2: left and right are both in the block\\n            else:\\n                rst.append(max(block_right_max[left], block_left_max[right]))\\n\\n        return rst\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n            return []\\n\\n        rst = []\\n        pq = []\\n\\n        # iterate through nums\\n        for idx, num in enumerate(nums):\\n            heapq.heappush(pq, (-num, idx))\\n\\n            if idx >= k:\\n                # remove elements which are already out of window\\n                while pq and pq[0][1] <= idx - k:\\n                    heapq.heappop(pq)\\n\\n            if idx >= k - 1:\\n                rst.append(-pq[0][0])\\n\\n        return rst\\n```\n```py\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n        \\treturn []\\n\\n        l = len(nums)\\n        if k > l:\\n        \\tk = l\\n\\n        # monotonously decreasing queue\\n        mono_queue = collections.deque()\\n        rst = []\\n\\n        for idx, num in enumerate(nums):\\n            # maintain the monotonously decreasing property\\n            while mono_queue and nums[mono_queue[-1]] <= num:\\n                mono_queue.pop()\\n\\n            # push current index onto the queue\\n            mono_queue.append(idx)\\n\\n            # check whether currently the largest element in the queue (element\\n            # at the front) is within the window or not\\n            while mono_queue and mono_queue[0] <= idx - k:\\n                mono_queue.popleft()\\n\\n            if idx >= k - 1:\\n                rst.append(nums[mono_queue[0]])\\n\\n        return rst\\n```\n```py\\nclass Solution:\\n    # idea from: https://leetcode.com/problems/sliding-window-maximum/solution/\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n            return []\\n\\n        len_ = len(nums)\\n        block_left_max = [0] * len_\\n        block_right_max = [0] * len_\\n        rst = []\\n\\n        # O(n)\\n        for i in range(0, len_, k):\\n            # left: start index of current block\\n            # right: end index of current block\\n            left, right = i, min(len_ -  1, i + k - 1)\\n            # fill block_left_max from the start of block\\n            block_left_max[left] = nums[left]\\n            for j in range(left + 1, right + 1):\\n                block_left_max[j] = max(block_left_max[j - 1], nums[j])\\n            # fill block_right_max from the end of block\\n            block_right_max[right] = nums[right]\\n            for j in range(right - 1, left - 1, -1):\\n                block_right_max[j] = max(block_right_max[j + 1], nums[j])\\n\\n        # iterate through nums, O(n)\\n        for left in range(0, len_ - k + 1):\\n            right = left + k - 1\\n            # situation 1: left and right are both in the block\\n            if left % k == 0:\\n                rst.append(block_left_max[right])\\n            # situation 2: left and right are both in the block\\n            else:\\n                rst.append(max(block_right_max[left], block_left_max[right]))\\n\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187814,
                "title": "javascript-es6",
                "content": "```\\nvar maxSlidingWindow = function(nums, k) {\\n  const result = [];\\n  if (nums.length == 0) return result;\\n  const deque = [];\\n  const add= n => {\\n    while(deque.length > 0 &&  n > deque[deque.length - 1]){\\n      deque.pop();\\n    }\\n    deque.push(n);\\n  }\\n  const remove = n => {\\n    if ( n == deque[0]) {\\n      deque.shift();\\n    } \\n  }\\n  let j = 0;\\n  nums.forEach((n, index) => {\\n    add(n);\\n    if(index >= (k -1)){\\n      result.push(deque[0]);\\n      remove(nums[j]);\\n      j++;\\n    }\\n  });\\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSlidingWindow = function(nums, k) {\\n  const result = [];\\n  if (nums.length == 0) return result;\\n  const deque = [];\\n  const add= n => {\\n    while(deque.length > 0 &&  n > deque[deque.length - 1]){\\n      deque.pop();\\n    }\\n    deque.push(n);\\n  }\\n  const remove = n => {\\n    if ( n == deque[0]) {\\n      deque.shift();\\n    } \\n  }\\n  let j = 0;\\n  nums.forEach((n, index) => {\\n    add(n);\\n    if(index >= (k -1)){\\n      result.push(deque[0]);\\n      remove(nums[j]);\\n      j++;\\n    }\\n  });\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916609,
                "title": "easiest-solution-with-minimum-t-c-possible",
                "content": "# Intuition\\nWe are using a **max heap** so that **max element** is always at the **top**\\nIn addtion to it, if the topmost element is **out of the window**(the case when we move forward but the max element is left behind). we **start popping** it until we are in the **range** of our **sliding window** itself.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n- Declare a max Heap and push a pair of the element and its corresponding index till k.\\n- Push back the top element at first in the answer vector.\\n- Now run a loop from index equal to k till n.\\n- While traversing keep pushing the elements and their indexes in the heap and at the same time\\n- Keep popping the elements who are left behind in the sliding window\\n- We will only pop if the top element is out of the sliding window \\n- And in the end we return our answer vector.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**O(N*KLog(K))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(N)**\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int, int>> pq;\\n        int n = nums.size();\\n        vector<int> ans;\\n\\n        for(int i = 0; i < k; i++) {\\n            pq.push({nums[i], i});\\n        }\\n\\n        ans.push_back(pq.top().first);\\n\\n        for(int i = k; i < n; i++) {\\n            pq.push({nums[i], i});\\n\\n            while(pq.top().second < i+1-k) {\\n                pq.pop();\\n            }\\n\\n            ans.push_back(pq.top().first);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n![4q0zf1.jpg](https://assets.leetcode.com/users/images/220731cf-83f5-4f86-99c2-b1673e43c2c3_1692167098.3389668.jpeg)",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int, int>> pq;\\n        int n = nums.size();\\n        vector<int> ans;\\n\\n        for(int i = 0; i < k; i++) {\\n            pq.push({nums[i], i});\\n        }\\n\\n        ans.push_back(pq.top().first);\\n\\n        for(int i = k; i < n; i++) {\\n            pq.push({nums[i], i});\\n\\n            while(pq.top().second < i+1-k) {\\n                pq.pop();\\n            }\\n\\n            ans.push_back(pq.top().first);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916077,
                "title": "acc-100-js-ts-java-c-c-c-python-python3-php-kotlin",
                "content": "---\\n![header_.png](https://assets.leetcode.com/users/images/ab4510d5-90e7-4616-b1e1-aac91ec90eea_1692159981.2067795.png)\\n\\n---\\n```Python3 []\\nfrom collections import deque\\n\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        result = []\\n        window = deque()  # Store indices of elements in the current window\\n        \\n        for i in range(len(nums)):\\n            # Remove elements that are out of the current window from the front of the deque\\n            while window and window[0] < i - k + 1:\\n                window.popleft()\\n            \\n            # Remove elements that are smaller than the current element from the back of the deque\\n            while window and nums[window[-1]] < nums[i]:\\n                window.pop()\\n            \\n            # Add the current index to the back of the deque\\n            window.append(i)\\n            \\n            # Append the maximum element of the current window to the result\\n            if i >= k - 1:\\n                result.append(nums[window[0]])\\n        \\n        return result\\n```\\n```python []\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if not nums:\\n            return []\\n\\n        result = []\\n        window = deque()  # Stores indices of elements within the sliding window\\n\\n        for i in range(len(nums)):\\n            # Remove indices that are out of the current sliding window\\n            while window and window[0] < i - k + 1:\\n                window.popleft()\\n\\n            # Remove indices of smaller elements since they will not be useful\\n            while window and nums[window[-1]] < nums[i]:\\n                window.pop()\\n\\n            window.append(i)  # Add the current index to the deque\\n\\n            # The first element in the deque is always the maximum for the current window\\n            if i >= k - 1:\\n                result.append(nums[window[0]])\\n\\n        return result\\n```\\n```Javascript []\\nvar maxSlidingWindow = function(nums, k) {\\n    const result = [];\\n    const deque = []; // Store indices of elements\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        // Remove elements that are out of the current window\\n        while (deque.length > 0 && deque[0] < i - k + 1) {\\n            deque.shift();\\n        }\\n        \\n        // Remove smaller elements as they are not potential max candidates\\n        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {\\n            deque.pop();\\n        }\\n        \\n        deque.push(i);\\n        \\n        // The front element of the deque is always the maximum for the current window\\n        if (i >= k - 1) {\\n            result.push(nums[deque[0]]);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\n```Typrscript []\\nfunction maxSlidingWindow(nums: number[], k: number): number[] {\\n    const result: number[] = [];\\n    const deque: number[] = []; // Store indices, not actual elements\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        // Remove elements that are out of the current window\\n        while (deque.length > 0 && deque[0] < i - k + 1) {\\n            deque.shift();\\n        }\\n        \\n        // Remove elements that are smaller than the current element\\n        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {\\n            deque.pop();\\n        }\\n        \\n        deque.push(i); // Add the current element\\'s index to the deque\\n        \\n        // If the left end of the window is inside the array, add maximum to the result\\n        if (i >= k - 1) {\\n            result.push(nums[deque[0]]);\\n        }\\n    }\\n    \\n    return result;\\n}\\n```\\n```Java []\\nimport java.util.ArrayDeque;\\nimport java.util.Deque;\\n\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if (nums == null || nums.length == 0 || k <= 0) {\\n            return new int[0];\\n        }\\n        \\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n        int resultIdx = 0;\\n        \\n        Deque<Integer> deque = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Remove elements that are out of the current window\\n            while (!deque.isEmpty() && deque.peek() < i - k + 1) {\\n                deque.poll();\\n            }\\n            \\n            // Remove smaller elements as they are no longer candidates for max\\n            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\\n                deque.pollLast();\\n            }\\n            \\n            deque.offer(i); // Add current index to the deque\\n            \\n            // Add max element to the result array for the current window\\n            if (i >= k - 1) {\\n                result[resultIdx++] = nums[deque.peek()];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n```PHP []\\nclass Solution {\\nfunction maxSlidingWindow($nums, $k)\\n{\\n\\tif ($k == 1) {\\n\\t\\treturn $nums;\\n\\t}\\n\\n\\t$count = count($nums);\\n\\tif ($k >= $count) {\\n\\t\\treturn [max($nums)];\\n\\t}\\n\\n\\t$result = [];\\n\\t$queue = new SplQueue();\\n\\n\\tfor ($i = 0; $i < $k; $i++) {\\n\\t\\twhile (!$queue->isEmpty() && $nums[$i] >= $nums[$queue->top()]) {\\n\\t\\t\\t $queue->pop();\\n\\t\\t}\\n\\t\\t$queue->push($i);\\n\\t}\\n\\n\\tfor (; $i < $count; $i++) {\\n\\t\\t$result[] = $nums[$queue->bottom()];\\n\\n\\t\\tif (!$queue->isEmpty() && $queue->bottom() <= $i - $k) {\\n\\t\\t\\t$queue->shift();\\n\\t\\t}\\n\\n\\t\\twhile (!$queue->isEmpty() && $nums[$i] >= $nums[$queue->top()]) {\\n\\t\\t\\t$queue->pop();\\n\\t\\t}\\n\\t\\t$queue->push($i);\\n\\t}\\n\\n\\t$result[] = $nums[$queue->bottom()];\\n\\n\\treturn $result;\\n}\\n}\\n```\\n```Kotlin []\\nimport java.util.PriorityQueue\\n\\nclass Solution {\\n    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {\\n        val result = mutableListOf<Int>()\\n        val maxHeap = PriorityQueue<Pair<Int, Int>>(compareBy { -it.first })\\n        \\n        for (i in nums.indices) {\\n            // Remove elements that are out of the current window\\n            while (maxHeap.isNotEmpty() && maxHeap.peek().second < i - k + 1) {\\n                maxHeap.poll()\\n            }\\n            \\n            // Add the current element to the heap\\n            maxHeap.offer(nums[i] to i)\\n            \\n            // Add the maximum element in the current window to the result\\n            if (i >= k - 1) {\\n                result.add(maxHeap.peek().first)\\n            }\\n        }\\n        \\n        return result.toIntArray()\\n    }\\n}\\n```\\n```C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\\n    if (numsSize == 0 || k == 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n\\n    // Calculate the number of sliding windows\\n    int numWindows = numsSize - k + 1;\\n\\n    // Allocate memory for the result array\\n    int *result = (int *)malloc(numWindows * sizeof(int));\\n    if (!result) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n\\n    // Create a deque (double-ended queue) to store indices of elements in the sliding window\\n    int *deque = (int *)malloc(numsSize * sizeof(int));\\n    int front = 0, rear = -1; // Indices for the front and rear of the deque\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        // Remove elements that are out of the current sliding window from the front of the deque\\n        while (front <= rear && deque[front] < i - k + 1) {\\n            front++;\\n        }\\n\\n        // Remove elements that are smaller than the current element from the rear of the deque\\n        while (front <= rear && nums[deque[rear]] < nums[i]) {\\n            rear--;\\n        }\\n\\n        // Add the current element\\'s index to the rear of the deque\\n        deque[++rear] = i;\\n\\n        // Calculate the maximum value for the current sliding window\\n        if (i >= k - 1) {\\n            result[i - k + 1] = nums[deque[front]];\\n        }\\n    }\\n\\n    *returnSize = numWindows;\\n    free(deque);\\n    return result;\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> result;\\n        deque<int> window; // Stores indices of elements within the current window\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            // Remove indices that are out of the current window\\n            while (!window.empty() && window.front() <= i - k)\\n                window.pop_front();\\n            \\n            // Remove smaller elements from the back as they won\\'t affect the maximum\\n            while (!window.empty() && nums[window.back()] < nums[i])\\n                window.pop_back();\\n            \\n            window.push_back(i); // Add the current index to the window\\n            \\n            // The first element in the window is always the maximum for the current window\\n            if (i >= k - 1)\\n                result.push_back(nums[window.front()]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int[] MaxSlidingWindow(int[] nums, int k) {\\n        if (nums.Length == 0 || k == 0) {\\n            return new int[0];\\n        }\\n        \\n        int n = nums.Length;\\n        int[] result = new int[n - k + 1];\\n        int ri = 0; // Index for the result array\\n        \\n        // Create a deque to store indices of elements in the current window\\n        LinkedList<int> deque = new LinkedList<int>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Remove indices of elements that are out of the current window\\n            while (deque.Count > 0 && deque.First.Value < i - k + 1) {\\n                deque.RemoveFirst();\\n            }\\n            \\n            // Remove indices of elements that are smaller than the current element\\n            while (deque.Count > 0 && nums[deque.Last.Value] < nums[i]) {\\n                deque.RemoveLast();\\n            }\\n            \\n            // Add the current index to the deque\\n            deque.AddLast(i);\\n            \\n            // The first element in the deque is always the maximum for the current window\\n            if (i >= k - 1) {\\n                result[ri++] = nums[deque.First.Value];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n---\\n![download.jpg](https://assets.leetcode.com/users/images/5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg)\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```Python3 []\\nfrom collections import deque\\n\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        result = []\\n        window = deque()  # Store indices of elements in the current window\\n        \\n        for i in range(len(nums)):\\n            # Remove elements that are out of the current window from the front of the deque\\n            while window and window[0] < i - k + 1:\\n                window.popleft()\\n            \\n            # Remove elements that are smaller than the current element from the back of the deque\\n            while window and nums[window[-1]] < nums[i]:\\n                window.pop()\\n            \\n            # Add the current index to the back of the deque\\n            window.append(i)\\n            \\n            # Append the maximum element of the current window to the result\\n            if i >= k - 1:\\n                result.append(nums[window[0]])\\n        \\n        return result\\n```\n```python []\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if not nums:\\n            return []\\n\\n        result = []\\n        window = deque()  # Stores indices of elements within the sliding window\\n\\n        for i in range(len(nums)):\\n            # Remove indices that are out of the current sliding window\\n            while window and window[0] < i - k + 1:\\n                window.popleft()\\n\\n            # Remove indices of smaller elements since they will not be useful\\n            while window and nums[window[-1]] < nums[i]:\\n                window.pop()\\n\\n            window.append(i)  # Add the current index to the deque\\n\\n            # The first element in the deque is always the maximum for the current window\\n            if i >= k - 1:\\n                result.append(nums[window[0]])\\n\\n        return result\\n```\n```Javascript []\\nvar maxSlidingWindow = function(nums, k) {\\n    const result = [];\\n    const deque = []; // Store indices of elements\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        // Remove elements that are out of the current window\\n        while (deque.length > 0 && deque[0] < i - k + 1) {\\n            deque.shift();\\n        }\\n        \\n        // Remove smaller elements as they are not potential max candidates\\n        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {\\n            deque.pop();\\n        }\\n        \\n        deque.push(i);\\n        \\n        // The front element of the deque is always the maximum for the current window\\n        if (i >= k - 1) {\\n            result.push(nums[deque[0]]);\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\n```Typrscript []\\nfunction maxSlidingWindow(nums: number[], k: number): number[] {\\n    const result: number[] = [];\\n    const deque: number[] = []; // Store indices, not actual elements\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        // Remove elements that are out of the current window\\n        while (deque.length > 0 && deque[0] < i - k + 1) {\\n            deque.shift();\\n        }\\n        \\n        // Remove elements that are smaller than the current element\\n        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {\\n            deque.pop();\\n        }\\n        \\n        deque.push(i); // Add the current element\\'s index to the deque\\n        \\n        // If the left end of the window is inside the array, add maximum to the result\\n        if (i >= k - 1) {\\n            result.push(nums[deque[0]]);\\n        }\\n    }\\n    \\n    return result;\\n}\\n```\n```Java []\\nimport java.util.ArrayDeque;\\nimport java.util.Deque;\\n\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if (nums == null || nums.length == 0 || k <= 0) {\\n            return new int[0];\\n        }\\n        \\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n        int resultIdx = 0;\\n        \\n        Deque<Integer> deque = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Remove elements that are out of the current window\\n            while (!deque.isEmpty() && deque.peek() < i - k + 1) {\\n                deque.poll();\\n            }\\n            \\n            // Remove smaller elements as they are no longer candidates for max\\n            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {\\n                deque.pollLast();\\n            }\\n            \\n            deque.offer(i); // Add current index to the deque\\n            \\n            // Add max element to the result array for the current window\\n            if (i >= k - 1) {\\n                result[resultIdx++] = nums[deque.peek()];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```PHP []\\nclass Solution {\\nfunction maxSlidingWindow($nums, $k)\\n{\\n\\tif ($k == 1) {\\n\\t\\treturn $nums;\\n\\t}\\n\\n\\t$count = count($nums);\\n\\tif ($k >= $count) {\\n\\t\\treturn [max($nums)];\\n\\t}\\n\\n\\t$result = [];\\n\\t$queue = new SplQueue();\\n\\n\\tfor ($i = 0; $i < $k; $i++) {\\n\\t\\twhile (!$queue->isEmpty() && $nums[$i] >= $nums[$queue->top()]) {\\n\\t\\t\\t $queue->pop();\\n\\t\\t}\\n\\t\\t$queue->push($i);\\n\\t}\\n\\n\\tfor (; $i < $count; $i++) {\\n\\t\\t$result[] = $nums[$queue->bottom()];\\n\\n\\t\\tif (!$queue->isEmpty() && $queue->bottom() <= $i - $k) {\\n\\t\\t\\t$queue->shift();\\n\\t\\t}\\n\\n\\t\\twhile (!$queue->isEmpty() && $nums[$i] >= $nums[$queue->top()]) {\\n\\t\\t\\t$queue->pop();\\n\\t\\t}\\n\\t\\t$queue->push($i);\\n\\t}\\n\\n\\t$result[] = $nums[$queue->bottom()];\\n\\n\\treturn $result;\\n}\\n}\\n```\n```Kotlin []\\nimport java.util.PriorityQueue\\n\\nclass Solution {\\n    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {\\n        val result = mutableListOf<Int>()\\n        val maxHeap = PriorityQueue<Pair<Int, Int>>(compareBy { -it.first })\\n        \\n        for (i in nums.indices) {\\n            // Remove elements that are out of the current window\\n            while (maxHeap.isNotEmpty() && maxHeap.peek().second < i - k + 1) {\\n                maxHeap.poll()\\n            }\\n            \\n            // Add the current element to the heap\\n            maxHeap.offer(nums[i] to i)\\n            \\n            // Add the maximum element in the current window to the result\\n            if (i >= k - 1) {\\n                result.add(maxHeap.peek().first)\\n            }\\n        }\\n        \\n        return result.toIntArray()\\n    }\\n}\\n```\n```C []\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {\\n    if (numsSize == 0 || k == 0) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n\\n    // Calculate the number of sliding windows\\n    int numWindows = numsSize - k + 1;\\n\\n    // Allocate memory for the result array\\n    int *result = (int *)malloc(numWindows * sizeof(int));\\n    if (!result) {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n\\n    // Create a deque (double-ended queue) to store indices of elements in the sliding window\\n    int *deque = (int *)malloc(numsSize * sizeof(int));\\n    int front = 0, rear = -1; // Indices for the front and rear of the deque\\n\\n    for (int i = 0; i < numsSize; i++) {\\n        // Remove elements that are out of the current sliding window from the front of the deque\\n        while (front <= rear && deque[front] < i - k + 1) {\\n            front++;\\n        }\\n\\n        // Remove elements that are smaller than the current element from the rear of the deque\\n        while (front <= rear && nums[deque[rear]] < nums[i]) {\\n            rear--;\\n        }\\n\\n        // Add the current element\\'s index to the rear of the deque\\n        deque[++rear] = i;\\n\\n        // Calculate the maximum value for the current sliding window\\n        if (i >= k - 1) {\\n            result[i - k + 1] = nums[deque[front]];\\n        }\\n    }\\n\\n    *returnSize = numWindows;\\n    free(deque);\\n    return result;\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> result;\\n        deque<int> window; // Stores indices of elements within the current window\\n        \\n        for (int i = 0; i < nums.size(); ++i) {\\n            // Remove indices that are out of the current window\\n            while (!window.empty() && window.front() <= i - k)\\n                window.pop_front();\\n            \\n            // Remove smaller elements from the back as they won\\'t affect the maximum\\n            while (!window.empty() && nums[window.back()] < nums[i])\\n                window.pop_back();\\n            \\n            window.push_back(i); // Add the current index to the window\\n            \\n            // The first element in the window is always the maximum for the current window\\n            if (i >= k - 1)\\n                result.push_back(nums[window.front()]);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int[] MaxSlidingWindow(int[] nums, int k) {\\n        if (nums.Length == 0 || k == 0) {\\n            return new int[0];\\n        }\\n        \\n        int n = nums.Length;\\n        int[] result = new int[n - k + 1];\\n        int ri = 0; // Index for the result array\\n        \\n        // Create a deque to store indices of elements in the current window\\n        LinkedList<int> deque = new LinkedList<int>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Remove indices of elements that are out of the current window\\n            while (deque.Count > 0 && deque.First.Value < i - k + 1) {\\n                deque.RemoveFirst();\\n            }\\n            \\n            // Remove indices of elements that are smaller than the current element\\n            while (deque.Count > 0 && nums[deque.Last.Value] < nums[i]) {\\n                deque.RemoveLast();\\n            }\\n            \\n            // Add the current index to the deque\\n            deque.AddLast(i);\\n            \\n            // The first element in the deque is always the maximum for the current window\\n            if (i >= k - 1) {\\n                result[ri++] = nums[deque.First.Value];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3057730,
                "title": "simple-and-easy-to-understand-queue",
                "content": "* *Time Complexity :* **O(N)**\\n* *Space Complexity:* **O(K)** #if we ignore result list\\n```\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        res = []\\n        queue = []\\n        for i, num in enumerate(nums):\\n            while queue and nums[queue[-1]] <= num:\\n                queue.pop()\\n            queue.append(i)\\n            if i - k == queue[0]: queue.pop(0)\\n            if i + 1 >= k:\\n                res.append(nums[queue[0]])\\n        return res\\n```\\n*UpVote,* if you like it **:)**",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        res = []\\n        queue = []\\n        for i, num in enumerate(nums):\\n            while queue and nums[queue[-1]] <= num:\\n                queue.pop()\\n            queue.append(i)\\n            if i - k == queue[0]: queue.pop(0)\\n            if i + 1 >= k:\\n                res.append(nums[queue[0]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741932,
                "title": "c-sliding-window-using-deque-easy-solution-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n       vector<int> ans;\\n       for(int i=0;i<nums.size();i++){\\n           //Remove out of range k\\n           if(!dq.empty() && dq.front() == i-k) dq.pop_front();\\n           \\n           //remive smaller numbers in k range as they are useless\\n           while(!dq.empty() && nums[dq.back()] <= nums[i]){\\n               dq.pop_back();\\n           }\\n           \\n           dq.push_back(i);\\n           if(i >= k-1){\\n               ans.push_back(nums[dq.front()]);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n       vector<int> ans;\\n       for(int i=0;i<nums.size();i++){\\n           //Remove out of range k\\n           if(!dq.empty() && dq.front() == i-k) dq.pop_front();\\n           \\n           //remive smaller numbers in k range as they are useless\\n           while(!dq.empty() && nums[dq.back()] <= nums[i]){\\n               dq.pop_back();\\n           }\\n           \\n           dq.push_back(i);\\n           if(i >= k-1){\\n               ans.push_back(nums[dq.front()]);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723385,
                "title": "java-treemap-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;  //length of array\\n        int m=0; //counter for ans array\\n        int[] ans=new int[n-k+1]; //array to store output\\n        TreeMap<Integer, Integer> treeMap=new TreeMap<>(); //<Element,Frequency>\\n        for(int i=0;i<n;i++){   //iterate over array \\n            \\n            /*add element at ith index of array in treeMap. \\n            If no freq mapped(naya element aaya), it take default value 0 and increament one. \\n            If element already exists, just increament the frequency by 1*/\\n            treeMap.put(nums[i],treeMap.getOrDefault(nums[i],0)+1);  \\n            \\n            if(i>=k-1){    //if k=3, toh teen element is in tree map so now we can perform the necessary operations\\n                \\n                //Treemap has data in sorted fashion so extract the last key which is also maximux\\n                ans[m++]=treeMap.lastKey();\\n                \\n                //from the Starting, one element has to be removed(i-k+1) so that another can be taken into consideration, so we decreament its frequency\\n                treeMap.put(nums[i-k+1],treeMap.get(nums[i-k+1])-1);\\n                \\n                //if frequency of(i-k+1)th element becomes zero, we simply remove that element.\\n                if(treeMap.get(nums[i-k+1])==0)\\n                    treeMap.remove(nums[i-k+1]);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;  //length of array\\n        int m=0; //counter for ans array\\n        int[] ans=new int[n-k+1]; //array to store output\\n        TreeMap<Integer, Integer> treeMap=new TreeMap<>(); //<Element,Frequency>\\n        for(int i=0;i<n;i++){   //iterate over array \\n            \\n            /*add element at ith index of array in treeMap. \\n            If no freq mapped(naya element aaya), it take default value 0 and increament one. \\n            If element already exists, just increament the frequency by 1*/\\n            treeMap.put(nums[i],treeMap.getOrDefault(nums[i],0)+1);  \\n            \\n            if(i>=k-1){    //if k=3, toh teen element is in tree map so now we can perform the necessary operations\\n                \\n                //Treemap has data in sorted fashion so extract the last key which is also maximux\\n                ans[m++]=treeMap.lastKey();\\n                \\n                //from the Starting, one element has to be removed(i-k+1) so that another can be taken into consideration, so we decreament its frequency\\n                treeMap.put(nums[i-k+1],treeMap.get(nums[i-k+1])-1);\\n                \\n                //if frequency of(i-k+1)th element becomes zero, we simply remove that element.\\n                if(treeMap.get(nums[i-k+1])==0)\\n                    treeMap.remove(nums[i-k+1]);\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718690,
                "title": "3-methods-using-priority-queue-doubly-ended-queue-and-dp-commented",
                "content": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n\\t\\n        // Priority Queue =========================================================\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        for (int i = 0; i < k; ++i) pq.add(new int[]{nums[i], i});\\n        int[] ans = new int[nums.length - k + 1];\\n        ans[0] = pq.peek()[0];\\n        int j = 1;\\n        for (int i = k; i < nums.length; ++i) {\\n            pq.add(new int[]{nums[i], i});\\n            while (pq.peek()[1] <= i - k)\\n                pq.poll();\\n            ans[j++] = pq.peek()[0];\\n        }\\n        return ans;\\n        \\n        // Dequeue ================================================================\\n        if (nums == null || k < 0) return new int[0];\\n        int n = nums.length;\\n        int[] arr = new int[n - k + 1];\\n        // stores index\\n        Deque<Integer> que = new ArrayDeque<>();\\n        int j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            // remove numbers from start if they are out of range\\n            while (!que.isEmpty() && que.peek() < i - k + 1)\\n                que.poll();\\n            // remove numbers from last if they are smaller than current no. bcz they are useless (just like me)\\n            while (!que.isEmpty() && nums[que.peekLast()] < nums[i])\\n                que.pollLast();\\n            // put current index in queue\\n            que.offer(i);\\n            if (i >= k - 1)\\n                arr[j++] = nums[que.peek()];\\n        }\\n        return arr;\\n    }\\n\\t\\n\\t// DP =====================================================================\\n        if (nums == null || k < 0) return new int[0];\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        left[0] = nums[0];\\n        int[] right = new int[n];\\n        right[n - 1] = nums[n - 1];\\n        for (int i = 1; i < n; ++i) {\\n            if (i % k == 0) {\\n                left[i] = nums[i];\\n            } else {\\n                left[i] = Math.max( nums[i], left[i - 1] );\\n            }\\n            \\n            int j = n - 1 - i;\\n            if ((j + 1) % k == 0) {\\n                right[j] = nums[j];\\n            } else {\\n                right[j] = Math.max( nums[j], right[j + 1] );\\n            }\\n        }\\n        int[] ans = new int[n - k + 1];\\n        for (int i = 0; i < n - k + 1; ++i)\\n            ans[i] = Math.max( right[i], left[i + k - 1] );\\n        return ans;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n\\t\\n        // Priority Queue =========================================================\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        for (int i = 0; i < k; ++i) pq.add(new int[]{nums[i], i});\\n        int[] ans = new int[nums.length - k + 1];\\n        ans[0] = pq.peek()[0];\\n        int j = 1;\\n        for (int i = k; i < nums.length; ++i) {\\n            pq.add(new int[]{nums[i], i});\\n            while (pq.peek()[1] <= i - k)\\n                pq.poll();\\n            ans[j++] = pq.peek()[0];\\n        }\\n        return ans;\\n        \\n        // Dequeue ================================================================\\n        if (nums == null || k < 0) return new int[0];\\n        int n = nums.length;\\n        int[] arr = new int[n - k + 1];\\n        // stores index\\n        Deque<Integer> que = new ArrayDeque<>();\\n        int j = 0;\\n        for (int i = 0; i < n; ++i) {\\n            // remove numbers from start if they are out of range\\n            while (!que.isEmpty() && que.peek() < i - k + 1)\\n                que.poll();\\n            // remove numbers from last if they are smaller than current no. bcz they are useless (just like me)\\n            while (!que.isEmpty() && nums[que.peekLast()] < nums[i])\\n                que.pollLast();\\n            // put current index in queue\\n            que.offer(i);\\n            if (i >= k - 1)\\n                arr[j++] = nums[que.peek()];\\n        }\\n        return arr;\\n    }\\n\\t\\n\\t// DP =====================================================================\\n        if (nums == null || k < 0) return new int[0];\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        left[0] = nums[0];\\n        int[] right = new int[n];\\n        right[n - 1] = nums[n - 1];\\n        for (int i = 1; i < n; ++i) {\\n            if (i % k == 0) {\\n                left[i] = nums[i];\\n            } else {\\n                left[i] = Math.max( nums[i], left[i - 1] );\\n            }\\n            \\n            int j = n - 1 - i;\\n            if ((j + 1) % k == 0) {\\n                right[j] = nums[j];\\n            } else {\\n                right[j] = Math.max( nums[j], right[j + 1] );\\n            }\\n        }\\n        int[] ans = new int[n - k + 1];\\n        for (int i = 0; i < n - k + 1; ++i)\\n            ans[i] = Math.max( right[i], left[i + k - 1] );\\n        return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541248,
                "title": "c-o-n-stack",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:** Nearest Greater on Right\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// storing index of Next Greater or Equal on Right\\n    vector<int> greaterEqualOnRight(vector<int>& a){\\n        int n=a.size();\\n        vector<int> ngr(n,n);\\n        stack<pair<int,int>> st;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()>0 && st.top().first<a[i]) st.pop();\\n            if(st.size()>0){\\n                ngr[i]=st.top().second;\\n            }\\n            st.push({a[i],i});\\n        }\\n        return ngr;\\n    }\\n    \\n    vector<int> maxSlidingWindow(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> ngr=greaterEqualOnRight(a);\\n        \\n        int i=0, j=0;\\n        vector<int> ans;\\n\\t\\t// i is starting index of K size window\\n\\t\\t// j points at max value in window\\n        while(i<=n-k){\\n            j=max(i,j);\\n            while(ngr[j]<i+k){\\n                j=ngr[j]; // if index is within k size window for next greater element\\n            }\\n            ans.push_back(a[j]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// storing index of Next Greater or Equal on Right\\n    vector<int> greaterEqualOnRight(vector<int>& a){\\n        int n=a.size();\\n        vector<int> ngr(n,n);\\n        stack<pair<int,int>> st;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()>0 && st.top().first<a[i]) st.pop();\\n            if(st.size()>0){\\n                ngr[i]=st.top().second;\\n            }\\n            st.push({a[i],i});\\n        }\\n        return ngr;\\n    }\\n    \\n    vector<int> maxSlidingWindow(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> ngr=greaterEqualOnRight(a);\\n        \\n        int i=0, j=0;\\n        vector<int> ans;\\n\\t\\t// i is starting index of K size window\\n\\t\\t// j points at max value in window\\n        while(i<=n-k){\\n            j=max(i,j);\\n            while(ngr[j]<i+k){\\n                j=ngr[j]; // if index is within k size window for next greater element\\n            }\\n            ans.push_back(a[j]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479215,
                "title": "c-o-n-stacks-highly-readable-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        \\n        // Find next greater element to the right of every element\\n        int * right = new int[nums.size()];\\n        stack<int> st;\\n        st.push(nums.size() - 1);\\n        right[nums.size()-1] = nums.size();\\n        \\n        for(int idx = nums.size() - 2; idx >= 0; idx--){\\n            while(st.size() > 0 && nums[idx] >= nums[st.top()])\\n                st.pop();\\n            \\n            if(st.size() == 0)\\n                right[idx] = nums.size();\\n            else\\n                right[idx] = st.top();\\n            \\n            st.push(idx);\\n        }\\n        \\n        // Now find next greater element in current window\\n        int jdx = 0;\\n        vector<int> ans;\\n        for(int idx = 0; idx <= nums.size() - k; idx ++){\\n            if(jdx < idx)\\n                jdx = idx;\\n            \\n            while(right[jdx] < idx + k)\\n                jdx = right[jdx];\\n            \\n            ans.push_back(nums[jdx]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nThanks for reading through - and make sure you upvote if it helped you !\\nDo comment down for any queries : )",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        \\n        // Find next greater element to the right of every element\\n        int * right = new int[nums.size()];\\n        stack<int> st;\\n        st.push(nums.size() - 1);\\n        right[nums.size()-1] = nums.size();\\n        \\n        for(int idx = nums.size() - 2; idx >= 0; idx--){\\n            while(st.size() > 0 && nums[idx] >= nums[st.top()])\\n                st.pop();\\n            \\n            if(st.size() == 0)\\n                right[idx] = nums.size();\\n            else\\n                right[idx] = st.top();\\n            \\n            st.push(idx);\\n        }\\n        \\n        // Now find next greater element in current window\\n        int jdx = 0;\\n        vector<int> ans;\\n        for(int idx = 0; idx <= nums.size() - k; idx ++){\\n            if(jdx < idx)\\n                jdx = idx;\\n            \\n            while(right[jdx] < idx + k)\\n                jdx = right[jdx];\\n            \\n            ans.push_back(nums[jdx]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307306,
                "title": "python-8-line-solution-using-heap",
                "content": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        h,ans  =[],[]\\n        for i in range(k):heappush(h,(-nums[i],i))\\n        ans.append(-h[0][0])\\n        for i in range(k,len(nums)):\\n            heappush(h, (-nums[i],i))    \\n            while h and (i - h[0][1]) >=k:heappop(h)    \\n            ans.append((-h[0][0]))\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        h,ans  =[],[]\\n        for i in range(k):heappush(h,(-nums[i],i))\\n        ans.append(-h[0][0])\\n        for i in range(k,len(nums)):\\n            heappush(h, (-nums[i],i))    \\n            while h and (i - h[0][1]) >=k:heappop(h)    \\n            ans.append((-h[0][0]))\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280531,
                "title": "c-easy-solution-using-set",
                "content": "For every window of size k we need to find maximum element. Following are the steps:\\n1. Insert first K elements to set and add last element of set to answer vector.\\n2. Iterate over the whole array starting from K and at every index remove the last kth element i.e (i-k) and push last element of set into answer vector.\\n\\n*Note- This method is very useful in many such kind of problems.*\\nSimilar problem -[JUMP GAME VI](http://leetcode.com/problems/jump-game-vi/discuss/1263356/C++-DP+MULTISET+EASY) \\n\\n**SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        multiset<int>S;\\n        int n=nums.size();\\n        for(int i=0;i<k;i++) S.insert(nums[i]);  // inserting first k elements\\n        vector<int>v;\\n        v.push_back(*S.rbegin());  //max element of set\\n        for(int i=k;i<n;i++)\\n        {\\n            S.erase(S.find(nums[i-k]));   //use set.find as it erases only first occurance of element\\n            S.insert(nums[i]);\\n            v.push_back(*S.rbegin());\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n**Time Complexity : O(nlogk)**\\n**Space : O(k)**\\nCorrect me if I\\'m wrong somewhere and upvote it.\\n**Thanks**",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        multiset<int>S;\\n        int n=nums.size();\\n        for(int i=0;i<k;i++) S.insert(nums[i]);  // inserting first k elements\\n        vector<int>v;\\n        v.push_back(*S.rbegin());  //max element of set\\n        for(int i=k;i<n;i++)\\n        {\\n            S.erase(S.find(nums[i-k]));   //use set.find as it erases only first occurance of element\\n            S.insert(nums[i]);\\n            v.push_back(*S.rbegin());\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232432,
                "title": "three-solution-naive-to-better-to-efficient-short-code-and-begginer-friendly",
                "content": "**First Approach: Naive O(n*k) TLE**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>q;\\n        vector<int>res;\\n        int ind=0,maxx=INT_MIN;\\n        for(ind=0;ind<k;ind++){\\n            q.push_back(nums[ind]);\\n            maxx=max(maxx,nums[ind]);\\n        }\\n        res.push_back(maxx);\\n        for(int i=ind;i<nums.size();i++){\\n            int val;\\n            q.pop_front();\\n            q.push_back(nums[i]);\\n            val= *max_element(q.begin(),q.end());\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**2nd Approach: Better O(n*logk)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        vector<int>res;\\n        int ind=0;\\n        for(ind=0;ind<k;ind++){\\n            pq.push({nums[ind],ind});\\n        }\\n        res.push_back(pq.top().first);\\n        for(int i=ind;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=i-k) pq.pop();\\n            res.push_back(pq.top().first);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**3rd Approach: Efficient O(n)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<pair<int,int>>dq;\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            while(!dq.empty() && dq.back().first<nums[i])\\n                dq.pop_back();\\n            dq.push_back({nums[i],i});\\n            if(i>=k-1){\\n                if(dq.front().second==i-k) dq.pop_front();\\n                res.push_back(dq.front().first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>q;\\n        vector<int>res;\\n        int ind=0,maxx=INT_MIN;\\n        for(ind=0;ind<k;ind++){\\n            q.push_back(nums[ind]);\\n            maxx=max(maxx,nums[ind]);\\n        }\\n        res.push_back(maxx);\\n        for(int i=ind;i<nums.size();i++){\\n            int val;\\n            q.pop_front();\\n            q.push_back(nums[i]);\\n            val= *max_element(q.begin(),q.end());\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>pq;\\n        vector<int>res;\\n        int ind=0;\\n        for(ind=0;ind<k;ind++){\\n            pq.push({nums[ind],ind});\\n        }\\n        res.push_back(pq.top().first);\\n        for(int i=ind;i<nums.size();i++){\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=i-k) pq.pop();\\n            res.push_back(pq.top().first);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<pair<int,int>>dq;\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++){\\n            while(!dq.empty() && dq.back().first<nums[i])\\n                dq.pop_back();\\n            dq.push_back({nums[i],i});\\n            if(i>=k-1){\\n                if(dq.front().second==i-k) dq.pop_front();\\n                res.push_back(dq.front().first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954503,
                "title": "c-using-multiset-with-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        multiset<int> set; // can store all elements in sorted manner of given datatype\\n        int left = 0; // to remove the element at this index when window of K is computed\\n        vector<int> res;\\n        for(int right = 0; right < nums.size(); right++) {\\n            set.insert(nums[right]); // takes log(N) time\\n            if(set.size() == k) {\\n                res.push_back(*(set.rbegin())); // gives max element -> * gives us the element at that address\\n                set.erase(set.find(nums[left++]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        multiset<int> set; // can store all elements in sorted manner of given datatype\\n        int left = 0; // to remove the element at this index when window of K is computed\\n        vector<int> res;\\n        for(int right = 0; right < nums.size(); right++) {\\n            set.insert(nums[right]); // takes log(N) time\\n            if(set.size() == k) {\\n                res.push_back(*(set.rbegin())); // gives max element -> * gives us the element at that address\\n                set.erase(set.find(nums[left++]));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951724,
                "title": "python-sliding-window-maximum",
                "content": "Here we use a double ended queue. Every time we add a new element to the our deque window, we pop all elements from the right that are smaller than the new element, because the entire time they remain in the window, they can never be the maximum.\\n\\nSince we are popping elements from the window, we need to keep track of the original index of each element, so that we can pop it from the left at the appropriate time.\\n\\nConsequently, this means that the maximum of the window will always be the leftmost element.\\n\\n\\tdef maxSlidingWindow(self, nums, k):\\n        \\n        window = collections.deque()\\n        \\n\\t\\t#Build the initial window (first k elements)\\n\\t\\t#You can skip this, see comment below\\n        for i in range(k):      \\n            while window and nums[i] > window[-1][0]:\\n                window.pop()                \\n            window.append((nums[i], i))\\n        \\n        res = [window[0][0]]\\n        \\n\\t\\t#Iterate through each element until the end\\n        for i in range(k, len(nums)):\\n            \\n\\t\\t\\t#pop elements from the left once they\\'re outside the window\\n            if i-k >= window[0][1]:           \\n                window.popleft()\\n            \\n\\t\\t\\t#pop any elements from the right that are smaller than the new one, as they are redundant\\n            while window and nums[i] > window[-1][0]:\\n                window.pop()               \\n\\t\\t\\t#append the new element to the deque (along with its original position)\\n            window.append((nums[i], i))\\n            \\n\\t\\t\\t#consequently, the largest element must be the leftmost\\n            res.append(window[0][0])\\n                \\n        return res",
                "solutionTags": [],
                "code": "Here we use a double ended queue. Every time we add a new element to the our deque window, we pop all elements from the right that are smaller than the new element, because the entire time they remain in the window, they can never be the maximum.\\n\\nSince we are popping elements from the window, we need to keep track of the original index of each element, so that we can pop it from the left at the appropriate time.\\n\\nConsequently, this means that the maximum of the window will always be the leftmost element.\\n\\n\\tdef maxSlidingWindow(self, nums, k):\\n        \\n        window = collections.deque()\\n        \\n\\t\\t#Build the initial window (first k elements)\\n\\t\\t#You can skip this, see comment below\\n        for i in range(k):      \\n            while window and nums[i] > window[-1][0]:\\n                window.pop()                \\n            window.append((nums[i], i))\\n        \\n        res = [window[0][0]]\\n        \\n\\t\\t#Iterate through each element until the end\\n        for i in range(k, len(nums)):\\n            \\n\\t\\t\\t#pop elements from the left once they\\'re outside the window\\n            if i-k >= window[0][1]:           \\n                window.popleft()\\n            \\n\\t\\t\\t#pop any elements from the right that are smaller than the new one, as they are redundant\\n            while window and nums[i] > window[-1][0]:\\n                window.pop()               \\n\\t\\t\\t#append the new element to the deque (along with its original position)\\n            window.append((nums[i], i))\\n            \\n\\t\\t\\t#consequently, the largest element must be the leftmost\\n            res.append(window[0][0])\\n                \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 951650,
                "title": "c-99-100-memory-15-liner-crispy-af",
                "content": "```\\nclass Solution {\\nprivate:\\n    deque<int> S;\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res;\\n        for (int i=0; i<nums.size(); i++) {\\n            while (!S.empty() && nums[S.back()] <= nums[i]) {\\n                S.pop_back();\\n            }\\n            while (!S.empty() && S.front() <= i-k) {\\n                S.pop_front();\\n            }\\n            S.push_back(i);\\n            if (i >= k-1) {\\n                res.push_back(nums[S.front()]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nExplanation -\\n\\n1. Add new candidate maximums to deque, and remove the ones that are no more a part of the window\\n2. Return the maximum from the deque\\n3. ???\\n4. Profit! \\uD83E\\uDD19\\n\\nAs always,\\n\\uD83E\\uDD19 Stay crispy guys \\uD83E\\uDD19",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    deque<int> S;\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> res;\\n        for (int i=0; i<nums.size(); i++) {\\n            while (!S.empty() && nums[S.back()] <= nums[i]) {\\n                S.pop_back();\\n            }\\n            while (!S.empty() && S.front() <= i-k) {\\n                S.pop_front();\\n            }\\n            S.push_back(i);\\n            if (i >= k-1) {\\n                res.push_back(nums[S.front()]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895215,
                "title": "easy-c-sliiding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size(); // n=8, k=3\\n        deque<pair<int, int>> deque;\\n        vector<int> result;\\n        \\n        for(int i=0; i<k; i++){\\n            while(!deque.empty() && deque.back().second<nums[i]) // 3, -1\\n                deque.pop_back();\\n            deque.push_back({i, nums[i]}); // 1(3), 2(-1)\\n        }\\n        result.push_back(deque.front().second); // 3   \\n        \\n        for(int i=k; i<n; i++){\\n            while(!deque.empty() && deque.back().second<nums[i]) // 7\\n                deque.pop_back();\\n            while(!deque.empty() && deque.front().first<i-k+1) // 2(-1), 3(-3)\\n                deque.pop_front();\\n            \\n            deque.push_back({i, nums[i]}); // 3(-3)\\n            result.push_back(deque.front().second); // 2(-1)\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\n\\nAlgorithm Outline:\\n1. slide K size, deque, \\n2. store in deque, pop right while newval > top\\n3. pop left when index out of range. store index, val in deque\\n4. store in result vector. return\\n\\nk = 3\\n \\n[1,3,-1,-3,5,3,6,7]\\n\\n[3,3,5,5,6,7]\\n\\n*/\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size(); // n=8, k=3\\n        deque<pair<int, int>> deque;\\n        vector<int> result;\\n        \\n        for(int i=0; i<k; i++){\\n            while(!deque.empty() && deque.back().second<nums[i]) // 3, -1\\n                deque.pop_back();\\n            deque.push_back({i, nums[i]}); // 1(3), 2(-1)\\n        }\\n        result.push_back(deque.front().second); // 3   \\n        \\n        for(int i=k; i<n; i++){\\n            while(!deque.empty() && deque.back().second<nums[i]) // 7\\n                deque.pop_back();\\n            while(!deque.empty() && deque.front().first<i-k+1) // 2(-1), 3(-3)\\n                deque.pop_front();\\n            \\n            deque.push_back({i, nums[i]}); // 3(-3)\\n            result.push_back(deque.front().second); // 2(-1)\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\n\\nAlgorithm Outline:\\n1. slide K size, deque, \\n2. store in deque, pop right while newval > top\\n3. pop left when index out of range. store index, val in deque\\n4. store in result vector. return\\n\\nk = 3\\n \\n[1,3,-1,-3,5,3,6,7]\\n\\n[3,3,5,5,6,7]\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783988,
                "title": "python-beats-99-82",
                "content": "Note: this is O(kn) worst case (when the list is reverse sorted)\\n```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        m = max(nums[:k])\\n        mArr = [m]\\n        for x in range(k,len(nums)):\\n            m = max(nums[x],m)\\n            if nums[x-k] == m:\\n                m = max(nums[x-k+1:x+1])\\n            mArr.append(m)\\n        return mArr\\n```\\n\\nA faster O(n) (by time complexity) solution is to use deque:\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        q, res = deque(), []\\n        for i in range(len(nums)):\\n            if i-k >= 0:\\n                res.append(nums[q[0]])\\n                while q and q[0]<=i-k:\\n                    q.popleft()\\n            while q and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n        res.append(nums[q[0]])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        m = max(nums[:k])\\n        mArr = [m]\\n        for x in range(k,len(nums)):\\n            m = max(nums[x],m)\\n            if nums[x-k] == m:\\n                m = max(nums[x-k+1:x+1])\\n            mArr.append(m)\\n        return mArr\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        q, res = deque(), []\\n        for i in range(len(nums)):\\n            if i-k >= 0:\\n                res.append(nums[q[0]])\\n                while q and q[0]<=i-k:\\n                    q.popleft()\\n            while q and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n        res.append(nums[q[0]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636811,
                "title": "java-solution-with-explanation-o-n-this-pattern-is-use-full-for-other-solutions",
                "content": "This is one of the generic problem of the sliding window. You can beat the other solutions with minor optimizaitons, i.e. using arrays and all, but the importaint thing is to identify the pattern and use it in other cases.\\n\\nSolution\\nIts a sliding window problem which means we need 2 pointers right and left.\\nnow.\\nmaintain a deque which will return the max value of window at any moment. Its called as max deque.\\nTo maintain a max deque when right pointer is moving toward the end, \\nWhen you encounter a new element, From the end of the deque remove all elements which are smaller than the encountered element as we are not going to need as we have already found the greater element.\\nNow add the new element int the deque and hence play by the problem\\n\\nSample Code.\\n\\n```\\npublic int[] maxSlidingWindow(int[] nums, int k)\\n   {\\n      // A deque which holds the max elements for window size of k\\n      Deque<Integer> maxWindowQueue = new LinkedList<>();\\n\\n      // Max window to be returned\\n      int[] maxWindow = new int[nums.length + 1 - k];\\n\\n      int left = 0, right = 0, mwCtr = 0;\\n\\n      while (right < nums.length)\\n      {\\n         int dig = nums[right];\\n\\n         // Remove from the end, those elements which are smaller than dig.\\n         while (!maxWindowQueue.isEmpty() && dig > maxWindowQueue.getLast())\\n         {\\n            maxWindowQueue.removeLast();\\n         }\\n\\n         // Add the new found element.\\n         maxWindowQueue.addLast(dig);\\n\\n         // We have reached the window size\\n         if (right - left + 1 == k)\\n         {\\n            maxWindow[mwCtr] = maxWindowQueue.getFirst();\\n            mwCtr++;\\n\\n            // Now we need to slice the left corner\\n            // Doing so, If you find the number being removed is the max element we need to pop\\n            // that element as well from the dequeue\\n            if (nums[left] == maxWindowQueue.getFirst())\\n            {\\n               maxWindowQueue.removeFirst();\\n            }\\n            // Slice the left corner\\n            left++;\\n         }\\n\\n         // Increment right as usual\\n         right++;\\n      }\\n      return maxWindow;\\n   }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] maxSlidingWindow(int[] nums, int k)\\n   {\\n      // A deque which holds the max elements for window size of k\\n      Deque<Integer> maxWindowQueue = new LinkedList<>();\\n\\n      // Max window to be returned\\n      int[] maxWindow = new int[nums.length + 1 - k];\\n\\n      int left = 0, right = 0, mwCtr = 0;\\n\\n      while (right < nums.length)\\n      {\\n         int dig = nums[right];\\n\\n         // Remove from the end, those elements which are smaller than dig.\\n         while (!maxWindowQueue.isEmpty() && dig > maxWindowQueue.getLast())\\n         {\\n            maxWindowQueue.removeLast();\\n         }\\n\\n         // Add the new found element.\\n         maxWindowQueue.addLast(dig);\\n\\n         // We have reached the window size\\n         if (right - left + 1 == k)\\n         {\\n            maxWindow[mwCtr] = maxWindowQueue.getFirst();\\n            mwCtr++;\\n\\n            // Now we need to slice the left corner\\n            // Doing so, If you find the number being removed is the max element we need to pop\\n            // that element as well from the dequeue\\n            if (nums[left] == maxWindowQueue.getFirst())\\n            {\\n               maxWindowQueue.removeFirst();\\n            }\\n            // Slice the left corner\\n            left++;\\n         }\\n\\n         // Increment right as usual\\n         right++;\\n      }\\n      return maxWindow;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375666,
                "title": "easy-heap-solution",
                "content": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n            return []\\n        cnt = collections.defaultdict(int)\\n        heap = []\\n        for i in range(k):\\n            heapq.heappush(heap,-nums[i])\\n        res = [-heap[0]]\\n        for i in range(1,len(nums)-k+1):\\n            heapq.heappush(heap,-nums[i+k-1])\\n            cnt[-nums[i-1]] += 1\\n            while cnt[heap[0]] > 0:\\n                cnt[heap[0]] -= 1\\n                heapq.heappop(heap)\\n            res += [-heap[0]]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if not nums:\\n            return []\\n        cnt = collections.defaultdict(int)\\n        heap = []\\n        for i in range(k):\\n            heapq.heappush(heap,-nums[i])\\n        res = [-heap[0]]\\n        for i in range(1,len(nums)-k+1):\\n            heapq.heappush(heap,-nums[i+k-1])\\n            cnt[-nums[i-1]] += 1\\n            while cnt[heap[0]] > 0:\\n                cnt[heap[0]] -= 1\\n                heapq.heappop(heap)\\n            res += [-heap[0]]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174263,
                "title": "from-o-nlogk-time-to-o-n-time",
                "content": "### O(nlogk) time, O(k) space\\n> With constant space, the solution takes O(nk) time, where k counts for finding the maximum of a window.\\n\\n> To raise k to logk, we take advantage of a self-balancing binary search tree: TreeMap in Java is such an implementation.\\n```\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if (nums.length == 0) {\\n            return new int[0];\\n        }\\n        int[] res = new int[nums.length - k + 1];\\n        TreeMap<Integer, Integer> window = new TreeMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (i - k + 1 > 0) {\\n                // remove leftmost indexed in window, i - k\\n                window.put(nums[i - k], window.get(nums[i - k]) - 1);\\n                if (window.get(nums[i - k]) == 0) {\\n                    window.remove(nums[i - k]);\\n                }\\n            }\\n            window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\\n            if (i - k + 1 >= 0) {\\n                res[i - k + 1] = window.lastKey();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\\n### O(n) time, O(k) space\\n> We maintain a deque of indices that their corresponding elements are possible to be the maximum of the current or future window\\n\\n> It respects the contract that\\n> - indexes in deque are all in the current window \\n> - their corresponding values are in decreasing order\\n\\n> In this way, `deque.peekFirst` is always the maximal of current window\\n\\n****\\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        Deque<Integer> monoDeq = new LinkedList<>();\\n        int[] resArr = new int[nums.length - k + 1];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (!monoDeq.isEmpty() && nums[monoDeq.getLast()] <= nums[i]) {\\n                monoDeq.removeLast();\\n            }\\n            monoDeq.addLast(i);\\n            if (monoDeq.getFirst() < i - k + 1) {\\n                monoDeq.removeFirst();\\n            }\\n            if (i - k + 1 >= 0) {\\n                resArr[i - k + 1] = nums[monoDeq.getFirst()];\\n            }\\n        }\\n        \\n        return resArr;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if (nums.length == 0) {\\n            return new int[0];\\n        }\\n        int[] res = new int[nums.length - k + 1];\\n        TreeMap<Integer, Integer> window = new TreeMap<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (i - k + 1 > 0) {\\n                // remove leftmost indexed in window, i - k\\n                window.put(nums[i - k], window.get(nums[i - k]) - 1);\\n                if (window.get(nums[i - k]) == 0) {\\n                    window.remove(nums[i - k]);\\n                }\\n            }\\n            window.put(nums[i], window.getOrDefault(nums[i], 0) + 1);\\n            if (i - k + 1 >= 0) {\\n                res[i - k + 1] = window.lastKey();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        Deque<Integer> monoDeq = new LinkedList<>();\\n        int[] resArr = new int[nums.length - k + 1];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (!monoDeq.isEmpty() && nums[monoDeq.getLast()] <= nums[i]) {\\n                monoDeq.removeLast();\\n            }\\n            monoDeq.addLast(i);\\n            if (monoDeq.getFirst() < i - k + 1) {\\n                monoDeq.removeFirst();\\n            }\\n            if (i - k + 1 >= 0) {\\n                resArr[i - k + 1] = nums[monoDeq.getFirst()];\\n            }\\n        }\\n        \\n        return resArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66079,
                "title": "accepted-c-solution",
                "content": "    public int[] MaxSlidingWindow(int[] nums, int k) {\\n            if (nums == null || nums.Length == 0) return new int[0];\\n            if(nums.Length < k) return new int[1]{nums.Max()};\\n            var result = new int[nums.Length - k + 1];\\n            var d = new LinkedList<int>();\\n\\n            for (var i = 0; i < nums.Length; i++)\\n            {\\n                if(d.Any() && d.First() == i-k) d.RemoveFirst();\\n\\n                //Remove the item that less than nums[i], since they are useless\\n                while(d.Any() && nums[d.Last()] < nums[i]) d.RemoveLast();\\n                d.AddLast(i);\\n\\n                if (i >= k-1)\\n                {\\n                    result[i - k + 1] = nums[d.First()];\\n                }\\n            }\\n            return result;\\n    }",
                "solutionTags": [],
                "code": "    public int[] MaxSlidingWindow(int[] nums, int k) {\\n            if (nums == null || nums.Length == 0) return new int[0];\\n            if(nums.Length < k) return new int[1]{nums.Max()};\\n            var result = new int[nums.Length - k + 1];\\n            var d = new LinkedList<int>();\\n\\n            for (var i = 0; i < nums.Length; i++)\\n            {\\n                if(d.Any() && d.First() == i-k) d.RemoveFirst();\\n\\n                //Remove the item that less than nums[i], since they are useless\\n                while(d.Any() && nums[d.Last()] < nums[i]) d.RemoveLast();\\n                d.AddLast(i);\\n\\n                if (i >= k-1)\\n                {\\n                    result[i - k + 1] = nums[d.First()];\\n                }\\n            }\\n            return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66130,
                "title": "treemap-solution-o-nlogk-and-deque-solution-o-n",
                "content": "TreeMap Solution\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums.length == 0)\\n            return nums;\\n        int[] res = new int[nums.length - k + 1];\\n        TreeMap<Integer, Set<Integer>> memo = new TreeMap<>();\\n        for(int i = 0 ; i < k ; i++){\\n            if(memo.containsKey(nums[i])){\\n                memo.get(nums[i]).add(i);\\n            }else{\\n                Set<Integer> temp = new HashSet<>();\\n                temp.add(i);\\n                memo.put(nums[i], temp);\\n            }\\n        }\\n        res[0] = memo.lastKey();\\n        for(int i = k ; i < nums.length ; i++){\\n            if(memo.get(nums[i - k]).size() == 1){\\n                memo.remove(nums[i - k]);\\n            }else{\\n                memo.get(nums[i - k]).remove(i - k);\\n            }\\n            if(memo.containsKey(nums[i]))\\n                memo.get(nums[i]).add(i);\\n            else{\\n                Set<Integer> temp = new HashSet<>();\\n                temp.add(i);\\n                memo.put(nums[i], temp);\\n            }\\n            res[i - k + 1] = memo.lastKey();\\n        }\\n        return res;\\n    }\\n\\nDeque Solution\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums.length == 0)\\n            return nums;\\n        int[] res = new int[nums.length - k + 1];\\n        Deque<Integer> memo = new ArrayDeque<>();\\n        for(int i = 0  ; i < nums.length ; i++){\\n            while(memo.size() > 0 && memo.getLast() < nums[i])\\n                memo.removeLast();\\n            memo.add(nums[i]);\\n            if(i < k - 1)\\n                continue;\\n            res[i - k + 1] = memo.peek();\\n            if(nums[i - k + 1] == res[i - k + 1])\\n                memo.removeFirst();\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "TreeMap Solution\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums.length == 0)\\n            return nums;\\n        int[] res = new int[nums.length - k + 1];\\n        TreeMap<Integer, Set<Integer>> memo = new TreeMap<>();\\n        for(int i = 0 ; i < k ; i++){\\n            if(memo.containsKey(nums[i])){\\n                memo.get(nums[i]).add(i);\\n            }else{\\n                Set<Integer> temp = new HashSet<>();\\n                temp.add(i);\\n                memo.put(nums[i], temp);\\n            }\\n        }\\n        res[0] = memo.lastKey();\\n        for(int i = k ; i < nums.length ; i++){\\n            if(memo.get(nums[i - k]).size() == 1){\\n                memo.remove(nums[i - k]);\\n            }else{\\n                memo.get(nums[i - k]).remove(i - k);\\n            }\\n            if(memo.containsKey(nums[i]))\\n                memo.get(nums[i]).add(i);\\n            else{\\n                Set<Integer> temp = new HashSet<>();\\n                temp.add(i);\\n                memo.put(nums[i], temp);\\n            }\\n            res[i - k + 1] = memo.lastKey();\\n        }\\n        return res;\\n    }\\n\\nDeque Solution\\n\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(nums.length == 0)\\n            return nums;\\n        int[] res = new int[nums.length - k + 1];\\n        Deque<Integer> memo = new ArrayDeque<>();\\n        for(int i = 0  ; i < nums.length ; i++){\\n            while(memo.size() > 0 && memo.getLast() < nums[i])\\n                memo.removeLast();\\n            memo.add(nums[i]);\\n            if(i < k - 1)\\n                continue;\\n            res[i - k + 1] = memo.peek();\\n            if(nums[i - k + 1] == res[i - k + 1])\\n                memo.removeFirst();\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4065444,
                "title": "c-explanation-with-visualization-very-easy-using-sliding-window-and-priority-queue",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis question is easily solve using sliding window and max priority queue\\nwe are first take 2 pointer for start and end of sliding window \\nwindow size is (end-start+1) \\nif window size is k then we find max element of that window using max priority queue\\nlet\\'s understand this approach using example\\nnums = [1,3,-1,-3,2,3,6,7], k = 3\\nmake max priority queue of pair first element of pair is nums[i] and second element is i (index)\\nif (end-start+1)<k then push {nums[i],i} in priority queue and apply end++\\n\\n\\nobserve below photo \\n![image.png](https://assets.leetcode.com/users/images/3ce9e1d4-1212-4925-8294-75ca65fcedd6_1695143394.2750392.png)\\n\\n\\n\\nnow take data of top of priotity queue \\nsee a index of top element if top element index is greater than or equal to start and less than or equal to end it means your data is valid for window (start,end) so priority queue top element first data store in answer array \\nsuppose index is not >=start and <=end in this case pop data \\n\\ntake next window \\n![image.png](https://assets.leetcode.com/users/images/e066817a-10d0-491a-8c8f-7a61f841b7e6_1695143512.255379.png)\\n\\n\\npick top element of priority queue it is valid for window (start,end) then push in answer array\\n\\n![image.png](https://assets.leetcode.com/users/images/2f26d7e6-4335-4e9c-992d-68c7cf63e4b8_1695143580.3010266.png)\\n\\nnow top element is invalid so pop top element \\nand check next element\\n![image.png](https://assets.leetcode.com/users/images/d51320c2-c5d2-4a42-8af3-21d3132ee8a0_1695143645.0977106.png) \\n\\nnow this algorithm follow until end<(nums array size)\\n\\n![image.png](https://assets.leetcode.com/users/images/9082177b-502f-4380-ae3d-fa7f4fbdd106_1695143746.2568717.png)\\n\\n\\ntake next window\\n![image.png](https://assets.leetcode.com/users/images/53956112-df8e-43c6-a790-79bcc2474de2_1695143810.3528473.png)\\n\\ntake next window\\n![image.png](https://assets.leetcode.com/users/images/1ff56f6e-b9f6-4e2c-9667-5cf488dd4fd3_1695143854.0181296.png)\\n\\n\\nnow done algorithm \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        priority_queue<pair<int,int>>pq;\\n        // i is start and j is end \\n        int i=0,j=0;\\n        while(j<nums.size())\\n        {\\n            pq.push({nums[j],j});\\n            if(j-i+1==k)\\n            {\\n                // j-i+1 is window size \\n                bool done=false;\\n                while(!done)\\n                {\\n                    int top_ind=pq.top().second;\\n                    // check top element index is valid or not\\n                    // valid => push top element first data in answer \\n                    // invalid => pop top element\\n                    if(top_ind>=i && top_ind<=j)\\n                    {\\n                        done=true;\\n                        ans.push_back(pq.top().first);\\n                    }\\n                    else\\n                    pq.pop();\\n                }\\n                if(pq.top().second==i)\\n                pq.pop();\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        priority_queue<pair<int,int>>pq;\\n        // i is start and j is end \\n        int i=0,j=0;\\n        while(j<nums.size())\\n        {\\n            pq.push({nums[j],j});\\n            if(j-i+1==k)\\n            {\\n                // j-i+1 is window size \\n                bool done=false;\\n                while(!done)\\n                {\\n                    int top_ind=pq.top().second;\\n                    // check top element index is valid or not\\n                    // valid => push top element first data in answer \\n                    // invalid => pop top element\\n                    if(top_ind>=i && top_ind<=j)\\n                    {\\n                        done=true;\\n                        ans.push_back(pq.top().first);\\n                    }\\n                    else\\n                    pq.pop();\\n                }\\n                if(pq.top().second==i)\\n                pq.pop();\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916835,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nIn the problem, we employ a double-ended queue (deque) to track the indices of potential maximum elements within sliding windows of size k as they traverse the input vector nums. By maintaining a deque that stores only relevant indices, removing unnecessary elements, and ensuring that the maximum candidate elements are consistently positioned at the front of the deque, we identify the maximum element for each window and populate the result vector. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We use a deque q to store the indices of potential maximum elements within the window.\\n- For each element in nums, we:\\n- - Remove elements from the front of q that are no longer in the current window.\\n- - Remove elements from the back of q that are smaller than the current element.\\n- Add the current element\\'s index to the back of q.\\n- If the window size is equal to k, add the maximum element (at the front of q) to the result vector.\\n- Return the result vector containing maximum elements for each window.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> v;\\n        deque<int> q;\\n        for(int i=0;i<nums.size();i++){\\n            if(!q.empty() and q.front()==i-k) q.pop_front();\\n            while(!q.empty() and nums[i]>nums[q.back()]) q.pop_back();\\n            q.push_back(i);\\n            if(i>=k-1) v.push_back(nums[q.front()]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> v;\\n        deque<int> q;\\n        for(int i=0;i<nums.size();i++){\\n            if(!q.empty() and q.front()==i-k) q.pop_front();\\n            while(!q.empty() and nums[i]>nums[q.back()]) q.pop_back();\\n            q.push_back(i);\\n            if(i>=k-1) v.push_back(nums[q.front()]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916065,
                "title": "c-solution-for-sliding-window-maximum-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using a sliding window and a data structure that helps efficiently maintain the maximum element within that window. In this solution, a Deque (Double-ended queue) is used to store indices of elements. The front of the Deque always contains the index of the maximum element in the current window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an empty Deque and an array result to store the maximum elements for each sliding window.\\n1. Iterate through the input array nums, and for each element, perform the following steps:\\na. Remove indices of elements from the front of the Deque that are no longer within the current window.\\nb. Remove indices of elements from the back of the Deque that are smaller than the current element.\\nc. Add the current index to the back of the Deque.\\nd. If the current index is greater than or equal to k - 1, it means the window size is now k, so add the maximum element (front element of the Deque) to the result array.\\n1. Return the result array containing maximum elements for each sliding window.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe Deque operations (AddLast, AddFirst, RemoveLast, RemoveFirst, First) take constant time O(1).\\nIn the worst case, each element is added and removed from the Deque at most twice, resulting in a linear time complexity O(n), where n is the length of the input array nums.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe Deque stores at most k indices, where k is the size of the sliding window.\\nThe result array stores the maximum elements for each sliding window, which contains n - k + 1 elements.\\nOverall, the space complexity is O(n - k + 1), which simplifies to O(n) in the worst case.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MaxSlidingWindow(int[] nums, int k) {\\n        if (nums.Length == 0 || k == 0) {\\n        return new int[0];\\n        }\\n    \\n        int n = nums.Length;\\n        int[] result = new int[n - k + 1];\\n        int ri = 0; // Index for the result array\\n        \\n        // Create a Deque (Double-ended queue) to store indices of elements\\n        // The front of the Deque will always have the index of the maximum element in the current window\\n        LinkedList<int> deque = new LinkedList<int>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Remove indices of elements that are out of the current window from the front of the Deque\\n            while (deque.Count > 0 && deque.First.Value < i - k + 1) {\\n                deque.RemoveFirst();\\n            }\\n            \\n            // Remove indices of elements that are smaller than the current element from the back of the Deque\\n            while (deque.Count > 0 && nums[deque.Last.Value] < nums[i]) {\\n                deque.RemoveLast();\\n            }\\n            \\n            // Add the current index to the back of the Deque\\n            deque.AddLast(i);\\n            \\n            // If the window has moved to the point where it contains \\'k\\' elements, start storing the maximum for each window\\n            if (i >= k - 1) {\\n                result[ri++] = nums[deque.First.Value];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MaxSlidingWindow(int[] nums, int k) {\\n        if (nums.Length == 0 || k == 0) {\\n        return new int[0];\\n        }\\n    \\n        int n = nums.Length;\\n        int[] result = new int[n - k + 1];\\n        int ri = 0; // Index for the result array\\n        \\n        // Create a Deque (Double-ended queue) to store indices of elements\\n        // The front of the Deque will always have the index of the maximum element in the current window\\n        LinkedList<int> deque = new LinkedList<int>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            // Remove indices of elements that are out of the current window from the front of the Deque\\n            while (deque.Count > 0 && deque.First.Value < i - k + 1) {\\n                deque.RemoveFirst();\\n            }\\n            \\n            // Remove indices of elements that are smaller than the current element from the back of the Deque\\n            while (deque.Count > 0 && nums[deque.Last.Value] < nums[i]) {\\n                deque.RemoveLast();\\n            }\\n            \\n            // Add the current index to the back of the Deque\\n            deque.AddLast(i);\\n            \\n            // If the window has moved to the point where it contains \\'k\\' elements, start storing the maximum for each window\\n            if (i >= k - 1) {\\n                result[ri++] = nums[deque.First.Value];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916036,
                "title": "using-deque-tc-sc-easy-clean-fast-intuitive",
                "content": "# Approach\\nTo store only the greater elements of a window that may contribute to other windows as well.\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n\\n- Space complexity: O(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!dq.empty() &&nums[i] > dq.front())\\n            dq.pop_front();\\n\\n            dq.push_front(nums[i]);\\n\\n            if(i>=k-1)\\n            {\\n                ans.push_back(dq.back());\\n                if(dq.back() == nums[i-k+1])\\n                dq.pop_back();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!dq.empty() &&nums[i] > dq.front())\\n            dq.pop_front();\\n\\n            dq.push_front(nums[i]);\\n\\n            if(i>=k-1)\\n            {\\n                ans.push_back(dq.back());\\n                if(dq.back() == nums[i-k+1])\\n                dq.pop_back();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915855,
                "title": "c-deque-beats-90-day-16",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()== i-k)dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i])\\n            dq.pop_back();\\n\\n            dq.push_back(i);\\n            if(i>=k-1)ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()== i-k)dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i])\\n            dq.pop_back();\\n\\n            dq.push_back(i);\\n            if(i>=k-1)ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915800,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        seen=[]\\n        ans=[]   \\n        for i in range(n):\\n            if seen and seen[0]==i-k:\\n                seen.pop(0)\\n\\n            while seen and nums[seen[-1]]<nums[i]:\\n                seen.pop()\\n\\n            seen.append(i)\\n            if i>=k-1:\\n                ans.append(nums[seen[0]])\\n        return ans                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        n=len(nums)\\n        seen=[]\\n        ans=[]   \\n        for i in range(n):\\n            if seen and seen[0]==i-k:\\n                seen.pop(0)\\n\\n            while seen and nums[seen[-1]]<nums[i]:\\n                seen.pop()\\n\\n            seen.append(i)\\n            if i>=k-1:\\n                ans.append(nums[seen[0]])\\n        return ans                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843534,
                "title": "c-brute-to-optimal-detailed-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each window we need to keep track of potential maximum values. A normal slinding window approach does not work as after sliding we cannot comment on next maximum value in ```O(1)``` time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Brute Force: Consider all windows of size K\\n1. The ending index of the last window will be N-k where N is the size of ```nums``` array\\n2. We can run two nested loops where outer loop fixes the starting index ```0 <= i <= N-k``` and inner loop considers the window of size k ```i <= j < i + k```. We can keep updating the maximum value and add it to the result array in the end.\\n3. Time Complexity: ```O((N-k+1)*k)```. When k = N/2 it will become ```O(N^2)``` \\n\\n### Using Deque\\n1. We can think of using a monotonic stack to store the potential maxmimum values for each subarray. \\n2. But since we need to keep sliding our window we want to keep removing the values from bottom of stack when required\\n3. Hence we can use a deque and on sliding the window make sure that the ```deq.front() != i-k``` which corresponds to the first element of previous window that has been removed on sliding\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```O(n)```: Maximum times any element is visited is 2. Once when inserting in deque and once when popping\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```O(k)```: At any given time the maximum number of elements our deque will store will be the elements of current window which is of size k. This can happen when all the elements of the window are in decreasing order.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        deque <int> deq;\\n        vector <int> res;\\n\\n        for(int i = 0; i < k; i++){\\n            while(!deq.empty() && nums[i] > nums[deq.back()]){\\n                deq.pop_back();\\n            }\\n\\n            deq.push_back(i);\\n        }\\n        res.push_back(nums[deq.front()]);\\n\\n        for(int i = k; i < n; i++){\\n            while(!deq.empty() && nums[i] > nums[deq.back()]){\\n                deq.pop_back();\\n            }\\n\\n            deq.push_back(i);\\n            if(deq.front() == i - k) deq.pop_front();\\n            res.push_back(nums[deq.front()]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```O(1)```\n```nums```\n```0 <= i <= N-k```\n```i <= j < i + k```\n```O((N-k+1)*k)```\n```O(N^2)```\n```deq.front() != i-k```\n```O(n)```\n```O(k)```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        deque <int> deq;\\n        vector <int> res;\\n\\n        for(int i = 0; i < k; i++){\\n            while(!deq.empty() && nums[i] > nums[deq.back()]){\\n                deq.pop_back();\\n            }\\n\\n            deq.push_back(i);\\n        }\\n        res.push_back(nums[deq.front()]);\\n\\n        for(int i = k; i < n; i++){\\n            while(!deq.empty() && nums[i] > nums[deq.back()]){\\n                deq.pop_back();\\n            }\\n\\n            deq.push_back(i);\\n            if(deq.front() == i - k) deq.pop_front();\\n            res.push_back(nums[deq.front()]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840100,
                "title": "c-beats-99-sliding-window-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n We are using the sliding window approach , in which we are moving from left to right and we are using the deque to track the maximum num present in the window . \\nWe are pushing and popping the elements from last because we are trying to make deque in the decreasing order so that maximum element can be obtained from the front of the deque .\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n- \\n\\n- Space complexity:\\n O(K) // as the window can have max of k elements\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> d1;\\n        vector<int> ans;\\n        // process the k elements in the decreasing order in the deque \\n        for ( int i = 0 ; i < k ; i++)\\n        {\\n            int element = nums[i];\\n            while( (!d1.empty() ) && nums[d1.back()] <= element )\\n            {\\n                d1.pop_back();\\n            }\\n            // finally push the current element into the deque\\n            d1.push_back(i);\\n        }\\n        for( int i = k ; i < nums.size(); i++)\\n        {\\n            // store the ans of the previous window \\n            ans.push_back(nums[d1.front()]);\\n            // check for the next window\\n            while(  (!d1.empty() ) && (i - d1.front() >= k) )\\n            {\\n                d1.pop_front();\\n                // popping in order to make decreasing queue\\n            }\\n            // now we need to push acc to condition\\n            while( (!d1.empty() ) && ( nums[d1.back()] <= nums[i]) )\\n            {\\n                d1.pop_back();\\n            }\\n            // as our deque is in the dec order so now push the index\\n            d1.push_back(i);\\n        }\\n        // handling the last window case\\n        \\n        if(!d1.empty())\\n            {\\n                ans.push_back(nums[d1.front()]);\\n            }\\n        \\n  return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> d1;\\n        vector<int> ans;\\n        // process the k elements in the decreasing order in the deque \\n        for ( int i = 0 ; i < k ; i++)\\n        {\\n            int element = nums[i];\\n            while( (!d1.empty() ) && nums[d1.back()] <= element )\\n            {\\n                d1.pop_back();\\n            }\\n            // finally push the current element into the deque\\n            d1.push_back(i);\\n        }\\n        for( int i = k ; i < nums.size(); i++)\\n        {\\n            // store the ans of the previous window \\n            ans.push_back(nums[d1.front()]);\\n            // check for the next window\\n            while(  (!d1.empty() ) && (i - d1.front() >= k) )\\n            {\\n                d1.pop_front();\\n                // popping in order to make decreasing queue\\n            }\\n            // now we need to push acc to condition\\n            while( (!d1.empty() ) && ( nums[d1.back()] <= nums[i]) )\\n            {\\n                d1.pop_back();\\n            }\\n            // as our deque is in the dec order so now push the index\\n            d1.push_back(i);\\n        }\\n        // handling the last window case\\n        \\n        if(!d1.empty())\\n            {\\n                ans.push_back(nums[d1.front()]);\\n            }\\n        \\n  return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654095,
                "title": "easy-c-solution-beat-95",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i =0;i<k;i++){\\n            while(!dq.empty()&& nums[i]>=nums[dq.back()])\\n                dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            if(i-dq.front()>=k)\\n                dq.pop_front();\\n             while(!dq.empty()&& nums[i]>=nums[dq.back()])\\n                dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i =0;i<k;i++){\\n            while(!dq.empty()&& nums[i]>=nums[dq.back()])\\n                dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            if(i-dq.front()>=k)\\n                dq.pop_front();\\n             while(!dq.empty()&& nums[i]>=nums[dq.back()])\\n                dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642991,
                "title": "double-ended-queue-full-and-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccessing all the elements only once, and sliding the window over the whole array to find the maximum element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Basically , I\\'ve used a Double Ended Queue for this question, as we can access it from both the ends.\\n2. Now the question arises, why do we need to access it from both the ends? \\nSee this example to know the answer:\\nGiven array is [7,3,2,1,8,3,6,5,9] && k = 3,\\nSo our sliding window will be of size = 3;\\n\\n- **We\\'ll be maintaing a decreasing queue (Decreasing Monotonic Queue):**\\nIt will look like this:\\n7\\n7 3 \\n7 3 2\\nNow 1 arrives, but our queue is full, so we\\'ll simply pop the 1st element, our queue looks like this now:\\n3 2 1\\nNow since 8 is greater than all these three elements, all the elements will be popped, now our queue looks like this:\\n8\\n8 3\\n8 6 \\n**Now 8 will be popped, as 5 has arrived and our window size is 3**, so to include 5 and 8 we\\'ll need a window size of min 4.\\n6 5\\n9\\n\\n3. Now, declare a vector named answer to store the maximum elements of each window respectively.\\n4. For each window, our maximum element is the element on the front of the queue.\\n5. Continuing the above example:\\n7 is pushed\\n3 is pushed\\n8 is pushed\\n8 is pushed\\n8 is pushed\\n6 is pushed\\n9 is pushed\\n\\n- See from the above step, I\\'ve pushed all the elements which were on the front of the deque.\\n\\n6. So, we\\'ve reached to our final answer, which is: [7,3,8,8,8,6,9].\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe need to traverse the array.\\n\\n- Space complexity: **O(k)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using a deque of size \\'k\\'.\\n\\n\\n***Feel free to post your doubts in the comment section.***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        deque <int> q; //double ended queue, this is for storing the indices\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!q.empty() && q.front() == i - k) \\n            {\\n                q.pop_front();   //Ensuring that the size of the window doesn\\'t exceeds k\\n            }\\n            while(!q.empty() && nums[q.back()] < nums[i])\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n            if(i >= k - 1)\\n            {\\n                ans.push_back(nums[q.front()]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n\\n        int n = nums.size();\\n\\n        deque <int> q; //double ended queue, this is for storing the indices\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!q.empty() && q.front() == i - k) \\n            {\\n                q.pop_front();   //Ensuring that the size of the window doesn\\'t exceeds k\\n            }\\n            while(!q.empty() && nums[q.back()] < nums[i])\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back(i);\\n            if(i >= k - 1)\\n            {\\n                ans.push_back(nums[q.front()]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512249,
                "title": "easy-solution-using-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse max heap to get maximum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor every windows push into heap and check if the maximum belongs to previous window then pop\\n# Complexity\\n- Time complexity:$$O(nlogk)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        \\n        vector<int> ans;\\n        priority_queue<pair<int, int>> heap;\\n\\n\\n        for (int i=0; i<k; i++) heap.push({nums[i], i});\\n        \\n        ans.push_back(heap.top().first);\\n\\n        for(int i=k; i<nums.size(); i++) {\\n\\n            heap.push({nums[i], i});\\n\\n            while (heap.top().second <= i-k) heap.pop();\\n\\n            ans.push_back(heap.top().first);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        \\n        vector<int> ans;\\n        priority_queue<pair<int, int>> heap;\\n\\n\\n        for (int i=0; i<k; i++) heap.push({nums[i], i});\\n        \\n        ans.push_back(heap.top().first);\\n\\n        for(int i=k; i<nums.size(); i++) {\\n\\n            heap.push({nums[i], i});\\n\\n            while (heap.top().second <= i-k) heap.pop();\\n\\n            ans.push_back(heap.top().first);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363941,
                "title": "well-commented-c-code-using-deque",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> res;\\n        for(int i = 0; i < nums.size(); i++) {\\n            // if the front element of the deque is the index i - k then its out of the window\\n            // so we will have to pop the front most element\\n            if (dq.front() == i - k) dq.pop_front();\\n            // we are storing indices in dq.\\n            // while nums[last_indice_stored] < nums[i], we will have to pop the last element\\n            while (!dq.empty() && nums[dq.back()] < nums[i])\\n            {\\n                dq.pop_back();\\n            }\\n            dq.push_back(i); // pushing index\\n            if (i >= k - 1) res.push_back(nums[dq.front()]); // finding res array as ans\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> res;\\n        for(int i = 0; i < nums.size(); i++) {\\n            // if the front element of the deque is the index i - k then its out of the window\\n            // so we will have to pop the front most element\\n            if (dq.front() == i - k) dq.pop_front();\\n            // we are storing indices in dq.\\n            // while nums[last_indice_stored] < nums[i], we will have to pop the last element\\n            while (!dq.empty() && nums[dq.back()] < nums[i])\\n            {\\n                dq.pop_back();\\n            }\\n            dq.push_back(i); // pushing index\\n            if (i >= k - 1) res.push_back(nums[dq.front()]); // finding res array as ans\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354104,
                "title": "clear-and-easy-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n      \\n        int l=0,r=0;        //  l=left pointer, r=right pointer\\n        \\n        priority_queue<pair<int,int>> pq;       \\n        \\n        if(k>nums.size()) return ans;\\n        \\n        while(r<nums.size()){\\n            if(r-l+1<k){\\n                pq.push(make_pair(nums[r],r));\\n                r++;\\n            }\\n            else{\\n                if(r<nums.size()) pq.push(make_pair(nums[r],r));\\n                \\n                if(l<=pq.top().second)\\n                    ans.push_back(pq.top().first);\\n                else{\\n                    while(l>pq.top().second){\\n                        pq.pop();\\n                    }\\n                    ans.push_back(pq.top().first);\\n                }\\n                \\n                l++;\\n                r++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n      \\n        int l=0,r=0;        //  l=left pointer, r=right pointer\\n        \\n        priority_queue<pair<int,int>> pq;       \\n        \\n        if(k>nums.size()) return ans;\\n        \\n        while(r<nums.size()){\\n            if(r-l+1<k){\\n                pq.push(make_pair(nums[r],r));\\n                r++;\\n            }\\n            else{\\n                if(r<nums.size()) pq.push(make_pair(nums[r],r));\\n                \\n                if(l<=pq.top().second)\\n                    ans.push_back(pq.top().first);\\n                else{\\n                    while(l>pq.top().second){\\n                        pq.pop();\\n                    }\\n                    ans.push_back(pq.top().first);\\n                }\\n                \\n                l++;\\n                r++;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284313,
                "title": "javascript-239-sliding-window-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Priority Queue - delete when req, when max is out of window length\\n2. Monotonic Queue - delete small on left, as we go right\\n- https://assets.leetcode.com/static_assets/posts/sliding_window_maximum.gif\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar maxSlidingWindow = function (a, wLen) {\\n    let n = a.length,\\n        pq = new PriorityQueue({\\n            compare: (a, b) => b[1] - a[1] || b[0] - a[0],\\n        }),\\n        ans = [];\\n\\n    for (let R = 0; R < n; R++) {\\n        pq.enqueue([R, a[R]]);\\n        if (R < wLen - 1) continue;\\n\\n        while (pq.front()[0] <= R - wLen) {\\n            pq.dequeue();\\n        }\\n        ans.push(pq.front()[1]);\\n    }\\n    return ans;\\n};\\n```\\n\\n2\\n```\\nvar maxSlidingWindow = function (a, wLen) {\\n    let n = a.length,\\n        q = [],\\n        ans = [];\\n\\n    for (let R = 0; R < n; R++) {\\n        while (q.length && a[R] >= q[q.length - 1][1]) {\\n            q.pop();\\n        }\\n        q.push([R, a[R]]);\\n        if (R < wLen - 1) continue;\\n\\n        while (q[0][0] <= R - wLen) {\\n            q.shift();\\n        }\\n        ans.push(q[0][1]);\\n    }\\n    return ans;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSlidingWindow = function (a, wLen) {\\n    let n = a.length,\\n        pq = new PriorityQueue({\\n            compare: (a, b) => b[1] - a[1] || b[0] - a[0],\\n        }),\\n        ans = [];\\n\\n    for (let R = 0; R < n; R++) {\\n        pq.enqueue([R, a[R]]);\\n        if (R < wLen - 1) continue;\\n\\n        while (pq.front()[0] <= R - wLen) {\\n            pq.dequeue();\\n        }\\n        ans.push(pq.front()[1]);\\n    }\\n    return ans;\\n};\\n```\n```\\nvar maxSlidingWindow = function (a, wLen) {\\n    let n = a.length,\\n        q = [],\\n        ans = [];\\n\\n    for (let R = 0; R < n; R++) {\\n        while (q.length && a[R] >= q[q.length - 1][1]) {\\n            q.pop();\\n        }\\n        q.push([R, a[R]]);\\n        if (R < wLen - 1) continue;\\n\\n        while (q[0][0] <= R - wLen) {\\n            q.shift();\\n        }\\n        ans.push(q[0][1]);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259084,
                "title": "sliding-window-maximum-fastest-python-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nSliding Window with Fixed Size and deque()\\n\\n# Complexity\\n- Time complexity: The time complexity of the given code is O(n), where n is the length of the input list nums.\\n- This is because the code uses a sliding window approach to iterate through the list exactly once, and each element is added to and removed from the deque at most once. The time complexity of adding and removing elements from a deque is O(1), so the overall time complexity of the algorithm is O(n).\\n\\nTherefore, the code has linear time complexity and is considered to be efficient for most practical purposes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The space complexity of the given code is O(k), where k is the size of the sliding window.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        i=0\\n        j=0\\n        d=deque()\\n        res=[]\\n        while j<len(nums):\\n            while  len(d)>0 and d[-1]<nums[j]:\\n                d.pop()\\n            d.append(nums[j])\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                res.append(d[0])\\n                if d[0]==nums[i]:\\n                    d.popleft()\\n                i+=1\\n                j+=1\\n        return res\\n\\n\\n        # maxi=0\\n        # l=[]\\n        # for i in range(len(nums)-k+1):\\n        #     maxi=max(nums[i:i+k])\\n        #     l.append(maxi)   \\n        # return l \\n        # i=0\\n        # j=0\\n        # l=[]\\n        # maxi=-float(\\'inf\\')\\n        # while j<len(nums):\\n        #     maxi=max(maxi,nums[j])\\n        #     if (j-i+1)<k:\\n        #         j+=1\\n        #     elif (j-i+1)==k:\\n        #         maxi=max(nums[i:j+1])\\n        #         l.append(maxi)\\n                \\n        #         i+=1\\n               \\n        #         j+=1\\n        # return l\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        i=0\\n        j=0\\n        d=deque()\\n        res=[]\\n        while j<len(nums):\\n            while  len(d)>0 and d[-1]<nums[j]:\\n                d.pop()\\n            d.append(nums[j])\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                res.append(d[0])\\n                if d[0]==nums[i]:\\n                    d.popleft()\\n                i+=1\\n                j+=1\\n        return res\\n\\n\\n        # maxi=0\\n        # l=[]\\n        # for i in range(len(nums)-k+1):\\n        #     maxi=max(nums[i:i+k])\\n        #     l.append(maxi)   \\n        # return l \\n        # i=0\\n        # j=0\\n        # l=[]\\n        # maxi=-float(\\'inf\\')\\n        # while j<len(nums):\\n        #     maxi=max(maxi,nums[j])\\n        #     if (j-i+1)<k:\\n        #         j+=1\\n        #     elif (j-i+1)==k:\\n        #         maxi=max(nums[i:j+1])\\n        #         l.append(maxi)\\n                \\n        #         i+=1\\n               \\n        #         j+=1\\n        # return l\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222502,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy using deque\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->https://takeuforward.org/data-structure/sliding-window-maximum/\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()== i-k)dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i])\\n            dq.pop_back();\\n\\n            dq.push_back(i);\\n            if(i>=k-1)ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};\\n \\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()== i-k)dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i])\\n            dq.pop_back();\\n\\n            dq.push_back(i);\\n            if(i>=k-1)ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110955,
                "title": "c-using-maps-only-no-deque-easy-to-understand",
                "content": "# Intuition\\nUsing the automatic sorting property of ordered hashmaps.\\n\\n# Approach\\n1) Declare an ordered map\\n2) Using 2 pointers i and j, traverse through the array and keep on inserting the elements in the map (the count of the element being the value in key-value pair)\\n3) Find the value of the maximum element by pointing the iterator to the end by mpp.end() and then it--\\n4) Keep on pushing the maximum element in the vector and remove the frequency of the element from the map.\\n5) Check (for repeating elements) if the frequency of any element is 0 then erase it from the map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        map<int,int> mpp;\\n        vector<int> v;\\n        int i=0;\\n        int j=0;\\n        map<int,int> :: iterator it;\\n        while(j<nums.size()){\\n            mpp[nums[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                it=mpp.end();\\n                it--;\\n                v.push_back(it->first);\\n                //if(nums[i]==it->first){\\n                    mpp[nums[i]]--;\\n                //}\\n                if(mpp[nums[i]]==0) mpp.erase(nums[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        map<int,int> mpp;\\n        vector<int> v;\\n        int i=0;\\n        int j=0;\\n        map<int,int> :: iterator it;\\n        while(j<nums.size()){\\n            mpp[nums[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                it=mpp.end();\\n                it--;\\n                v.push_back(it->first);\\n                //if(nums[i]==it->first){\\n                    mpp[nums[i]]--;\\n                //}\\n                if(mpp[nums[i]]==0) mpp.erase(nums[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029702,
                "title": "c-priority-queue-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought which came to my mind is using a heap of current window elements and getting the max out of it and pushing into a vector and returning it while we traverse all the windows of size k. But in this approach we need to remove the left most element of the previous window while we add a new element to the right of our window.\\nBut we cant directly remove the left element of previous window directly right? Then how we do we go about it ?\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, the approach is we use a hashmap for this. We maintain a hashmap and whenever we change our window we simply increase the frequency of the old left most element and fetch the top of the heap and store it in a variable say tt. now while the top of the heap is tt and our map contains tt, what does that mean ? this means that the top of our heap contains an element which was removed(which wasn\\'t technically, we mimiced by incresaing the count of it), we can simply decrease the frequency of this top element tt and pop it from the heap and get the new heap top and update tt with the new top of heap. we do this while our tt is present in the map and in the loop, of the frequency of the top becomes 0 we simply erase it from the hashmap, indicating this element is removed completely.\\n\\n# Complexity\\n- Time complexity: O(n*logk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n\\n        priority_queue<int>pq;\\n        unordered_map<int,int>mp;\\n        vector<int>ans;\\n        int n = nums.size();\\n        for(int i=0;i<k;++i)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        int t = pq.top();\\n        ans.push_back(t);\\n        int l = 1;\\n        int r = k;\\n        while(r<n)\\n        {\\n            // Add the new right guy into the heap\\n            pq.push(nums[r]);\\n            // gotta remove l-1 guy from heap\\n            mp[nums[l-1]]++;\\n            int tt = pq.top();\\n            while(pq.size() and mp.find(tt)!=mp.end())\\n            {\\n                mp[tt]--;\\n\\n                if(mp[tt]==0)\\n                {\\n                    mp.erase(tt);\\n                }\\n                pq.pop();\\n                tt = pq.top();\\n            }\\n            ans.push_back(pq.top());\\n            r++;\\n            l++;\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```\\n\\n Commment below if you have any doubts. Cheers!!",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n\\n        priority_queue<int>pq;\\n        unordered_map<int,int>mp;\\n        vector<int>ans;\\n        int n = nums.size();\\n        for(int i=0;i<k;++i)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        int t = pq.top();\\n        ans.push_back(t);\\n        int l = 1;\\n        int r = k;\\n        while(r<n)\\n        {\\n            // Add the new right guy into the heap\\n            pq.push(nums[r]);\\n            // gotta remove l-1 guy from heap\\n            mp[nums[l-1]]++;\\n            int tt = pq.top();\\n            while(pq.size() and mp.find(tt)!=mp.end())\\n            {\\n                mp[tt]--;\\n\\n                if(mp[tt]==0)\\n                {\\n                    mp.erase(tt);\\n                }\\n                pq.pop();\\n                tt = pq.top();\\n            }\\n            ans.push_back(pq.top());\\n            r++;\\n            l++;\\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985824,
                "title": "simple-montonic-queue-or-deque-soln-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMonotonic Queue will be highly efficient since  sliding or two pointer  will be O(n*k) so we will do it in O(n) using deque  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo first we insert k indexes  and during that we check if element at deque\\'s back is smaller than the next element if its we remove one element from back. And if window size exceeds k we remove from front and at every iteration if i>k-1 we should push front of deque in a vector because front  will be the max in the window size of k .Because we have compared each element from back if its higher we remove if not it will be automatically the max . \\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        int i=0,j=0;\\n        int maxi=INT_MIN;\\n        vector<int>ans;\\n         int n = arr.size();\\n        deque<int>dq;\\n        while(i<n){\\n            // if it exceeds the window remove it from front beacuse max is at front and that is now beyond the window size so remove \\n            if(!dq.empty() and dq.front()<i-k+1)dq.pop_front();\\n           // if upcoming elemnt is higher that that present at back we remove that element \\n            while(!dq.empty() and arr[dq.back()]<arr[i]){\\n                dq.pop_back();\\n            }\\n          // insert the index in deque\\n            dq.push_back(i++);\\n         //  push the fornt of deque in vector\\n            if(i>k-1)ans.push_back(arr[dq.front()]);\\n        }\\n        return ans;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        int i=0,j=0;\\n        int maxi=INT_MIN;\\n        vector<int>ans;\\n         int n = arr.size();\\n        deque<int>dq;\\n        while(i<n){\\n            // if it exceeds the window remove it from front beacuse max is at front and that is now beyond the window size so remove \\n            if(!dq.empty() and dq.front()<i-k+1)dq.pop_front();\\n           // if upcoming elemnt is higher that that present at back we remove that element \\n            while(!dq.empty() and arr[dq.back()]<arr[i]){\\n                dq.pop_back();\\n            }\\n          // insert the index in deque\\n            dq.push_back(i++);\\n         //  push the fornt of deque in vector\\n            if(i>k-1)ans.push_back(arr[dq.front()]);\\n        }\\n        return ans;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982573,
                "title": "sliding-window-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo understand this, we would first need to check whether we are doing any repetitions. To understand this, consider the following scenario:\\n\\nWindow : [1,2,3]  and the next incoming value is 2\\n\\nFor this state, we get a maximum of 3. However, when our state changes to, [2,3,2] we again check what is the largest element even though we know that the outgoing element is not the largest one. Hence, the point of concern lies only when the outgoing element was the largest. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe address this problem with the help of a data structure that keeps checking whether the incoming element is larger than the already present elements. This could be implemented with the help of a de-queue. When shifting our window, we push the new element in from the rear of our de-queue. \\nEvery time before entering a new element, we first need to check whether the element present at the front is out of bounds of our present window size. If so, we need to pop that out. Also, we need to check from the rear that the element present is smaller than the incoming element. If yes, there\\u2019s no point storing them and hence we pop them out. Finally, the element present at the front would be our largest element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(K)\\n# Code\\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] a, int k) {\\n\\n          int n = a.length;\\n        int[] r = new int[n - k + 1];\\n        int ri = 0;\\n        // store index\\n        Deque < Integer > q = new ArrayDeque < > ();\\n        for (int i = 0; i < a.length; i++) {\\n            // remove numbers out of range k\\n            if (!q.isEmpty() && q.peek() == i - k) {\\n                q.poll();\\n            }\\n            // remove smaller numbers in k range as they are useless\\n            while (!q.isEmpty() && a[q.peekLast()] < a[i]) {\\n                q.pollLast();\\n            }\\n\\n            q.offer(i);\\n            if (i >= k - 1) {\\n                r[ri++] = a[q.peek()];\\n            }\\n        }\\n        return r;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sliding Window",
                    "Heap (Priority Queue)",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] a, int k) {\\n\\n          int n = a.length;\\n        int[] r = new int[n - k + 1];\\n        int ri = 0;\\n        // store index\\n        Deque < Integer > q = new ArrayDeque < > ();\\n        for (int i = 0; i < a.length; i++) {\\n            // remove numbers out of range k\\n            if (!q.isEmpty() && q.peek() == i - k) {\\n                q.poll();\\n            }\\n            // remove smaller numbers in k range as they are useless\\n            while (!q.isEmpty() && a[q.peekLast()] < a[i]) {\\n                q.pollLast();\\n            }\\n\\n            q.offer(i);\\n            if (i >= k - 1) {\\n                r[ri++] = a[q.peek()];\\n            }\\n        }\\n        return r;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980687,
                "title": "using-deque-to-calculate-slidingmax-in-o-n-time-complexity-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDeque\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 1:\\n            return nums\\n\\n        slidingMax = [-10000] * (len(nums)-k+1)\\n        dq = deque([0]) # save the index of local maximum\\n\\n        for i in range(1, len(nums)):\\n            while dq and nums[dq[-1]] < nums[i]:\\n                dq.pop()\\n            dq.append(i)\\n            if i - dq[0] >=k:\\n                dq.popleft()\\n            if i >= k-1:\\n                slidingMax[i-k+1] = nums[dq[0]]\\n        \\n        return slidingMax\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 1:\\n            return nums\\n\\n        slidingMax = [-10000] * (len(nums)-k+1)\\n        dq = deque([0]) # save the index of local maximum\\n\\n        for i in range(1, len(nums)):\\n            while dq and nums[dq[-1]] < nums[i]:\\n                dq.pop()\\n            dq.append(i)\\n            if i - dq[0] >=k:\\n                dq.popleft()\\n            if i >= k-1:\\n                slidingMax[i-k+1] = nums[dq[0]]\\n        \\n        return slidingMax\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972092,
                "title": "scala-functional-style-tail-recursive-pattern-matching-time-complexity-o-n",
                "content": "# Intuition\\n\\nWe use a monotonic decreasing deque, which implies that the first element is the maximum.\\nOnce the maximum element is too far to stay in the window, we remove it, moving the maximum the to next largest element.\\nTo maintain the decreasing order, we remove elements from the deque that are smaller than the elements being added.\\n\\n---\\n\\n\\n# Implementation\\n\\n## **queue match**:\\n\\n- **case Nil**: The queue is empty, generate a queue with the current index *i*, proceed with the recursion over the next index *i+1*.\\n - **case xs :+ x if nums(i) > nums(x) nums(i) > nums(x)**: Maintain monotonic decreasing, all elements in the queue smaller than the current one have no chance of being the maximum, so get rid of them.\\n - **case x +: xs if x == i - k**:   *x* is the index of the maximum element. If *x + k == i*, then it is outside the window.\\n -  **case _**: add the current index to the queue and its related value to the answers. Proceed with the recursion over the next index *i+1*.\\n\\n\\n# Note\\n\\n- To make the code smoother, I apply the logic to the whole input array and remove the first *k - 1* solutions (i.e, the first window).\\n- Why vectors? Effective constant time for every operation.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {\\n\\n    @tailrec\\n    def loop(i: Int, queue: Vector[Int], answers: Vector[Int]): Vector[Int] =\\n\\n      queue match {\\n        case _ if i + 1 > nums.length => answers\\n        case Nil  => loop(i + 1, queue :+ i, answers :+ nums(i))\\n        case xs :+ x if nums(i) > nums(x) => loop(i, xs, answers)\\n        case x +: xs if x == i - k => loop(i, xs, answers)\\n        case _ => loop(i + 1, queue :+ i, answers :+ nums(queue.head))\\n      }\\n\\n    loop(0, Vector.empty[Int], Vector.empty[Int]).drop(k-1).toArray\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  def maxSlidingWindow(nums: Array[Int], k: Int): Array[Int] = {\\n\\n    @tailrec\\n    def loop(i: Int, queue: Vector[Int], answers: Vector[Int]): Vector[Int] =\\n\\n      queue match {\\n        case _ if i + 1 > nums.length => answers\\n        case Nil  => loop(i + 1, queue :+ i, answers :+ nums(i))\\n        case xs :+ x if nums(i) > nums(x) => loop(i, xs, answers)\\n        case x +: xs if x == i - k => loop(i, xs, answers)\\n        case _ => loop(i + 1, queue :+ i, answers :+ nums(queue.head))\\n      }\\n\\n    loop(0, Vector.empty[Int], Vector.empty[Int]).drop(k-1).toArray\\n\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2825098,
                "title": "c-max-heap-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n\\t\\t\\tpriority_queue<pair<int, int>>q;\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0; i<k; i++){q.push({nums[i], i});}\\n\\t\\t\\tans.push_back(q.top().first);\\n\\t\\t\\tfor(int i=k; i<nums.size(); i++){\\n\\t\\t\\t\\tq.push({nums[i], i});\\n\\t\\t\\t\\twhile(q.top().second<=i-k){\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.push_back(q.top().first);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n\\t\\t\\tpriority_queue<pair<int, int>>q;\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0; i<k; i++){q.push({nums[i], i}",
                "codeTag": "Java"
            },
            {
                "id": 2731401,
                "title": "c-most-easy-one-using-priority-queue-instead-of-deque-with-detailed-explanation",
                "content": "```\\ntypedef pair<int,int> pi;\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pi,vector<pi>> st;// max heap\\n        int cnt=0;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while(!st.empty() and (st.top().first<nums[i])) // if nums[i] greater than topmost element of queue then pop\\n            {\\n                st.pop();\\n            }\\n            while(!st.empty() and i-st.top().second+1>k) // if size of window greater than k then pop\\n                st.pop();\\n            st.push({nums[i],i});\\n            if(i>=k-1) // whenever size greater than equal to k-1 for every window we need to store the maximum\\n            {\\n                if(!st.empty())\\n                {\\n                    ans.push_back(st.top().first);\\n                }\\n                 if(!st.empty() and st.top().second==i-k) // if index is equal to i-k then pop since it is not required for the next window \\n                 st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,int> pi;\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pi,vector<pi>> st;// max heap\\n        int cnt=0;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            while(!st.empty() and (st.top().first<nums[i])) // if nums[i] greater than topmost element of queue then pop\\n            {\\n                st.pop();\\n            }\\n            while(!st.empty() and i-st.top().second+1>k) // if size of window greater than k then pop\\n                st.pop();\\n            st.push({nums[i],i});\\n            if(i>=k-1) // whenever size greater than equal to k-1 for every window we need to store the maximum\\n            {\\n                if(!st.empty())\\n                {\\n                    ans.push_back(st.top().first);\\n                }\\n                 if(!st.empty() and st.top().second==i-k) // if index is equal to i-k then pop since it is not required for the next window \\n                 st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706751,
                "title": "python-only-heap-no-queue-90-faster",
                "content": "```\\nfrom heapq import heappush , heapify , heappop\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        max_ = [] \\n        heapify(max_)\\n        ans = []\\n        for i in range(k) :\\n            heappush(max_ , [-nums[i] , i])\\n            \\n        ans.append(-max_[0][0])\\n        start = 0\\n        end = k\\n        while end < len(nums) :\\n            while max_ and max_[0][1] <= start :\\n                heappop(max_)\\n            \\n            heappush(max_ , [-nums[end] , end])\\n            \\n            ans.append(-max_[0][0])\\n            start += 1\\n            end += 1\\n            \\n        return ans\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush , heapify , heappop\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        max_ = [] \\n        heapify(max_)\\n        ans = []\\n        for i in range(k) :\\n            heappush(max_ , [-nums[i] , i])\\n            \\n        ans.append(-max_[0][0])\\n        start = 0\\n        end = k\\n        while end < len(nums) :\\n            while max_ and max_[0][1] <= start :\\n                heappop(max_)\\n            \\n            heappush(max_ , [-nums[end] , end])\\n            \\n            ans.append(-max_[0][0])\\n            start += 1\\n            end += 1\\n            \\n        return ans\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2611562,
                "title": "c-sliding-window-and-deque",
                "content": "\\t*******please upvote if you like*******\\n\\tclass Solution {\\n\\tpublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        deque<int>q;\\n        int i=0,j=0;\\n        while(j<nums.size()){\\n            while(!q.empty()&&q.back()<nums[j])\\n                q.pop_back();\\n            q.push_back(nums[j]);\\n            if(j-i+1<k)\\n                j++;\\n            else{\\n                ans.push_back(q.front());\\n                if(q.front()==nums[i])\\n                    q.pop_front();\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int>ans;\\n        deque<int>q;\\n        int i=0,j=0;\\n        while(j<nums.size()){\\n            while(!q.empty()&&q.back()<nums[j])\\n                q.pop_back();\\n            q.push_back(nums[j]);\\n            if(j-i+1<k)\\n                j++;\\n            else{\\n                ans.push_back(q.front());\\n                if(q.front()==nums[i])\\n                    q.pop_front();\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2580350,
                "title": "c-100-worst-to-best-approaches-with-explanation-easy-to-understand",
                "content": "**Read the below approach from wrost to optimised approach.**\\n\\n***Please upvote if you like it***\\n\\n**Approach 1 : Brute force ( TLE and Not Accepted)**\\n* Just take two loops and check the maximum value for each sliding window, then push that maximum inside the answer vector.\\n\\n**~Time Complexity: O(N^2)**\\n* **Reason:** One loop for traversing and another to findMax.\\n\\n**~Space Complexity: O(K)**\\n\\n* **Reason:** No.of windows\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0;i<=n-k;i++){\\n            int mx=INT_MIN;\\n            for(int j=i;j<i+k;j++){\\n                mx=max(mx,nums[j]);\\n            }\\n            ans.push_back(mx);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2 : Optimized Solution ( Accepted)**\\n* We address this problem with the help of a data structure that keeps checking whether the incoming element is larger than the already present elements. This could be implemented with the help of a de-queue. When shifting our window, we push the new element in from the rear of our de-queue.\\n* Every time before entering a new element, we first need to check whether the element present at the front is out of bounds of our present window size. If so, we need to pop that out. Also, we need to check from the rear that the element present is smaller than the incoming element. If yes, there\\u2019s no point storing them and hence we pop them out. Finally, the element present at the front would be our largest element for current window\\n\\n**~Time Complexity: O(N)**\\n**~Space Complexity: O(K)**\\n\\n**Code:-**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k) dq.pop_front();\\n            \\n            while(!dq.empty() && nums[dq.back()]< nums[i])\\n                dq.pop_back();\\n            \\n            dq.push_back(i);\\n            if(i>=k-1) ans.push_back(nums[dq.front()]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0;i<=n-k;i++){\\n            int mx=INT_MIN;\\n            for(int j=i;j<i+k;j++){\\n                mx=max(mx,nums[j]);\\n            }\\n            ans.push_back(mx);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k) dq.pop_front();\\n            \\n            while(!dq.empty() && nums[dq.back()]< nums[i])\\n                dq.pop_back();\\n            \\n            dq.push_back(i);\\n            if(i>=k-1) ans.push_back(nums[dq.front()]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441354,
                "title": "c-o-n-using-deque",
                "content": "```\\nvector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        \\n        deque<int>q;vector<int>l;int i=0,j=0;\\n        while(j<arr.size())\\n        {\\n            if(!q.empty() && arr[j]>arr[q.back()])\\n            {\\n                while(!q.empty() && arr[j]>arr[q.back()])\\n                    q.pop_back();\\n                q.push_back(j);\\n            }\\n            else\\n                q.push_back(j);\\n            if(j-i+1==k)\\n            {\\n                l.push_back(arr[q.front()]);i++;\\n            }\\n            j++;\\n            if(j-q.front()==k)\\n                q.pop_front();\\n        }\\n        return l;\\n    }",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nvector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n        \\n        deque<int>q;vector<int>l;int i=0,j=0;\\n        while(j<arr.size())\\n        {\\n            if(!q.empty() && arr[j]>arr[q.back()])\\n            {\\n                while(!q.empty() && arr[j]>arr[q.back()])\\n                    q.pop_back();\\n                q.push_back(j);\\n            }\\n            else\\n                q.push_back(j);\\n            if(j-i+1==k)\\n            {\\n                l.push_back(arr[q.front()]);i++;\\n            }\\n            j++;\\n            if(j-q.front()==k)\\n                q.pop_front();\\n        }\\n        return l;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2182740,
                "title": "two-solutions-sliding-window-using-array-list-and-dequeue",
                "content": "Using ArrayList\\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int[] ans = new int[nums.length-k+1];\\n        int arrIndex = 0;\\n        ArrayList<Integer> tentativeMax = new ArrayList<>();\\n        int i = 0 , j = 0;\\n        while(j < nums.length){\\n            int index = tentativeMax.size()-1;\\n            while (tentativeMax.size() != 0 && tentativeMax.get(index) < nums[j]){\\n                tentativeMax.remove(index--);\\n            }\\n            tentativeMax.add(nums[j]);\\n            if (j-i+1<k){\\n                j++;\\n            }\\n            else{\\n                ans[arrIndex++] = tentativeMax.get(0);\\n                if (Objects.equals(tentativeMax.get(0), nums[i])){//equals removes the null case\\n                    tentativeMax.remove(0);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nUsing Dequeue\\n\\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int[] ans = new int[nums.length-k+1];\\n        int arrIndex = 0;\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        int i = 0;\\n        while ( i < nums.length) {\\n            if (!queue.isEmpty() && queue.peek()==(i-k)){\\n                //Removing all those elements which are out of range of K sub-array\\n                queue.poll();\\n            }\\n            while (!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]){\\n                //Removing the smaller numbers in the queue that are of no use\\n                queue.pollLast();\\n            }\\n            queue.add(i);\\n            if (!queue.isEmpty() && i>=k-1){//This loop will run after we have reached the end of the first sub-array.\\n                ans[arrIndex++] = nums[queue.peek()];\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int[] ans = new int[nums.length-k+1];\\n        int arrIndex = 0;\\n        ArrayList<Integer> tentativeMax = new ArrayList<>();\\n        int i = 0 , j = 0;\\n        while(j < nums.length){\\n            int index = tentativeMax.size()-1;\\n            while (tentativeMax.size() != 0 && tentativeMax.get(index) < nums[j]){\\n                tentativeMax.remove(index--);\\n            }\\n            tentativeMax.add(nums[j]);\\n            if (j-i+1<k){\\n                j++;\\n            }\\n            else{\\n                ans[arrIndex++] = tentativeMax.get(0);\\n                if (Objects.equals(tentativeMax.get(0), nums[i])){//equals removes the null case\\n                    tentativeMax.remove(0);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int[] ans = new int[nums.length-k+1];\\n        int arrIndex = 0;\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        int i = 0;\\n        while ( i < nums.length) {\\n            if (!queue.isEmpty() && queue.peek()==(i-k)){\\n                //Removing all those elements which are out of range of K sub-array\\n                queue.poll();\\n            }\\n            while (!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]){\\n                //Removing the smaller numbers in the queue that are of no use\\n                queue.pollLast();\\n            }\\n            queue.add(i);\\n            if (!queue.isEmpty() && i>=k-1){//This loop will run after we have reached the end of the first sub-array.\\n                ans[arrIndex++] = nums[queue.peek()];\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567598,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1566657,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1922362,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 2016471,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1570698,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1950183,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1918002,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 2016128,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 2016027,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1573411,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1567598,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1566657,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1922362,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 2016471,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1570698,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1950183,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1918002,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 2016128,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 2016027,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1573411,
                "content": [
                    {
                        "username": "satvik-sharma",
                        "content": "The problem statement is a little vague.\\n  \\nWe need to return the Maximum Element from each window.\\n\\nmax sliding window = list of max element for each window"
                    },
                    {
                        "username": "HimalayanBoy",
                        "content": "[@Ritik-chaudhary](/Ritik-chaudhary) Because a max heap can give the top greatest elements but it won't be retaining the elements only specific to a window. i.e. Consider [10, 7, 5, 8]. If you maintain a k sized heap (say 3), you can get the correct ans for first window but for the next window, your heap shall still retain the 10, which is not correct. You need to handle this, explicitly then it's possible.\nHope you understand. "
                    },
                    {
                        "username": "Ritik-chaudhary",
                        "content": "In this question why we can\\'t use priority_queue<int> i.e max heap ??"
                    },
                    {
                        "username": "suriansh",
                        "content": "If you are looking for explanation of the solution approach i recommend you read these two pages of \\n*Competitive Programmer\\u2019s Handbook - Antti Laaksonen*\\n\\n![image](https://assets.leetcode.com/users/images/61bbe523-a7bf-42d4-ad3a-79cc0ac99667_1614678308.9428155.png)\\n\\n![image](https://assets.leetcode.com/users/images/0bb507e7-c0a8-454c-9055-5cfbd2442c2f_1614678319.4603157.png)\\n\\n"
                    },
                    {
                        "username": "JaceLeeBee",
                        "content": "This is a really useful resource in general and it moved me on from the brute force approach."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "Link to the section in the pdf: [8.3 Sliding window minimum](https://jadi.net/wp-content/uploads/2017/07/competetive-programmers-handbook.pdf#page=91)"
                    },
                    {
                        "username": "omkar_iitr",
                        "content": "[@Priyanxu](/Priyanxu) Competitive Programmer\\u2019s Handbook -Antti Laaksonen\\n"
                    },
                    {
                        "username": "Priyanxu",
                        "content": "broo book name ?\\n"
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "It might not be a big achievement for many , but i solved this problem in 1 go (with 0 errors in run also) within 15 min . "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hey [@Paramjeet Singh](/Paramjeet__singh), congratulations!\\nIt is the same for me as well!! My hard work feels so validated right now.\\nSeeing the question tag as hard and slowly realizing that maybe I can do this.. And finally reaching the solution.. It feels so good!"
                    },
                    {
                        "username": "f20201382",
                        "content": "Award chahiye?"
                    },
                    {
                        "username": "MahendraChourasiya",
                        "content": "which approach did you use? please reply"
                    },
                    {
                        "username": "santanusen",
                        "content": "Feel-good hard."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "bhai hard pata nahi kyu likha h, mere khyal se medium h ye at max, iski sahi place easy me difficult questions me honi chiye"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "i also did it in one go without any errors, and i feel good"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "[@hadyawayda](/hadyawayda) deque == double ended queue it all makes sense now"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Did you use a double ended queue? "
                    },
                    {
                        "username": "Kikimora",
                        "content": "It\\'s the first \"Hard\" problem which I solved without hints. My code is slow, but it\\'s mine:) Today is a happy day."
                    },
                    {
                        "username": "Poochofpain",
                        "content": "Congratulations! Same. I solved it by using a monotonic queue of the actual numbers, not indices and it was super slow (still not exactly sure why that is). But I solved it!"
                    },
                    {
                        "username": "devC_B",
                        "content": "Emotions synced \\u2013 I\\'m right with you."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "we are in the same boat, bro! Cheer cheer"
                    },
                    {
                        "username": "stefan_dimov",
                        "content": "The description is a little bit misleading: \"You can only see the k numbers in the window\". No, you can see ALL the numbers from the beginning. It should\\'ve been: \"You need to get the max number for every window with size k\" ..."
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "why this is hard question it\\'s just a concept of normal sliding window ;\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can\\'t just apply max() for each window. Use deque for better complexity, so it\\'s not about only sliding windows."
                    },
                    {
                        "username": "statx2",
                        "content": "worst wording ever"
                    },
                    {
                        "username": "z3eg",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n\\nanyone else having this problem?"
                    },
                    {
                        "username": "priyanshu054",
                        "content": "it means time limit exceeded"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "You are messing up in the passing by reference thing or the static tag somewhere, I face this problem sometimes as well."
                    },
                    {
                        "username": "Tempomy",
                        "content": "yes , same problem here too.\nhttps://leetcode.com/problems/sliding-window-maximum/description/comments/2016126"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Use priority_queue for pair (nums[i], i)! That might not be very fast, but more intuitive."
                    },
                    {
                        "username": "Brachis",
                        "content": "\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\nThis is false, because one of the tests is [] 0\\nPlease, add corrections.\\nThanks"
                    }
                ]
            },
            {
                "id": 1569494,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 1567724,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 2016266,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 1571481,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 2016234,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 2016126,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 1970778,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 1949470,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 1573289,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 1964796,
                "content": [
                    {
                        "username": "code4happy",
                        "content": "Description:\\n\"You may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\"\\n\\nTest Case: []/0\\nnon-empty array is [] ????\\n0 is >= 1?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "[@Doged-IP](/Doged-IP) naah, had to check out the editorial approach, that works but other slower ones do not"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "[@PratyayDhond](/PratyayDhond) did u manage to get past it?\\n"
                    },
                    {
                        "username": "PratyayDhond",
                        "content": "just came across it , it is weird"
                    },
                    {
                        "username": "nashbarath",
                        "content": "Create a descending order map, and insert first k elements. our map\\'s first element will;point to the greatest element in the map. \\nIn the second for loop, as its a sliding window, im removing the first elem(\\na[k-i]) and adding the current upcoming elem (a[i]) into the window. \\nfor that im  decreasing the elem\\'s frequency in the map. also note that decreasing the freq to 0 wont delete the elem from the map, so im using m.erase to delete the elem , and incrementing the frequency of the curr elem. and deriving the greatest elem in the map again using it->first. \\n![image](https://assets.leetcode.com/users/images/fd0b4a3f-dd82-4cda-8ee2-a5e51521bccc_1643263408.6621459.png)\\n\\n"
                    },
                    {
                        "username": "hadyawayda",
                        "content": "Too bad I did the same implementation in JavaScript and got TLE :(\\n\\nfunction maxSlidingWindow(nums: number[], k: number, output = [], map = new Map()): number[] {\\n  \\n  for ( let i = 0; i < k; i++ ) {\\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\\n  }\\n\\n  for ( let i = 0; i < nums.length - k + 1; i++ ) {\\n    let max = [...map.keys()]\\n    output.push(Math.max(...max))\\n    if ( map.get(nums[i]) === 1 ) {\\n      map.delete(nums[i])\\n    }\\n    if ( map.get(nums[i]) > 1 ) {\\n      map.set(nums[i], map.get(nums[i]) - 1)\\n    }\\n    map.set(nums[i + k], (map.get(nums[i + k]) || 0) + 1)\\n  }\\n\\n  return output\\n};"
                    },
                    {
                        "username": "mankaran_07",
                        "content": "This should be a Medium problem. It is a simple sliding window question."
                    },
                    {
                        "username": "giacomo",
                        "content": "The hints for the problem suggest using a deque (https://leetcode.com/problems/sliding-window-maximum/). I guess that the hint given can be used for a linear time solution.\\n\\nI checked some solutions posted in this forum, such as: https://leetcode.com/discuss/55376/a-clear-solution-using-deque-c -- but with such solutions, isn't the worst-case complexity *O*(<em>kn</em>)?\\n\\nFor example, take `nums = [7,6,5,4,3,2,1]`. The body of the `for` loop runs *n* times, while the body of the `while` loop runs *k* times, giving *O*(<em>kn</em>).\\n\\nIs there something I am missing?"
                    },
                    {
                        "username": "Poochofpain",
                        "content": "k is a constant. O(k*n) is just O(n)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "After more than seven years the link to the solution you mentioned is broken.  \\nI guess it\\'s this one: [A clear solution using deque (C++)](https://leetcode.com/problems/sliding-window-maximum/solutions/66077/a-clear-solution-using-deque-c/) by fnnfaa2020, right?  \\n\\nEach element gets appended to the queue exactly once and popped of at most once. So while the `while` loop might sometimes iterate `k` times that doesn\\'t affect the overall linear runtime complexity."
                    },
                    {
                        "username": "22mca062Shlok",
                        "content": "has anyone faced tle on 51st testcase?  it just says like in \\n\\'Last Executed Input\\'\\nnums = \\n\\n... just rest is empty i dont know what to do is it a bug?"
                    },
                    {
                        "username": "tifv",
                        "content": "Apparently, it may so happen that all test cases are passed, but after that the time limit is found to be exceeded."
                    },
                    {
                        "username": "k1174",
                        "content": "same.\\n"
                    },
                    {
                        "username": "Tempomy",
                        "content": "I am having a problem regarding the submission of the code. My code has passed all the 51/51 text cases but still for a empty input it\\'s returning time limit exceeded. I am unable attach the snap shot of the code and console. so here is my code. please help me over it.\\n\\nCode:-\\nclass Solution {\\n    public int[] maxSlidingWindow(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        if (k==1)\\n            return nums;\\n        for (int i=0;i<k;i++){\\n            max=Math.max(nums[i],max);\\n        }\\n        int n=nums.length,p=1;\\n        if (k==n)\\n            return new int[]{max};\\n        int[] res=new int[n-k+1];\\n        res[0]=max;\\n        for(int i=k;i<nums.length;i++){\\n            if (max==nums[i-k]){\\n                max=Integer.MIN_VALUE;\\n                for (int j=i-k+1;j<i+1;j++){\\n                    max=Math.max(nums[j],max);\\n                }\\n            }   \\n            if (max<nums[i]){\\n                max=nums[i];\\n                res[p++]=nums[i];\\n            }\\n            else\\n                res[p++]=max;\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "ssj0936",
                        "content": "I am so curious about how a normal guy to figure out the solution with deque. It\\'s the second time I\\'ve tried to solve it, and it\\'s also the second time I feel frustrated about that solution just like the gift from alien ...\\n\\nCould any one tell me how you figure out the solution step by step ?"
                    },
                    {
                        "username": "harshdevmurari007",
                        "content": "There are some concepts and techniques to tackle such categories of problems......you must know concept of sliding window first......only then you could identify such problem and apply those concepts to generate solution...."
                    },
                    {
                        "username": "Whateverokokokok",
                        "content": "What an awful description! Just say return the max number of a window. What the heck is a max sliding window????"
                    },
                    {
                        "username": "ruthihelp",
                        "content": "[https://vimeo.com/381339598]"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "What does this mean?  On the right side the results shows 51/51 test cases passed but I get Time Limit Exceeded error?"
                    },
                    {
                        "username": "nkthanh",
                        "content": "same problem"
                    }
                ]
            },
            {
                "id": 1944394,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 1905324,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 2016702,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 2069170,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 2016090,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 1901556,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 1572174,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 1571480,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 2016735,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 2065782,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Poorly written problem statement.. once again.\\n\\nReturn the max **number** within the sliding window."
                    },
                    {
                        "username": "anchal2002",
                        "content": "while running test case i m getting right ans  but while submitting it shows TLE. I think i am not using any static or global variables . Please check my ans if found any error;   \\n`class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int n=nums.size();\\n        int i=0;\\n        while(i<k)\\n        {\\n            pq.push({nums[i],i});\\n            i++;\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(pq.top().first);\\n        //cout<<i<<endl;\\n        i=k;\\n        while(i<n)\\n        {\\n            pq.push({nums[i],i});\\n            while(pq.top().second<=(i-k))\\n                pq.pop();\\n            cout<<nums[i]<<\" \"<<i<<endl;\\n            ans.push_back(pq.top().first);\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};`\\n"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "## 1st HARD Problem I Solved without any Help. \nSlow but correct! Cheers to the small victories.😎"
                    },
                    {
                        "username": "PalakTripathi1",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        int maxi=-100000;\\n        vector<int>v,v1;\\n        while(j<nums.size()){\\n            if(nums[j]>maxi){\\n                maxi=nums[j];\\n            }\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                v.push_back(maxi);\\n                if(maxi==nums[i]){\\n                    for(int m=i+1;m<=j;m++){\\n                        int a=nums[m];\\n                        v1.push_back(a);\\n                    }\\n                    maxi=*max_element(v1.begin(),v1.end());\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\nLine 1034: Char 16: runtime error: reference binding to null pointer of type \\'int\\' (stl_iterator.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/stl_iterator.h:1043:16\\n\\nWhat is not correct in this code Can someone plzz help?"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "The only challenge here is to somehow remove the elements from priority queue whose index is less than k from the current index.\\n\\n`Methods :-`\\n\\nA. Either use a separate data structure to store such elements like a `map`.\\n                     \\n`OR`\\n\\nB. Alongside with elements, store the `indices` too in the priority queue as a `pair` and don\\'t pick the elements whose index is less than k from the current index."
                    },
                    {
                        "username": "SkinheadBob",
                        "content": "\\'the max sliding window\\' == \\'max element in the window\\'\\n\\nAre we still doing phrasing ?"
                    },
                    {
                        "username": "anbmic",
                        "content": "I thought -->\\nNote: \\nYou may assume k is always valid, 1 \\u2264 k \\u2264 input array\\'s size for non-empty array.\\n???? \\n"
                    },
                    {
                        "username": "Sunshiwu007",
                        "content": "question says:\\nYou may assume k is always valid, ie: 1 \\u2264 k \\u2264 input array's size for non-empty array."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Thak geya hu daily skip karte karte .. Kab daily Problem solve mein bhi Easy question aiyega :-)"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Ayega paarth is niras jiwan ki yathartta se to sab kasht mai hai tumhe bas haar nai manni aur karm karte chlna hai"
                    },
                    {
                        "username": "Geekyforce",
                        "content": "Can someone see my solution and guide me ? \\nits getting hard for me to solve. i am just appling sliding window concept and not using deque or list because i dont know them well;\\ncode rum but memory limit exceed//\\nsomeone help plz, see my code //"
                    }
                ]
            },
            {
                "id": 2053494,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2050946,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2048579,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2038761,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2033029,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2028583,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2027714,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2021416,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2019865,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2018478,
                "content": [
                    {
                        "username": "gjw_eire",
                        "content": "I agree with other comments here. The wording is pretty bad. I coded a solution for my interpretation of the problem. \\n\\nIf I understand correctly, you can see the previous sliding window(s).  Bah, moving on."
                    },
                    {
                        "username": "LMS5400",
                        "content": "I got a time limit exceeded, clearly a bug in leetcode which is ironic. It can\\'t handle n^2 algorithms. Maybe they don\\'t have strong enough computers.\\n\\npretty sad, I\\'m not paying for this trash\\n\\n"
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@psionl0](/psionl0) omg bro, you should expect sacrarium when you read it. "
                    },
                    {
                        "username": "psionl0",
                        "content": "Considering that this problem is labeled ``hard`` you should expect to have to optimize your solution somehow (hint: use queues).\\nHow much is LeetCode charging you to do daily problems?"
                    },
                    {
                        "username": "zhihong2",
                        "content": "interesting point observed for python solution using monotonic queue. if I use regular python [] to implement monotonic queue, the solution passed the test but if I use deque from collections module, the solution failed with LTE. Any insights? "
                    },
                    {
                        "username": "gameboy2288",
                        "content": "Time Limit Exceeded\\n51 / 51 testcases passed\\nLast Executed Input\\nUse Testcase\\nnums =\\nplease help to solve this i\\'m kinda stuck.."
                    },
                    {
                        "username": "likekrishnendu",
                        "content": "Struck for three days, but now I\\'m happy \\uD83D\\uDE36"
                    },
                    {
                        "username": "RedoUser",
                        "content": "The hardest part of this problem is deciphering the objective. I rarely complain about problem statements, as I feel that breaking down problems into digestible chunks is part of the problem-solving process, but this feels misleading and borders on mendacious. Heck even the first two iterations of the example problem can lead you astray.\n\nThe problem wants you to find the MAXIMUM VALUE contained within each WINDOW, and NOT whether or not the sum of the current window is the max sum of all windows.\n\nAs far as difficulty goes, this should be rated a Medium at best. There are Easy problems harder than this.\n\nIts difficulty is based on previous knowledge--you either know the appropriate data structure or you do not. Know it? You can solve the problem. Don't know it? Well then good luck."
                    },
                    {
                        "username": "_antho",
                        "content": "Happy to say I figured out a high level approach on this one pretty quickly. There were a few edge cases I missed but I got it on the fourth try. Granted its slow lol"
                    },
                    {
                        "username": "IlaPoly",
                        "content": "Time Limit Exceeded 51/51 testcases passed\\nI\\'ve tried to optimize the code without using a deque and I don\\'t get how i can make the code faster.\\nAny advice?\\n\\n `class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> answer;\\n        int pos = 0;\\n        int max = nums[0];\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (nums[i] > max)\\n            {\\n                max = nums[i];\\n                pos = i;\\n            }\\n        }\\n\\n\\n        for (int i = 0; i < nums.size() - k + 1; i++)\\n        {\\n            if (nums[i + k - 1] > max)\\n            {\\n                max = nums[i + k - 1];\\n                pos = k;\\n            }\\n\\n            if (pos == 0 && nums[i] == max)\\n                pos = 1;\\n            else if (pos == 0 && nums[i + k - 1] == max)\\n                pos = k;\\n            \\n            if (pos == 0)\\n            {\\n                int prevMax = max;\\n                max = nums[i];\\n                pos = 1;\\n                for (int j = i, l = i + k - 1; j <= l; j++, l--)\\n                {\\n                    if (nums[j] >= max)\\n                    {\\n                        max = nums[j];\\n                        pos = j - i + 1;\\n                        if (nums[j] == prevMax)\\n                            break;\\n                    }\\n                    if (nums[l] >= max)\\n                    {\\n                        max = nums[l];\\n                        pos = l - i + 1;\\n                        if (nums[l] == prevMax)\\n                            break;\\n                    }\\n                }\\n            }\\n            answer.push_back(max);\\n            --pos;\\n        }\\n        return answer;\\n    }\\n};`"
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded\nAny suggestion? \n```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nfunction maxArr(from, to, arr) {\n  let maxVal = Math.max(...arr.slice(from, to ))\n  return maxVal\n}\nvar maxSlidingWindow = function(nums, k) {\n  if (nums.length === k) {\n    return [Math.max(...nums)]\n  }\n  const res = []\n  let prevMax = nums[0]\n  for (let i = 0; i < nums.length - k + 1; i++ ) {\n    // removed nums[i -1]\n    // added nums[i+k -1]\n    let thisMax = undefined\n    if (i === 0) {\n      thisMax = maxArr(i, i+k, nums)\n      prevMax = thisMax\n    } else {\n      if (nums[i -1] < prevMax) {\n        // safely removed\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n          prevMax= thisMax\n        } else {\n          thisMax = prevMax\n        }\n      } else {\n        if (nums[i+k -1]> prevMax) {\n          thisMax = nums[i+k -1]\n        } else {\n           thisMax = maxArr(i, i+k, nums)\n        }\n        prevMax = thisMax\n      }\n    }\n    res.push(thisMax)\n  }\n  return res\n};\n```"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "you can improve your maxArr function by writing something like this \\n\\nfunction maxArr(startIndex, endIndex, arr) {\\n let max = arr[startIndex];\\n\\n   for(let i=startIndex;i<endIndex;i++){\\n       if(arr[i]>max){\\n          max=arr[i]\\n       }\\n   }  \\n   return max\\n}\\n"
                    },
                    {
                        "username": "user0581xU",
                        "content": "[@tifv](/tifv)  So using a max-heap will work? I have to implement an entire heap structure?"
                    },
                    {
                        "username": "tifv",
                        "content": "`thisMax = maxArr(i, i+k, nums)` is a too expensive way to recompute maximum. You need a more advanced data structure to do this faster. (Hint to the problem is kinda helpful in this regard.)"
                    },
                    {
                        "username": "itsnot_deepak_",
                        "content": "how to deal with time limit exceeded in python my code is correct but in cases with large inputs it exceeds time limit"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "show me your code\\n"
                    }
                ]
            },
            {
                "id": 2018211,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2018052,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2017972,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2017326,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2017191,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2017133,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2017126,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2017117,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2017059,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2017033,
                "content": [
                    {
                        "username": "Godzilla1495",
                        "content": "I implemented a solution for this task but I had a time limit exceeded. Can I improve this solution or do I have to use only a monotonic queue approach? \\n\\n\\npublic int[] MaxSlidingWindow(int[] nums, int k) {\\n      var start = 0;\\n      var end = k - 1;\\n      var maxSlidingWindow = new List<int>();\\n      var maxLength = nums.Length - 1;\\n      while (end <= maxLength) {\\n        var max = nums[start];\\n        for (int i = start; i <= end; i++)\\n        {\\n            max = Math.Max(max, nums[i]);\\n        }\\n        maxSlidingWindow.Add(max);\\n        start++;\\n        end++;\\n      }\\n      return maxSlidingWindow.ToArray();\\n }\\n"
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "your code is of O(N^2) complexity thats why time limit is exceeded!\\nmake it O(N) using deque then it will work properly."
                    },
                    {
                        "username": "vijaysince89",
                        "content": "You have to use Monotonic queue. Your approach will check the max in each window from beginning to end. That\\'s why you are getting TLE. "
                    },
                    {
                        "username": "BrownCarter",
                        "content": "47/51 good for interview?"
                    },
                    {
                        "username": "blackzu69",
                        "content": "super test-cases. _|_"
                    },
                    {
                        "username": "danielmascena",
                        "content": "I was defeated by the testcase 47, that is a tough cookie to crack"
                    },
                    {
                        "username": "charonme",
                        "content": "good bye 245 streak"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "i love how pairs are utilised to keep the window size in check, otherwise the max element window would output max element of array not only the window. This problem can be used to define use of indices in such a cool way!"
                    },
                    {
                        "username": "artale",
                        "content": "This was a pain in the a**"
                    },
                    {
                        "username": "wasiullahahmed",
                        "content": "[9,10,9,-7,-4,-8,2,-6]  for value k=5\\nwhy the ans for above test case is [10,10,9,9] instead of [10,10,9,2]?"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "The leetcode expected answer for this test case is 10,10,9,2 only. Please check again."
                    },
                    {
                        "username": "singhsupriya711",
                        "content": "why time limit is exceeded in this code??\\n        maxi=[]\\n        while k<len(nums)-2:\\n            maxi.append(max(nums[k],nums[k+1],nums[k+2]));\\n\\n        return maxi"
                    },
                    {
                        "username": "tifv",
                        "content": "Your loop checks a condition, `k<len(nums)-2`, but none of the variables in that condition are ever modified. This loop will continue endlessly."
                    },
                    {
                        "username": "harshraj_305",
                        "content": "While solving this problem, its showing runtime error when you use this condition\\n\\n            while (dq.back() < nums[j] && dq.size() > 0) {\\n                  dq.pop_back();\\n            }\\n\\nbut when you change this condition like this\\n \\n           while (dq.size() > 0 && dq.back() < nums[j])\\n\\nit works totally fine, with all testcases passed!!\\n\\nanyone knows?"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Because if $$dq.size()$$ equal to zero, then where is no any element and you can\\'t compare it\\'s $$back$$ with anything."
                    }
                ]
            },
            {
                "id": 2017014,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016967,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016935,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016768,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016763,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016760,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016756,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016736,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016697,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016688,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "If you still confused about the intuition that why here dequeue is applied..\nWatch [this video ](https://www.youtube.com/watch?v=grBlaja75lk) By Aryan Mittal .\n [@Aryan Mittal](/aryan_0077)\n "
                    },
                    {
                        "username": "lucasscodes",
                        "content": "A bad binary search window list \"works\".\nA sortedDict counter \"works\".\nBut its all slow, what is the real solution..."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "use deque"
                    },
                    {
                        "username": "vijaysince89",
                        "content": "I guess I have written a code that has better performance than the DeQue method. But still I'm getting Time Limit exceeds exception. Can anyone point out why from my below code ?\n\n ```\n       List<Integer> result=new ArrayList<>();\n       int largeIndex=-1;\n       for(int i=0;i<=nums.length-k;i++){\n           int last=i+k-1;\n           int largest=Integer.MIN_VALUE;\n           int first=i;\n           if(largeIndex>=i){\n               if(nums[largeIndex]<nums[last]){\n                   largest=nums[last];\n                   largeIndex=last;\n               }\n               else{\n                   largest=nums[largeIndex];\n               }\n           }else{\n               while(first<=last){\n               if(largest<nums[first]){\n                   largest=nums[first];\n                   largeIndex=first;\n               }\n               first++;\n               }\n           }\n           result.add(largest);\n       }\n       return result.stream().mapToInt(i->i).toArray();"
                    },
                    {
                        "username": "tifv",
                        "content": "This code will perform better than brute-force solution in some cases, but still has $O(n^2)$ worst-case perfomance: if the array is decreasing, it will hit the costly `else` branch on each iteration. You have to somehow cheapen the computation of the new maximum."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": " The problem is in the condition if (largeIndex >= i) and the subsequent loop. If largeIndex is not updated within this condition, the loop might continue indefinitely because first is never incremented, and the value of last never changes. This can happen if the nums[last] value is not larger than nums[largeIndex] at any point within the loop.\njust add this line after first else statement is over---\nlargeIndex = (nums[first] >= largest) ? first : largeIndex"
                    },
                    {
                        "username": "bk2444",
                        "content": "Why does this not work. Please help\n```python\n# [1,3,-1,-3,5,3,6,7]\n# SW1 = [1,3,-1]: Push all of these into heap Max(heap) = 3\n# Now SW2 = [3,-1,-3]. num that is added: -3 and deleted:1. delete_set = {1}\n# Since deleted is not the biggest, we can store that in a set Max(heap) = 3\n# Sw3 = [-1,-3,5]. Add : 5 and Delete: 3. delete_set = {1, 3} Max = 5\n# SW4 = [-3,5,3]: Add:-1, Delete:-1 delete_set = {1,3,-1}\n# SW5 = [5,3,6]: Add: 6 Delete: -3 delete_set = {1,3,-1,-3}\n# SW6 = [3,6,7]: Add: 7 Delete: 5. delete_set = {1,3,-1,-3,5}\n\n# For each add, we insert into the heap.\n# But when do we delete?\n# Suppose the top of the heap(Max) is in delete_list: We delete it.\n# Eg: [4,2,3,1] k = 3\n# SW1 = [4,2,3]: Max = 4\n# Delete : 4 and since 4 is top, we remove it\n# SW2 = [2,3,1]. Max = 3\n\n\n# We are taking advantage of the fact that, If we delete something other than the maximum, the result is still not going to change. So we can remember that we need to delete that element. That comes in handy if later in the future we have top of the heap that needs to be deleted. Our concern is only the top of heap since that determines the answer.\n\nfrom heapq import heappush, heappop\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        heap = []\n        for i in range(k):\n            heappush(heap, -1*nums[i])\n        delete_set = set()\n        ans = []\n        ans.append(-1*heap[0])\n        for i in range(k, len(nums)):\n            elem_add = -1*nums[i]\n            elem_del = -1*nums[i-k]\n            heappush(heap, elem_add)\n            delete_set.add(elem_del)\n            while heap[0] in delete_set:\n                delete_set.remove(heap[0])\n                heappop(heap)\n            ans.append(-1*heap[0])\n        return ans\n```"
                    },
                    {
                        "username": "bk2444",
                        "content": "[@tifv](/tifv) That makes sense. Thank you so much. It Worked. I used a defaultdict to store frequency"
                    },
                    {
                        "username": "tifv",
                        "content": "`delete_set` should not be a `set`, but some kind of a multiset, because occasionally you will need to remove two identical elements."
                    },
                    {
                        "username": "krhemant172003",
                        "content": "Steps of sliding window approach:\\n1. Know the size of your window(in this case it is k)\\n2. How would you get the answer for the first window?\\n  -> By getting the largest element among first k elements\\n3. Use some data structure to store the current answer\\n -> In case of sliding window it is  **deque**(generally) \\n4. Now know how adding new element to the might affect the current answer i.e. if the added element is greater than the current answer so update the current answer and store it.\\n5. Last but most important step remove all the element which does not fit the window."
                    },
                    {
                        "username": "m_karthik_7",
                        "content": " `\n\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n\n        Window = deque()\n\n        Window = nums[0:k]\n\n        result = [max(Window)]\n\n        for i in range(1, len(nums)-k+1):\n\n            Window.remove(nums[i-1])\n\n            Window.append(nums[i+k-1])\n\n            result.append(max(Window))\n\n        return (result)\n`\n This was my code IDK why it gives me TLE I don't know What's wrong with this time complexity my code has O(n) time complexity then why it gives me TLE??????????????"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "Your code has $$O(n*k)$$ time complexity.\nHow do you think $$max(Window)$$ works for linked list?"
                    },
                    {
                        "username": "Mcraellhs",
                        "content": "Solved this without using any ques or other data structures.\\nI used basic array only :D"
                    },
                    {
                        "username": "KOCMOHABT",
                        "content": "I\\'ve checked your AC. Did you see your execution time? \\n$$Runtime: 8681 ms$$\\nIt\\'s very strange that it got accepted."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why is it tagged under hard? It should be tagged under medium category because o(n log n) requires basic multiset operations which can pass and o(n) complexity requires deque\\nfor example sliding window with deque and this problem is very similiar to the problem like https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/ it\\'s tagged under medium "
                    },
                    {
                        "username": "satyam47",
                        "content": "Map + Priority Queue"
                    },
                    {
                        "username": "light_70",
                        "content": "Problem statement can be more precise."
                    }
                ]
            },
            {
                "id": 2016678,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016613,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016391,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016347,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016327,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016261,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016230,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016166,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016165,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016127,
                "content": [
                    {
                        "username": "paradoxtown",
                        "content": "today is wednesday, right?"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "Segment tree passes XD Although tc is not so good."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "> Return the max sliding window.\\n\\n> k = 3\\n\\n> Output: [3,3,5,5,6,7]\\n\\nhuh? that makes no sense!\\n(please fix that. it\\'s not, like, misleading or unclear -- it\\'s a completely different problem here!)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**shouldn\\'t it be, Return the max in sliding window not Return the max sliding window.**\\n**wrong description**"
                    },
                    {
                        "username": "dikshawali",
                        "content": "This is a beautiful question !!"
                    },
                    {
                        "username": "chinmaykothe98",
                        "content": "Can someone help me in this approach. Failing 37/51 where nums[] is very big and k=50000\\n\\n public int[] maxSlidingWindow(int[] nums, int k) {\\n        if(k==1)\\n            return nums;\\n        int size = nums.length-k+1;\\n        int x = 0;\\n        int ans[] = new int[size];\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\\n        for(int i=0; i<k; i++){\\n            pq.add(nums[i]);\\n        }\\n        ans[x++] = pq.peek();\\n        int i = 1;\\n        int j = k;\\n        while(j<nums.length){\\n            pq.remove(nums[i-1]);\\n            pq.add(nums[j]);\\n            ans[x++] = pq.peek();\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "The solution you propose is of time complexity O(k*log(k)) and the solution given is of time complexity O(n), which is faster."
                    },
                    {
                        "username": "emailforharshit25",
                        "content": "Why didn\\'t k*log(k) approach using priority queue work, can someone please explain ? Thanks!"
                    },
                    {
                        "username": "fekze",
                        "content": "38 testcase c++ time limit :/"
                    },
                    {
                        "username": "Doged-IP",
                        "content": "does anyone know how to deal with the testcase with nothing in it\\'s nums array?\\n"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Segment-Tree is available for the problem, refer to the solution:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3915831/c-solution-by-setment-tree/"
                    }
                ]
            },
            {
                "id": 2016116,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 2016073,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 2016050,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 2016036,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 2015041,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 2014545,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 2008658,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 2004469,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 1966104,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 1958986,
                "content": [
                    {
                        "username": "senguptabihan",
                        "content": "what is wrong \n\n        int n=nums.size();        \n        vector<int>v;\n        for(int i=0;i<=n-k;i++)\n        {\n            int max1=-1;\n            for(int j=i;j<i+k;j++)\n            {\n                max1=max(max1,nums[j]);\n            }\n            v.push_back(max1);\n        }\n        return v;\n"
                    },
                    {
                        "username": "senguptabihan",
                        "content": "[@QuarantinedSoul](/QuarantinedSoul)  okk thanks "
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "1)try to solve it in linear time complexity, you are doing brute force it will exceed time limit\n2) max1 = -1, is wrong as values can range from -10^4 to 10^4"
                    },
                    {
                        "username": "TonyTang99",
                        "content": "It's very strange why I have passed all the test cases but got an limit time excceeded error? \nI'm using Dynamic Programming to solve the problem."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "did u get this as well?\\n\\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums =\\n"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "This hardly feels like a hard problem. It\\'s very intuitive to use a priority queue, add the right element and poll from it while the head\\'s index in lesser than the window\\'s left pointer."
                    },
                    {
                        "username": "Doged-IP",
                        "content": "do you know how to deal with \\nTime Limit Exceeded\\n51 / 51 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "aftab0711",
                        "content": "Not understood button \\uD83D\\uDC49\\uD83D\\uDC49"
                    },
                    {
                        "username": "gnakul2001",
                        "content": "I am getting TLE Error on Test Case 51/51 where nums=<empty> ans no k column. \\n\\n\\nCode:\\nclass Solution {\\n    int getMaxElementIdx(vector<int>& nums, int last, int start=0){\\n        int maxValue = nums[start];\\n        int maxIndex = start;\\n        \\n        for (int i = start+1; i < last+start; i++) {\\n            if (nums[i] >= maxValue) {\\n                maxValue = nums[i];\\n                maxIndex = i;\\n            }\\n        }\\n        return maxIndex;\\n    }\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(n==0){\\n            return ans;\\n        }\\n        if(n <= 1 || k == 1){\\n            return nums;\\n        }\\n        int maxNumIdx = getMaxElementIdx(nums, k);\\n        ans.push_back(nums[maxNumIdx]);\\n        for(int i=1;i<n-k+1;i++){\\n            if(maxNumIdx < i){\\n                maxNumIdx = getMaxElementIdx(nums, k, i);\\n            }else{\\n                if(nums[maxNumIdx] < nums[i+k-1]){\\n                    maxNumIdx = i+k-1;\\n                }\\n            }\\n            ans.push_back(nums[maxNumIdx]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\nBut If I write same code using deque then it passed all test cases:\\nclass Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        deque<int> dq;\\n        for(int i=0;i<k;i++){\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        ans.push_back(nums[dq.front()]);\\n        for(int i=k;i<nums.size();i++){\\n            while(!dq.empty() && i-k >= dq.front()) dq.pop_front();\\n            while(!dq.empty() && nums[i] >= nums[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n            ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "SirBzik",
                        "content": "Its funny how using collection from kotlin (kotlin.collections.ArrayDeque) will make your code here run 3 times slower comparing to using same collection from java"
                    },
                    {
                        "username": "thiruthuvarajan",
                        "content": "Hi, \n\nI have issue with my code.  (AlertL this code might contain partial solution. )\nI am using PriorityQueue for sorting and finding the max value. But everyone using deque with similar solution.\n\nI get time exceeded for 38th test case . I believe this is O(n) solution. But can anyone enlighten me ? \n\nDoes sorting creates the problem or additional time ?\n\n\n\n  int left = 0; \\n\n   int inc = 0;\n   int[] res = new int[nums.length - k + 1];\n   PriorityQueue<Integer> priorityQueue = new PriorityQueue<>((Integer c1, Integer c2) -> Integer.compare(c2, c1));\n      for(int i = 0;i< nums.length ;i++) {\n           priorityQueue.add(nums[i]);\n           if(i + 1 >= k) {\n               res[inc++] = priorityQueue.peek();\n               priorityQueue.remove(nums[left++]);\n           }\n}"
                    },
                    {
                        "username": "mlivingston",
                        "content": "Some of these massive input test cases are a little ridiculous .... this problem is actually very simple .... this solution should be perfectly acceptable:\\nhttps://gist.github.com/mlivingston40/028c1f1d7bd338fb06d7f6026d363891"
                    },
                    {
                        "username": "WhatAGod",
                        "content": "Overkill but segment tree works on this problem"
                    },
                    {
                        "username": "Eckhart01",
                        "content": "This problem is really interesting, reminds me of one of my dp homework problem with O(n) optimization."
                    }
                ]
            },
            {
                "id": 1954756,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1953055,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1936951,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1920996,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1918036,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1911326,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1909652,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1907946,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1887487,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1866098,
                "content": [
                    {
                        "username": "wtfcoder",
                        "content": "Maintain a priority queue and map to store frequency, modify map in each round and remove top elements from the priority queue until top element has frequency more than 0. "
                    },
                    {
                        "username": "reassurance",
                        "content": "**Guys i have this `python` solution of O(N) TC and O(K) SC...can someone specify a way to make this faster ?**\\n ```\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        res=[]\\n        window=deque(nums[:k])\\n        res.append(max(window))\\n        window.popleft()\\n        for i in range(k,len(nums)):\\n            window.append(nums[i])\\n            res.append(max(window))\\n            window.popleft()\\n        return res\\n            \\n```"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Intuition\\nC++, Dequeu(Doubly linked list) Solution Optimal.\\n\\nApproach\\nAlgorithm: Sliding Window Maximum\\n\\nInputs:\\n\\nnums: A vector of integers representing the input array.\\nk: An integer representing the size of the sliding window.\\nOutput:\\n\\nans: A vector of integers containing the maximum elements in each sliding window.\\nInitialize an empty deque called \"dq\".\\nInitialize an empty vector called \"ans\".\\nLet \"n\" be the size of the input array \"nums\".\\nIterate \"i\" from 0 to \"n - 1\":\\nWhile \"dq\" is not empty and the index at the front of \"dq\" is less than\\nor equal to \"i - k\", remove the front element from \"dq\".\\nWhile \"dq\" is not empty and the value at the back of \"dq\" in \"nums\" is less\\nthan or equal to the value at index \"i\" in \"nums\", remove the back element from \"dq\".\\nAdd index \"i\" to the back of \"dq\".\\nIf \"i\" is greater than or equal to \"k - 1\":\\nAdd the value at the front of \"dq\" in \"nums\" to \"ans\".\\nReturn \"ans\" as the result of the algorithm.\\nThe algorithm uses a deque data structure to store indices\\nof elements in the sliding window. The deque is maintained\\nin such a way that the front element always represents the\\nmaximum element in the current window. The algorithm iterates\\nthrough the input array and updates the deque based on the\\nsliding window\\'s size. At each step, it checks if the front\\nelement is within the window\\'s range and removes it if necessary.\\nIt also removes any elements from the back of the deque that are\\nsmaller than or equal to the current element. Finally, it adds\\nthe maximum element from the deque to the answer vector when\\nthe window size is reached.\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nS.C=O(k)\\n\\nPlease Upvote if you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/sliding-window-maximum/solutions/3660596/c-dequeu-doubly-linked-list-solution-optimal/\\n"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "can this be solved in o(n) without using queue?"
                    },
                    {
                        "username": "najwer23",
                        "content": "one line with slice() in js, but TLE. \\n\\narggggggghhhhh..."
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "passed 41 / 51 testcases passed      \\nThe case is 836 array elements are given, the expected array element are same as  but there is mismatch in \\nresult output and excpected output . Please help !\\n\\n   int i = 0 ; \\n        int j = 0 ;\\n        //  List for storing negative element\\n        List<Integer> maxArray = new ArrayList<>() ;\\n         List<Integer> ansArray = new ArrayList<>() ;\\n\\n        while(j < nums.length)\\n        {\\n            int windowSize = j - i + 1 ;\\n            if(!maxArray.isEmpty() && maxArray.get(0) < nums[j] )\\n                {\\n                    maxArray.clear() ;\\n                }\\n                maxArray.add(nums[j]) ;\\n            if(windowSize < k )\\n            {\\n                j++;\\n            }\\n            else if(windowSize == k)\\n            {\\n                if( maxArray.get(0) == nums[i] )\\n                {\\n                    ansArray.add(maxArray.get(0));\\n                    maxArray.remove(0) ;\\n                    Collections.sort(maxArray, Collections.reverseOrder());\\n                }else{\\n                    ansArray.add(maxArray.get(0));\\n                }\\n                 \\n               \\n                i++;\\n                j++;\\n            }\\n\\n        }\\n        int[] ans = new int[ansArray.size()];\\n        for(int p = 0 ; p < ansArray.size() ; p++ )\\n        {\\n            ans[p] = ansArray.get(p);\\n        }\\n\\n        return ans ;"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "[@kumaramarjeet001](/kumaramarjeet001) \\u201CYou Are Most Welcome\\u201D"
                    },
                    {
                        "username": "kumaramarjeet001",
                        "content": "[@Bantydeni](/Bantydeni)  Thanks for your review ."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The code provided is using the sliding window technique to find the maximum element in each subarray of size k in an array of integers. The code initializes two pointers i and j to 0, and two lists maxArray and ansArray to store the maximum element in each subarray and the final answer, respectively. The code then enters a while loop that runs until j reaches the end of the array. In each iteration, the code calculates the size of the current window, adds the current element to maxArray, and checks if the maximum element in maxArray is less than the current element. If so, it clears maxArray and adds the current element to it. If the window size is less than k, the code increments j. If the window size is equal to k, the code checks if the first element in maxArray is equal to the first element in the current window. If so, it adds the first element in maxArray to ansArray, removes it from maxArray, and sorts the remaining elements in maxArray in descending order. If not, it simply adds the first element in maxArray to ansArray. The code then increments i and j. Finally, the code converts ansArray to an array of integers and returns it.\\nTo help with the issue of the mismatch between the expected output and the actual output, it would be helpful to know the expected output and the test cases that are failing. Without this information, it is difficult to determine the cause of the mismatch. It is possible that there is a bug in the implementation or that the sliding window technique is not the optimal approach for solving the problem."
                    },
                    {
                        "username": "Bantydeni",
                        "content": "In the brute force approach, we iterate over all possible sliding windows of size k and find the maximum for each window by looking through all its elements. The GetMax function is used to find the maximum element in a given window. Here\\'s an implementation of the GetMax function in Python:\\ndef GetMax(arr, start, end):\\n    max_val = arr[start]\\n    for i in range(start + 1, end):\\n        if arr[i] > max_val:\\n            max_val = arr[i]\\n    return max_val\\n\\nThe function takes an array arr, a starting index start, and an ending index end, and returns the maximum element in the subarray arr[start:end]. The function initializes the maximum value to the first element of the subarray, and then iterates over the remaining elements of the subarray, updating the maximum value if it finds a larger element. The time complexity of the GetMax function is O(k), where k is the size of the sliding window. Since we call this function for each sliding window, the time complexity of the brute force approach is O(n*k), where n is the size of the input array."
                    },
                    {
                        "username": "Abhay1708",
                        "content": " vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n        deque<int>dq;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            if(!dq.empty() && dq.front()==i-k)\\n            dq.pop_front();\\n            while(!dq.empty() && nums[dq.back()]<nums[i]){\\n                dq.pop_back();\\n            }\\n                dq.push_back(i);\\n                if(i>=k-1)\\n                ans.push_back(nums[dq.front()]);\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "Normal sliding window without double ended queue get TLE. but good enough for interview?"
                    },
                    {
                        "username": "smitu2410",
                        "content": "I encountered Wrong Answer/Runtime Error for a specific test case. When I test my code using this test case, it produced the correct output. Why?  \nI tried to debug my code, but it seems that it doesn't have any static or global variables. Another  cause might be undefined behaviour but I'm unable to figure out what is the undefined behaviour.  Sorry for such a noob question. Thank you . Here is the code.\nhttps://leetcode.com/problems/sliding-window-maximum/submissions/935099556/?orderBy=most_votes"
                    },
                    {
                        "username": "smitu2410",
                        "content": "Seems like there was a bug in the code. Which was not related to static or global variable issue. I fixed one of the  if condition  at line 37 and it worked magically.  :)"
                    }
                ]
            },
            {
                "id": 1859349,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            },
            {
                "id": 1853518,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            },
            {
                "id": 1828090,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            },
            {
                "id": 1804036,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            },
            {
                "id": 1781854,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            },
            {
                "id": 1772639,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            },
            {
                "id": 1757550,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            },
            {
                "id": 1756040,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            },
            {
                "id": 1755251,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            },
            {
                "id": 1753257,
                "content": [
                    {
                        "username": "Anusha952",
                        "content": "ans"
                    },
                    {
                        "username": "gauravpatel22",
                        "content": "tle gving by using the concept of sliding window\\n"
                    },
                    {
                        "username": "aquaman55",
                        "content": "[@hadyawayda](/hadyawayda) It is a stupid testcase for it to TLE"
                    },
                    {
                        "username": "pritz99",
                        "content": "I have been using while loop but 44/51 test cases are pass only ?? why this is happening? I have also tried for loop but no change in solution.\n\n\n public  int max(int[] arr,int s,int e) {\n\t\tint m= Integer.MIN_VALUE;\n\t\tfor(int i=s;i<=e;i++) {\n\t\t\tif(m<arr[i]) m=arr[i];\n\t\t}\n\t\treturn m;\n\t}\n    public int[] maxSlidingWindow(int[] arr, int k) {\n      int s=0;\n\t\tint e=k-1;\n\t\t int[] arr2= new int[arr.length-k+1];\n\t\tint i1=0;\n\t\twhile(e<arr.length) {\n\t\tarr2[i1]=max(arr,s,e);\n\t\ti1++;\n\t\t\ts++;\n\t\t\te++;\n\t\t}\n\t\t\n\t\treturn arr2;\n    }"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you.\\n"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Time Limit Exceeded 37/51 passes. Help!\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        ArrayList<Integer> list = new ArrayList<> ( );\n        int[] ans = new int[nums.length - k + 1];\n        int start = 0;\n        int length = 0;\n        for(int i = 0; i<nums.length; i++) {\n            list.add(nums[i]);\n            while(list.size() == k ) { \n                ans[start] = (Collections.max(list));\n                list.remove(0);\n                start++;\n            }\n        }\n        return ans;\n    }\n}\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "This solution uses a naive approach where for each sliding window it determines the maximal element by iterating over the window, the runtime complexity is in O(n * k). That\\'s too slow, you will need something faster. (This problem is classified as \"hard\" for a reason.)  \\nTake a look at the \"Related Topics\", perhaps that will inspire you."
                    },
                    {
                        "username": "IWBTFU",
                        "content": "class Solution {\\npublic:\\n    vector<int> maxSlidingWindow(vector<int>& arr, int k) {\\n         int n=arr.size();\\n          int i=0,j=0;\\n        vector<int>ans;\\n          priority_queue<int>pq;\\n          while(j<=n)\\n          {\\n                    if(j-i+1<=k){\\n                              pq.push(arr[j]);\\n                              j++;\\n                    }\\n                    else\\n                    {\\n                              ans.push_back(pq.top());\\n                              if(arr[i]==pq.top())pq.pop();\\n                              i++;\\n                    }\\n          }\\n          return ans;\\n    }\\n};\\n\\n\\n\\nCAN SOMEONE POINT OUT MY MISTAKE IT\\'S WORKING FINE ON LOCAL COMPILER"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`while(j<=n)` and `pq.push(arr[j]);` => accesses `arr` out of bounds.  \\nYou could change the condition of the `while` loop to `i + k <= n`.\\n\\nAlso, if I understand the code correctly, the `if` branch inside the loop adds new elements to the priority queue if the current sliding window is smaller than `k`. The `else` branch removes the largest element from the priority queue, if it is outside of the sliding window.  \\nNow imagine `arr={3,4,1,2}` and `k=2`. `3` and `4` get added to the `pq`. Then `3` gets **not** removed because it\\'s not the largest element in `pq`. Then `4` gets removed because it\\'s outside of the sliding window but `3` still is in `pq`. The function should return `{4,4,2}` but it actually returns `{4,4,3}` because the `3` never was removed."
                    },
                    {
                        "username": "trafalgar_d_law",
                        "content": "Can anyone tell me how to know the expected time complexity asked for a given question?"
                    },
                    {
                        "username": "aftabalam2209",
                        "content": "Hard ones generally require O(n)."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "shreyasirao97",
                        "content": "Getting TLE with maxHeap :("
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "keep your problems yourself"
                    },
                    {
                        "username": "sugandhaggarwal083",
                        "content": "Is there a way we can import AVL in java here.\\nclass Solution {\\n    public int[] maxSlidingWindow(int nums[], int k){\\n        int[] result = new int[Math.max(1,nums.length-k+1)];\\n        AVL tree=new AVL();\\n        for (int i = 0; i < k; i++)\\n            tree.root = tree.insert(tree.root, nums[i]);\\n        for (int i = k; i < nums.length; i++){\\n            result[i-k] = tree.findMaxElement(); \\n            tree.root = tree.delete(tree.root, nums[i-k]); \\n            tree.root = tree.insert(tree.root, nums[i]);\\n        }  \\n        return result;\\n}}"
                    },
                    {
                        "username": "jobanputray24",
                        "content": "Yes, TreeSet or TreeMap."
                    },
                    {
                        "username": "3xp10it3r",
                        "content": "[medium](https://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7)\n\nhttps://medium.com/@digvijaygupta2143/maximum-of-all-subarrays-of-size-k-sliding-window-2c172b48ffc7\n\nblog explaning easy sliding window solution"
                    }
                ]
            }
        ]
    },
    {
        "title": "Nested List Weight Sum",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1572783,
                "content": [
                    {
                        "username": "cuzzo",
                        "content": "The problem says that the input to the main function `depth_sum` is a `NestedInteger` -- but it is actually a regular ruby array."
                    },
                    {
                        "username": "nn2",
                        "content": "The first sentence of the description is poorly worded.  IMHO it should read:\\nYou are given a list of `NestedInteger`s.  A `NestedInteger` can represent a single Integer or a List of `NestedInteger`s.  Thus you can get several \"nested\" layers of `NestedInteger`s.   "
                    },
                    {
                        "username": "svara1nis",
                        "content": "This question should probably be marked as \"Easy\" based on: the length of the solution, concepts that are tested here, and simply the accepted submission rate overall."
                    },
                    {
                        "username": "zytlsgj92",
                        "content": "I can\\'t understand what this sentense means\\n `1 <= nestedList.length <= 50`\\nDoes nestedList.length mean the number of integer(A)? or the size of list(B)?\\nwhen the situation is like this \\n`nestedList =[1,2,3,[4,5,[6,7]]]`\\nA would be 7 and B would be 4\\nwhich one is right?"
                    },
                    {
                        "username": "panhejia",
                        "content": "> Does nestedList.length mean the number of integer(A)? or the size of list(B)?\\n\\nsize of the list. B.\\n\\nView `nestedList =[1,2,3,[4,5,[6,7]]]` as \\n```java\\nList.of(\\n    new NestedInteger(1),\\n    new NestedInteger(2),\\n    new NestedInteger(3),\\n    new NestedInteger()\\n         .add(4)\\n         .add(5)\\n         .add( new NestedInteger().add(6).add(7) )\\n)\\n```"
                    },
                    {
                        "username": "ahmedrmunir",
                        "content": "It means the size of the list. In this case, nestedList contains 4 elements."
                    }
                ]
            },
            {
                "id": 1706924,
                "content": [
                    {
                        "username": "cuzzo",
                        "content": "The problem says that the input to the main function `depth_sum` is a `NestedInteger` -- but it is actually a regular ruby array."
                    },
                    {
                        "username": "nn2",
                        "content": "The first sentence of the description is poorly worded.  IMHO it should read:\\nYou are given a list of `NestedInteger`s.  A `NestedInteger` can represent a single Integer or a List of `NestedInteger`s.  Thus you can get several \"nested\" layers of `NestedInteger`s.   "
                    },
                    {
                        "username": "svara1nis",
                        "content": "This question should probably be marked as \"Easy\" based on: the length of the solution, concepts that are tested here, and simply the accepted submission rate overall."
                    },
                    {
                        "username": "zytlsgj92",
                        "content": "I can\\'t understand what this sentense means\\n `1 <= nestedList.length <= 50`\\nDoes nestedList.length mean the number of integer(A)? or the size of list(B)?\\nwhen the situation is like this \\n`nestedList =[1,2,3,[4,5,[6,7]]]`\\nA would be 7 and B would be 4\\nwhich one is right?"
                    },
                    {
                        "username": "panhejia",
                        "content": "> Does nestedList.length mean the number of integer(A)? or the size of list(B)?\\n\\nsize of the list. B.\\n\\nView `nestedList =[1,2,3,[4,5,[6,7]]]` as \\n```java\\nList.of(\\n    new NestedInteger(1),\\n    new NestedInteger(2),\\n    new NestedInteger(3),\\n    new NestedInteger()\\n         .add(4)\\n         .add(5)\\n         .add( new NestedInteger().add(6).add(7) )\\n)\\n```"
                    },
                    {
                        "username": "ahmedrmunir",
                        "content": "It means the size of the list. In this case, nestedList contains 4 elements."
                    }
                ]
            },
            {
                "id": 1809567,
                "content": [
                    {
                        "username": "cuzzo",
                        "content": "The problem says that the input to the main function `depth_sum` is a `NestedInteger` -- but it is actually a regular ruby array."
                    },
                    {
                        "username": "nn2",
                        "content": "The first sentence of the description is poorly worded.  IMHO it should read:\\nYou are given a list of `NestedInteger`s.  A `NestedInteger` can represent a single Integer or a List of `NestedInteger`s.  Thus you can get several \"nested\" layers of `NestedInteger`s.   "
                    },
                    {
                        "username": "svara1nis",
                        "content": "This question should probably be marked as \"Easy\" based on: the length of the solution, concepts that are tested here, and simply the accepted submission rate overall."
                    },
                    {
                        "username": "zytlsgj92",
                        "content": "I can\\'t understand what this sentense means\\n `1 <= nestedList.length <= 50`\\nDoes nestedList.length mean the number of integer(A)? or the size of list(B)?\\nwhen the situation is like this \\n`nestedList =[1,2,3,[4,5,[6,7]]]`\\nA would be 7 and B would be 4\\nwhich one is right?"
                    },
                    {
                        "username": "panhejia",
                        "content": "> Does nestedList.length mean the number of integer(A)? or the size of list(B)?\\n\\nsize of the list. B.\\n\\nView `nestedList =[1,2,3,[4,5,[6,7]]]` as \\n```java\\nList.of(\\n    new NestedInteger(1),\\n    new NestedInteger(2),\\n    new NestedInteger(3),\\n    new NestedInteger()\\n         .add(4)\\n         .add(5)\\n         .add( new NestedInteger().add(6).add(7) )\\n)\\n```"
                    },
                    {
                        "username": "ahmedrmunir",
                        "content": "It means the size of the list. In this case, nestedList contains 4 elements."
                    }
                ]
            },
            {
                "id": 1668107,
                "content": [
                    {
                        "username": "cuzzo",
                        "content": "The problem says that the input to the main function `depth_sum` is a `NestedInteger` -- but it is actually a regular ruby array."
                    },
                    {
                        "username": "nn2",
                        "content": "The first sentence of the description is poorly worded.  IMHO it should read:\\nYou are given a list of `NestedInteger`s.  A `NestedInteger` can represent a single Integer or a List of `NestedInteger`s.  Thus you can get several \"nested\" layers of `NestedInteger`s.   "
                    },
                    {
                        "username": "svara1nis",
                        "content": "This question should probably be marked as \"Easy\" based on: the length of the solution, concepts that are tested here, and simply the accepted submission rate overall."
                    },
                    {
                        "username": "zytlsgj92",
                        "content": "I can\\'t understand what this sentense means\\n `1 <= nestedList.length <= 50`\\nDoes nestedList.length mean the number of integer(A)? or the size of list(B)?\\nwhen the situation is like this \\n`nestedList =[1,2,3,[4,5,[6,7]]]`\\nA would be 7 and B would be 4\\nwhich one is right?"
                    },
                    {
                        "username": "panhejia",
                        "content": "> Does nestedList.length mean the number of integer(A)? or the size of list(B)?\\n\\nsize of the list. B.\\n\\nView `nestedList =[1,2,3,[4,5,[6,7]]]` as \\n```java\\nList.of(\\n    new NestedInteger(1),\\n    new NestedInteger(2),\\n    new NestedInteger(3),\\n    new NestedInteger()\\n         .add(4)\\n         .add(5)\\n         .add( new NestedInteger().add(6).add(7) )\\n)\\n```"
                    },
                    {
                        "username": "ahmedrmunir",
                        "content": "It means the size of the list. In this case, nestedList contains 4 elements."
                    }
                ]
            }
        ]
    }
]