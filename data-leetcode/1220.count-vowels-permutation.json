[
    {
        "title": "Push Dominoes",
        "question_content": "There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\nYou are given a string dominoes representing the initial state where:\n\n\tdominoes[i] = 'L', if the ith domino has been pushed to the left,\n\tdominoes[i] = 'R', if the ith domino has been pushed to the right, and\n\tdominoes[i] = '.', if the ith domino has not been pushed.\n\nReturn a string representing the final state.\n&nbsp;\nExample 1:\n\nInput: dominoes = \"RR.L\"\nOutput: \"RR.L\"\nExplanation: The first domino expends no additional force on the second domino.\n\nExample 2:\n\nInput: dominoes = \".L.R...LR..L..\"\nOutput: \"LL.RR.LLRRLL..\"\n\n&nbsp;\nConstraints:\n\n\tn == dominoes.length\n\t1 <= n <= 105\n\tdominoes[i] is either 'L', 'R', or '.'.",
        "solutions": [
            {
                "id": 132332,
                "title": "java-c-python-two-pointers",
                "content": "# **Intuition**:\\nWhether be pushed or not, depend on the shortest distance to \\'L\\' and \\'R\\'.\\nAlso the direction matters.\\nBase on this idea, you can do the same thing inspired by this problem.\\nhttps://leetcode.com/problems/shortest-distance-to-a-character/discuss/125788/\\n\\nHere is another idea is focus on only \\'L\\' and \\'R\\'.\\n<br>\\n\\n# **Complexity**:\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public String pushDominoes(String d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d.charAt(j) == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res.append(d.charAt(i));\\n            if (d.charAt(i) == d.charAt(j))\\n                for (int k = 0; k < middle; k++)\\n                    res.append(d.charAt(i));\\n            else if (d.charAt(i) == \\'L\\' && d.charAt(j) == \\'R\\')\\n                for (int k = 0; k < middle; k++)\\n                    res.append(\\'.\\');\\n            else {\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'R\\');\\n                if (middle % 2 == 1)\\n                    res.append(\\'.\\');\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'L\\');\\n            }\\n            i = j;\\n        }\\n        return res.toString();\\n    }\\n```\\n**C++:**\\n```cpp\\n    string pushDominoes(string d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        string res = \"\";\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d[j] == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res += d[i];\\n            if (d[i] == d[j])\\n                res += string(middle, d[i]);\\n            else if (d[i] == \\'L\\' && d[j] == \\'R\\')\\n                res += string(middle, \\'.\\');\\n            else\\n                res += string(middle / 2, \\'R\\') + string(middle % 2, \\'.\\') + string(middle / 2, \\'L\\');\\n            i = j;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def pushDominoes(self, d):\\n        d = \\'L\\' + d + \\'R\\'\\n        res = \"\"\\n        i = 0\\n        for j in range(1, len(d)):\\n            if d[j] == \\'.\\':\\n                continue\\n            middle = j - i - 1\\n            if i:\\n                res += d[i]\\n            if d[i] == d[j]:\\n                res += d[i] * middle\\n            elif d[i] == \\'L\\' and d[j] == \\'R\\':\\n                res += \\'.\\' * middle\\n            else:\\n                res += \\'R\\' * (middle / 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle / 2)\\n            i = j\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public String pushDominoes(String d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d.charAt(j) == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res.append(d.charAt(i));\\n            if (d.charAt(i) == d.charAt(j))\\n                for (int k = 0; k < middle; k++)\\n                    res.append(d.charAt(i));\\n            else if (d.charAt(i) == \\'L\\' && d.charAt(j) == \\'R\\')\\n                for (int k = 0; k < middle; k++)\\n                    res.append(\\'.\\');\\n            else {\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'R\\');\\n                if (middle % 2 == 1)\\n                    res.append(\\'.\\');\\n                for (int k = 0; k < middle / 2; k++)\\n                    res.append(\\'L\\');\\n            }\\n            i = j;\\n        }\\n        return res.toString();\\n    }\\n```\n```cpp\\n    string pushDominoes(string d) {\\n        d = \\'L\\' + d + \\'R\\';\\n        string res = \"\";\\n        for (int i = 0, j = 1; j < d.length(); ++j) {\\n            if (d[j] == \\'.\\') continue;\\n            int middle = j - i - 1;\\n            if (i > 0)\\n                res += d[i];\\n            if (d[i] == d[j])\\n                res += string(middle, d[i]);\\n            else if (d[i] == \\'L\\' && d[j] == \\'R\\')\\n                res += string(middle, \\'.\\');\\n            else\\n                res += string(middle / 2, \\'R\\') + string(middle % 2, \\'.\\') + string(middle / 2, \\'L\\');\\n            i = j;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def pushDominoes(self, d):\\n        d = \\'L\\' + d + \\'R\\'\\n        res = \"\"\\n        i = 0\\n        for j in range(1, len(d)):\\n            if d[j] == \\'.\\':\\n                continue\\n            middle = j - i - 1\\n            if i:\\n                res += d[i]\\n            if d[i] == d[j]:\\n                res += d[i] * middle\\n            elif d[i] == \\'L\\' and d[j] == \\'R\\':\\n                res += \\'.\\' * middle\\n            else:\\n                res += \\'R\\' * (middle / 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle / 2)\\n            i = j\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2628923,
                "title": "c-two-pointer-diagram-related-problems",
                "content": "**Approach**\\n1. If we encounter `.` in string, we move forward to next index.\\n2. If we encounter `L` in string, we see if index of right is -1, we make all the left index `L` until we see any other `L`.\\n2. If we encounter `L` in string and there is some previous `R` index, then we simultaneously change string from left and right side till two pointers reach each other. After that `right` moves back to `-1`.\\n3. If we encounter `R` in string, we see if the index of `R` is not -1, we make all the indices upto that index `R`.\\n\\n**Diagram Explanation**\\n\\n![image](https://assets.leetcode.com/users/images/ffb493fa-7b64-4859-8aa0-e2cf78d5a2bf_1664247243.6077156.png)\\n\\n![image](https://assets.leetcode.com/users/images/11608e78-545d-435f-afb1-d824948f13d9_1664247249.2657273.png)\\n\\n**Explanation of steps** \\nIn **step 8**, we encountered `L`, so first thing we check if index of previous `right` is not `-1`. Here `right` is `3`, so we started making `R` from index 4 onwards  and simultaneously started making `L` from index `7` in backward direction. We will stop if left and right pointer arrives at same point. After than, we send right to -1 until we find another `R` in string.\\n\\n**C++ Code**\\n\\n```cpp\\nstring pushDominoes(string s) {\\n    int N = s.size(), right = -1;\\n    for (int i = 0; i < N; ++i) {\\n        if (s[i] == \\'L\\') {\\n            if (right == -1) { \\n                // Step 2\\n                for (int j = i - 1; j >= 0 && s[j] == \\'.\\'; --j) {\\n                  s[j] = \\'L\\';  \\n                } \\n            } else {\\n                // Step 8\\n                for (int j = right + 1, k = i - 1; j < k; ++j, --k) {\\n                    s[j] = \\'R\\';\\n                    s[k] = \\'L\\';\\n                } \\n                right = -1;\\n            }\\n        } else if (s[i] == \\'R\\') {\\n            if (right != -1) {\\n                for (int j = right + 1; j < i; ++j) s[j] = \\'R\\';\\n            }\\n            right = i;\\n        }\\n    }\\n    if (right != -1) {\\n        for (int j = right + 1; j < N; ++j) s[j] = \\'R\\';\\n    }\\n    return s;\\n}\\n```\\n\\n**Related Problems - Two Pointer**\\n[1. Two Sum ](https://leetcode.com/problems/two-sum/)\\n[2. Container With Most Water ](https://leetcode.com/problems/container-with-most-water/)\\n[3. 3Sum ](https://leetcode.com/problems/3sum/)\\n[4. Minimum Window Substring ](https://leetcode.com/problems/minimum-window-substring/)\\n[5. Remove Duplicates from Sorted List ](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\\n[6. Reorder List ](https://leetcode.com/problems/reorder-list/)\\n[7. Maximum Product Subarray ](https://leetcode.com/problems/maximum-product-subarray/)\\n[8. Palindrome Linked List ](https://leetcode.com/problems/palindrome-linked-list/)\\n[9. Subarray Product Less Than K ](https://leetcode.com/problems/subarray-product-less-than-k/)\\n[10. Backspace String Compare ](https://leetcode.com/problems/backspace-string-compare/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nstring pushDominoes(string s) {\\n    int N = s.size(), right = -1;\\n    for (int i = 0; i < N; ++i) {\\n        if (s[i] == \\'L\\') {\\n            if (right == -1) { \\n                // Step 2\\n                for (int j = i - 1; j >= 0 && s[j] == \\'.\\'; --j) {\\n                  s[j] = \\'L\\';  \\n                } \\n            } else {\\n                // Step 8\\n                for (int j = right + 1, k = i - 1; j < k; ++j, --k) {\\n                    s[j] = \\'R\\';\\n                    s[k] = \\'L\\';\\n                } \\n                right = -1;\\n            }\\n        } else if (s[i] == \\'R\\') {\\n            if (right != -1) {\\n                for (int j = right + 1; j < i; ++j) s[j] = \\'R\\';\\n            }\\n            right = i;\\n        }\\n    }\\n    if (right != -1) {\\n        for (int j = right + 1; j < N; ++j) s[j] = \\'R\\';\\n    }\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352339,
                "title": "c-simple-and-clean-easy-to-understand-o-n-solution-with-detailed-explanation",
                "content": "**Explanation:**\\nFirst, we iterate the dominoes twice.\\n1. From left to right, we want to check which dominoes might be falling to the right side.\\n\\tSo every time we see a \\'R\\' we know that the next dominoes will maybe fall right, so we save in the \\'right\\' vector the distance from the previous \\'R\\'. (Until we reach a \\'L\\').\\n2. From right to left, we do the same for the left side.\\nExample:\\nLet\\'s use the second example from the question - \".L.R...LR..L..\".\\nThe \\'right\\' array will look like this: [0,0,0,0,1,2,3,0,0,1,2,0,0,0]\\nThe \\'left\\' array will look like this: [1,0,0,0,3,2,1,0,0,2,1,0,0,0]\\n\\nNext step is to compare \\'right and \\'left\\'.\\nFor each i:\\n1. If both are 0 - we just copy what we had in dominoes.\\n2. If right[i] is 0 but left[i] is not, it means this domino falls to the left, and vice versa.\\n3. if they are both equal, which means that we have balance of the forces and we stay vertical.\\n4. If we have to different values in right[i] and left[i], we find the minimum which means that it\\'s closer.\\n\\n**If you like it, please upvote!\\nHave any comments? I\\'d love to hear!**\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132482,
                "title": "java-one-pass-in-place-13ms",
                "content": "Keep track of last seen \\'L\\' and \\'R\\' as indices (variables L and R).\\n1. If you see \\'R\\' and R > L, you have R....R, turn everything to \\'R\\'.\\n2. If you see \\'R\\' and R < L, you have L...R and you don\\'t need to do anything.\\n3. If you see \\'L\\' and L > R, you have L....L, turn everything to \\'L\\'.\\n4. if you see \\'L\\' and L < R, you have R....L, have to pointers from both sides, lo and hi, turn a[lo]=\\'R\\' and a[hi] = \\'L\\', increment lo, decrement hi, make sure you do nothing when lo=hi\\n5. Watch out for edge cases. Note i<=dominoes.length(), this is to deal with L.. Also note L and R are initialized to -1, not 0.\\n```java\\npublic String pushDominoes(String dominoes) {\\n        char[] a = dominoes.toCharArray();\\n        for (int i = 0, L = -1, R = -1; i <= dominoes.length(); i++)\\n            if (i == a.length || a[i] == \\'R\\') {\\n                if (R > L)//R..R, turn all to R\\n                    while (R < i)\\n                        a[R++] = \\'R\\';\\n                R = i;\\n            } else if (a[i] == \\'L\\')\\n                if (L > R || R == -1)//L..L, turn all to L\\n                    while (++L < i)\\n                        a[L] = \\'L\\';\\n                else { //R...L\\n                    L = i;\\n                    for (int lo = R + 1, hi = L - 1; lo < hi; ) {//one in the middle stays \\'.\\'\\n                        a[lo++] = \\'R\\';\\n                        a[hi--] = \\'L\\';\\n                    }\\n                }\\n        return new String(a);\\n    }",
                "solutionTags": [],
                "code": "Keep track of last seen \\'L\\' and \\'R\\' as indices (variables L and R).\\n1. If you see \\'R\\' and R > L, you have R....R, turn everything to \\'R\\'.\\n2. If you see \\'R\\' and R < L, you have L...R and you don\\'t need to do anything.\\n3. If you see \\'L\\' and L > R, you have L....L, turn everything to \\'L\\'.\\n4. if you see \\'L\\' and L < R, you have R....L, have to pointers from both sides, lo and hi, turn a[lo]=\\'R\\' and a[hi] = \\'L\\', increment lo, decrement hi, make sure you do nothing when lo=hi\\n5. Watch out for edge cases. Note i<=dominoes.length(), this is to deal with L.. Also note L and R are initialized to -1, not 0.\\n```java\\npublic String pushDominoes(String dominoes) {\\n        char[] a = dominoes.toCharArray();\\n        for (int i = 0, L = -1, R = -1; i <= dominoes.length(); i++)\\n            if (i == a.length || a[i] == \\'R\\') {\\n                if (R > L)//R..R, turn all to R\\n                    while (R < i)\\n                        a[R++] = \\'R\\';\\n                R = i;\\n            } else if (a[i] == \\'L\\')\\n                if (L > R || R == -1)//L..L, turn all to L\\n                    while (++L < i)\\n                        a[L] = \\'L\\';\\n                else { //R...L\\n                    L = i;\\n                    for (int lo = R + 1, hi = L - 1; lo < hi; ) {//one in the middle stays \\'.\\'\\n                        a[lo++] = \\'R\\';\\n                        a[hi--] = \\'L\\';\\n                    }\\n                }\\n        return new String(a);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2628891,
                "title": "python3-7-lines-with-explanation-t-m-100-98",
                "content": "```\\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```\\n\\n[https://leetcode.com/submissions/detail/664004716/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132330,
                "title": "funny-idea-but-passed-within-time-limit-python",
                "content": "I think the code is self-explanatory: just imaging what would happen in each turn.\\n```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        while(True):\\n            new = dominoes.replace(\\'R.L\\', \\'S\\')\\n            new = new.replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            if new == dominoes:\\n                break\\n            else:\\n                dominoes = new\\n        return dominoes.replace(\\'S\\', \\'R.L\\')\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        while(True):\\n            new = dominoes.replace(\\'R.L\\', \\'S\\')\\n            new = new.replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            if new == dominoes:\\n                break\\n            else:\\n                dominoes = new\\n        return dominoes.replace(\\'S\\', \\'R.L\\')\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 787845,
                "title": "o-n-c-easy-solution-90",
                "content": "This is a beautiful solution, which took me some time to think. This solution is very easy to understand with the O(N) solution. \\nI have used the 2-pointer technique to solve this question.\\n**Code Implementation:**\\nLet us consider the Eg. \" . L . R . . . L R . . L . . \"\\nSo, we will iterate the string twice,\\nIn first iteration, we iterate from left to right, Therefore, when we encounter \\'R\\',  that means it will make the next domino fall towards right (If it was a \\' . \\').\\nLet us use an array to store the count of dominoes which may fall towards right,\\nAfter first Iteration, the \\'r\\' array will be \\n .  L  .  R  .  .  .  L R  .  .  L  .  . \\n0  0 0 0  1 2 3 0 0  1 2 0  0 0\\n\\nNow, in our second iteration, we travel the string from right to left, therefore, we mark all the \\' . \\'s if they have a tendency to fall towards left\\n .  L  .  R  .  .  .  L R  .  .  L  .  . \\n1  0 0 0  3 2 1 0 0  2 1 0  0 0\\n\\nSo, now, we have 2 arrays and we can compare them to get the effective direction of fall.\\nThe conditions are, \\n* If a domino doesnt fall towards Left (l[i] == 0), but falls towards Right (r[i] > 0) then it has only one direction hence it will fall towards Right, and vice versa.\\n* If we notice that both l[i] && r[i] are zero then that means it was already assigned a direction which we can get from the input string.\\n* If l[i] && r[i] have same non zero value for L and R, that means it has it its neighbouring domino falling towards it, that means it won\\'t fall, hence we will assign \\' . \\' to this.\\n* And the last case is, if l[i] > r[i] and both are non zero, then we assign the direction R(minimum value of l[i] and r[i] get the direction.)\\n\\nHappy Coding!\\n\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int> l(n, 0), r(n, 0);\\n        char prev = \\'.\\';\\n        int count = 1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'R\\'){\\n                prev = \\'R\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'L\\') prev = \\'L\\';\\n            if(prev == \\'R\\' && s[i] == \\'.\\') r[i] = count++;\\n        }\\n        prev = \\'.\\';\\n        count = 1;\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i] == \\'L\\'){\\n                prev = \\'L\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'R\\') prev = \\'R\\';\\n            if(prev == \\'L\\' && s[i] == \\'.\\') l[i] = count++;\\n        }\\n        string ans = \"\";\\n        for(int i=0; i<n; i++){\\n            if(!l[i] && !r[i]) ans += s[i];\\n            else if(!l[i]) ans += \\'R\\';\\n            else if(!r[i]) ans += \\'L\\';\\n            else if(l[i] == r[i]) ans += \\'.\\';\\n            else if(l[i] > r[i]) ans += \\'R\\';\\n            else ans += \\'L\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); cout.tie(NULL);\\n    }\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int> l(n, 0), r(n, 0);\\n        char prev = \\'.\\';\\n        int count = 1;\\n        for(int i=0; i<n; i++){\\n            if(s[i] == \\'R\\'){\\n                prev = \\'R\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'L\\') prev = \\'L\\';\\n            if(prev == \\'R\\' && s[i] == \\'.\\') r[i] = count++;\\n        }\\n        prev = \\'.\\';\\n        count = 1;\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i] == \\'L\\'){\\n                prev = \\'L\\';\\n                count = 1;\\n                continue;\\n            }\\n            else if(s[i] == \\'R\\') prev = \\'R\\';\\n            if(prev == \\'L\\' && s[i] == \\'.\\') l[i] = count++;\\n        }\\n        string ans = \"\";\\n        for(int i=0; i<n; i++){\\n            if(!l[i] && !r[i]) ans += s[i];\\n            else if(!l[i]) ans += \\'R\\';\\n            else if(!r[i]) ans += \\'L\\';\\n            else if(l[i] == r[i]) ans += \\'.\\';\\n            else if(l[i] > r[i]) ans += \\'R\\';\\n            else ans += \\'L\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 132682,
                "title": "python-o-n-solution-go-through-array-twice",
                "content": "First pass, from left to right, only count distance of current index to previous \\'R\\'. Save all distance in dist array\\nSecond pass, from right to left, count distance of current index to previous \\'L\\'. If lDist < rDist (dist[i]), current cell should be \\'L\\', if lDist == rDist, current cell should be \\'.\\' \\n```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        lst = list(dominoes)\\n        dist = [0] * len(dominoes)\\n        rDist = None\\n        for i, val in enumerate(lst):\\n            if val == \\'R\\':\\n                rDist = 0\\n            elif val == \\'L\\':\\n                rDist = None\\n            elif rDist != None:\\n                rDist += 1\\n                dist[i] = rDist\\n                lst[i] = \\'R\\'\\n        lDist = None\\n        for i in range(len(lst) - 1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                lDist = 0\\n            elif dominoes[i] == \\'R\\':\\n                lDist = None\\n            elif lDist != None:\\n                lDist += 1\\n                if lDist < dist[i] or lst[i] == \\'.\\':\\n                    lst[i] = \\'L\\'\\n                elif lDist == dist[i]:\\n                    lst[i] = \\'.\\'\\n        return \\'\\'.join(lst)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def pushDominoes(self, dominoes):\\n        \"\"\"\\n        :type dominoes: str\\n        :rtype: str\\n        \"\"\"\\n        lst = list(dominoes)\\n        dist = [0] * len(dominoes)\\n        rDist = None\\n        for i, val in enumerate(lst):\\n            if val == \\'R\\':\\n                rDist = 0\\n            elif val == \\'L\\':\\n                rDist = None\\n            elif rDist != None:\\n                rDist += 1\\n                dist[i] = rDist\\n                lst[i] = \\'R\\'\\n        lDist = None\\n        for i in range(len(lst) - 1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                lDist = 0\\n            elif dominoes[i] == \\'R\\':\\n                lDist = None\\n            elif lDist != None:\\n                lDist += 1\\n                if lDist < dist[i] or lst[i] == \\'.\\':\\n                    lst[i] = \\'L\\'\\n                elif lDist == dist[i]:\\n                    lst[i] = \\'.\\'\\n        return \\'\\'.join(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352252,
                "title": "python-simulate-process-explained",
                "content": "Let us iterate through our string and keep two pointers: for positions where values not equal to `.` and the go one after another. Pointers `prev, i` can point to symbols `L` or `R` and we can have `4` different options:\\n\\n1. `L...L`, in this case, we need to fill everything with `L`\\n2. `R...R`, in this case, we need to fill everything with `R`\\n3. `L...R`, we need to keep it as it is\\n4. `R...L`, then we need to fill first half with `R` and second with `L`, handling odd and even cases.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space is `O(n)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def pushDominoes(self, D):\\n        D = \"L\" + D + \"R\"\\n        n, prev, ans = len(D), 0, \"\"\\n        for i in range(1, n):\\n            diff = i - prev - 1\\n            if D[i] == \".\": continue\\n            \\n            if D[i] == D[prev]:\\n                ans += D[i]*diff     \\n            elif D[i] == \"L\" and D[prev] == \"R\":\\n                m, d = divmod(diff, 2)\\n                ans += \"R\"*m + \".\"*d + \"L\"*m\\n            else:\\n                ans += \".\"*diff\\n                \\n            ans += D[i]\\n            prev = i\\n        \\n        return ans[:-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def pushDominoes(self, D):\\n        D = \"L\" + D + \"R\"\\n        n, prev, ans = len(D), 0, \"\"\\n        for i in range(1, n):\\n            diff = i - prev - 1\\n            if D[i] == \".\": continue\\n            \\n            if D[i] == D[prev]:\\n                ans += D[i]*diff     \\n            elif D[i] == \"L\" and D[prev] == \"R\":\\n                m, d = divmod(diff, 2)\\n                ans += \"R\"*m + \".\"*d + \"L\"*m\\n            else:\\n                ans += \".\"*diff\\n                \\n            ans += D[i]\\n            prev = i\\n        \\n        return ans[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347029,
                "title": "c-o-n-easy-to-write-may-the-force-be-with-you",
                "content": "We just need to consider the two closest non-period characters. \\n`left_r_dis[i]` is the smallest distance between `dominoes[i]` and its left `R`.\\n`right_l_dis[i]` is the smallest distance between `dominoes[i]` and its right `L`.\\n```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left_r_dis(n + 1, 0);\\n        vector<int> right_l_dis(n + 1, 0);\\n        int r_pos = n + 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (dominoes[i] == \\'R\\') {\\n                r_pos = i;\\n            }\\n            else if (dominoes[i] == \\'L\\') {\\n                r_pos = n + 1;\\n            }\\n            left_r_dis[i] = r_pos == n + 1 ? n + 1 : i - r_pos;\\n        }\\n        int l_pos = -1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (dominoes[i] == \\'L\\') {\\n                l_pos = i;\\n            }\\n            else if (dominoes[i] == \\'R\\') {\\n                l_pos = -1;\\n            }\\n            right_l_dis[i] = l_pos == -1 ? n + 1 : l_pos - i;\\n        }\\n        \\n        string result = dominoes;\\n        for (int i = 0; i < n; ++i) {\\n            if (left_r_dis[i] < right_l_dis[i]) result[i] = \\'R\\';\\n            else if (left_r_dis[i] > right_l_dis[i]) result[i] = \\'L\\';\\n            //else\\n        }\\n\\n        return result;\\n    } \\n};\\n```\\n\\n// It is quite like the problem [Leetcode] container with most water.\\nThey are all first consider one element in the array.",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left_r_dis(n + 1, 0);\\n        vector<int> right_l_dis(n + 1, 0);\\n        int r_pos = n + 1;\\n        for (int i = 0; i < n; ++i) {\\n            if (dominoes[i] == \\'R\\') {\\n                r_pos = i;\\n            }\\n            else if (dominoes[i] == \\'L\\') {\\n                r_pos = n + 1;\\n            }\\n            left_r_dis[i] = r_pos == n + 1 ? n + 1 : i - r_pos;\\n        }\\n        int l_pos = -1;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (dominoes[i] == \\'L\\') {\\n                l_pos = i;\\n            }\\n            else if (dominoes[i] == \\'R\\') {\\n                l_pos = -1;\\n            }\\n            right_l_dis[i] = l_pos == -1 ? n + 1 : l_pos - i;\\n        }\\n        \\n        string result = dominoes;\\n        for (int i = 0; i < n; ++i) {\\n            if (left_r_dis[i] < right_l_dis[i]) result[i] = \\'R\\';\\n            else if (left_r_dis[i] > right_l_dis[i]) result[i] = \\'L\\';\\n            //else\\n        }\\n\\n        return result;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630335,
                "title": "4-cases-stupidly-simple",
                "content": "**So, there are 4 cases:**\\n* **LL:** everything in between will be \\'L\\' |  **<-L . . . <-L**\\n* **RR:** everything in between will be \\'R\\' |  **R-> . . . R->** \\n* **LR:** everything in between will be \\'.\\' | **<-L . . . R->**\\n* **RL:**  they will `meet in the middle` |  **R-> . . . <-L**\\n*[ in case of RL, if the count of \\'.\\'s was odd, the middle element will be `\\'.\\'` ]*\\n\\n**Code:**\\n\\n    StringBuilder sb = new StringBuilder();\\n    public String pushDominoes(String dominoes) {\\n        int count = 0; char last = \\'L\\';\\n        for(char ch : dominoes.toCharArray()){\\n            if(ch!=\\'.\\'){\\n\\t\\t\\t\\tif(ch==last) add(count, last);             // case LL & RR\\n\\t\\t\\t\\telse if(last==\\'L\\') add(count, \\'.\\');  // case LR\\n\\t\\t\\t\\telse {                                     // case RL\\n\\t\\t\\t\\t\\tadd(count/2, \\'R\\');\\n\\t\\t\\t\\t\\tif(count%2!=0) sb.append(\\'.\\');\\n\\t\\t\\t\\t\\tadd(count/2, \\'L\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t\\tlast = ch; count = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse count++;\\n        }\\n        add(count, last==\\'R\\'?\\'R\\':\\'.\\');  // for trailing \\'.\\'s\\n        return sb.toString();\\n    }\\n    \\n    void add(int count, char ch){  // append \\'ch\\' to sb \\'count\\' times\\n        for(int i=0; i<count; i++) sb.append(ch);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**So, there are 4 cases:**\\n* **LL:** everything in between will be \\'L\\' |  **<-L . . . <-L**\\n* **RR:** everything in between will be \\'R\\' |  **R-> . . . R->** \\n* **LR:** everything in between will be \\'.\\' | **<-L . . . R->**\\n* **RL:**  they will `meet in the middle` |  **R-> . . . <-L**\\n*[ in case of RL, if the count of \\'.\\'s was odd, the middle element will be `\\'.\\'` ]*\\n\\n**Code:**\\n\\n    StringBuilder sb = new StringBuilder();\\n    public String pushDominoes(String dominoes) {\\n        int count = 0; char last = \\'L\\';\\n        for(char ch : dominoes.toCharArray()){\\n            if(ch!=\\'.\\'){\\n\\t\\t\\t\\tif(ch==last) add(count, last);             // case LL & RR\\n\\t\\t\\t\\telse if(last==\\'L\\') add(count, \\'.\\');  // case LR\\n\\t\\t\\t\\telse {                                     // case RL\\n\\t\\t\\t\\t\\tadd(count/2, \\'R\\');\\n\\t\\t\\t\\t\\tif(count%2!=0) sb.append(\\'.\\');\\n\\t\\t\\t\\t\\tadd(count/2, \\'L\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsb.append(ch);\\n\\t\\t\\t\\tlast = ch; count = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse count++;\\n        }\\n        add(count, last==\\'R\\'?\\'R\\':\\'.\\');  // for trailing \\'.\\'s\\n        return sb.toString();\\n    }\\n    \\n    void add(int count, char ch){  // append \\'ch\\' to sb \\'count\\' times\\n        for(int i=0; i<count; i++) sb.append(ch);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1352325,
                "title": "push-dominoes-2-approaches-easy-understanding",
                "content": "# Approach #1: Adjacent Symbols\\nBetween *every group* of vertical dominoes ( `\\'.\\'` ), we have up to two non-vertical dominoes bordering this group. Since additional dominoes outside this group do not affect the outcome, we can analyze these situations individually: *there are 9 of them* (as the border could be empty). \\nAnd, if we border the dominoes by `\\'L\\'` and `\\'R\\'`, there are only 4 cases. \\nWe\\'ll write new letters between these symbols depending on each case.\\n\\n**Algorithm**\\n* If we have say `\"A....B\"`, where A = B, then we should write `\"AAAAAA\"`.\\n* If we have `\"R....L\"`, then we will write `\"RRRLLL\"`, or `\"RRR.LLL\"` if we have an odd number of dots. If the initial symbols are at positions `i` and `j`, we can check our distance `k-i` and `j-k` to decide at position k whether to write `\\'L\\'`, `\\'R\\'`, or `\\'.\\'`.\\n* If we have `\"L....R\"` we don\\'t do anything. We can `skip` this case.\\n\\n**Solution In Java** *(Let Me Know in the comments if you want the code in C++)*\\n```\\n public String pushDominoes(String dominoes) {\\n        int N = dominoes.length();\\n        int[] indexes = new int[N+2];\\n        char[] symbols = new char[N+2];\\n        int len = 1;\\n        indexes[0] = -1;\\n        symbols[0] = \\'L\\';\\n\\n        for (int i = 0; i < N; ++i)\\n            if (dominoes.charAt(i) != \\'.\\') {\\n                indexes[len] = i;\\n                symbols[len++] = dominoes.charAt(i);\\n            }\\n\\n        indexes[len] = N;\\n        symbols[len++] = \\'R\\';\\n\\n        char[] ans = dominoes.toCharArray();\\n        for (int index = 0; index < len - 1; ++index) {\\n            int i = indexes[index], j = indexes[index+1];\\n            char x = symbols[index], y = symbols[index+1];\\n            char write;\\n            if (x == y) {\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = x;\\n            } else if (x > y) { // RL\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = k-i == j-k ? \\'.\\' : k-i < j-k ? \\'R\\' : \\'L\\';\\n            }\\n        }\\n\\n        return String.valueOf(ans);\\n    }\\n```\\n\\n# Approach #2: Calculate Force\\nWe can calculate the net force applied on every domino. The forces we care about are how close a domino is to a leftward `R\\'`, and to a rightward `\\'L\\'`: the closer we are, the stronger the force.\\n\\n**Algorithm**\\n1. Scanning from left to right, our force decays by 1 every iteration, and resets to `N` if we meet an `\\'R\\'`, so that `force[i]` is *higher* (than `force[j]`) if and only if `dominoes[i]` is closer (looking leftward) to `\\'R\\'` (than `dominoes[j]`).\\n2. Similarly, scanning from right to left, we can find the force going rightward (closeness to `\\'L\\'`).\\n3. For some domino `answer[i]`, if the forces are equal, then the answer is `\\'.\\'`. Otherwise, the answer is implied by whichever force is stronger.\\n\\n**Solution In Java** *(Let Me Know in the comments if you want the code in C++)*\\n```\\npublic String pushDominoes(String S) {\\n        char[] A = S.toCharArray();\\n        int N = A.length;\\n        int[] forces = new int[N];\\n\\n        int force = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (A[i] == \\'R\\') force = N;\\n            else if (A[i] == \\'L\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n\\n        force = 0;\\n        for (int i = N-1; i >= 0; --i) {\\n            if (A[i] == \\'L\\') force = N;\\n            else if (A[i] == \\'R\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int f: forces)\\n            ans.append(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        return ans.toString();\\n    }\\n```\\n\\n**Solution In C++**\\n```\\nclass Solution {\\n\\tpublic: \\n\\t\\tString pushDominoes(String S) {\\n\\t\\tstring res = \"\" ;\\n\\t\\tint n = S.length( ) , f = 0 ;\\n\\t\\tint ans[n] ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans[i] = 0 ;\\n        }\\n\\t\\tfor(int i=0;i < n;i++)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = n ;\\n\\t\\t\\telse if(S[i]==\\'L\\') \\n\\t\\t\\t\\tf = 0 ;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1)>0 ? (f - 1) : 0 ;\\n\\t\\t\\tans[i] += f ;\\n\\t\\t}\\n\\t\\tf = 0 ;\\n\\t\\tfor(int i = n - 1 ; i >= 0 ; i--)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'L\\')\\n\\t\\t\\t\\tf = n;\\n\\t\\t\\telse if(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1) > 0 ? (f-1) : 0 ;\\n\\t\\t\\tans[i] -= f ;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0 ; i < n ; i++) \\n\\t\\t\\tres += ans[i] < 0 ? \"L\" : ans[i] > 0 ?\"R\":\".\";\\n\\t\\treturn res ;\\n}\\n```\\nDo let me know any other approaches that come to your mind!",
                "solutionTags": [],
                "code": "```\\n public String pushDominoes(String dominoes) {\\n        int N = dominoes.length();\\n        int[] indexes = new int[N+2];\\n        char[] symbols = new char[N+2];\\n        int len = 1;\\n        indexes[0] = -1;\\n        symbols[0] = \\'L\\';\\n\\n        for (int i = 0; i < N; ++i)\\n            if (dominoes.charAt(i) != \\'.\\') {\\n                indexes[len] = i;\\n                symbols[len++] = dominoes.charAt(i);\\n            }\\n\\n        indexes[len] = N;\\n        symbols[len++] = \\'R\\';\\n\\n        char[] ans = dominoes.toCharArray();\\n        for (int index = 0; index < len - 1; ++index) {\\n            int i = indexes[index], j = indexes[index+1];\\n            char x = symbols[index], y = symbols[index+1];\\n            char write;\\n            if (x == y) {\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = x;\\n            } else if (x > y) { // RL\\n                for (int k = i+1; k < j; ++k)\\n                    ans[k] = k-i == j-k ? \\'.\\' : k-i < j-k ? \\'R\\' : \\'L\\';\\n            }\\n        }\\n\\n        return String.valueOf(ans);\\n    }\\n```\n```\\npublic String pushDominoes(String S) {\\n        char[] A = S.toCharArray();\\n        int N = A.length;\\n        int[] forces = new int[N];\\n\\n        int force = 0;\\n        for (int i = 0; i < N; ++i) {\\n            if (A[i] == \\'R\\') force = N;\\n            else if (A[i] == \\'L\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n\\n        force = 0;\\n        for (int i = N-1; i >= 0; --i) {\\n            if (A[i] == \\'L\\') force = N;\\n            else if (A[i] == \\'R\\') force = 0;\\n            else force = Math.max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int f: forces)\\n            ans.append(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        return ans.toString();\\n    }\\n```\n```\\nclass Solution {\\n\\tpublic: \\n\\t\\tString pushDominoes(String S) {\\n\\t\\tstring res = \"\" ;\\n\\t\\tint n = S.length( ) , f = 0 ;\\n\\t\\tint ans[n] ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            ans[i] = 0 ;\\n        }\\n\\t\\tfor(int i=0;i < n;i++)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = n ;\\n\\t\\t\\telse if(S[i]==\\'L\\') \\n\\t\\t\\t\\tf = 0 ;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1)>0 ? (f - 1) : 0 ;\\n\\t\\t\\tans[i] += f ;\\n\\t\\t}\\n\\t\\tf = 0 ;\\n\\t\\tfor(int i = n - 1 ; i >= 0 ; i--)\\n\\t\\t{\\n\\t\\t\\tif(S[i] == \\'L\\')\\n\\t\\t\\t\\tf = n;\\n\\t\\t\\telse if(S[i] == \\'R\\') \\n\\t\\t\\t\\tf = 0;\\n\\t\\t\\telse \\n\\t\\t\\t\\tf = (f-1) > 0 ? (f-1) : 0 ;\\n\\t\\t\\tans[i] -= f ;\\n\\t\\t}\\n\\n\\t\\tfor(int i = 0 ; i < n ; i++) \\n\\t\\t\\tres += ans[i] < 0 ? \"L\" : ans[i] > 0 ?\"R\":\".\";\\n\\t\\treturn res ;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119158,
                "title": "java-easy-solution",
                "content": "**Idea:**\\nusing two pointer left and right\\nthere are **4 Possible Cases** that left and right are Pointing to : \\n1.  **L  and. L** (all in between dominos will fall on left side) So mark all dominos to L from left to right \\n2. **L and R** (left pointer will fall to left and right to right so dominos in between will be as they were before) \\n3.  **R and L** (from left side dominos will start falling to right and from right side dominos will fall down to left )\\n4.  **R and R** (all in b/w dominos will fall in right side) So mark all dominos to R from left to right\\n\\nyou have someIdea now . Code will give you more clearity.\\n\\n**Complexity :**\\n```\\nTime : O(n)\\nSpace: O(n)\\n```\\n\\n```\\n    public String pushDominoes(String dominoes) {\\n        \\n        char[] arr=new char[dominoes.length()+2];\\n        arr[0]=\\'L\\';\\n        arr[arr.length-1]=\\'R\\';\\n        for(int i=1;i<arr.length-1;i++){\\n            arr[i]=dominoes.charAt(i-1);\\n        }\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(j!=arr.length){\\n            while(arr[j]==\\'.\\') j++;\\n            \\n            if(arr[i]==\\'L\\' && arr[j]==\\'L\\'){\\n                while(i!=j){\\n                    arr[i]=\\'L\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'L\\' && arr[j]==\\'R\\'){\\n                 i=j;\\n                 j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'R\\'){\\n                while(i!=j){\\n                    arr[i]=\\'R\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'L\\'){\\n                 int temp1=i+1;\\n                 int temp2=j-1;\\n                 while(temp1<temp2){\\n                     arr[temp1]=\\'R\\';\\n                     arr[temp2]=\\'L\\';\\n                     temp1++;\\n                     temp2--;\\n                 }\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(i=1;i<arr.length-1;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n```\\nPlease **UPVOTE** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nTime : O(n)\\nSpace: O(n)\\n```\n```\\n    public String pushDominoes(String dominoes) {\\n        \\n        char[] arr=new char[dominoes.length()+2];\\n        arr[0]=\\'L\\';\\n        arr[arr.length-1]=\\'R\\';\\n        for(int i=1;i<arr.length-1;i++){\\n            arr[i]=dominoes.charAt(i-1);\\n        }\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(j!=arr.length){\\n            while(arr[j]==\\'.\\') j++;\\n            \\n            if(arr[i]==\\'L\\' && arr[j]==\\'L\\'){\\n                while(i!=j){\\n                    arr[i]=\\'L\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'L\\' && arr[j]==\\'R\\'){\\n                 i=j;\\n                 j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'R\\'){\\n                while(i!=j){\\n                    arr[i]=\\'R\\';\\n                    i++;\\n                }\\n                j++;\\n            }else if(arr[i]==\\'R\\' && arr[j]==\\'L\\'){\\n                 int temp1=i+1;\\n                 int temp2=j-1;\\n                 while(temp1<temp2){\\n                     arr[temp1]=\\'R\\';\\n                     arr[temp2]=\\'L\\';\\n                     temp1++;\\n                     temp2--;\\n                 }\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        StringBuilder sb=new StringBuilder(\"\");\\n        for(i=1;i<arr.length-1;i++){\\n            sb.append(arr[i]);\\n        }\\n\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132520,
                "title": "java-one-pass-no-extra-storage-detailed-explanation",
                "content": "    class Solution {\\n        public String pushDominoes(String dominoes) {\\n            // algorithm 2018/05/20: playing with a few samples, it is easy to find the rule\\n            // if there is NO dot (meaning every domino is pushed), then the final state is the initial state\\n            //   for example, all \"LLL\" => \"LLL\", all \"RRR\" => \"RRR\",\\n            //                mixed \"LLLRR\" => \"LLLRR\" (falling domino having no effect on already-fallen domino)\\n            // if there is only ONE dot, we have a few possibilities:\\n            //   \"L.R\" => \"L.R\", \"R.L\" => \"R.L\" (center-one standing), \"L.L\" => \"LLL\", \"R.R\" => \"RRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L..R\" => \"L..R\", \"R..L\" => \"RRLL\" (center-one standing), \"L..L\" => \"LLLL\", \"R..R\" => \"RRRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L...R\" => \"L...R\", \"R...L\" => \"RR.LL\" (center-one standing), \"L...L\" => \"LLLLL\", \"R...R\" => \"RRRRR\"\\n            // Therefore the rule is:\\n            // for each region of dots (a substring \"P....Q\"), check its left and right\\n            //   if left is \"L\" and right is \"R\", the substring remains as is;\\n            //   if left is \"R\" and right is \"L\", the substring is converted into either \"RRRLLL\" or \"RR.LL\"\\n            //   if left and right are the same, the substring is converted into either \"RRRRR\" or \"LLLLL\"\\n\\n            assert (null != dominoes);\\n            // place a sentinel \"L\" + dominoes + \"R\", as this does not impact the final outcome\\n            dominoes = \"L\" + dominoes + \"R\";\\n\\n            // stringbuilder to hold the result\\n            StringBuilder builder = new StringBuilder();\\n\\n            // scan the string and split it into multiple groups, |groupStart, groupEnd| ... |groupStart, groupEnd| ...\\n            // \\'groupStart\\' and \\'groupEnd\\' designates a number of chars solely with \\'L\\' or \\'R\\'\\n            int strLen = dominoes.length();\\n            int groupStart = 0;\\n            int index = 0;      //\\n            while (index < strLen) {\\n                while (index < strLen && \\'.\\' != dominoes.charAt(index)) {\\n                    index++;\\n                }\\n                int groupEnd = index - 1;\\n                char leftCharForDotRegion = dominoes.charAt(groupEnd);\\n\\n                // copy this part of susbtring as is (no DOT in the middle)\\n                builder.append(dominoes.substring(groupStart, groupEnd + 1));\\n\\n                // either we reach the end of the string or we find a dot\\n                if (index == strLen) {\\n                    // final section with only \\'L\\'s and \\'R\\'s\\n                    break;\\n                }\\n\\n                // now we meet a DOT; scan until we meet the next \"L\" or \"R\"\\n                while (\\'.\\' == dominoes.charAt(index)) {\\n                    index++;        // we have the sentinel \"R\", so this will not reach the end of string\\n                }\\n                char rightCharForDotRegion = dominoes.charAt(index);\\n\\n                if (leftCharForDotRegion == rightCharForDotRegion) {\\n                    // replace dot with the same char\\n                    for (int count = 0; count < index - groupEnd - 1; count++) {\\n                        builder.append(leftCharForDotRegion);\\n                    }\\n                } else if (\\'L\\' == leftCharForDotRegion) {\\n                    // rightChar is \\'R\\', then keep the dots as it\\n                    for (int count = 0; count < index - groupEnd - 1; count++) {\\n                        builder.append(\\'.\\');\\n                    }\\n                } else {\\n                    // leftChar is \\'R\\' and right char is \\'L\\', we either have a SINGLE dot in the middle, or not dot\\n                    int countDots = index - groupEnd - 1;\\n                    // half R\\n                    for (int count = 0; count < countDots / 2; count++) {\\n                        builder.append(\\'R\\');\\n                    }\\n                    if (1 == countDots % 2) {\\n                        // center dot\\n                        builder.append(\\'.\\');\\n                    }\\n                    // half L\\n                    for (int count = 0; count < countDots / 2; count++) {\\n                        builder.append(\\'L\\');\\n                    }\\n                }\\n\\n                // now scan next group\\n                groupStart = index;\\n\\n            }\\n\\n            String result = builder.toString();\\n            return result.substring(1, strLen - 1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String pushDominoes(String dominoes) {\\n            // algorithm 2018/05/20: playing with a few samples, it is easy to find the rule\\n            // if there is NO dot (meaning every domino is pushed), then the final state is the initial state\\n            //   for example, all \"LLL\" => \"LLL\", all \"RRR\" => \"RRR\",\\n            //                mixed \"LLLRR\" => \"LLLRR\" (falling domino having no effect on already-fallen domino)\\n            // if there is only ONE dot, we have a few possibilities:\\n            //   \"L.R\" => \"L.R\", \"R.L\" => \"R.L\" (center-one standing), \"L.L\" => \"LLL\", \"R.R\" => \"RRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L..R\" => \"L..R\", \"R..L\" => \"RRLL\" (center-one standing), \"L..L\" => \"LLLL\", \"R..R\" => \"RRRR\"\\n            // if there are TWO dots, we have the following possibilities:\\n            //   \"L...R\" => \"L...R\", \"R...L\" => \"RR.LL\" (center-one standing), \"L...L\" => \"LLLLL\", \"R...R\" => \"RRRRR\"\\n            // Therefore the rule is:\\n            // for each region of dots (a substring \"P....Q\"), check its left and right\\n            //   if left is \"L\" and right is \"R\", the substring remains as is;\\n            //   if left is \"R\" and right is \"L\", the substring is converted into either \"RRRLLL\" or \"RR.LL\"\\n            //   if left and right are the same, the substring is converted into either \"RRRRR\" or \"LLLLL\"\\n\\n            assert (null != dominoes);\\n            // place a sentinel \"L\" + dominoes + \"R\", as this does not impact the final outcome\\n            dominoes = \"L\" + dominoes + \"R\";\\n\\n            // stringbuilder to hold the result\\n            StringBuilder builder = new StringBuilder();\\n\\n            // scan the string and split it into multiple groups, |groupStart, groupEnd| ... |groupStart, groupEnd| ...\\n            // \\'groupStart\\' and \\'groupEnd\\' designates a number of chars solely with \\'L\\' or \\'R\\'\\n            int strLen = dominoes.length();\\n            int groupStart = 0;\\n            int index = 0;      //\\n            while (index < strLen) {\\n                while (index < strLen && \\'.\\' != dominoes.charAt(index)) {\\n                    index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2628946,
                "title": "java-easy-solution-with-comments-89-faster-code-stringbuilder",
                "content": "\\t\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629157,
                "title": "c-2-pointers-short-simple",
                "content": "***DO UPVOTE IF IT HELPS !!!!!!***\\t\\n\\n\\t\\n\\tstring pushDominoes(string s) {\\n        \\n        int n = s.size();\\n        int r=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'L\\'){                                 \\n                if(r==-1){                                  //s[i]==\\'L\\' && r==-1\\n                    for(int j=i-1;j>=0 && s[j]==\\'.\\';j--){   //update all dominoes to left beginning from j=i-1 to j>=0\\n                        s[j]=\\'L\\';\\n                    }\\n                }\\n                else{                                      //s[i]==\\'L\\' && r!=-1\\n                    for(int j=r+1,k=i-1;j<k;j++,k--){      //update all dominoes lying between k=r+1 and j=i-1\\n                        s[j]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                    }\\n                    r=-1;        //important step update r = -1\\n                }\\n            }\\n            else if(s[i]==\\'R\\'){                            //s[i]==\\'R\\' && r!=-1\\n                if(r!=-1){                                 //update all dominoes lying right to j=r+1 till i\\n                    for(int j=r+1;j<i;j++){\\n                        s[j]=\\'R\\';\\n                    }\\n                }\\n                r=i;             //update r since r is found\\n            }\\n        }\\n        \\n        if(r!=-1){                     //if you have traversed complete string and r!=-1, then update all dominoes\\n            for(int j=r+1;j<n;j++) {   //beginning from r+1 to n to \\'R\\'\\n                s[j]=\\'R\\';\\n            }\\n        }\\n        \\n        return s;   \\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!!***\\t\\n\\n\\t\\n\\tstring pushDominoes(string s) {\\n        \\n        int n = s.size();\\n        int r=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(s[i]==\\'L\\'){                                 \\n                if(r==-1){                                  //s[i]==\\'L\\' && r==-1\\n                    for(int j=i-1;j>=0 && s[j]==\\'.\\';j--){   //update all dominoes to left beginning from j=i-1 to j>=0\\n                        s[j]=\\'L\\';\\n                    }\\n                }\\n                else{                                      //s[i]==\\'L\\' && r!=-1\\n                    for(int j=r+1,k=i-1;j<k;j++,k--){      //update all dominoes lying between k=r+1 and j=i-1\\n                        s[j]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                    }\\n                    r=-1;        //important step update r = -1\\n                }\\n            }\\n            else if(s[i]==\\'R\\'){                            //s[i]==\\'R\\' && r!=-1\\n                if(r!=-1){                                 //update all dominoes lying right to j=r+1 till i\\n                    for(int j=r+1;j<i;j++){\\n                        s[j]=\\'R\\';\\n                    }\\n                }\\n                r=i;             //update r since r is found\\n            }\\n        }\\n        \\n        if(r!=-1){                     //if you have traversed complete string and r!=-1, then update all dominoes\\n            for(int j=r+1;j<n;j++) {   //beginning from r+1 to n to \\'R\\'\\n                s[j]=\\'R\\';\\n            }\\n        }\\n        \\n        return s;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1352251,
                "title": "python-java-one-pass-time-complexity-of-o-n-in-constant-space",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = \"\" #Used to store final result.\\n        i=0\\n        while(i<len(dominoes)):\\n            #if charAt(i) is \\'L\\' or \\'R\\', just place append the same in res.\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                res+=dominoes[i]\\n                i+=1\\n            else:# dominoes[i]==\\'.\\':\\n                #if charAt(i) is \\'.\\' and previous is Right pushed then, we have to count the\\n\\t\\t\\t\\t#number of \\'.\\' (dots) and see what is at the other end of dot. \\n                if i>0 and dominoes[i-1]==\\'R\\':\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count of number of \\'.\\'(dots)\\n                    #if the other end is last index or if dominoe at other end is right pushed then\\n\\t\\t\\t\\t\\t#there is nothing to cancel the right pushed force of first dominoes and so all\\n\\t\\t\\t\\t\\t#\\'.\\'(dots) will be rightly pushed\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'R\\'*countDots\\n                    else:#if other end is \\'L\\' i.e, left pushed\\n                    #first half will be rightly pushed and second half is leftly pushed and\\n\\t\\t\\t\\t\\t#if count is odd, then force on middle one gets cancelled\\n                        res+=\\'R\\'*(countDots//2) + \\'.\\'*(countDots-2*(countDots//2)) + \\'L\\'*(countDots//2)\\n                    i=j\\n                else: #if the start of string is \\'.\\'(dot) or previous is not rightly pushed\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count the number of dots\\n                    \\n                    #if the other end is last index or if dominoe at other end is right pushed\\n\\t\\t\\t\\t\\t#then there is no force at all on stating indexes. So, all will remains \\'.\\'\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'.\\'*countDots\\n                    #if other end is left pushed, the all the starting will be pushed left\\n                    else:\\n                        res+=\\'L\\'*countDots\\n                    i=j\\n        \\n        return res\\n```\\n\\n\\n\\nJava solution of above Code:\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        String res = \"\", intermediate=\"\", intermediateDots=\"\";\\n        int i = 0, j;\\n        int length = dominoes.length();\\n        while(i<length){\\n            char ch = dominoes.charAt(i);\\n            if (ch==\\'L\\' || ch==\\'R\\')\\n            {   res += Character.toString(ch);\\n                i++;}\\n            else{\\n                if(i>0 && dominoes.charAt(i-1)==\\'R\\'){\\n                    j=i;\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediate+=\"R\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediate;\\n                    else\\n                        res += \"R\".repeat(count/2) + \".\".repeat(count-2*(count/2)) + \"L\".repeat(count/2);\\n                    i=j;\\n                }\\n                else{\\n                    j=i;\\n                    intermediateDots=\"\";\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediateDots+=\".\";\\n                        intermediate+=\"L\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediateDots;\\n                    else\\n                        res += intermediate;\\n                    i=j;\\n                }\\n            }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = \"\" #Used to store final result.\\n        i=0\\n        while(i<len(dominoes)):\\n            #if charAt(i) is \\'L\\' or \\'R\\', just place append the same in res.\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                res+=dominoes[i]\\n                i+=1\\n            else:# dominoes[i]==\\'.\\':\\n                #if charAt(i) is \\'.\\' and previous is Right pushed then, we have to count the\\n\\t\\t\\t\\t#number of \\'.\\' (dots) and see what is at the other end of dot. \\n                if i>0 and dominoes[i-1]==\\'R\\':\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count of number of \\'.\\'(dots)\\n                    #if the other end is last index or if dominoe at other end is right pushed then\\n\\t\\t\\t\\t\\t#there is nothing to cancel the right pushed force of first dominoes and so all\\n\\t\\t\\t\\t\\t#\\'.\\'(dots) will be rightly pushed\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'R\\'*countDots\\n                    else:#if other end is \\'L\\' i.e, left pushed\\n                    #first half will be rightly pushed and second half is leftly pushed and\\n\\t\\t\\t\\t\\t#if count is odd, then force on middle one gets cancelled\\n                        res+=\\'R\\'*(countDots//2) + \\'.\\'*(countDots-2*(countDots//2)) + \\'L\\'*(countDots//2)\\n                    i=j\\n                else: #if the start of string is \\'.\\'(dot) or previous is not rightly pushed\\n                    j=i\\n                    while(j<len(dominoes) and dominoes[j]==\\'.\\'):\\n                        j+=1\\n                    countDots = (j-i) #count the number of dots\\n                    \\n                    #if the other end is last index or if dominoe at other end is right pushed\\n\\t\\t\\t\\t\\t#then there is no force at all on stating indexes. So, all will remains \\'.\\'\\n                    if j==len(dominoes) or dominoes[j]==\\'R\\':\\n                        res+=\\'.\\'*countDots\\n                    #if other end is left pushed, the all the starting will be pushed left\\n                    else:\\n                        res+=\\'L\\'*countDots\\n                    i=j\\n        \\n        return res\\n```\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        String res = \"\", intermediate=\"\", intermediateDots=\"\";\\n        int i = 0, j;\\n        int length = dominoes.length();\\n        while(i<length){\\n            char ch = dominoes.charAt(i);\\n            if (ch==\\'L\\' || ch==\\'R\\')\\n            {   res += Character.toString(ch);\\n                i++;}\\n            else{\\n                if(i>0 && dominoes.charAt(i-1)==\\'R\\'){\\n                    j=i;\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediate+=\"R\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediate;\\n                    else\\n                        res += \"R\".repeat(count/2) + \".\".repeat(count-2*(count/2)) + \"L\".repeat(count/2);\\n                    i=j;\\n                }\\n                else{\\n                    j=i;\\n                    intermediateDots=\"\";\\n                    intermediate=\"\";\\n                    while(j<length && dominoes.charAt(j)==\\'.\\'){\\n                        intermediateDots+=\".\";\\n                        intermediate+=\"L\";\\n                        j+=1;\\n                    }\\n                    int count = j-i;\\n                    if (j==length || dominoes.charAt(j)==\\'R\\')\\n                        res += intermediateDots;\\n                    else\\n                        res += intermediate;\\n                    i=j;\\n                }\\n            }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858300,
                "title": "javascript-2-pointers",
                "content": "```\\nvar pushDominoes = function(dominoes) {\\n    let l=0, r=1;\\n    const arr = (\"L\"+dominoes+\"R\").split(\"\");\\n    while(l<arr.length-1){\\n        while(arr[r]==\\'.\\') \\n            r++;\\n        if(arr[l]==arr[r]) \\n            for(let i=l+1; i<r; i++) \\n                arr[i]=arr[l];\\n        if(arr[l]>arr[r]) \\n            for(let i=1; i<=(r-l-1)/2; i++){\\n                arr[l+i] = \\'R\\';\\n                arr[r-i] = \\'L\\';\\n            }   \\n        l=r++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pushDominoes = function(dominoes) {\\n    let l=0, r=1;\\n    const arr = (\"L\"+dominoes+\"R\").split(\"\");\\n    while(l<arr.length-1){\\n        while(arr[r]==\\'.\\') \\n            r++;\\n        if(arr[l]==arr[r]) \\n            for(let i=l+1; i<r; i++) \\n                arr[i]=arr[l];\\n        if(arr[l]>arr[r]) \\n            for(let i=1; i<=(r-l-1)/2; i++){\\n                arr[l+i] = \\'R\\';\\n                arr[r-i] = \\'L\\';\\n            }   \\n        l=r++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466596,
                "title": "intuitive-python-solution-sliding-window-0-n",
                "content": "A lot of the other python solutions are a bit hard to wrap your mind around. This one felt fairly intuitive, it has a few parts:\\n\\nwe will use a sliding window approach, where we attempt to create a window that needs to be \"filled\" with appropriate values. Some examples of these windows are:\\n\"L...R\" -> \"L...R\"\\n\"R...L\" -> \"RR.LL\"\\n\"....L\" -> \"LLLLL\"\\n\"R....\" -> \"RRRRR\"\\n\\nWith those examples in mind, there are really only a few cases we need to deal with. They are:\\n\\n\\t1. we create a window that needs to be filled. If this is the case, there are a few things to consider:\\n\\t\\t- the window is of the form \"R...L\" -> fill while LO and HI pointers move toward each other\\n\\t\\t- the window is of the form \"....L\" -> fill totally with L\\n\\t\\t- the window is of the form \"R....\" -> fill totally with R\\n\\n\\t2. we create a window that has no change. (EX. \"L....R\", or \"....R\", or \"L....\")\\n\\n\\ndefining a do_fill function to fill our dominoes array keeps the main method concise. Also, LO and HI values are copied into the do_fill function, so we don\\'t have to reset them in our main while loop.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        lo, hi = 0, 0\\n        d = list(dominoes)\\n        chk = {\"L\", \"R\"}\\n        while hi < len(d):\\n\\t\\t   #window needs to be filled or we might have a postfix like \"R....\", so fill it\\n            if d[hi] in chk or hi == len(d)-1:\\n                self.do_fill(lo, hi, d)\\n                lo=hi\\n            hi+=1\\n            \\n        return \"\".join(d)\\n    \\n    def do_fill(self, lo, hi, d):\\n        if d[hi] == \"L\":\\n            if d[lo] == \"R\":\\n\\t\\t\\t    #window is Rs from the left and Ls from the right\\n                while lo < hi:\\n                    d[lo] = \"R\"\\n                    d[hi] = \"L\"\\n                    lo+=1\\n                    hi-=1\\n            else:\\n\\t\\t\\t   #window is completely L\\n                while lo <= hi:\\n                    d[lo] = \"L\"\\n                    lo+=1                 \\n        elif d[lo] == \"R\":\\n\\t\\t\\t\\t#window is completely R\\n                while lo <= hi:\\n                    d[lo] = \"R\"\\n                    lo+=1  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        lo, hi = 0, 0\\n        d = list(dominoes)\\n        chk = {\"L\", \"R\"}\\n        while hi < len(d):\\n\\t\\t   #window needs to be filled or we might have a postfix like \"R....\", so fill it\\n            if d[hi] in chk or hi == len(d)-1:\\n                self.do_fill(lo, hi, d)\\n                lo=hi\\n            hi+=1\\n            \\n        return \"\".join(d)\\n    \\n    def do_fill(self, lo, hi, d):\\n        if d[hi] == \"L\":\\n            if d[lo] == \"R\":\\n\\t\\t\\t    #window is Rs from the left and Ls from the right\\n                while lo < hi:\\n                    d[lo] = \"R\"\\n                    d[hi] = \"L\"\\n                    lo+=1\\n                    hi-=1\\n            else:\\n\\t\\t\\t   #window is completely L\\n                while lo <= hi:\\n                    d[lo] = \"L\"\\n                    lo+=1                 \\n        elif d[lo] == \"R\":\\n\\t\\t\\t\\t#window is completely R\\n                while lo <= hi:\\n                    d[lo] = \"R\"\\n                    lo+=1  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352147,
                "title": "fastest-o-n-solution-c-well-explained",
                "content": "1. Just keep a track of nearest left in left array and nearest right in right array\\n2. The one which is smaller will have more influence on that point \\n3. If both are equal it implies no  change to that domino\\n```\\nstring pushDominoes(string dominoes) {\\n\\n\\tint n=dominoes.size();\\n\\tvector<int> left(n);\\n\\tvector<int> right(n);\\n\\n\\tint k=-1;\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(dominoes[i]==\\'R\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tright[i]=k;\\n\\t}\\n\\n\\t for(int i=n-1;i>=0;i--){\\n\\t\\tif(dominoes[i]==\\'L\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tleft[i]=k;\\n\\t}\\n\\tstring ans=\"\";\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t  if(left[i]==-1 && right[i]==-1)\\n\\t\\t  ans.push_back(\\'.\\');\\n\\t  else if(left[i]==-1)  \\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]==-1)  \\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]<left[i])\\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]>left[i])\\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]==left[i])\\n\\t\\t  ans.push_back(\\'.\\');  \\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\nIf this solution helps, Do Upvote !",
                "solutionTags": [],
                "code": "```\\nstring pushDominoes(string dominoes) {\\n\\n\\tint n=dominoes.size();\\n\\tvector<int> left(n);\\n\\tvector<int> right(n);\\n\\n\\tint k=-1;\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tif(dominoes[i]==\\'R\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tright[i]=k;\\n\\t}\\n\\n\\t for(int i=n-1;i>=0;i--){\\n\\t\\tif(dominoes[i]==\\'L\\')\\n\\t\\t\\tk=0;\\n\\t\\telse if(dominoes[i]==\\'.\\' && k>=0)\\n\\t\\t\\tk++;\\n\\t\\telse\\n\\t\\t\\tk=-1;\\n\\n\\t\\tleft[i]=k;\\n\\t}\\n\\tstring ans=\"\";\\n\\n\\tfor(int i=0;i<n;i++){\\n\\t  if(left[i]==-1 && right[i]==-1)\\n\\t\\t  ans.push_back(\\'.\\');\\n\\t  else if(left[i]==-1)  \\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]==-1)  \\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]<left[i])\\n\\t\\t  ans.push_back(\\'R\\');\\n\\t  else if(right[i]>left[i])\\n\\t\\t  ans.push_back(\\'L\\');\\n\\t  else if(right[i]==left[i])\\n\\t\\t  ans.push_back(\\'.\\');  \\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1562258,
                "title": "simple-java-soltuion-using-bfs",
                "content": "class Solution {\\n    \\n\\tpublic String pushDominoes(String dominoes) {\\n        char[] res = new char[dominoes.length()];\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for(int i = 0 ; i < dominoes.length() ; i++){\\n            if(dominoes.charAt(i) != \\'.\\') \\n                queue.add(i);\\n            res[i] = dominoes.charAt(i);\\n        }\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            \\n            Map<Integer , Character> map = new HashMap<>();\\n            \\n            while(size-- > 0){\\n                int index = queue.poll();\\n                if(res[index] != \\'.\\'){\\n                    if(res[index] == \\'L\\'){\\n                        if(index - 1 >= 0 && res[index - 1] == \\'.\\'){\\n                            if(map.containsKey(index - 1)) \\n                                map.remove(index - 1);\\n                            else{\\n                                map.put(index - 1 , \\'L\\');\\n                                queue.add(index - 1);\\n                            }\\n                        }\\n                    }else{\\n                        if(index + 1 < res.length && res[index + 1] == \\'.\\'){\\n                            if(map.containsKey(index + 1)) \\n                                map.remove(index + 1);\\n                            else{\\n                                map.put(index + 1 , \\'R\\');\\n                                queue.add(index + 1);\\n                            } \\n                        }\\n                    }\\n                }\\n            }\\n            \\n            for(int key : map.keySet())\\n                res[key] = map.get(key); \\n            \\n        }\\n        \\n        return String.valueOf(res);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String pushDominoes(String dominoes) {\\n        char[] res = new char[dominoes.length()];\\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        for(int i = 0 ; i < dominoes.length() ; i++){\\n            if(dominoes.charAt(i) != \\'.\\') \\n                queue.add(i);\\n            res[i] = dominoes.charAt(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 132929,
                "title": "naive-bfs-easy-to-understand-and-could-be-used-as-first-solution",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] arr = new char[dominoes.length()];\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        Queue<Integer> leftQ = new LinkedList<>();\\n        Queue<Integer> rightQ = new LinkedList<>();\\n        Arrays.fill(left, Integer.MAX_VALUE);\\n        Arrays.fill(right, Integer.MAX_VALUE);\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'L\\') {\\n                leftQ.offer(i);\\n                left[i] = 0;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\') {\\n                rightQ.offer(i);\\n                right[i] = 0;\\n            }\\n        }\\n        int step = 0;\\n        while (leftQ.size() > 0 || rightQ.size() > 0) {\\n            step++;\\n            int leftSize = leftQ.size();\\n            while (leftSize > 0) {\\n                leftSize--;\\n                int pos = leftQ.poll();\\n                if (pos > 0 && left[pos - 1] == Integer.MAX_VALUE && dominoes.charAt(pos - 1) != \\'R\\') {\\n                    leftQ.offer(pos - 1);\\n                    left[pos - 1] = step;\\n                }\\n            }\\n            int rightSize = rightQ.size();\\n            while (rightSize > 0) {\\n                rightSize--;\\n                int pos = rightQ.poll();\\n                if (pos + 1< dominoes.length() && right[pos + 1] == Integer.MAX_VALUE && dominoes.charAt(pos + 1) != \\'L\\') {\\n                    rightQ.offer(pos + 1);\\n                    right[pos + 1] = step;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (left[i] - right[i] == 0) {\\n                arr[i] = \\'.\\';\\n            }\\n            else if (left[i] - right[i] > 0) {\\n                arr[i] = \\'R\\';\\n            }\\n            else {\\n                arr[i] = \\'L\\';\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] arr = new char[dominoes.length()];\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        Queue<Integer> leftQ = new LinkedList<>();\\n        Queue<Integer> rightQ = new LinkedList<>();\\n        Arrays.fill(left, Integer.MAX_VALUE);\\n        Arrays.fill(right, Integer.MAX_VALUE);\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'L\\') {\\n                leftQ.offer(i);\\n                left[i] = 0;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\') {\\n                rightQ.offer(i);\\n                right[i] = 0;\\n            }\\n        }\\n        int step = 0;\\n        while (leftQ.size() > 0 || rightQ.size() > 0) {\\n            step++;\\n            int leftSize = leftQ.size();\\n            while (leftSize > 0) {\\n                leftSize--;\\n                int pos = leftQ.poll();\\n                if (pos > 0 && left[pos - 1] == Integer.MAX_VALUE && dominoes.charAt(pos - 1) != \\'R\\') {\\n                    leftQ.offer(pos - 1);\\n                    left[pos - 1] = step;\\n                }\\n            }\\n            int rightSize = rightQ.size();\\n            while (rightSize > 0) {\\n                rightSize--;\\n                int pos = rightQ.poll();\\n                if (pos + 1< dominoes.length() && right[pos + 1] == Integer.MAX_VALUE && dominoes.charAt(pos + 1) != \\'L\\') {\\n                    rightQ.offer(pos + 1);\\n                    right[pos + 1] = step;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < dominoes.length(); i++) {\\n            if (left[i] - right[i] == 0) {\\n                arr[i] = \\'.\\';\\n            }\\n            else if (left[i] - right[i] > 0) {\\n                arr[i] = \\'R\\';\\n            }\\n            else {\\n                arr[i] = \\'L\\';\\n            }\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629708,
                "title": "simple-python3-solution-99-faster-using-stringreplacement-explained",
                "content": "## ***UPVOTE*** if it is helpful\\n``` \\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:         # States for the dominoes:\\n                        #   \\u2022 Any triplet that reaches the state \\'R.L\\' remains\\n                        #     that state permanently.\\n                        #  \\n                        #   \\u2022 These changes occur to pairs that are not part of an \\'R.L\\':\\n                        #     \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\'\\n\\n                        #  Here\\'s the plan:\\n                        #    1) To avoid the problem with the \\'R.L\\' state when we  address the \\n\\t\\t\\t\\t\\t\\t#       \\'R.\\' --> \\'RR\\' and  \\'.L\\' --> \\'LL\\' changes, we replace each \\'R.L\\' \\n\\t\\t\\t\\t\\t\\t#.       with a dummy string (say, \\'xxx\\').\\n                        #       \\n                        #    2) We perform the \\'R.\\' --> \\'RR\\', .L\\' --> \\'LL\\' replacements.\\n\\n                        #    3) Once the actions described in 1) and 2) are completed, we repeat \\n                        #       until no changes occur. We replace the dummy string with \\'R.L\\'. \\n    def pushDominoes(self, dominoes: str) -> str:\\n        temp = \\'\\'\\n        \\n        while dominoes != temp:\\n            temp = dominoes\\n            dominoes = dominoes.replace(\\'R.L\\', \\'xxx\\')       # <-- 1)\\n            dominoes = dominoes.replace(\\'R.\\', \\'RR\\')         # <-- 2)\\n            dominoes = dominoes.replace(\\'.L\\', \\'LL\\')         # <-- 2)\\n\\n        return  dominoes.replace(\\'xxx\\', \\'R.L\\')              # <-- 3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628701,
                "title": "easy-to-understand-dp-solution-explained-line-by-line-o-n",
                "content": "The problem becomes very easy to understand once we look from the point of view of any dominoe. Consider any stable dominoe at time 0. If there exists a dominoe to its right that has been tilted to the left at time 0- let\\'s say at a distance of A, our current dominoe will be tilted to the left at time A in absence of any other force from the left. Now suppose, if there exists a dominoe to the left that has been tilted to the right at time 0- let\\'s say at a distance of B, our current dominoe will be tilted to the right at time B. Now the dominoe faces 2 opposing forces at time A & time B. There are 3 scenarios:-\\n\\n- **A==B :** In this case the dominoe will face opposing forces exactly at same time and hence won\\'t move in either direction.\\n- **A < B :** The dominoe will face a force from the right pushing it to the left much before any force comes from the left pushing it to the right. Hence it will tilt to the left.\\n- **A > B :** By similar reasoning as above the dominoe will tilt to the right.\\n\\nSo during the implementation, we just need to maintain two vectors - L & R, denoting the earliest time at which any i\\'th dominoe will face a force to the left and right respectively. If a dominoe will never face a force to the left, L[i] = INT_MAX (denoting infinity) and similarly if the dominoe never faces a force to the right, R[i] = INT_MAX.\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tvector<int> L(n,INT_MAX);\\n\\t\\t\\tvector<int> R(n,INT_MAX);\\n\\t\\t\\t\\n\\t\\t\\t//Initialize L vector\\n\\t\\t\\tif(s[n-1]==\\'L\\')\\n\\t\\t\\t\\tL[n-1]=0;\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'R\\')\\n\\t\\t\\t\\t\\tcontinue;    // This is because if there exists any dominoe to the right pushing to the left,\\n\\t\\t\\t\\t\\t\\t      \\t// our current (i\\'th) dominoe cancels it with a right force of its own\\n\\t\\t\\t\\tif(s[i]==\\'L\\')\\n\\t\\t\\t\\t\\tL[i]=0;\\n\\t\\t\\t\\telse if(L[i+1]!=INT_MAX)\\n\\t\\t\\t\\t\\tL[i]=1+L[i+1];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t//Initialize R vector\\n\\t\\t\\tif(s[0]==\\'R\\')\\n\\t\\t\\t\\tR[0]=0;\\n\\t\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'L\\')\\n\\t\\t\\t\\t\\tcontinue;   // This is because if there exists any dominoe to the left pushing to the right,\\n\\t\\t\\t\\t\\t      \\t  // our current (i\\'th) dominoe cancels it with a left force of its own\\n\\t\\t\\t\\tif(s[i]==\\'R\\')\\n\\t\\t\\t\\t\\tR[i]=0;\\n\\t\\t\\t\\telse if(R[i-1]!=INT_MAX)\\n\\t\\t\\t\\t\\tR[i]=1+R[i-1];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// Now start looking from the point of view of every dominoe\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(L[i]==R[i])    // The dominoe faces both forces at equal times, or never faces a force from either side (i.e. L[i]=R[i]=INT_MAX)\\n\\t\\t\\t\\t\\tans+=\".\";\\n\\t\\t\\t\\telse if(L[i]<R[i])  // Left force reaches the dominoe earlier\\n\\t\\t\\t\\t\\tans+=\"L\";\\n\\t\\t\\t\\telse              // Right force reaches the dominoe earlier\\n\\t\\t\\t\\t\\tans+=\"R\";\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string s) {\\n\\t\\t\\tint n = s.length();\\n\\t\\t\\tvector<int> L(n,INT_MAX);\\n\\t\\t\\tvector<int> R(n,INT_MAX);\\n\\t\\t\\t\\n\\t\\t\\t//Initialize L vector\\n\\t\\t\\tif(s[n-1]==\\'L\\')\\n\\t\\t\\t\\tL[n-1]=0;\\n\\t\\t\\tfor(int i=n-2;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]==\\'R\\')\\n\\t\\t\\t\\t\\tcontinue;    // This is because if there exists any dominoe to the right pushing to the left,\\n\\t\\t\\t\\t\\t\\t      \\t// our current (i\\'th) dominoe cancels it with a right force of its own\\n\\t\\t\\t\\tif(s[i]==\\'L\\')\\n\\t\\t\\t\\t\\tL[i]=0;\\n\\t\\t\\t\\telse if(L[i+1]!=INT_MAX)\\n\\t\\t\\t\\t\\tL[i]=1+L[i+1];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 753346,
                "title": "c-o-n-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n = d.size();\\n        d=\"L\"+d+\"R\";\\n        int l=0,r=1,p1,p2;\\n        while(l<=(n+1) && r<=(n+1)){\\n            while(d[r]==\\'.\\'){\\n                r++;\\n            }\\n            if(d[l]==\\'R\\' && d[r]==\\'L\\'){\\n                p1=l+1,p2=r-1;\\n                while(p1<p2){\\n                    d[p1]=\\'R\\'; d[p2]=\\'L\\'; p1++; p2--;\\n                }\\n            }else if(d[l]==\\'L\\' && d[r]==\\'L\\'){\\n                p2=r-1;\\n                while(p2>l){\\n                    d[p2]=\\'L\\'; p2--;\\n                }\\n            }else if(d[l]==\\'R\\' && d[r]==\\'R\\'){\\n                p1=l+1;\\n                while(p1<r){\\n                    d[p1]=\\'R\\'; p1++;\\n                }\\n            }\\n            l=r;\\n            r++;\\n        }\\n        return d.substr(1,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n = d.size();\\n        d=\"L\"+d+\"R\";\\n        int l=0,r=1,p1,p2;\\n        while(l<=(n+1) && r<=(n+1)){\\n            while(d[r]==\\'.\\'){\\n                r++;\\n            }\\n            if(d[l]==\\'R\\' && d[r]==\\'L\\'){\\n                p1=l+1,p2=r-1;\\n                while(p1<p2){\\n                    d[p1]=\\'R\\'; d[p2]=\\'L\\'; p1++; p2--;\\n                }\\n            }else if(d[l]==\\'L\\' && d[r]==\\'L\\'){\\n                p2=r-1;\\n                while(p2>l){\\n                    d[p2]=\\'L\\'; p2--;\\n                }\\n            }else if(d[l]==\\'R\\' && d[r]==\\'R\\'){\\n                p1=l+1;\\n                while(p1<r){\\n                    d[p1]=\\'R\\'; p1++;\\n                }\\n            }\\n            l=r;\\n            r++;\\n        }\\n        return d.substr(1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628679,
                "title": "daily-leetcoding-challenge-september-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/push-dominoes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Adjacent Symbols [Accepted]\n\n  \n**Approach 2:** Calculate Force [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/push-dominoes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1884399,
                "title": "c-87-faster-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>&l,int pos)\\n    {\\n        int e=l.size()-1,s=0,index=-1;\\n        while(s<=e)\\n        {\\n            int mid=s+(e-s)/2;\\n            if(l[mid]>pos)\\n            {\\n                index=mid;\\n                e=mid-1;\\n            }else s=mid+1;\\n        }\\n        return index;\\n    }\\n    string pushDominoes(string s) \\n    {\\n        vector<int>l,r;\\n        int n=s.size(),i=0;\\n        bool ch=false;\\n\\t\\t//storing positions of l and r\\n        for(int i=0;i<n;i++)\\n        {     \\n            if(s[i]==\\'R\\')\\n            {\\n                if(ch)r[r.size()-1]=i;\\n                else r.push_back(i);\\n                ch=true;\\n            }else if(s[i]==\\'L\\')\\n            {\\n                l.push_back(i);\\n                ch=false;\\n            }\\n        }\\n        \\n        for(i=0;i<r.size();i++)\\n        {\\n            int index=binarysearch(l,r[i]);\\n            if(index==-1)break;\\n            // cout<<r[i]<<\" \"<<l[index]<<endl;\\n            int mid=l[index]-r[i]-1;\\n            mid/=2;\\n            if(mid==0)continue;\\n            int ss=r[i]+1,e=l[index]-1,c=mid;\\n            \\n            while(c--)\\n            {\\n                s[ss++]=\\'R\\';\\n            }\\n            \\n            c=mid;\\n            while(c--)\\n            {\\n                s[e--]=\\'L\\';\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\' )\\n            {\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'R\\' && (s[i+1]==\\'R\\' || s[i+1]==\\'.\\'))   {\\n                    s[i++]=\\'R\\';\\n                }\\n                // cout<<i<<endl;\\n                if(i-1>=0 && i==n-1 && s[i-1]==\\'R\\')s[i]=\\'R\\';\\n                int j=i;\\n                while(i-1>=0 && i+1<=n && s[i+1]==\\'L\\' && s[i-1]!=\\'R\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'L\\' && s[i+1]==\\'L\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                if(i==0 && s[i+1]==\\'L\\')s[i]=\\'L\\';\\n                i=j;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarysearch(vector<int>&l,int pos)\\n    {\\n        int e=l.size()-1,s=0,index=-1;\\n        while(s<=e)\\n        {\\n            int mid=s+(e-s)/2;\\n            if(l[mid]>pos)\\n            {\\n                index=mid;\\n                e=mid-1;\\n            }else s=mid+1;\\n        }\\n        return index;\\n    }\\n    string pushDominoes(string s) \\n    {\\n        vector<int>l,r;\\n        int n=s.size(),i=0;\\n        bool ch=false;\\n\\t\\t//storing positions of l and r\\n        for(int i=0;i<n;i++)\\n        {     \\n            if(s[i]==\\'R\\')\\n            {\\n                if(ch)r[r.size()-1]=i;\\n                else r.push_back(i);\\n                ch=true;\\n            }else if(s[i]==\\'L\\')\\n            {\\n                l.push_back(i);\\n                ch=false;\\n            }\\n        }\\n        \\n        for(i=0;i<r.size();i++)\\n        {\\n            int index=binarysearch(l,r[i]);\\n            if(index==-1)break;\\n            // cout<<r[i]<<\" \"<<l[index]<<endl;\\n            int mid=l[index]-r[i]-1;\\n            mid/=2;\\n            if(mid==0)continue;\\n            int ss=r[i]+1,e=l[index]-1,c=mid;\\n            \\n            while(c--)\\n            {\\n                s[ss++]=\\'R\\';\\n            }\\n            \\n            c=mid;\\n            while(c--)\\n            {\\n                s[e--]=\\'L\\';\\n            }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\' )\\n            {\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'R\\' && (s[i+1]==\\'R\\' || s[i+1]==\\'.\\'))   {\\n                    s[i++]=\\'R\\';\\n                }\\n                // cout<<i<<endl;\\n                if(i-1>=0 && i==n-1 && s[i-1]==\\'R\\')s[i]=\\'R\\';\\n                int j=i;\\n                while(i-1>=0 && i+1<=n && s[i+1]==\\'L\\' && s[i-1]!=\\'R\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                while(i-1>=0 && i+1<=n && s[i-1]==\\'L\\' && s[i+1]==\\'L\\')\\n                {\\n                    s[i--]=\\'L\\';\\n                }\\n                if(i==0 && s[i+1]==\\'L\\')s[i]=\\'L\\';\\n                i=j;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2632337,
                "title": "c-simulate-each-second",
                "content": "Busy day, didn\\'t have time to think of more than one approach of solving this problem.\\n\\n### Approach 1: simulate each second (78ms ~40%)\\n\\nThe intiution is the simulate second after second of the falling dominos. We start out with the dominios that are not standing straight and then we use the current state to compute the next state. This needs to happen in one go. Only at the end of a second we make the current state equal to the newly computed state. For long strings copying the state feels expensive. A variation might be to keep track in a vector which dominos we need to change and modify them before the next round.\\n\\n```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            string next = ds;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        // ... are we pushing the last one or isn\\'t the next one over leaning against it?\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            next[i + 1] = \\'R\\';\\n                            q.push(i + 1);\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            next[i - 1] = \\'L\\';\\n                            q.push(i - 1);\\n                        }\\n                    }\\n                }\\n            }\\n            // Take over the state for the next second.\\n            swap(ds, next);\\n        }\\n        return ds;\\n    }\\n```\\n\\nKeep track of the modifications in a extra vector only seems to make it slightly faster (72ms):\\n\\n```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            vector<pair<int, char>> mod;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            mod.push_back({i + 1, \\'R\\'});\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            mod.push_back({i - 1, \\'L\\'});\\n                        }\\n                    }\\n                }\\n            }\\n            // Apply the change for the next round.\\n            for (auto [i, ch] : mod) {\\n                ds[i] = ch;\\n                q.push(i);\\n            }\\n        }\\n        return ds;\\n    }\\n```\\n\\n\\n**Complexity Analysis**\\n  * Ain\\'t no time for that. :)\\n\\n_As always: Feedback, questions, and comments are welcome, and consider leaving a like (aka upvote) before you leave._\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**\\n",
                "solutionTags": [],
                "code": "```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            string next = ds;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        // ... are we pushing the last one or isn\\'t the next one over leaning against it?\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            next[i + 1] = \\'R\\';\\n                            q.push(i + 1);\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            next[i - 1] = \\'L\\';\\n                            q.push(i - 1);\\n                        }\\n                    }\\n                }\\n            }\\n            // Take over the state for the next second.\\n            swap(ds, next);\\n        }\\n        return ds;\\n    }\\n```\n```cpp\\n    string pushDominoes(string ds) {\\n        const int n = size(ds);\\n        queue<int> q;\\n        // Add all \\'L\\'s and \\'R\\'s to be processed.\\n        for (int i = 0; i < n; ++i) {\\n            if (ds[i] != \\'.\\') q.push(i);\\n        }\\n        while (!empty(q)) {\\n            int q_size = size(q);\\n            // Process each second on it\\'s own. We need to make a decision\\n            // based on the current state for computing the next state, because\\n            // all dominos fall simultaneously.\\n            vector<pair<int, char>> mod;\\n            while (q_size--) {\\n                const int i = q.front(); q.pop();\\n                if (ds[i] == \\'R\\') {\\n                    // If the domino is leaning right and can push the next one over ...\\n                    if (i < n - 1 && ds[i + 1] == \\'.\\') {\\n                        if (i == n - 2 || i < n - 2 && ds[i + 2] != \\'L\\') {\\n                            mod.push_back({i + 1, \\'R\\'});\\n                        }\\n                    }\\n                } else {\\n                    // Same for a left leaning domino ...\\n                    if (i > 0 && ds[i - 1] == \\'.\\') {\\n                        if (i == 1 || i > 1 && ds[i - 2] != \\'R\\') {\\n                            mod.push_back({i - 1, \\'L\\'});\\n                        }\\n                    }\\n                }\\n            }\\n            // Apply the change for the next round.\\n            for (auto [i, ch] : mod) {\\n                ds[i] = ch;\\n                q.push(i);\\n            }\\n        }\\n        return ds;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631190,
                "title": "java-commented-all-cases",
                "content": "```\\n/*\\n\\n    \"L.L.R...LR..L..R\"\\n    four orientations possible\\n      (1)      [L...L] -> all [LLLLL]\\n      \\n      (2)      [R...L] -> two cases even or odd numbers of spaces between them\\n               case I  (even)  -> first half [RRR]\\n                                  second half [LLL]\\n               case II  (odd)  -> first half [RR] \\n                                  middle piece will stand [.] \\n                                  second half [LL]\\n      (3)      [L...R] -> no change between [L...R]\\n      (4)      [R...R] -> all [RRRRR]\\n\\t  \\n*/\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        //  adding \"L\" and \"R\" on left and right (respectively) will not cause any change\\n        dominoes = \"L\" + dominoes + \"R\";\\n        char[] a = dominoes.toCharArray();\\n        int l = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            while (a[i] == \\'.\\') {\\n                //  skip all the dominoes that are not initially pushed\\n                i++;\\n            }\\n            //  four cases possible\\n            if (a[l] == \\'L\\' && a[i] == \\'L\\') {\\n                while (l != i) a[l++] = \\'L\\';\\n            } else if(a[l] == \\'R\\' && a[i] == \\'L\\') {\\n                //  two cases of even number of non pushed dominoes or odd \\n                //  both cases are handled in the while loop\\n                int oi = i;    //  saving original i\\n\\t\\t\\t\\twhile (l < i) {\\n                    a[l++] = \\'R\\';\\n                    a[i--] = \\'L\\';\\n                }\\n                i = oi;\\n            } else if(a[l] == \\'L\\' && a[i] == \\'R\\') {\\n                //  no change inside the [L...R] pair\\n            } else if(a[l] == \\'R\\' && a[i] == \\'R\\') {\\n                while (l != i) a[l++] = \\'R\\';\\n            }\\n            l = i;\\n        }\\n\\t\\t// removing the initial changes we made\\n        return (new String(a)).substring(1, a.length - 1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String pushDominoes(String dominoes) {\\n        //  adding \"L\" and \"R\" on left and right (respectively) will not cause any change\\n        dominoes = \"L\" + dominoes + \"R\";\\n        char[] a = dominoes.toCharArray();\\n        int l = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            while (a[i] == \\'.\\') {\\n                //  skip all the dominoes that are not initially pushed\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2356371,
                "title": "easy-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=size(s);\\n        queue<pair<int,char>>q;//queue to store the index and character at that index\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\' or s[i]==\\'R\\') //pushing all the L and R into our queue\\n                q.push({i,s[i]});\\n        }\\n        vector<pair<int,char>>temp;//a temp vector \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto top=q.front();\\n                q.pop();\\n                int index=top.first;\\n                char ch=top.second;\\n                \\n                if(ch==\\'L\\')//if we encounter an L from queue\\n                {\\n                    if(index-2>=0 and s[index-2]==\\'R\\') continue;//to chck for condition .R.LL\\n                    if(index-1>=0 and s[index-1]==\\'.\\'){\\n                        q.push({index-1,\\'L\\'});\\n                        temp.push_back({index-1,\\'L\\'});\\n                    }\\n                }\\n                else if(ch==\\'R\\')\\n                {\\n                    if(index+2<n and s[index+2]==\\'L\\') continue;//to chck for condition .R.L...\\n                    if(index+1<n and s[index+1]==\\'.\\'){\\n                        q.push({index+1,\\'R\\'});\\n                        temp.push_back({index+1,\\'R\\'});\\n                    }\\n                }\\n            }\\n            for( auto i:temp)//after a level of BFS is done update the original string \\n            {\\n                pair<int,char>&p=i;\\n                s[p.first]=p.second;\\n            }\\n        }\\n        return s;//return the new string\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=size(s);\\n        queue<pair<int,char>>q;//queue to store the index and character at that index\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\' or s[i]==\\'R\\') //pushing all the L and R into our queue\\n                q.push({i,s[i]});\\n        }\\n        vector<pair<int,char>>temp;//a temp vector \\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto top=q.front();\\n                q.pop();\\n                int index=top.first;\\n                char ch=top.second;\\n                \\n                if(ch==\\'L\\')//if we encounter an L from queue\\n                {\\n                    if(index-2>=0 and s[index-2]==\\'R\\') continue;//to chck for condition .R.LL\\n                    if(index-1>=0 and s[index-1]==\\'.\\'){\\n                        q.push({index-1,\\'L\\'});\\n                        temp.push_back({index-1,\\'L\\'});\\n                    }\\n                }\\n                else if(ch==\\'R\\')\\n                {\\n                    if(index+2<n and s[index+2]==\\'L\\') continue;//to chck for condition .R.L...\\n                    if(index+1<n and s[index+1]==\\'.\\'){\\n                        q.push({index+1,\\'R\\'});\\n                        temp.push_back({index+1,\\'R\\'});\\n                    }\\n                }\\n            }\\n            for( auto i:temp)//after a level of BFS is done update the original string \\n            {\\n                pair<int,char>&p=i;\\n                s[p.first]=p.second;\\n            }\\n        }\\n        return s;//return the new string\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630271,
                "title": "c-o-n-time-and-space-solution-commented-code-for-more-understanding",
                "content": "We just need to check the distance of L from the right side of current dominoes[i] and distance of R from the left side of current dominoes[i] and take the minimum of the two. \\nCommented Code for better Understanding. Please Upvote if it helped! \\uD83D\\uDE03\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int>distanceOfL(n, 0), distanceofR(n, 0);\\n    // we traverse from left to right as only the R which are in the left position will affect any dominoes[i] == \\'.\\'\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\'){\\n                distanceofR[i] = 0;\\n            }\\n            // we are checking this because if dominoes[i] == \\'L\\', then we need to cut off the affect of the R \\n\\t\\t\\t//which was present on the left side of the current dominoes[i]\\n            else if(dominoes[i] == \\'L\\'){\\n                distanceofR[i] = 1e9;\\n            }\\n            else{\\n                if(i > 0 && distanceofR[i - 1] != 1e9){\\n                    distanceofR[i] = distanceofR[i - 1] + 1;\\n                }\\n                else{\\n                     distanceofR[i] = 1e9;\\n                }\\n            }\\n        }\\n        // we are traversing from right as only the L which are in right position will affect any dominoes[i] == \\'.\\'\\n        for(int i = n - 1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\'){\\n                distanceOfL[i] = 0;\\n            }\\n             // we are checking this because if dominoes[i] == R\\', then we need to cut off the affect of the L\\n\\t\\t\\t //which was present on the right side of the current dominoes[i]\\n            else if(dominoes[i] == \\'R\\'){\\n                distanceOfL[i] = 1e9;\\n            }\\n            else{\\n                if(i < n - 1 && distanceOfL[i + 1] != 1e9){\\n                    distanceOfL[i] = distanceOfL[i + 1] + 1;\\n                }\\n                else{\\n                    distanceOfL[i] = 1e9;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(distanceOfL[i] < distanceofR[i]){\\n                dominoes[i] = \\'L\\';\\n            }\\n            else if(distanceofR[i] < distanceOfL[i]){\\n                dominoes[i] = \\'R\\';\\n            }\\n           // When distanceofR[i] == distanceOfL[i], dominoes[i] will be \\'.\\' \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int>distanceOfL(n, 0), distanceofR(n, 0);\\n    // we traverse from left to right as only the R which are in the left position will affect any dominoes[i] == \\'.\\'\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\'){\\n                distanceofR[i] = 0;\\n            }\\n            // we are checking this because if dominoes[i] == \\'L\\', then we need to cut off the affect of the R \\n\\t\\t\\t//which was present on the left side of the current dominoes[i]\\n            else if(dominoes[i] == \\'L\\'){\\n                distanceofR[i] = 1e9;\\n            }\\n            else{\\n                if(i > 0 && distanceofR[i - 1] != 1e9){\\n                    distanceofR[i] = distanceofR[i - 1] + 1;\\n                }\\n                else{\\n                     distanceofR[i] = 1e9;\\n                }\\n            }\\n        }\\n        // we are traversing from right as only the L which are in right position will affect any dominoes[i] == \\'.\\'\\n        for(int i = n - 1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\'){\\n                distanceOfL[i] = 0;\\n            }\\n             // we are checking this because if dominoes[i] == R\\', then we need to cut off the affect of the L\\n\\t\\t\\t //which was present on the right side of the current dominoes[i]\\n            else if(dominoes[i] == \\'R\\'){\\n                distanceOfL[i] = 1e9;\\n            }\\n            else{\\n                if(i < n - 1 && distanceOfL[i + 1] != 1e9){\\n                    distanceOfL[i] = distanceOfL[i + 1] + 1;\\n                }\\n                else{\\n                    distanceOfL[i] = 1e9;\\n                }\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(distanceOfL[i] < distanceofR[i]){\\n                dominoes[i] = \\'L\\';\\n            }\\n            else if(distanceofR[i] < distanceOfL[i]){\\n                dominoes[i] = \\'R\\';\\n            }\\n           // When distanceofR[i] == distanceOfL[i], dominoes[i] will be \\'.\\' \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630182,
                "title": "c-easy-solution-using-if-else",
                "content": "* Make a vector of pair (V) of char and int which **contains** the **characters L and R** with respective indices\\n* make two variables previdx and prevchar ans assign them the first occourence of L or R i.e. **prevchar=v[0].first  , previdx=v[0].second**\\n* traverse in v from index 1\\n* Now Total there are **4 conditions** \\n1.  **prevchar==\\'L\\' and currchar==\\'L\\'** \\n2.  **prevchar==\\'L\\' and currchar==\\'R\\'**\\n3.  **prevchar==\\'R\\' and currchar==\\'R\\'**\\n4.  **prevchar==\\'R\\' and currchar==\\'L\\'**\\n\\n* **Case 1: prevchar==\\'L\\' and currchar==\\'L\\'**\\n Do ans+=\\'L\\' from previdx+1 to curridx\\n* **Case 2: prevchar==\\'L\\' and currchar==\\'R\\'**\\n Do ans+=dominoes[i] from previdx+1 to curridx \\n * **Case 3: prevchar==\\'R\\' and currchar==\\'R\\'**\\n Do ans+=\\'R\\' from previdx+1 to curridx \\n  * **Case 4: prevchar==\\'R\\' and currchar==\\'L\\'**\\n Now in this case find the length of string from previdx to curridx i.e.**len=(curridx-previdx+1)**\\n**If len is odd** \\n  do **ans+=\\'R\\'** from previdx to mid-1 \\n ans+=\\'.\\'\\n and do **ans+=\\'L\\'** from mid+1 to curridx\\n else \\n  do **ans+=\\'R\\'** from previdx to mid\\n and do **ans+=\\'L\\'** from mid+1 to curridx\\n \\n Lastly check if curr idx is less than n-1 then check the prevchar if it is L then append **\\'.\\'** upto n-1 \\n and if it is R then append **\\'R\\'** upto n-1\\n\\n**Time Complexity: O(N)\\nSpace Complexity: O(N)\\nCode**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<pair<char,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]!=\\'.\\')\\n                v.push_back({dominoes[i],i});\\n        }\\n        if(v.size()==0) return dominoes;\\n        string ans=\"\";\\n        int tmp=v[0].second;\\n            tmp++;\\n        char prevchar;\\n        int previdx=v[0].second;\\n        if(v[0].first==\\'L\\')\\n        {\\n            while(tmp--)\\n            ans+=\\'L\\';\\n            prevchar=\\'L\\';\\n        }\\n        else\\n        {\\n            tmp--;\\n            while(tmp--)\\n            ans+=\\'.\\';\\n            ans+=\\'R\\';\\n            prevchar=\\'R\\';\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            char currchar=v[i].first;\\n            int curridx=v[i].second;\\n            \\n            if(prevchar==\\'L\\' && currchar==\\'L\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else if(prevchar==\\'L\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=dominoes[j];\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'L\\')\\n            {\\n                int len=curridx-previdx+1;\\n                int mid=(previdx+curridx)/2;\\n                if(len&1)\\n                {\\n                    for(int j=previdx+1;j<mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                else \\n                {\\n                    \\n                    for(int j=previdx+1;j<=mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    // ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                \\n            }\\n            \\n            previdx=curridx;\\n            prevchar=currchar;\\n        }\\n        if(previdx<n-1)\\n        {\\n            if(prevchar==\\'L\\')\\n            {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'.\\';\\n                }\\n            }\\n            else {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<pair<char,int>>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]!=\\'.\\')\\n                v.push_back({dominoes[i],i});\\n        }\\n        if(v.size()==0) return dominoes;\\n        string ans=\"\";\\n        int tmp=v[0].second;\\n            tmp++;\\n        char prevchar;\\n        int previdx=v[0].second;\\n        if(v[0].first==\\'L\\')\\n        {\\n            while(tmp--)\\n            ans+=\\'L\\';\\n            prevchar=\\'L\\';\\n        }\\n        else\\n        {\\n            tmp--;\\n            while(tmp--)\\n            ans+=\\'.\\';\\n            ans+=\\'R\\';\\n            prevchar=\\'R\\';\\n        }\\n        for(int i=1;i<v.size();i++)\\n        {\\n            char currchar=v[i].first;\\n            int curridx=v[i].second;\\n            \\n            if(prevchar==\\'L\\' && currchar==\\'L\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else if(prevchar==\\'L\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=dominoes[j];\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'R\\')\\n            {\\n                for(int j=previdx+1;j<=curridx;j++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(prevchar==\\'R\\' && currchar==\\'L\\')\\n            {\\n                int len=curridx-previdx+1;\\n                int mid=(previdx+curridx)/2;\\n                if(len&1)\\n                {\\n                    for(int j=previdx+1;j<mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                else \\n                {\\n                    \\n                    for(int j=previdx+1;j<=mid;j++)\\n                    {\\n                        ans+=\\'R\\';\\n                    }\\n                    // ans+=\\'.\\';\\n                    for(int j=mid+1;j<=curridx;j++)\\n                    {\\n                        ans+=\\'L\\';\\n                    }\\n                }\\n                \\n            }\\n            \\n            previdx=curridx;\\n            prevchar=currchar;\\n        }\\n        if(previdx<n-1)\\n        {\\n            if(prevchar==\\'L\\')\\n            {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'.\\';\\n                }\\n            }\\n            else {\\n                for(int i=previdx+1;i<n;i++)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629832,
                "title": "easy-python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = \\'L\\' + dominoes + \\'R\\'\\n        res = []\\n        left = 0\\n        \\n        for right in range(1, len(dominoes)):\\n            if dominoes[right] == \\'.\\': \\n                continue\\n                \\n            middle = right - left - 1\\n            if left: \\n                res.append(dominoes[left])\\n            if dominoes[left] == dominoes[right]: \\n                res.append(dominoes[left] * middle)\\n            elif dominoes[left] == \\'L\\' and dominoes[right] == \\'R\\':\\n                res.append(\\'.\\' * middle)\\n            else: \\n                res.append(\\'R\\' * (middle // 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle // 2))\\n            left = right\\n            \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = \\'L\\' + dominoes + \\'R\\'\\n        res = []\\n        left = 0\\n        \\n        for right in range(1, len(dominoes)):\\n            if dominoes[right] == \\'.\\': \\n                continue\\n                \\n            middle = right - left - 1\\n            if left: \\n                res.append(dominoes[left])\\n            if dominoes[left] == dominoes[right]: \\n                res.append(dominoes[left] * middle)\\n            elif dominoes[left] == \\'L\\' and dominoes[right] == \\'R\\':\\n                res.append(\\'.\\' * middle)\\n            else: \\n                res.append(\\'R\\' * (middle // 2) + \\'.\\' * (middle % 2) + \\'L\\' * (middle // 2))\\n            left = right\\n            \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629079,
                "title": "javascript-easy-solution-with-explanation-two-pointers-dynamic-programming",
                "content": "We are going to approach this problem by using dp Array \\n\\nLets take example \\nFrom the left of dominoes we are pushing towards Right and we are storing the index of the last right push if the left push is on the particular point we are putting the index as -1 and also if there are no right push as of now and we have \".\" means also we are considering -1.\\nGiven Input =>  \".L.R...LR..L..\"\\nAfter the left-side right push dpL => [ -1,-1,-1,3,3,3,3,-1,8,8,8,-1,-1,-1]\\n\\nAfter that we have to take the right-side left push we are keeping the \\'R\\' and \".\" as -1 and storing the index of the left push from the right side.\\nAfter the right-side-left-push dpR =>[1,1,-1,-1,7,7,7,7,-1,11,11,11,-1,-1]\\n\\nThen For finalizing result string we are doing followin checks\\n 1. if both the dp consist of -1 that means no push occured on the particular domino so we are adding \".\"\\n 2. Then are checking is any one of the dp having the push like its having any index other than -1. If dpR consist means that is left push vice versa for the dp L.\\n 3. Then if the both contains index we are calculating the nearest index and putting their value if both are equal we are adding \".\" \\n\\nPlease upvote this solution if you like this \\n\\n\\n```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(d) {\\n    let dpL = [];\\n    let dpR = [];\\n    for(let i =0;i<d.length;i++){\\n        if(d[i]===\\'R\\'){\\n            dpL[i] = i;\\n        } else if(d[i]===\\'L\\'){\\n            dpL[i] = -1;\\n        } else if(dpL[i]!=-1){\\n            dpL[i] = dpL[i-1]===undefined ? -1:dpL[i-1];\\n        }\\n        let j = d.length-i-1;\\n        if(d[j]===\\'L\\'){\\n            dpR[j] = j;\\n        } else if(d[j]===\\'R\\'){\\n            dpR[j] = -1;\\n        } else if(dpR[j]!=-1){\\n            dpR[j] = dpR[j+1]===undefined ? -1:dpR[j+1];\\n        }\\n    }\\n    let res = \\'\\';\\n    for(let i=0;i<d.length;i++){\\n\\t\\t// check 1\\n        if(dpR[i]==-1&dpL[i]==-1){\\n            res+=\".\"\\n            }\\n        else if(dpL[i]!==-1 && dpR[i]!==-1){\\n\\t\\t\\t//  check 3\\n            if(Math.abs(dpL[i]-i)===Math.abs(dpR[i]-i)){\\n                res+=\".\";\\n            }\\n            else if(Math.abs(dpL[i]-i)<Math.abs(dpR[i]-i)){\\n                res+=\\'R\\';\\n            }\\n            else{\\n                res+=\\'L\\';\\n            }\\n        }\\n        else{\\n\\t\\t\\t// check 2\\n            res+=dpL[i]===-1?\\'L\\':\\'R\\'\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(d) {\\n    let dpL = [];\\n    let dpR = [];\\n    for(let i =0;i<d.length;i++){\\n        if(d[i]===\\'R\\'){\\n            dpL[i] = i;\\n        } else if(d[i]===\\'L\\'){\\n            dpL[i] = -1;\\n        } else if(dpL[i]!=-1){\\n            dpL[i] = dpL[i-1]===undefined ? -1:dpL[i-1];\\n        }\\n        let j = d.length-i-1;\\n        if(d[j]===\\'L\\'){\\n            dpR[j] = j;\\n        } else if(d[j]===\\'R\\'){\\n            dpR[j] = -1;\\n        } else if(dpR[j]!=-1){\\n            dpR[j] = dpR[j+1]===undefined ? -1:dpR[j+1];\\n        }\\n    }\\n    let res = \\'\\';\\n    for(let i=0;i<d.length;i++){\\n\\t\\t// check 1\\n        if(dpR[i]==-1&dpL[i]==-1){\\n            res+=\".\"\\n            }\\n        else if(dpL[i]!==-1 && dpR[i]!==-1){\\n\\t\\t\\t//  check 3\\n            if(Math.abs(dpL[i]-i)===Math.abs(dpR[i]-i)){\\n                res+=\".\";\\n            }\\n            else if(Math.abs(dpL[i]-i)<Math.abs(dpR[i]-i)){\\n                res+=\\'R\\';\\n            }\\n            else{\\n                res+=\\'L\\';\\n            }\\n        }\\n        else{\\n\\t\\t\\t// check 2\\n            res+=dpL[i]===-1?\\'L\\':\\'R\\'\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629066,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Two Pointers***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        \\n        int n = str.size();\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        while(right < n)\\n        {\\n            if(str[right] == \\'.\\')\\n            {\\n                right++;\\n                \\n                continue;\\n            }\\n            \\n            if(str[right] == str[left] || (str[left] == \\'.\\' && str[right] == \\'L\\'))\\n            {\\n                int i = left;\\n                \\n                while(i < right)\\n                {\\n                    str[i] = str[right];\\n                    \\n                    i++;\\n                }\\n            }\\n            else if(str[left] == \\'R\\' && str[right] == \\'L\\')\\n            {\\n                int i = left;\\n                \\n                int j = right;\\n                \\n                while(i < j)\\n                {\\n                    str[i] = \\'R\\';\\n                    \\n                    str[j] = \\'L\\';\\n                    \\n                    i++;\\n                    \\n                    j--;\\n                }\\n            }\\n            \\n            // update pointers\\n            \\n            left = right;\\n            \\n            right++;\\n        }\\n        \\n        // if the last push is \\'R\\' then replace all the characters right to it with \\'R\\'\\n        \\n        if(str[left] == \\'R\\')\\n        {\\n            int i = left;\\n            \\n            while(i < n)\\n            {\\n                str[i] = \\'R\\';\\n                \\n                i++;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        \\n        int n = str.size();\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        while(right < n)\\n        {\\n            if(str[right] == \\'.\\')\\n            {\\n                right++;\\n                \\n                continue;\\n            }\\n            \\n            if(str[right] == str[left] || (str[left] == \\'.\\' && str[right] == \\'L\\'))\\n            {\\n                int i = left;\\n                \\n                while(i < right)\\n                {\\n                    str[i] = str[right];\\n                    \\n                    i++;\\n                }\\n            }\\n            else if(str[left] == \\'R\\' && str[right] == \\'L\\')\\n            {\\n                int i = left;\\n                \\n                int j = right;\\n                \\n                while(i < j)\\n                {\\n                    str[i] = \\'R\\';\\n                    \\n                    str[j] = \\'L\\';\\n                    \\n                    i++;\\n                    \\n                    j--;\\n                }\\n            }\\n            \\n            // update pointers\\n            \\n            left = right;\\n            \\n            right++;\\n        }\\n        \\n        // if the last push is \\'R\\' then replace all the characters right to it with \\'R\\'\\n        \\n        if(str[left] == \\'R\\')\\n        {\\n            int i = left;\\n            \\n            while(i < n)\\n            {\\n                str[i] = \\'R\\';\\n                \\n                i++;\\n            }\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629055,
                "title": "easy-to-understand-javascript-solution-using-two-pointers",
                "content": "\\n&emsp;The problem requires us to see how it will end up if we let all the dominoes fall into the direction they are set, all at the same time. This may be doable in real life but computers can\\'t do this. We should come up of a solution that computers can execute... a methodological one.\\n<br />\\n**Using 2-Pointers:**\\n\\n&emsp;If we think about it, we only really care about how the dominoes standing vertically that\\'s sandwiched between the falling dominoes will react. To do this, we just need to see what will happen between the window of dominoes converging from left to right `\"R\"` and right to left `\"L\"`.\\n\\n&emsp;The code loops through the array of dominoes, checking the window requirement. Once it reaches there, it simulates what happens to the dominoes in the middle of falling dominoes. If it reaches a common point, it will ignored since force falling from the opposite direction will cancel out each other. Once it\\'s done, it will move on to another window until all of them have been checked. \\n\\n**Handling Corner Cases:**\\n\\n&emsp;Corner case happens when the first index has a vertical domino `\".\"` and one of the succeeding domino is falling from the left `\"L\"` or vice versa for the last index but the predecessor is falling from the right `\"R\"` \\n&emsp;*eg.* `\"(..L).RR...LL(R...)\"`\\n\\n&emsp;we temporarily append `\"L\"` to the first index and `\"R\"` to the last index to  handle the corner cases. This doesn\\'t change anything but it allows us to handle both cases in a single for loop.\\n<br>\\nTime Complexity: **O(n)**\\nSpace Compelxity: **O(n)**\\n\\n```javascript\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = \"L\" + dominoes + \"R\"; \\n    const arr = dominoes.split(\\'\\'), n = dominoes.length;\\n\\n    for (let l = 0, r = 1; r < n; r++) {\\n        if (arr[r] === \".\") continue;\\n\\n        if (arr[r] === \"L\" && arr[l] === \"R\")\\n            for (let i = l+1, j = r-1; j-i && i < j; i++, j--)\\n                arr[i] = \"R\", arr[j] = \"L\";\\n\\n        // handle both corner cases\\n        if (arr[l] === arr[r])\\n            for (let i = l; i < r; i++)\\n                arr[i] = arr[r];\\n\\n        l = r;\\n    }\\n\\n    return arr.slice(1, n-1).join(\\'\\');\\n};```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```javascript\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = \"L\" + dominoes + \"R\"; \\n    const arr = dominoes.split(\\'\\'), n = dominoes.length;\\n\\n    for (let l = 0, r = 1; r < n; r++) {\\n        if (arr[r] === \".\") continue;\\n\\n        if (arr[r] === \"L\" && arr[l] === \"R\")\\n            for (let i = l+1, j = r-1; j-i && i < j; i++, j--)\\n                arr[i] = \"R\", arr[j] = \"L\";\\n\\n        // handle both corner cases\\n        if (arr[l] === arr[r])\\n            for (let i = l; i < r; i++)\\n                arr[i] = arr[r];\\n\\n        l = r;\\n    }\\n\\n    return arr.slice(1, n-1).join(\\'\\');\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 348579,
                "title": "python-force-caculate",
                "content": "O(N)\\n```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        force = N = len(dominoes)\\n        tmp = 0\\n        ans = [0] * N\\n        for i in range(N):\\n            if dominoes[i] == \\'R\\':\\n                tmp = force\\n            if dominoes[i] == \\'L\\':\\n                tmp = 0\\n            ans[i] += max(tmp, 0)\\n            tmp -= 1\\n        tmp = 0\\n        for i in range(N-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                tmp = -force\\n            if dominoes[i] == \\'R\\':\\n                tmp = 0\\n            ans[i] += min(tmp, 0)\\n            tmp += 1\\n        return \\'\\'.join([ \\'R\\' if n>0 else \\'L\\' if n<0 else \\'.\\' for n in ans])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        force = N = len(dominoes)\\n        tmp = 0\\n        ans = [0] * N\\n        for i in range(N):\\n            if dominoes[i] == \\'R\\':\\n                tmp = force\\n            if dominoes[i] == \\'L\\':\\n                tmp = 0\\n            ans[i] += max(tmp, 0)\\n            tmp -= 1\\n        tmp = 0\\n        for i in range(N-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                tmp = -force\\n            if dominoes[i] == \\'R\\':\\n                tmp = 0\\n            ans[i] += min(tmp, 0)\\n            tmp += 1\\n        return \\'\\'.join([ \\'R\\' if n>0 else \\'L\\' if n<0 else \\'.\\' for n in ans])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2631203,
                "title": "python-iterative-bfs-solution-o-n-time-o-n-space",
                "content": "```\\n# * Iterative BFS Solution | O(n) Time | O(n) Space\\n# * n -> The length of dominoes string\\n\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes_list = list(dominoes)\\n        # * Start the BFS traversal.\\n        # * Push all the `L` and `R` into the queue for processing.\\n        queue = collections.deque(\\n            [(idx, d) for idx, d in enumerate(dominoes_list) if d != \".\"]\\n        )\\n\\n        while queue:\\n            cur_idx, cur_dominoe = queue.popleft()\\n            if cur_dominoe == \"L\" and cur_idx > 0 and dominoes_list[cur_idx - 1] == \".\":\\n                queue.append((cur_idx - 1, \"L\"))\\n                dominoes_list[cur_idx - 1] = \"L\"\\n\\n            elif (\\n                cur_dominoe == \"R\"\\n                and cur_idx + 1 < len(dominoes_list)\\n                and dominoes_list[cur_idx + 1] == \".\"\\n            ):\\n                if (\\n                    cur_idx + 2 < len(dominoes_list)\\n                    and dominoes_list[cur_idx + 2] == \"L\"\\n                ):\\n                    queue.popleft()\\n\\n                else:\\n                    queue.append((cur_idx + 1, \"R\"))\\n                    dominoes_list[cur_idx + 1] = \"R\"\\n\\n        return \"\".join(dominoes_list)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n# * Iterative BFS Solution | O(n) Time | O(n) Space\\n# * n -> The length of dominoes string\\n\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes_list = list(dominoes)\\n        # * Start the BFS traversal.\\n        # * Push all the `L` and `R` into the queue for processing.\\n        queue = collections.deque(\\n            [(idx, d) for idx, d in enumerate(dominoes_list) if d != \".\"]\\n        )\\n\\n        while queue:\\n            cur_idx, cur_dominoe = queue.popleft()\\n            if cur_dominoe == \"L\" and cur_idx > 0 and dominoes_list[cur_idx - 1] == \".\":\\n                queue.append((cur_idx - 1, \"L\"))\\n                dominoes_list[cur_idx - 1] = \"L\"\\n\\n            elif (\\n                cur_dominoe == \"R\"\\n                and cur_idx + 1 < len(dominoes_list)\\n                and dominoes_list[cur_idx + 1] == \".\"\\n            ):\\n                if (\\n                    cur_idx + 2 < len(dominoes_list)\\n                    and dominoes_list[cur_idx + 2] == \"L\"\\n                ):\\n                    queue.popleft()\\n\\n                else:\\n                    queue.append((cur_idx + 1, \"R\"))\\n                    dominoes_list[cur_idx + 1] = \"R\"\\n\\n        return \"\".join(dominoes_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630107,
                "title": "using-two-pointer-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        string str=\"\";\\n        int i=0,j=n-1;\\n        //to strore the time duration when left effect will occur to that dominoe box\\n        vector<int> l(n,0);  \\n        //to strore the time duration when right effect will occur to that dominoe box\\n        vector<int> r(n,0);\\n        int prev=0,cnt=0;\\n        while(i<n)\\n        {\\n            if(dominoes[prev]==\\'R\\' && dominoes[i]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=i;\\n                cnt=0;\\n            }\\n            r[i]=cnt;\\n            i++;\\n        }\\n      \\n        cnt =0;\\n        prev=j;\\n        while(j>=0)\\n        {\\n            if(dominoes[prev]==\\'L\\' && dominoes[j]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=j;\\n                cnt=0;\\n            }\\n            l[j]=cnt;\\n            j--;\\n        }\\n           \\n        for(int i=0;i<n;i++)\\n        {\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]!=0){  \\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]==0){\\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]!=0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]==0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] == r[i] && dominoes[i]==\\'.\\'){\\n                dominoes[i]=\\'.\\';\\n            }\\n           \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        string str=\"\";\\n        int i=0,j=n-1;\\n        //to strore the time duration when left effect will occur to that dominoe box\\n        vector<int> l(n,0);  \\n        //to strore the time duration when right effect will occur to that dominoe box\\n        vector<int> r(n,0);\\n        int prev=0,cnt=0;\\n        while(i<n)\\n        {\\n            if(dominoes[prev]==\\'R\\' && dominoes[i]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=i;\\n                cnt=0;\\n            }\\n            r[i]=cnt;\\n            i++;\\n        }\\n      \\n        cnt =0;\\n        prev=j;\\n        while(j>=0)\\n        {\\n            if(dominoes[prev]==\\'L\\' && dominoes[j]==\\'.\\'){\\n                cnt++;\\n            }\\n            else {\\n                prev=j;\\n                cnt=0;\\n            }\\n            l[j]=cnt;\\n            j--;\\n        }\\n           \\n        for(int i=0;i<n;i++)\\n        {\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]!=0){  \\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]==0){\\n                dominoes[i]=\\'L\\';\\n            }\\n            if(l[i] > r[i] && dominoes[i]==\\'.\\' && r[i]!=0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] < r[i] && dominoes[i]==\\'.\\' && l[i]==0){\\n                dominoes[i]=\\'R\\';\\n            }\\n            if(l[i] == r[i] && dominoes[i]==\\'.\\'){\\n                dominoes[i]=\\'.\\';\\n            }\\n           \\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629684,
                "title": "c-2-pointer-simple-and-concise-code-commented",
                "content": "```\\nstring pushDominoes(string d) {\\n        int n = d.size(), i = 0, prev = 0;\\n        string ans(n, \\'.\\');//initialize ans with \\'.\\'s\\n        while(i<n){\\n            while(i<n && d[i] == \\'.\\')i++;\\n            if(i<n && d[i] == \\'L\\'){\\n                //if encountered an L first, then update from prev to this position all as \\'L\\'\\n                while(prev <= i)\\n                    ans[prev++] = \\'L\\';\\n                i++;\\n            }\\n            else if(i<n && d[i] == \\'R\\'){\\n                //if encountered an \\'R\\', then search for \\'L\\' on the right side\\n                while(i<n && d[i] == \\'R\\'){//to reduce redundancy, just traverse all the run of \\'R\\'s.\\n                    ans[i] = \\'R\\';//also keep on updating the \\'R\\' given in the original string\\n                    i++;\\n                }\\n                prev = i;\\n                while(i<n && d[i] == \\'.\\')i++;\\n                if((i<n && d[i] == \\'R\\') || i == n){\\n                    //we encountered another \\'R\\', or reached the end, so update all the \\'.\\'s to \\'R\\' as no collision\\n                    while(prev < i)\\n                        ans[prev++] = \\'R\\';\\n                }\\n                else if(i<n && d[i] == \\'L\\'){\\n                    int p1 = i-1;\\n                    //we encountered an \\'L\\', so using two pointers, update R and L, as long as the pointers don\\'t collide\\n                    while(prev < p1){\\n                        ans[prev++] = \\'R\\';\\n                        ans[p1--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            prev = i;\\n        }\\n        return  ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nstring pushDominoes(string d) {\\n        int n = d.size(), i = 0, prev = 0;\\n        string ans(n, \\'.\\');//initialize ans with \\'.\\'s\\n        while(i<n){\\n            while(i<n && d[i] == \\'.\\')i++;\\n            if(i<n && d[i] == \\'L\\'){\\n                //if encountered an L first, then update from prev to this position all as \\'L\\'\\n                while(prev <= i)\\n                    ans[prev++] = \\'L\\';\\n                i++;\\n            }\\n            else if(i<n && d[i] == \\'R\\'){\\n                //if encountered an \\'R\\', then search for \\'L\\' on the right side\\n                while(i<n && d[i] == \\'R\\'){//to reduce redundancy, just traverse all the run of \\'R\\'s.\\n                    ans[i] = \\'R\\';//also keep on updating the \\'R\\' given in the original string\\n                    i++;\\n                }\\n                prev = i;\\n                while(i<n && d[i] == \\'.\\')i++;\\n                if((i<n && d[i] == \\'R\\') || i == n){\\n                    //we encountered another \\'R\\', or reached the end, so update all the \\'.\\'s to \\'R\\' as no collision\\n                    while(prev < i)\\n                        ans[prev++] = \\'R\\';\\n                }\\n                else if(i<n && d[i] == \\'L\\'){\\n                    int p1 = i-1;\\n                    //we encountered an \\'L\\', so using two pointers, update R and L, as long as the pointers don\\'t collide\\n                    while(prev < p1){\\n                        ans[prev++] = \\'R\\';\\n                        ans[p1--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            prev = i;\\n        }\\n        return  ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629342,
                "title": "python-solution-o-n-comments",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        left=[0]*n\\n        right=[0]*n\\n        \\n        # traverse from left side \\n        # keep count of \\'R\\' occurennces\\n        count=0\\n        for i in range(n):\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                count=0\\n            left[i]=count\\n            if dominoes[i]==\\'R\\' or count!=0:\\n                count+=1\\n        \\n        # traverse from right side \\n        # keep count of \\'L\\' occurennces\\n        count=0\\n        for i in range(n-1, -1, -1):\\n            if dominoes[i]==\\'R\\' or dominoes[i]==\\'L\\':\\n                count=0\\n            right[i]=count\\n            if dominoes[i]==\\'L\\' or count!=0:\\n                count+=1\\n            \\n        # print(left)\\n        # print(right)\\n        \\n        # formulate ans based on occurence count of \\'L\\' and \\'R\\'\\n        ans=\\'\\'\\n        for i in range(n):\\n            if left[i]==right[i]:\\n                ans+=dominoes[i]\\n            else:\\n                if left[i]==0 and right[i]!=0:\\n                    ans+=\\'L\\'\\n                elif right[i]==0 and left[i]!=0:\\n                    ans+=\\'R\\'\\n                elif left[i]>right[i]:\\n                    ans+=\\'L\\'\\n                else:\\n                    ans+=\\'R\\'\\n        \\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        left=[0]*n\\n        right=[0]*n\\n        \\n        # traverse from left side \\n        # keep count of \\'R\\' occurennces\\n        count=0\\n        for i in range(n):\\n            if dominoes[i]==\\'L\\' or dominoes[i]==\\'R\\':\\n                count=0\\n            left[i]=count\\n            if dominoes[i]==\\'R\\' or count!=0:\\n                count+=1\\n        \\n        # traverse from right side \\n        # keep count of \\'L\\' occurennces\\n        count=0\\n        for i in range(n-1, -1, -1):\\n            if dominoes[i]==\\'R\\' or dominoes[i]==\\'L\\':\\n                count=0\\n            right[i]=count\\n            if dominoes[i]==\\'L\\' or count!=0:\\n                count+=1\\n            \\n        # print(left)\\n        # print(right)\\n        \\n        # formulate ans based on occurence count of \\'L\\' and \\'R\\'\\n        ans=\\'\\'\\n        for i in range(n):\\n            if left[i]==right[i]:\\n                ans+=dominoes[i]\\n            else:\\n                if left[i]==0 and right[i]!=0:\\n                    ans+=\\'L\\'\\n                elif right[i]==0 and left[i]!=0:\\n                    ans+=\\'R\\'\\n                elif left[i]>right[i]:\\n                    ans+=\\'L\\'\\n                else:\\n                    ans+=\\'R\\'\\n        \\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629115,
                "title": "cpp-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        \\n        string ans = dom;\\n        queue<pair<int,char>>dq;\\n        \\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i] != \\'.\\')\\n            {\\n                dq.push({i,ans[i]});\\n            }\\n        }\\n        \\n        while(!dq.empty())\\n        {\\n            int i = dq.front().first;\\n            int d = dq.front().second;\\n            dq.pop();\\n            if(d == \\'L\\' and i > 0 and ans[i-1] == \\'.\\')\\n            {\\n                dq.push({i-1,\\'L\\'});\\n                ans[i-1] = \\'L\\';\\n            }\\n            else if(d == \\'R\\')\\n            {\\n                if(i+1 < ans.length() and ans[i+1] == \\'.\\')\\n                {\\n                    if(i+2 < ans.length() and ans[i+2] == \\'L\\')\\n                    {\\n                        dq.pop();\\n                    }\\n                    else{\\n                        dq.push({i+1,\\'R\\'});\\n                        ans[i+1] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        \\n        string ans = dom;\\n        queue<pair<int,char>>dq;\\n        \\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(ans[i] != \\'.\\')\\n            {\\n                dq.push({i,ans[i]});\\n            }\\n        }\\n        \\n        while(!dq.empty())\\n        {\\n            int i = dq.front().first;\\n            int d = dq.front().second;\\n            dq.pop();\\n            if(d == \\'L\\' and i > 0 and ans[i-1] == \\'.\\')\\n            {\\n                dq.push({i-1,\\'L\\'});\\n                ans[i-1] = \\'L\\';\\n            }\\n            else if(d == \\'R\\')\\n            {\\n                if(i+1 < ans.length() and ans[i+1] == \\'.\\')\\n                {\\n                    if(i+2 < ans.length() and ans[i+2] == \\'L\\')\\n                    {\\n                        dq.pop();\\n                    }\\n                    else{\\n                        dq.push({i+1,\\'R\\'});\\n                        ans[i+1] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628823,
                "title": "c-explaination-concise-code",
                "content": "**Observations**:\\nThe observations are for indices with **dominoes[i]==\\'.\\'**\\n1. the nearest dominoes on left and right determines the direction of fall\\n2. on the left side , if nearest domino is a \\'R\\' , then it is valid\\n3. On the right side , if nearest domino is a \\'L\\', then it  is valid\\n4.  If both sides have valid and different distance dominoes , min-dist domino decides the direction\\n5.  Else if a single side contains a valid domino , that directon decides\\n6.  In all other case the dominos[i] is unchanged\\n\\n**Time:O(n)**\\n**Space:O(n)**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n       int n=dominoes.size();\\n        \\n       vector<int> left(n,-1) , right(n);\\n       for(int i=0;i<n;i++){\\n           //nearest left domino\\n           if(dominoes[i] != \\'.\\') left[i] = i;\\n           else left[i] = (i-1 >= 0)?left[i-1]:-1;\\n           \\n           //nearest right domino\\n           if(dominoes[n-i-1] !=\\'.\\') right[n-i-1]=n-i-1;\\n           else right[n-i-1] = (n-i < n)?right[n-i]:n;\\n       }\\n        \\n        \\n       for(int i=0;i<n;i++){\\n           if(dominoes[i]!=\\'.\\') continue;\\n           \\n\\t\\t  //for invalid domino we use INT_MAX , so we can disacrd it while taking min\\n           int left_power = (left[i]==-1 or dominoes[left[i]]==\\'L\\')?INT_MAX:i-left[i];\\n           int right_power = (right[i]==n or dominoes[right[i]]==\\'R\\')?INT_MAX:right[i]-i;\\n           \\n           if(left_power != right_power){\\n               dominoes[i] = (left_power < right_power)?\\'R\\':\\'L\\';\\n           }\\n           \\n       }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n       int n=dominoes.size();\\n        \\n       vector<int> left(n,-1) , right(n);\\n       for(int i=0;i<n;i++){\\n           //nearest left domino\\n           if(dominoes[i] != \\'.\\') left[i] = i;\\n           else left[i] = (i-1 >= 0)?left[i-1]:-1;\\n           \\n           //nearest right domino\\n           if(dominoes[n-i-1] !=\\'.\\') right[n-i-1]=n-i-1;\\n           else right[n-i-1] = (n-i < n)?right[n-i]:n;\\n       }\\n        \\n        \\n       for(int i=0;i<n;i++){\\n           if(dominoes[i]!=\\'.\\') continue;\\n           \\n\\t\\t  //for invalid domino we use INT_MAX , so we can disacrd it while taking min\\n           int left_power = (left[i]==-1 or dominoes[left[i]]==\\'L\\')?INT_MAX:i-left[i];\\n           int right_power = (right[i]==n or dominoes[right[i]]==\\'R\\')?INT_MAX:right[i]-i;\\n           \\n           if(left_power != right_power){\\n               dominoes[i] = (left_power < right_power)?\\'R\\':\\'L\\';\\n           }\\n           \\n       }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628799,
                "title": "java-solution-easy-understanding-comments",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n      \\n        // ex: .L.R...LR..L..\\n        // create two arrays: one corresponding to left to right momentum and one for right to left momentum\\n        // left to right: if we are on a \\'.\\' and we see a \\'R\\' to the left of us, we need to add 1 to our current momentum\\n        // right to left: if we are on a \\'.\\' and we see a \\'L\\' to the right of us, we need to add 1 to our current momentum\\n\\t\\t// note:  array values are initially 0 at each index and the current momentum can be found by looking at the previous index\\n        // 0, 0, 0, 0, 1, 2, 3, 0, 0, 1, 2, 0, 0, 0 -> left to right (loop the dominoes string from left to right)\\n        // 1, 0, 0, 0, 3, 2, 1, 0, 0, 2, 1, 0, 0, 0 -> right to left (loop the dominoes string from right to left)\\n        \\n        // finally loop over the length of the arrays: \\n\\t\\t// if both arrays contain the same momentum value, keep the original character found in dominoes string\\n        // if one of the arrays contains a momentum of 0, choose the letter corresponding to the other array\\n        // both momentums are non zero values, choose the letter corresponding to the array of the smallest value\\n\\t\\t// note:  left to right array corresponds to setting the \\'R\\' character, the opposite is true for the right to left array\\n        \\n        StringBuilder result = new StringBuilder();\\n        int[] ltr = new int[dominoes.length()]; // momentum going from left to right\\n        int[] rtl = new int[dominoes.length()]; // momentum going from right to left\\n        \\n        // left to right momentum \\n        for (int i = 1; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i - 1) == \\'R\\' || ltr[i - 1] > 0)) {\\n                \\n                ltr[i] = ltr[i - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        // right to left momentum\\n        for (int i = dominoes.length() - 2; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i + 1) == \\'L\\' || rtl[i + 1] > 0)) {\\n                \\n                rtl[i] = rtl[i + 1] + 1;\\n            }\\n        }\\n        \\n        \\n        // compute the result by looking at both arrays and taking the smallest momentum value that is non zero\\n        // note:  original value from dominoes will remain for equal momentums\\n        for(int i = 0; i < dominoes.length(); i++) {\\n            if (ltr[i] == rtl[i]) {\\n                result.append(dominoes.charAt(i));\\n            } else if (ltr[i] == 0 || rtl[i] == 0) {\\n                // take the non zero\\n                if (ltr[i] == 0) {\\n                    result.append(\"L\");\\n                } else {\\n                    result.append(\"R\");\\n                }\\n            } else {\\n                // take the smallest value\\n                if (ltr[i] < rtl[i]) {\\n                    result.append(\"R\");\\n                } else {\\n                    result.append(\"L\");\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n      \\n        // ex: .L.R...LR..L..\\n        // create two arrays: one corresponding to left to right momentum and one for right to left momentum\\n        // left to right: if we are on a \\'.\\' and we see a \\'R\\' to the left of us, we need to add 1 to our current momentum\\n        // right to left: if we are on a \\'.\\' and we see a \\'L\\' to the right of us, we need to add 1 to our current momentum\\n\\t\\t// note:  array values are initially 0 at each index and the current momentum can be found by looking at the previous index\\n        // 0, 0, 0, 0, 1, 2, 3, 0, 0, 1, 2, 0, 0, 0 -> left to right (loop the dominoes string from left to right)\\n        // 1, 0, 0, 0, 3, 2, 1, 0, 0, 2, 1, 0, 0, 0 -> right to left (loop the dominoes string from right to left)\\n        \\n        // finally loop over the length of the arrays: \\n\\t\\t// if both arrays contain the same momentum value, keep the original character found in dominoes string\\n        // if one of the arrays contains a momentum of 0, choose the letter corresponding to the other array\\n        // both momentums are non zero values, choose the letter corresponding to the array of the smallest value\\n\\t\\t// note:  left to right array corresponds to setting the \\'R\\' character, the opposite is true for the right to left array\\n        \\n        StringBuilder result = new StringBuilder();\\n        int[] ltr = new int[dominoes.length()]; // momentum going from left to right\\n        int[] rtl = new int[dominoes.length()]; // momentum going from right to left\\n        \\n        // left to right momentum \\n        for (int i = 1; i < dominoes.length(); i++) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i - 1) == \\'R\\' || ltr[i - 1] > 0)) {\\n                \\n                ltr[i] = ltr[i - 1] + 1;\\n            }\\n            \\n        }\\n        \\n        // right to left momentum\\n        for (int i = dominoes.length() - 2; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'.\\' \\n                && (dominoes.charAt(i + 1) == \\'L\\' || rtl[i + 1] > 0)) {\\n                \\n                rtl[i] = rtl[i + 1] + 1;\\n            }\\n        }\\n        \\n        \\n        // compute the result by looking at both arrays and taking the smallest momentum value that is non zero\\n        // note:  original value from dominoes will remain for equal momentums\\n        for(int i = 0; i < dominoes.length(); i++) {\\n            if (ltr[i] == rtl[i]) {\\n                result.append(dominoes.charAt(i));\\n            } else if (ltr[i] == 0 || rtl[i] == 0) {\\n                // take the non zero\\n                if (ltr[i] == 0) {\\n                    result.append(\"L\");\\n                } else {\\n                    result.append(\"R\");\\n                }\\n            } else {\\n                // take the smallest value\\n                if (ltr[i] < rtl[i]) {\\n                    result.append(\"R\");\\n                } else {\\n                    result.append(\"L\");\\n                }\\n            }\\n        }\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108778,
                "title": "c-simple-clean-and-well-commented-easy-to-understand-two-pointers",
                "content": "I have explained the code in the comments, easy to understand.\\n``` \\nclass Solution {\\npublic:\\n    //adding L and R at ends do not change the configuration\\n    //we have to divide the total string into parts, thats why adding L and R at ends for cases like ...L..R...\\n    //parts can be : L...L , R...R, L...R, R...L\\n    //L...L->all dots inside it will become L\\n    //R...R-> all dots inside it  will become R\\n    //L...R-> all dots remains unchanged\\n    //R...L->if dots are even then half R half L\\n    //else mid remains unchanged and one half R and other half L\\n    void solvefor(vector<char>&arr,int i,int j)\\n    {\\n        // i and j are pointer pointing to L or R in the parititon L/R...R/L\\n        //now check for all the 4 conditions\\n        \\n        //case 1 L....L , convert all to L \\n        if(arr[i]==\\'L\\' && arr[j]==\\'L\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'L\\';\\n            }\\n        }\\n        //case 2 R....R, convert all to R\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'R\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'R\\';\\n            }\\n        }\\n        \\n        //case 3 L...R, no change in middle;\\n        else if(arr[i]==\\'L\\' && arr[j]==\\'R\\')\\n        {\\n            //nothing to do\\n        }\\n        \\n        //case 4 R...L,check . are even or odd and do accordingly\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'L\\')\\n        {\\n            int diff=j-i;\\n            int mid=(j+i)/2;\\n            //case of odd dots, as positions are shifted\\n            if(diff%2==0)\\n            {\\n               for(int k=i+1;k<mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n            //case of even number of . so R....L converts to RRRLLL\\n            else\\n            {\\n                for(int k=i+1;k<=mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n        }\\n        \\n    }\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<char>arr(n+2);\\n        arr[0]=\\'L\\';\\n        arr[n+1]=\\'R\\';\\n        //L 1-String-n-2 R\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            arr[i]=dominoes[i-1];\\n            // cout<<arr[i];\\n        }\\n        \\n        int j=0;\\n        int k =1;\\n        //j->Lk->...L...R..LR..R -> K counts number of \\'.\\' and stops on L or R\\n        //in above case j will be at L and K will be at L so solve for L...L\\n        while(k<arr.size())\\n        {\\n            while(arr[k]==\\'.\\')\\n            {\\n                k++;\\n            }\\n            //solve only for cases like L...L , not for LL\\n            if(k-j>1)\\n            {\\n                solvefor(arr,j,k);\\n            }\\n            j=k;\\n            k++;\\n        }\\n        string ans=\"\";\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n}; \\n```\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    //adding L and R at ends do not change the configuration\\n    //we have to divide the total string into parts, thats why adding L and R at ends for cases like ...L..R...\\n    //parts can be : L...L , R...R, L...R, R...L\\n    //L...L->all dots inside it will become L\\n    //R...R-> all dots inside it  will become R\\n    //L...R-> all dots remains unchanged\\n    //R...L->if dots are even then half R half L\\n    //else mid remains unchanged and one half R and other half L\\n    void solvefor(vector<char>&arr,int i,int j)\\n    {\\n        // i and j are pointer pointing to L or R in the parititon L/R...R/L\\n        //now check for all the 4 conditions\\n        \\n        //case 1 L....L , convert all to L \\n        if(arr[i]==\\'L\\' && arr[j]==\\'L\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'L\\';\\n            }\\n        }\\n        //case 2 R....R, convert all to R\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'R\\')\\n        {\\n            for(int k=i+1;k<j;k++)\\n            {\\n                arr[k]=\\'R\\';\\n            }\\n        }\\n        \\n        //case 3 L...R, no change in middle;\\n        else if(arr[i]==\\'L\\' && arr[j]==\\'R\\')\\n        {\\n            //nothing to do\\n        }\\n        \\n        //case 4 R...L,check . are even or odd and do accordingly\\n        else if(arr[i]==\\'R\\' && arr[j]==\\'L\\')\\n        {\\n            int diff=j-i;\\n            int mid=(j+i)/2;\\n            //case of odd dots, as positions are shifted\\n            if(diff%2==0)\\n            {\\n               for(int k=i+1;k<mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n            //case of even number of . so R....L converts to RRRLLL\\n            else\\n            {\\n                for(int k=i+1;k<=mid;k++)\\n               {\\n                   arr[k]=\\'R\\';\\n               }\\n                for(int k=mid+1;k<j;k++)  \\n                {\\n                   arr[k]=\\'L\\'; \\n                }\\n            }\\n        }\\n        \\n    }\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        vector<char>arr(n+2);\\n        arr[0]=\\'L\\';\\n        arr[n+1]=\\'R\\';\\n        //L 1-String-n-2 R\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            arr[i]=dominoes[i-1];\\n            // cout<<arr[i];\\n        }\\n        \\n        int j=0;\\n        int k =1;\\n        //j->Lk->...L...R..LR..R -> K counts number of \\'.\\' and stops on L or R\\n        //in above case j will be at L and K will be at L so solve for L...L\\n        while(k<arr.size())\\n        {\\n            while(arr[k]==\\'.\\')\\n            {\\n                k++;\\n            }\\n            //solve only for cases like L...L , not for LL\\n            if(k-j>1)\\n            {\\n                solvefor(arr,j,k);\\n            }\\n            j=k;\\n            k++;\\n        }\\n        string ans=\"\";\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            ans+=arr[i];\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "C++"
            },
            {
                "id": 1354390,
                "title": "c-3-approaches-commented-like-a-story-line-by-line-for-easy-understanding",
                "content": "```\\n//Approach-1 (O(n) time : Two Pointer Technique)\\n/*\\n\\tIn this approach, you just need to find sections like this\\n\\tX .   .   .   . X\\n\\ti                j\\n\\tWhere X can be \\'R\\' or \\'L\\' and in between there can be as many dots\\n\\tNow,\\n\\t- you know the length of mid part\\n\\t- If char[i] == char[j] == \\'R\\', means all go towards right (R)\\n\\t-  char[i]  == char[j] == \\'L\\', means all go towards Left (L)\\n\\t-  If char[i] = \\'L\\' and char[j] = \\'R\\', means middle part is not affected so the remain \\'.\\'\\n\\t-  If char[i] = \\'R\\' and char[j] = \\'L\\', then it will affect the middle part.\\n\\t   The middle_part/2 close to i will be affected by \\'R\\' and middle_part/2 close to j will be   \\n\\t   effected by \\'L\\'  and the last mid point (middle_part%2) will be unaffected due to equal  \\n\\t   force from left and right so it remains \\'.\\'\\n*/\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string s = \"L\" + dominoes + \"R\";\\n        int n    = s.length();\\n        string result = \"\";\\n        for(int i = 0, j = 1; j<n; j++) {\\n            if(s[j] == \\'.\\') continue;\\n            \\n            int midPartLength = j-i-1;\\n            if(i > 0)\\n                result.push_back(s[i]);\\n            \\n            if(s[i] == s[j])\\n                result += string(midPartLength, s[i]);\\n            else if(s[i] == \\'L\\' && s[j] == \\'R\\')\\n                result += string(midPartLength, \\'.\\');\\n            else\\n                result += string(midPartLength/2, \\'R\\') + string(midPartLength%2, \\'.\\') + string(midPartLength/2, \\'L\\');\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (O(n) time : Finding closest \\'L\\' and closest \\'R\\')\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> rightClosestL(n);\\n        vector<int> leftClosestR(n);\\n        \\n        //Moving right to left to find rightClosestL\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                rightClosestL[i] = i; //L starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                rightClosestL[i] = i < n-1 ? rightClosestL[i+1] : -1;\\n            else\\n                rightClosestL[i] = -1;\\n        }\\n        \\n        //Moving left to right to find leftClosestR\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                leftClosestR[i] = i; //R starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                leftClosestR[i] = i > 0 ? leftClosestR[i-1] : -1;\\n            else\\n                leftClosestR[i] = -1;\\n        }\\n        \\n        string result(n, \\' \\');\\n        \\n        for(int i = 0; i<n; i++) {\\n            int distRightL = abs(i-rightClosestL[i]); //distance from \\'R\\' towards my left direction\\n            int distLeftR  = abs(i-leftClosestR[i]);  //distance from \\'L\\' towards my right direction\\n            \\n            if(rightClosestL[i] == leftClosestR[i])\\n                result[i] = \\'.\\';\\n            else if(rightClosestL[i] == -1)  //No force from right direction towards left, so move R\\n                result[i] = \\'R\\';\\n            else if(leftClosestR[i] == -1)   //No force from left direction towards right, so move L\\n                result[i] = \\'L\\';\\n            else if(distLeftR == distRightL) //Equal force from left and right\\n                result[i] = \\'.\\';\\n            else\\n                result[i] = distRightL < distLeftR ? \\'L\\': \\'R\\'; //which ever force is greater (either from left by \\'R\\' or from right by \\'L\\') i.e. whichever is closer wins\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (O(n) time : Using Force Simulation)\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> forces(n);\\n        \\n        //Move from left to right and look for right force \\'R\\'\\n        int force = 0; //initially\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                force = n; //My max power towards Right starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'L\\')\\n                force = 0; //I can\\'t give force towards Right :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] = force;\\n        }\\n        \\n        //Move from right to left and look for left force \\'L\\'\\n        force = 0; //initially\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                force = n; //My max power towards Left starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'R\\')\\n                force = 0; //I can\\'t give force towards Left :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] -= force; //resultant force (that\\'s why I am subtracting)\\n        }\\n        \\n        //Now I will find resultant direction on each domino basis of resultant force on them\\n        string result(n ,\\' \\');\\n        for(int i = 0; i<n; i++) {\\n            if(forces[i] < 0)\\n                result[i] = \\'L\\';\\n            else if(forces[i] > 0)\\n                result[i] = \\'R\\';\\n            else\\n                result[i] = \\'.\\';\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (O(n) time : Two Pointer Technique)\\n/*\\n\\tIn this approach, you just need to find sections like this\\n\\tX .   .   .   . X\\n\\ti                j\\n\\tWhere X can be \\'R\\' or \\'L\\' and in between there can be as many dots\\n\\tNow,\\n\\t- you know the length of mid part\\n\\t- If char[i] == char[j] == \\'R\\', means all go towards right (R)\\n\\t-  char[i]  == char[j] == \\'L\\', means all go towards Left (L)\\n\\t-  If char[i] = \\'L\\' and char[j] = \\'R\\', means middle part is not affected so the remain \\'.\\'\\n\\t-  If char[i] = \\'R\\' and char[j] = \\'L\\', then it will affect the middle part.\\n\\t   The middle_part/2 close to i will be affected by \\'R\\' and middle_part/2 close to j will be   \\n\\t   effected by \\'L\\'  and the last mid point (middle_part%2) will be unaffected due to equal  \\n\\t   force from left and right so it remains \\'.\\'\\n*/\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string s = \"L\" + dominoes + \"R\";\\n        int n    = s.length();\\n        string result = \"\";\\n        for(int i = 0, j = 1; j<n; j++) {\\n            if(s[j] == \\'.\\') continue;\\n            \\n            int midPartLength = j-i-1;\\n            if(i > 0)\\n                result.push_back(s[i]);\\n            \\n            if(s[i] == s[j])\\n                result += string(midPartLength, s[i]);\\n            else if(s[i] == \\'L\\' && s[j] == \\'R\\')\\n                result += string(midPartLength, \\'.\\');\\n            else\\n                result += string(midPartLength/2, \\'R\\') + string(midPartLength%2, \\'.\\') + string(midPartLength/2, \\'L\\');\\n            i = j;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (O(n) time : Finding closest \\'L\\' and closest \\'R\\')\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> rightClosestL(n);\\n        vector<int> leftClosestR(n);\\n        \\n        //Moving right to left to find rightClosestL\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                rightClosestL[i] = i; //L starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                rightClosestL[i] = i < n-1 ? rightClosestL[i+1] : -1;\\n            else\\n                rightClosestL[i] = -1;\\n        }\\n        \\n        //Moving left to right to find leftClosestR\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                leftClosestR[i] = i; //R starts from me\\n            else if(dominoes[i] == \\'.\\')\\n                leftClosestR[i] = i > 0 ? leftClosestR[i-1] : -1;\\n            else\\n                leftClosestR[i] = -1;\\n        }\\n        \\n        string result(n, \\' \\');\\n        \\n        for(int i = 0; i<n; i++) {\\n            int distRightL = abs(i-rightClosestL[i]); //distance from \\'R\\' towards my left direction\\n            int distLeftR  = abs(i-leftClosestR[i]);  //distance from \\'L\\' towards my right direction\\n            \\n            if(rightClosestL[i] == leftClosestR[i])\\n                result[i] = \\'.\\';\\n            else if(rightClosestL[i] == -1)  //No force from right direction towards left, so move R\\n                result[i] = \\'R\\';\\n            else if(leftClosestR[i] == -1)   //No force from left direction towards right, so move L\\n                result[i] = \\'L\\';\\n            else if(distLeftR == distRightL) //Equal force from left and right\\n                result[i] = \\'.\\';\\n            else\\n                result[i] = distRightL < distLeftR ? \\'L\\': \\'R\\'; //which ever force is greater (either from left by \\'R\\' or from right by \\'L\\') i.e. whichever is closer wins\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-3 (O(n) time : Using Force Simulation)\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        \\n        vector<int> forces(n);\\n        \\n        //Move from left to right and look for right force \\'R\\'\\n        int force = 0; //initially\\n        for(int i = 0; i<n; i++) {\\n            if(dominoes[i] == \\'R\\')\\n                force = n; //My max power towards Right starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'L\\')\\n                force = 0; //I can\\'t give force towards Right :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] = force;\\n        }\\n        \\n        //Move from right to left and look for left force \\'L\\'\\n        force = 0; //initially\\n        for(int i = n-1; i>=0; i--) {\\n            if(dominoes[i] == \\'L\\')\\n                force = n; //My max power towards Left starts from here and it will decrease as I progress\\n            else if(dominoes[i] == \\'R\\')\\n                force = 0; //I can\\'t give force towards Left :-(\\n            else\\n                force = max(force-1, 0); //I told ya, my power decreases as I progress and hit a \\'.\\'\\n            \\n            forces[i] -= force; //resultant force (that\\'s why I am subtracting)\\n        }\\n        \\n        //Now I will find resultant direction on each domino basis of resultant force on them\\n        string result(n ,\\' \\');\\n        for(int i = 0; i<n; i++) {\\n            if(forces[i] < 0)\\n                result[i] = \\'L\\';\\n            else if(forces[i] > 0)\\n                result[i] = \\'R\\';\\n            else\\n                result[i] = \\'.\\';\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352428,
                "title": "python-push-dominoes-really-simple-solution-o-n",
                "content": "Fully annotated code below but the idea behind it is:\\n - if we have no \\'collisions\\' then the dots in the middle will all be the same e.g. \\'L.....L\\' - all the dots will be \\'L\\', and vice versa for \\'R......R\\' all being \\'R\\'\\n - if we have a collision, then we attribute the dots in the middle evenly between \\'R\\' and \\'L\\' i.e. \\'R....L\\' becomes \\'RRRLLL\\'\\n - if we have a collision with an odd number of \\'.\\' then the middle element remains a \\'.\\'\\n - if we never have a collision e.g. \\'L....R\\' then we keep all the dots\\n\\nThe above allows us to walk through the array just once and add on what we need as we go.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n\\t\\n        # init ans\\n        answer = \\'\\'\\n        # set up so we don\\'t need to worry about ends of loop\\n        dom = \\'L\\' + dominoes + \\'R\\'\\n        # trailing var of last non dot, to help us populate large swathes\\n        prev = 0\\n        for i in range(1, len(dom)):\\n            # if this element is a \\'.\\', then we don\\'t know what to do with it yet\\n            # so let\\'s just continue iterating on to the next element\\n            if dom[i] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\n            # if we are here then the current element is not a \\'.\\'\\n            # let\\'s update a var j to keep track of how many \\'.\\' we have passed\\n            j = i - prev - 1\\n\\t\\t\\t\\n            # now we add on the previous element to the answer\\n            # if still zero then we don\\'t add\\n            # this prevents adding on the \\'L\\' we added to dom\\n            # also this won\\'t get called for the final \\'R\\' we added as only prev\\n            if prev:\\n                answer += dom[prev]\\n\\t\\t\\t\\t\\n            # now let\\'s check if we have no conflict\\n            # e.g. if we had \\'L.....L\\' then we need to add on 5 L\\'s (also same for \\'R.....R\\')\\n            # the first \\'L\\' got appended in the above step of adding prev\\n            # and the next \\'L\\' will get appended in the next step\\n            if dom[prev] == dom[i]:\\n                answer += dom[prev]*j\\n\\t\\t\\t\\t\\n            # now what about the opposite\\n            # e.g. we have \\'L.....R\\' then we would never populate the middle\\n            # so we need to add on 5 \\'.\\'\\n            elif dom[prev] == \\'L\\' and dom[i] == \\'R\\':\\n                answer += \\'.\\'*j\\n\\t\\t\\t\\t\\n            # else we must be in a sitch where we have:\\n            # e.g. \\'R....L\\' and they collide\\n            # if we have an even number then we add on m/2 R then m/2 L\\n            # if we have an odd number then the middle element must be a \\'.\\'\\n            else:\\n                answer += \\'R\\'*(j//2) + \\'.\\'*(j%2) + \\'L\\'*(j//2)\\n\\t\\t\\t\\t\\n            # update our trailing var as this iteration the element was not \\'.\\'\\n            prev=i\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n\\t\\n        # init ans\\n        answer = \\'\\'\\n        # set up so we don\\'t need to worry about ends of loop\\n        dom = \\'L\\' + dominoes + \\'R\\'\\n        # trailing var of last non dot, to help us populate large swathes\\n        prev = 0\\n        for i in range(1, len(dom)):\\n            # if this element is a \\'.\\', then we don\\'t know what to do with it yet\\n            # so let\\'s just continue iterating on to the next element\\n            if dom[i] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\n            # if we are here then the current element is not a \\'.\\'\\n            # let\\'s update a var j to keep track of how many \\'.\\' we have passed\\n            j = i - prev - 1\\n\\t\\t\\t\\n            # now we add on the previous element to the answer\\n            # if still zero then we don\\'t add\\n            # this prevents adding on the \\'L\\' we added to dom\\n            # also this won\\'t get called for the final \\'R\\' we added as only prev\\n            if prev:\\n                answer += dom[prev]\\n\\t\\t\\t\\t\\n            # now let\\'s check if we have no conflict\\n            # e.g. if we had \\'L.....L\\' then we need to add on 5 L\\'s (also same for \\'R.....R\\')\\n            # the first \\'L\\' got appended in the above step of adding prev\\n            # and the next \\'L\\' will get appended in the next step\\n            if dom[prev] == dom[i]:\\n                answer += dom[prev]*j\\n\\t\\t\\t\\t\\n            # now what about the opposite\\n            # e.g. we have \\'L.....R\\' then we would never populate the middle\\n            # so we need to add on 5 \\'.\\'\\n            elif dom[prev] == \\'L\\' and dom[i] == \\'R\\':\\n                answer += \\'.\\'*j\\n\\t\\t\\t\\t\\n            # else we must be in a sitch where we have:\\n            # e.g. \\'R....L\\' and they collide\\n            # if we have an even number then we add on m/2 R then m/2 L\\n            # if we have an odd number then the middle element must be a \\'.\\'\\n            else:\\n                answer += \\'R\\'*(j//2) + \\'.\\'*(j%2) + \\'L\\'*(j//2)\\n\\t\\t\\t\\t\\n            # update our trailing var as this iteration the element was not \\'.\\'\\n            prev=i\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083991,
                "title": "java-solution-two-pointers-beat-99",
                "content": "```\\n// Time complexity: O(N)\\n// Space complexity: O(N), where N is the length of input string\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // ask whether dominoes could be null\\n        final int N = dominoes.length();\\n        if (N <= 1) return dominoes;\\n        char[] res = dominoes.toCharArray();\\n        int i = 0;\\n        while (i < N) {\\n            if (res[i] == \\'.\\') {\\n                i++;\\n            } else if (res[i] == \\'L\\') {  // push left\\n                int j = i-1;\\n                while (j >= 0 && res[j] == \\'.\\') {\\n                    res[j--] = \\'L\\';\\n                }\\n                i++;\\n            } else { // res[i] == \\'R\\'\\n                int j = i+1;\\n                while (j < N && res[j] == \\'.\\') { // try to find \\'R\\' or \\'L\\' in the right side\\n                    j++;\\n                }\\n                if (j < N && res[j] == \\'L\\') { // if found \\'L\\', push left and right\\n                    for (int l = i+1, r = j-1; l < r; l++, r--) {\\n                        res[l] = \\'R\\';\\n                        res[r] = \\'L\\';\\n                    }\\n                    i = j + 1;\\n                } else {  // if no \\'L\\', push right\\n                    while (i < j) {\\n                        res[i++] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        return String.valueOf(res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity: O(N)\\n// Space complexity: O(N), where N is the length of input string\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // ask whether dominoes could be null\\n        final int N = dominoes.length();\\n        if (N <= 1) return dominoes;\\n        char[] res = dominoes.toCharArray();\\n        int i = 0;\\n        while (i < N) {\\n            if (res[i] == \\'.\\') {\\n                i++;\\n            } else if (res[i] == \\'L\\') {  // push left\\n                int j = i-1;\\n                while (j >= 0 && res[j] == \\'.\\') {\\n                    res[j--] = \\'L\\';\\n                }\\n                i++;\\n            } else { // res[i] == \\'R\\'\\n                int j = i+1;\\n                while (j < N && res[j] == \\'.\\') { // try to find \\'R\\' or \\'L\\' in the right side\\n                    j++;\\n                }\\n                if (j < N && res[j] == \\'L\\') { // if found \\'L\\', push left and right\\n                    for (int l = i+1, r = j-1; l < r; l++, r--) {\\n                        res[l] = \\'R\\';\\n                        res[r] = \\'L\\';\\n                    }\\n                    i = j + 1;\\n                } else {  // if no \\'L\\', push right\\n                    while (i < j) {\\n                        res[i++] = \\'R\\';\\n                    }\\n                }\\n            }\\n        }\\n        return String.valueOf(res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767282,
                "title": "c-brutally-nested-o-n-solution-98",
                "content": "This is essentially solution 1 of the editorial, just written in C++\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int start = 0;\\n        int l = 0;\\n        string ans = s;\\n        for(int i=0; i<s.size(); i++) {\\n            if (l == 0 && s[i] == \\'.\\') {\\n                start = i;\\n                l++;\\n            } else if ( l > 0 && s[i] == \\'.\\') {\\n                l++;\\n            } else if (s[i] != \\'.\\' && l > 0) {\\n                if (start == 0) {\\n                    if (s[start+l] == \\'L\\') for(int i=start; i<start+l; i++) s[i] = \\'L\\';\\n                } else {\\n                    if (s[start-1] == s[start+l]) {\\n                        for(int i=start; i<start+l; i++) s[i] = s[start-1];\\n                    }\\n                    else {\\n                        if (l&1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>start + l/2; i--) s[i] =\\'L\\';\\n                        }else if ((l&1)^1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<=start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>=start + l/2; i--) s[i] =\\'L\\';\\n                        }\\n                    }\\n                }\\n                l = 0;\\n                start = -1;\\n            }\\n        }\\n        // last part\\n        if (l > 0) {\\n            if (start != 0 && s[start-1] == \\'R\\') {\\n                for(int i=start; i<start + l; i++) {\\n                    s[i] = \\'R\\';\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int start = 0;\\n        int l = 0;\\n        string ans = s;\\n        for(int i=0; i<s.size(); i++) {\\n            if (l == 0 && s[i] == \\'.\\') {\\n                start = i;\\n                l++;\\n            } else if ( l > 0 && s[i] == \\'.\\') {\\n                l++;\\n            } else if (s[i] != \\'.\\' && l > 0) {\\n                if (start == 0) {\\n                    if (s[start+l] == \\'L\\') for(int i=start; i<start+l; i++) s[i] = \\'L\\';\\n                } else {\\n                    if (s[start-1] == s[start+l]) {\\n                        for(int i=start; i<start+l; i++) s[i] = s[start-1];\\n                    }\\n                    else {\\n                        if (l&1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>start + l/2; i--) s[i] =\\'L\\';\\n                        }else if ((l&1)^1 && s[start-1] == \\'R\\' && s[start + l] == \\'L\\') {\\n                            for(int i=start; i<=start + l/2; i++) s[i] = \\'R\\';\\n                            for(int i=start + l; i>=start + l/2; i--) s[i] =\\'L\\';\\n                        }\\n                    }\\n                }\\n                l = 0;\\n                start = -1;\\n            }\\n        }\\n        // last part\\n        if (l > 0) {\\n            if (start != 0 && s[start-1] == \\'R\\') {\\n                for(int i=start; i<start + l; i++) {\\n                    s[i] = \\'R\\';\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558273,
                "title": "two-pointers-c-30ms-solution",
                "content": "# Intuition\\n1) Can not use stack considering the testcase when one Domino is falling towards **Right** and one Domino is falling towards **Left**. Here we need to move half of the dominos fall Right and half fall Left in between these two dominos.\\n2) Whereas, rest of the dominos either continously fall Left or Right.\\n3) Using two pointers can handle all type of testcases\\n\\n\\n# Approach\\n1) The dominos group can be divided as:\\n   a) **. L**\\n   b) **. R**\\n   c) **L .**\\n   d) **R .**\\n   e) **L R**\\n   f) **R L**\\n   g) **L L**\\n   h) **R R**\\n2) The case where half of the in-between dominos fall left and half right comes under -> **R L** group.\\n3) Other groups can be handled in a **monotonous** way.\\n4) By using **two pointers**, we observe if the **current index** (j) is R or L, if it is R then we observe the **previous index** (i) which shows the group(from the above group table) the pointers i & j refer to.\\n5) So, if the pair **{ i, j }** belongs to:\\n a) **. L** - run a loop from i to j and fill with \\'L\\'\\n b) **. R** - do nothing ( even if vertical dominos are in-between)\\n c) **L .** - do nothing ( even if vertical dominos are in-between)\\n d) **R .** - run a loop from i to j and fill with \\'R\\'\\n e) **L R** - do nothing ( even if vertical dominos are in-between)\\n f) **R L** - calculate the distance between i and j to first distribute half indices to \\'R\\' and then half indices to \\'L\\'. If there is odd no. of spaces available, we need to skip the middle domino as it is self-balanced.\\n g) **L L** - run a loop from i to j and fill with \\'L\\'\\n h) **R R** - run a loop from i to j and fill with \\'R\\'\\n\\n# Complexity\\n- Time complexity:\\n **O(n+k) ~ O(n)**\\n where **n** is for traversing the string and **k** is for traversing to fill substrings with \\'L\\' and \\'R\\'\\n\\n- Space complexity:\\n**O(1)** - Since no additional space is required to store\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        int i=0,j=0,n=dom.size();\\n        while(i<n){\\n            int j=i;\\n            int solA = -1, solB = -1, solC = -1, solD = -1;\\n            while(j<n){\\n                if(dom[j]==\\'L\\'){\\n                    if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'.\\' || dom[i]==\\'L\\'){\\n                        // L to be inserted to the left till i\\n                        solA = 1;\\n                        break;\\n                    }\\n                    else{\\n                        // half R and half L to be inserted\\n                        solC = 1;\\n                        break;\\n                    }\\n                }\\n                else if(dom[j]==\\'R\\'){\\n                     if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'R\\'){\\n                        // fill R from i to j\\n                        solB = 1;\\n                        // cout<<i<<\" \"<<j<<endl;\\n                        break;\\n                    }\\n                    // move i to curr pos of j\\n                    i=j;\\n                    break;\\n                }\\n                else if(j==n-1 && dom[j]==\\'.\\'){\\n                    if(dom[i]==\\'R\\'){\\n                        solD=1;\\n                        break;\\n                    }\\n                }\\n                j++;\\n            }\\n            // cout<<endl;\\n            if(solA==1){\\n                // inserting L\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'L\\';\\n            }\\n            if(solB==1){\\n                // inserting R\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'R\\';\\n            }\\n            if(solC==1){\\n                int k=i+(j-i-1)/2;\\n                for(int z=i;z<=k && z<n;z++) dom[z]=\\'R\\';\\n                for(int z=j;z>=(j-k+i) && z>0;z--) dom[z]=\\'L\\';\\n            }\\n            if(solD==1){\\n                for(int z=i;z<n;z++) dom[z]=\\'R\\';\\n            }\\n            i=j;\\n        }\\n        return dom;\\n    }\\n};\\n```\\n\\nDo upvote the solution, if understood the solution \\uD83D\\uDE0A\\nDo comment if finding difficult to understand any step.",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n        int i=0,j=0,n=dom.size();\\n        while(i<n){\\n            int j=i;\\n            int solA = -1, solB = -1, solC = -1, solD = -1;\\n            while(j<n){\\n                if(dom[j]==\\'L\\'){\\n                    if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'.\\' || dom[i]==\\'L\\'){\\n                        // L to be inserted to the left till i\\n                        solA = 1;\\n                        break;\\n                    }\\n                    else{\\n                        // half R and half L to be inserted\\n                        solC = 1;\\n                        break;\\n                    }\\n                }\\n                else if(dom[j]==\\'R\\'){\\n                     if(i==j){\\n                        j++;\\n                        continue;\\n                    }\\n                    if(dom[i]==\\'R\\'){\\n                        // fill R from i to j\\n                        solB = 1;\\n                        // cout<<i<<\" \"<<j<<endl;\\n                        break;\\n                    }\\n                    // move i to curr pos of j\\n                    i=j;\\n                    break;\\n                }\\n                else if(j==n-1 && dom[j]==\\'.\\'){\\n                    if(dom[i]==\\'R\\'){\\n                        solD=1;\\n                        break;\\n                    }\\n                }\\n                j++;\\n            }\\n            // cout<<endl;\\n            if(solA==1){\\n                // inserting L\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'L\\';\\n            }\\n            if(solB==1){\\n                // inserting R\\n                for(int k=i;k<j && k<n;k++) dom[k]=\\'R\\';\\n            }\\n            if(solC==1){\\n                int k=i+(j-i-1)/2;\\n                for(int z=i;z<=k && z<n;z++) dom[z]=\\'R\\';\\n                for(int z=j;z>=(j-k+i) && z>0;z--) dom[z]=\\'L\\';\\n            }\\n            if(solD==1){\\n                for(int z=i;z<n;z++) dom[z]=\\'R\\';\\n            }\\n            i=j;\\n        }\\n        return dom;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2795580,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        #define SET(ch, arr) \\\\\\n                    if (dominoes[i] == ch) { count = 1; prev = ch; } \\\\\\n                    else if (dominoes[i] != \\'.\\') prev = dominoes[i]; \\\\\\n                    if (prev == ch && dominoes[i] == \\'.\\') arr[i] = count++;\\n        \\n        string res = \"\";\\n        char prev;\\n        int n = dominoes.size(), count = 1;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            SET(\\'R\\', right);\\n        }\\n        \\n        prev = \\'.\\';\\n        for (int i = n-1; i >= 0; i--) {\\n            SET(\\'L\\', left);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (!left[i] && !right[i]) res += dominoes[i];\\n            else if (!left[i]) res += \\'R\\';\\n            else if (!right[i]) res += \\'L\\';\\n            else if (left[i] == right[i]) res += \\'.\\';\\n            else if (left[i] < right[i]) res += \\'L\\';\\n            else res += \\'R\\';\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630796,
                "title": "easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<dominoes.size();i++) {\\n            if(dominoes[i]==\\'L\\')\\n                q.push({0,i});\\n            else if(dominoes[i]==\\'R\\')\\n                q.push({2,i});\\n        }\\n        while(!q.empty()) {\\n            int size=q.size();\\n            unordered_map<int,char> um;\\n            for(int i=0;i<size;i++) {\\n                int side=q.front().first;\\n                int idx=q.front().second;\\n                q.pop();\\n                if(side==0 && idx-1>=0) {\\n                    if(dominoes[idx-1]==\\'.\\') {\\n                        if(um.find(idx-1)!=um.end())\\n                            um[idx-1]=\\'.\\';\\n                        else {\\n                            um[idx-1]=\\'L\\';\\n                            q.push({0,idx-1});\\n                        }\\n                    }\\n                } else if(side==2 && idx+1<=dominoes.size()-1) {\\n                    if(dominoes[idx+1]==\\'.\\') {\\n                        if(um.find(idx+1)!=um.end())\\n                            um[idx+1]=\\'.\\';\\n                        else {\\n                            um[idx+1]=\\'R\\';\\n                            q.push({2,idx+1});\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto x:um)\\n                dominoes[x.first]=x.second;\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<dominoes.size();i++) {\\n            if(dominoes[i]==\\'L\\')\\n                q.push({0,i});\\n            else if(dominoes[i]==\\'R\\')\\n                q.push({2,i});\\n        }\\n        while(!q.empty()) {\\n            int size=q.size();\\n            unordered_map<int,char> um;\\n            for(int i=0;i<size;i++) {\\n                int side=q.front().first;\\n                int idx=q.front().second;\\n                q.pop();\\n                if(side==0 && idx-1>=0) {\\n                    if(dominoes[idx-1]==\\'.\\') {\\n                        if(um.find(idx-1)!=um.end())\\n                            um[idx-1]=\\'.\\';\\n                        else {\\n                            um[idx-1]=\\'L\\';\\n                            q.push({0,idx-1});\\n                        }\\n                    }\\n                } else if(side==2 && idx+1<=dominoes.size()-1) {\\n                    if(dominoes[idx+1]==\\'.\\') {\\n                        if(um.find(idx+1)!=um.end())\\n                            um[idx+1]=\\'.\\';\\n                        else {\\n                            um[idx+1]=\\'R\\';\\n                            q.push({2,idx+1});\\n                        }\\n                    }\\n                }\\n            }\\n            for(auto x:um)\\n                dominoes[x.first]=x.second;\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630519,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int>time(n, 0);\\n        bool prev{false};\\n        for(int i = n - 1; i >= 0; i--){\\n            if(prev){\\n                if(s[i] == \\'.\\'){\\n                    time[i] = time[i+1] + 1;\\n                    s[i] = \\'L\\';\\n                }\\n                else if(s[i] == \\'R\\'){\\n                    prev = false;\\n                }\\n            }\\n            else{\\n                if(s[i] == \\'L\\'){\\n                    prev = true;\\n                }\\n            }\\n        }\\n        prev = false;\\n        for(int i = 0; i < n; i++){\\n            if(prev){\\n                if(s[i] == \\'.\\'){\\n                    s[i] = \\'R\\';\\n                    time[i] = time[i-1] + 1;\\n                }\\n                else if(s[i] == \\'L\\'){\\n                    if(time[i-1] + 1 == time[i]){\\n                        s[i] = \\'.\\';\\n                        prev = false;\\n                    }\\n                    else{\\n                        if(time[i-1] + 1 < time[i]){\\n                            s[i] = \\'R\\';\\n                            time[i] = time[i-1] + 1;\\n                        }\\n                        else{\\n                            prev = false;\\n                        }\\n                    }\\n                }\\n            }\\n            else{\\n                if(s[i] == \\'R\\'){\\n                    prev = true;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int>time(n, 0);\\n        bool prev{false}",
                "codeTag": "Java"
            },
            {
                "id": 2630428,
                "title": "easy-to-understand-o-n-o-n-solution-very-intuitive-solution",
                "content": "**Approach:**\\nSo what we need to do is just focus on the dominoes which are standing upright i.e. \\' . \\' Now if we are at a upright domino we need to know how far is a domino towards left which was pushed right and how far is a domnio which was pushed to the left. We can do this for every domino but this makes our work easier as we can just store the required distances in two arrays.\\n\\nLet\\'s see how the algorithm works\\n\\nFirst we walk from left to right\\n* If we find a domino which is pushed towards Left \\' L \\' we know this can never affect the dominoes on right so we mark our flag as false\\n* If we find a domino which is pushed towards right \\'R\\' we know this can affect the dominoes on the right side and thus we start a fresh count from zero.\\n* If we find a domino which is upright we change its value to count only if there was a Right earlier to it which is indicated by flag variable.\\n\\nSimilarly we walk from right to left and make a similar array.\\n\\nFinally we move from left to right and if we find an upright domino we check the distance of left and right domino and which ever is less we change our values accordingly.\\n\\nThe key point to note here is that only the values of the upright dominoes will change and thus we update our left and right arrays only at those positions.\\n\\n\\n\\nThe left and right are initialised with INT_MAX so as to account for unavalaibitiy of the required push.\\n\\nC++ code:\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n,INT_MAX);\\n        int count = 0;\\n        bool flag = false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    left[i]=count;\\n                }\\n            }\\n        }\\n        vector<int> right(n,INT_MAX);\\n        flag = false;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    right[i]=count;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                if(left[i]<right[i])\\n                    dominoes[i]=\\'R\\';\\n                else if(left[i]>right[i])\\n                    dominoes[i]=\\'L\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```\\n\\nIf you reached till here please upvote this solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n,INT_MAX);\\n        int count = 0;\\n        bool flag = false;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    left[i]=count;\\n                }\\n            }\\n        }\\n        vector<int> right(n,INT_MAX);\\n        flag = false;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                flag = false;\\n            }    \\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                count=0;\\n                flag = true;\\n            }\\n            else\\n            {\\n                if(flag)\\n                {\\n                    count++;\\n                    right[i]=count;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                if(left[i]<right[i])\\n                    dominoes[i]=\\'R\\';\\n                else if(left[i]>right[i])\\n                    dominoes[i]=\\'L\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630312,
                "title": "tc-sc-o-n-c-easy-solution",
                "content": "```\\n//TC=O(N)\\n//SC=O(N)\\n\\nclass Solution {\\npublic:\\n    void helper(vector<char> &arr, int j, int k){ // there are 4 conditions as follows\\n        if(arr[j]==\\'L\\' && arr[k]==\\'L\\') \\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'L\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'R\\')\\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'R\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'L\\')\\n            while(j!=k && j<k){\\n                arr[j++]=\\'R\\', arr[k--]=\\'L\\';\\n            }\\n        else j=k++;\\n    }\\n\\t\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        \\n\\t\\tvector<char> arr(n+2); //create a vector of size n+2 and make the 1st and last element \\'L\\' and \\'R\\' respectively\\n        arr[0] = \\'L\\';\\n        arr[n+1] = \\'R\\';\\n        \\n        for (int i=1; i < arr.size()-1; i++) //make elements from index 1 to second last index of vector as string characters \\n            arr[i]=dominoes[i - 1];\\n        \\n        int j=0;// keep 2 pointers j and k to find \\'L\\' and \\'R\\' in the vector\\n        int k=1;\\n        \\n        while (k < arr.size()){\\n            while(arr[k] == \\'.\\')\\n                k++;\\n            helper(arr, j, k);// call the helper function to modify the vector\\n            j=k++;\\n        }\\n\\t\\t\\n        string str=\"\";// after the vector is modified add indexes 1 to second last element of vector in a string and return it\\n        for(int i=1; i<arr.size()-1; i++){\\n            str+=arr[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//TC=O(N)\\n//SC=O(N)\\n\\nclass Solution {\\npublic:\\n    void helper(vector<char> &arr, int j, int k){ // there are 4 conditions as follows\\n        if(arr[j]==\\'L\\' && arr[k]==\\'L\\') \\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'L\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'R\\')\\n            for(int i=j; i<k; i++)\\n                arr[i]=\\'R\\';\\n        \\n        else if(arr[j]==\\'R\\' && arr[k]==\\'L\\')\\n            while(j!=k && j<k){\\n                arr[j++]=\\'R\\', arr[k--]=\\'L\\';\\n            }\\n        else j=k++;\\n    }\\n\\t\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n        \\n\\t\\tvector<char> arr(n+2); //create a vector of size n+2 and make the 1st and last element \\'L\\' and \\'R\\' respectively\\n        arr[0] = \\'L\\';\\n        arr[n+1] = \\'R\\';\\n        \\n        for (int i=1; i < arr.size()-1; i++) //make elements from index 1 to second last index of vector as string characters \\n            arr[i]=dominoes[i - 1];\\n        \\n        int j=0;// keep 2 pointers j and k to find \\'L\\' and \\'R\\' in the vector\\n        int k=1;\\n        \\n        while (k < arr.size()){\\n            while(arr[k] == \\'.\\')\\n                k++;\\n            helper(arr, j, k);// call the helper function to modify the vector\\n            j=k++;\\n        }\\n\\t\\t\\n        string str=\"\";// after the vector is modified add indexes 1 to second last element of vector in a string and return it\\n        for(int i=1; i<arr.size()-1; i++){\\n            str+=arr[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630169,
                "title": "may-the-force-be-with-you-easy-short-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size(); \\n        vector<pair<int,int>> dp(n,{0,0});\\n        // first domino to be dropped towards right , will be from left start!\\n       // beacuse all other dominoes next inline would depend on it!\\n        for(int i=0; i<n; i++) {\\n             if(s[i] == \\'R\\') {\\n                  dp[i].second = 1;\\n             }else if(s[i] == \\'.\\' && i) {\\n                  dp[i].second = dp[i-1].second ? 1 + dp[i-1].second : 0;\\n             }\\n        }\\n        // first domino to be dropped towards left , will be from far right!\\n       // because all other dominoes next inline would depend on it!\\n        for(int i=n-1; i>=0; i--) {\\n              if(s[i] == \\'L\\') {\\n                   dp[i].first = 1;\\n              }else if(s[i] == \\'.\\' && i+1<n) {\\n                   dp[i].first = dp[i+1].first ? 1 + dp[i+1].first : 0;\\n              }\\n        }\\n        for(int i=0; i<n; i++) {\\n             if(dp[i].second == 0 || dp[i].first == 0) {\\n                  s[i] = dp[i].second ? \\'R\\' : dp[i].first ? \\'L\\' : \\'.\\';  // current force direction!\\n             }else if(dp[i].first < dp[i].second) {\\n                  s[i] = \\'L\\';   // if left has a force near than right direction!\\n             }else if(dp[i].second < dp[i].first) {\\n                  s[i] = \\'R\\';  // if right has a force near than left direction!\\n             }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size(); \\n        vector<pair<int,int>> dp(n,{0,0});\\n        // first domino to be dropped towards right , will be from left start!\\n       // beacuse all other dominoes next inline would depend on it!\\n        for(int i=0; i<n; i++) {\\n             if(s[i] == \\'R\\') {\\n                  dp[i].second = 1;\\n             }else if(s[i] == \\'.\\' && i) {\\n                  dp[i].second = dp[i-1].second ? 1 + dp[i-1].second : 0;\\n             }\\n        }\\n        // first domino to be dropped towards left , will be from far right!\\n       // because all other dominoes next inline would depend on it!\\n        for(int i=n-1; i>=0; i--) {\\n              if(s[i] == \\'L\\') {\\n                   dp[i].first = 1;\\n              }else if(s[i] == \\'.\\' && i+1<n) {\\n                   dp[i].first = dp[i+1].first ? 1 + dp[i+1].first : 0;\\n              }\\n        }\\n        for(int i=0; i<n; i++) {\\n             if(dp[i].second == 0 || dp[i].first == 0) {\\n                  s[i] = dp[i].second ? \\'R\\' : dp[i].first ? \\'L\\' : \\'.\\';  // current force direction!\\n             }else if(dp[i].first < dp[i].second) {\\n                  s[i] = \\'L\\';   // if left has a force near than right direction!\\n             }else if(dp[i].second < dp[i].first) {\\n                  s[i] = \\'R\\';  // if right has a force near than left direction!\\n             }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629854,
                "title": "o-n-easy-solution-to-be-noted",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n=dominoes.length(),i,j=Integer.MIN_VALUE;\\n        char dom[]=dominoes.toCharArray(), res[]=new char[n];\\n        boolean r = false,l=true;\\n        for(i=0;i<n;i++){\\n            res[i]=dom[i];\\n            if(dom[i]==\\'L\\'){\\n                if(l){ \\n                    fill(j,i,res,0,-1);\\n                    if(j>=0) res[j]=\\'L\\';\\n                }\\n                else fill(j,i,res,1,-1);\\n                l=true;\\n                j=i;\\n            }else if(dom[i]==\\'R\\' || i==n-1){\\n                if(!l){\\n                    fill(j,i,res,1,0);\\n                    res[i]=\\'R\\';\\n                }\\n                j=i;\\n                l=false;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    void fill(int j, int i, char[] res, int incrj, int incri){\\n        for(;j<i && i>=0;j+=incrj,i+=incri){\\n            if(j>=0) res[j]=\\'R\\';\\n            res[i]=\\'L\\';\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n=dominoes.length(),i,j=Integer.MIN_VALUE;\\n        char dom[]=dominoes.toCharArray(), res[]=new char[n];\\n        boolean r = false,l=true;\\n        for(i=0;i<n;i++){\\n            res[i]=dom[i];\\n            if(dom[i]==\\'L\\'){\\n                if(l){ \\n                    fill(j,i,res,0,-1);\\n                    if(j>=0) res[j]=\\'L\\';\\n                }\\n                else fill(j,i,res,1,-1);\\n                l=true;\\n                j=i;\\n            }else if(dom[i]==\\'R\\' || i==n-1){\\n                if(!l){\\n                    fill(j,i,res,1,0);\\n                    res[i]=\\'R\\';\\n                }\\n                j=i;\\n                l=false;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    void fill(int j, int i, char[] res, int incrj, int incri){\\n        for(;j<i && i>=0;j+=incrj,i+=incri){\\n            if(j>=0) res[j]=\\'R\\';\\n            res[i]=\\'L\\';\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629294,
                "title": "python3-multi-source-bfs",
                "content": "I know that a lot of great solutions have been discussed in the discussion, but I want to share mine as well -- a multi-source BFS solution.\\n\\nThe idea is pretty straightforward, we first add all position where the initial forces happen (i.e. add all \"L\" and \"R\"), and then does BFS.\\n\\nNotice that we need to take special care of collisions, so we need to modify BFS a littile bit. Here is my solution.\\n\\nSpace Complexity: O(N) because each position will only be added to the queue or to the collision dictionary once.\\nTime Complexity: O(N) because we loop through each element once.\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        ans = [\\'.\\' for _ in range(len(dominoes))]\\n\\n        queue = deque()\\n        for i, d in enumerate(dominoes):\\n            if d == \\'L\\' or d == \\'R\\':\\n                queue.append((i, d))\\n            ans[i] = d\\n        \\n        while queue:\\n            size = len(queue)\\n            collision = defaultdict(list)\\n            for _ in range(size):\\n                i, d = queue.popleft()\\n                if d == \\'L\\' and i - 1 >= 0 and ans[i - 1] == \\'.\\':\\n                    collision[i - 1].append(\\'L\\')\\n                elif d == \\'R\\' and i + 1 < len(ans) and ans[i + 1] == \\'.\\':\\n                    collision[i + 1].append(\\'R\\')\\n            for pos in collision:\\n                if len(collision[pos]) == 2:\\n                    ans[pos] = \\'.\\'\\n                else:\\n                    ans[pos] = collision[pos][0]\\n                    queue.append((pos, collision[pos][0]))\\n                \\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        ans = [\\'.\\' for _ in range(len(dominoes))]\\n\\n        queue = deque()\\n        for i, d in enumerate(dominoes):\\n            if d == \\'L\\' or d == \\'R\\':\\n                queue.append((i, d))\\n            ans[i] = d\\n        \\n        while queue:\\n            size = len(queue)\\n            collision = defaultdict(list)\\n            for _ in range(size):\\n                i, d = queue.popleft()\\n                if d == \\'L\\' and i - 1 >= 0 and ans[i - 1] == \\'.\\':\\n                    collision[i - 1].append(\\'L\\')\\n                elif d == \\'R\\' and i + 1 < len(ans) and ans[i + 1] == \\'.\\':\\n                    collision[i + 1].append(\\'R\\')\\n            for pos in collision:\\n                if len(collision[pos]) == 2:\\n                    ans[pos] = \\'.\\'\\n                else:\\n                    ans[pos] = collision[pos][0]\\n                    queue.append((pos, collision[pos][0]))\\n                \\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629285,
                "title": "java-using-two-dp-array",
                "content": "DP solution is not best for this question but i just want to share my idea\\nFirst we creat two dp array, in the right dp ,\\nIf at Index i we have \\'L\\' then dp[i] = 0;\\nIf at Index i we have \\'R\\' then dp[i] = 1;\\nIf at Index i we have \\'.\\' then if dp[i - 1] is postive , dp[i] = dp[i - 1] + 1, else dp[i] = 0;\\nwe do the same thing with the left dp\\nnow we have two dp array, so we can get the answer we want.\\n```\\n.   L .  R  .  .  .  L  R  .  .  L  .  .\\n0  0  0  1  2  3  4  0  1  2  3  0  0  0             right\\n-2 -1 0  0 -4 -3 -2 -1  0 -3 -2 -1  0  0             left\\n```\\nbut we still have two case here.\\ncase 1 Either left or right is 0\\n\\t\\tso, if left[i] + right[i] < 0 is left, > 0 is right\\ncase 2 Neither left nor right is 0\\n\\t\\tin this case, if left[i] + right[i] < 0 means close to right beacse we start from 1 and we have 2 3 4 5 6 the smaller the number, the closer the distance. so it is R\\n\\t\\t if left[i] + right[i] > 0 it is L\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        for (int i = 0; i < left.length; i++) {\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                right[i] = 1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == 0) continue;\\n                if (right[i - 1] > 0) {\\n                    right[i] = right[i - 1] + 1;\\n                }\\n                continue;\\n            }\\n        }\\n        for (int i = right.length - 1; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                left[i] = -1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == right.length - 1) continue;\\n                if (left[i + 1] < 0) {\\n                    left[i] = left[i + 1] - 1;\\n                }\\n                continue;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < left.length; i++) {\\n            if (left[i] + right[i] == 0) {\\n                sb.append(\\'.\\');\\n            }else if (left[i] == 0 || right[i] == 0){\\n                if (left[i] + right[i] < 0) {\\n                    sb.append(\\'L\\');\\n                }else {\\n                    sb.append(\\'R\\');\\n                }\\n            }else if (left[i] + right[i] < 0) {\\n                sb.append(\\'R\\');\\n            }else {\\n                sb.append(\\'L\\');\\n            }\\n            System.out.print(left[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n.   L .  R  .  .  .  L  R  .  .  L  .  .\\n0  0  0  1  2  3  4  0  1  2  3  0  0  0             right\\n-2 -1 0  0 -4 -3 -2 -1  0 -3 -2 -1  0  0             left\\n```\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int[] left = new int[dominoes.length()];\\n        int[] right = new int[dominoes.length()];\\n        for (int i = 0; i < left.length; i++) {\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                right[i] = 1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == 0) continue;\\n                if (right[i - 1] > 0) {\\n                    right[i] = right[i - 1] + 1;\\n                }\\n                continue;\\n            }\\n        }\\n        for (int i = right.length - 1; i >= 0; i--) {\\n            if (dominoes.charAt(i) == \\'L\\'){\\n                left[i] = -1;\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'R\\'){\\n                continue;\\n            }\\n            if (dominoes.charAt(i) == \\'.\\'){\\n                if (i == right.length - 1) continue;\\n                if (left[i + 1] < 0) {\\n                    left[i] = left[i + 1] - 1;\\n                }\\n                continue;\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < left.length; i++) {\\n            if (left[i] + right[i] == 0) {\\n                sb.append(\\'.\\');\\n            }else if (left[i] == 0 || right[i] == 0){\\n                if (left[i] + right[i] < 0) {\\n                    sb.append(\\'L\\');\\n                }else {\\n                    sb.append(\\'R\\');\\n                }\\n            }else if (left[i] + right[i] < 0) {\\n                sb.append(\\'R\\');\\n            }else {\\n                sb.append(\\'L\\');\\n            }\\n            System.out.print(left[i]);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629222,
                "title": "two-pointers-approach-c-space-less-than-80-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Divided into following cases\\n    // L..R -> Stable\\n    // R..L -> Compart (equal no of rights and lefts)\\n    // L..L -> Leftwards\\n    // R..R -> Rightwards\\n    // ..R  -> Left part stable\\n    // ..L  -> Leftwards\\n    // L..  -> Right part stable\\n    // R..  -> Rightwards\\n    \\n    string pushDominoes(string dominoes) {\\n        string res;\\n        \\n        int l = 0;\\n        int r;\\n        \\n        int n = dominoes.size();\\n        \\n        int len;\\n        \\n        // Left is initiated with 0\\n        // Traversing the string with r\\n        \\n        for(r=0; r<n; r++){\\n            char curr = dominoes[r];\\n            \\n            if(curr == \\'L\\'){\\n                // can be a compart, left\\n                \\n                if(dominoes[l] == \\'R\\'){\\n                    // compart\\n                    res.push_back(\\'R\\');\\n                    len = r-l-1;\\n                    \\n                    int adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'R\\');\\n\\n                    if(len%2 == 1)\\n                        res.push_back(\\'.\\');\\n                    \\n                    adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'L\\');\\n                }else{\\n                    // left side\\n                    // both LL and .L\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'L\\');\\n                }\\n                \\n                l = r;\\n            }else if(curr == \\'R\\'){\\n                if(dominoes[l] == \\'L\\'){\\n                    // stable\\n                    res.push_back(\\'L\\');\\n                    len = r-l-1;\\n                    \\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }else if(dominoes[l] == \\'R\\'){\\n                    // right side\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'R\\');\\n                }else{\\n                    // . and R\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }\\n                \\n                l = r;\\n            }else\\n                continue;\\n        }\\n        \\n        \\n        // considering the last pair of l and r\\n        char curr = dominoes[l];\\n        r = n-1;\\n        \\n        len = r-l+1;\\n        \\n        if(curr == \\'R\\'){\\n            // Rightwards\\n            while(len--)\\n                res.push_back(\\'R\\');\\n        }else{ // L and . case\\n            for(int i=l; i<n; i++)\\n                res.push_back(dominoes[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Divided into following cases\\n    // L..R -> Stable\\n    // R..L -> Compart (equal no of rights and lefts)\\n    // L..L -> Leftwards\\n    // R..R -> Rightwards\\n    // ..R  -> Left part stable\\n    // ..L  -> Leftwards\\n    // L..  -> Right part stable\\n    // R..  -> Rightwards\\n    \\n    string pushDominoes(string dominoes) {\\n        string res;\\n        \\n        int l = 0;\\n        int r;\\n        \\n        int n = dominoes.size();\\n        \\n        int len;\\n        \\n        // Left is initiated with 0\\n        // Traversing the string with r\\n        \\n        for(r=0; r<n; r++){\\n            char curr = dominoes[r];\\n            \\n            if(curr == \\'L\\'){\\n                // can be a compart, left\\n                \\n                if(dominoes[l] == \\'R\\'){\\n                    // compart\\n                    res.push_back(\\'R\\');\\n                    len = r-l-1;\\n                    \\n                    int adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'R\\');\\n\\n                    if(len%2 == 1)\\n                        res.push_back(\\'.\\');\\n                    \\n                    adds = len/2;\\n                    while(adds--)\\n                        res.push_back(\\'L\\');\\n                }else{\\n                    // left side\\n                    // both LL and .L\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'L\\');\\n                }\\n                \\n                l = r;\\n            }else if(curr == \\'R\\'){\\n                if(dominoes[l] == \\'L\\'){\\n                    // stable\\n                    res.push_back(\\'L\\');\\n                    len = r-l-1;\\n                    \\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }else if(dominoes[l] == \\'R\\'){\\n                    // right side\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'R\\');\\n                }else{\\n                    // . and R\\n                    len = r-l;\\n                    while(len--)\\n                        res.push_back(\\'.\\');\\n                }\\n                \\n                l = r;\\n            }else\\n                continue;\\n        }\\n        \\n        \\n        // considering the last pair of l and r\\n        char curr = dominoes[l];\\n        r = n-1;\\n        \\n        len = r-l+1;\\n        \\n        if(curr == \\'R\\'){\\n            // Rightwards\\n            while(len--)\\n                res.push_back(\\'R\\');\\n        }else{ // L and . case\\n            for(int i=l; i<n; i++)\\n                res.push_back(dominoes[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628809,
                "title": "javascript-solution",
                "content": "```\\nvar pushDominoes = function(dominoes) {\\n    let start=0; \\n    let end=1;\\n    const arr = (\"L\"+ dominoes +\"R\").split(\"\");\\n    while(start < arr.length-1){\\n        while(arr[end]==\\'.\\') \\n            end++;\\n        if(arr[start] == arr[end]) \\n            for(let i= start+1; i<end; i++) {\\n                arr[i]=arr[start];   \\n            }\\n        if(arr[start]>arr[end]) \\n            for(let i=1; i<=(end-start-1)/2; i++){\\n                arr[start+i] = \\'R\\';\\n                arr[end-i] = \\'L\\';\\n            }   \\n        start=end++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar pushDominoes = function(dominoes) {\\n    let start=0; \\n    let end=1;\\n    const arr = (\"L\"+ dominoes +\"R\").split(\"\");\\n    while(start < arr.length-1){\\n        while(arr[end]==\\'.\\') \\n            end++;\\n        if(arr[start] == arr[end]) \\n            for(let i= start+1; i<end; i++) {\\n                arr[i]=arr[start];   \\n            }\\n        if(arr[start]>arr[end]) \\n            for(let i=1; i<=(end-start-1)/2; i++){\\n                arr[start+i] = \\'R\\';\\n                arr[end-i] = \\'L\\';\\n            }   \\n        start=end++;\\n    }\\n    return arr.slice(1,arr.length-1).join(\"\");\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2628772,
                "title": "java-simple-easy-to-understand-using-array-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length();\\n        char[] arr = s.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && arr[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = arr[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        arr[l]=\\'R\\';\\n                        arr[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        arr[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        arr[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length();\\n        char[] arr = s.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && arr[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = arr[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        arr[l]=\\'R\\';\\n                        arr[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        arr[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        arr[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053804,
                "title": "simple-ruby-string-replace-in-one-line",
                "content": "One line solution:\\n```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = dominoes.gsub(\\'R.L\\', \\'|\\').gsub(\\'.L\\', \\'LL\\').gsub(\\'R.\\', \\'RR\\').gsub(\\'|\\', \\'R.L\\') }\\nend\\n```\\n\\nCan also write in much more readable form:\\n```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = execute(dominoes) }\\nend\\n\\ndef execute(dominoes)\\n    dominoes\\n    .gsub(\\'R.L\\', \\'|\\')\\n    .gsub(\\'.L\\', \\'LL\\')\\n    .gsub(\\'R.\\', \\'RR\\')\\n    .gsub(\\'|\\', \\'R.L\\')\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = dominoes.gsub(\\'R.L\\', \\'|\\').gsub(\\'.L\\', \\'LL\\').gsub(\\'R.\\', \\'RR\\').gsub(\\'|\\', \\'R.L\\') }\\nend\\n```\n```\\ndef push_dominoes(dominoes)\\n    loop { return dominoes if dominoes == dominoes = execute(dominoes) }\\nend\\n\\ndef execute(dominoes)\\n    dominoes\\n    .gsub(\\'R.L\\', \\'|\\')\\n    .gsub(\\'.L\\', \\'LL\\')\\n    .gsub(\\'R.\\', \\'RR\\')\\n    .gsub(\\'|\\', \\'R.L\\')\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2012322,
                "title": "simple-replace-function-python",
                "content": "```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        while True:\\n            new= dominoes.replace(\\'R.L\\',\\'S\\').replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            \\n            if new==dominoes:\\n                break\\n            else:\\n                dominoes=new\\n        return dominoes.replace(\\'S\\',\\'R.L\\')\\n```",
                "solutionTags": [],
                "code": "```\\n    def pushDominoes(self, dominoes: str) -> str:\\n        while True:\\n            new= dominoes.replace(\\'R.L\\',\\'S\\').replace(\\'.L\\',\\'LL\\').replace(\\'R.\\',\\'RR\\')\\n            \\n            if new==dominoes:\\n                break\\n            else:\\n                dominoes=new\\n        return dominoes.replace(\\'S\\',\\'R.L\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2001558,
                "title": "simple-c-solution-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n       int n = dom.length(); \\n       queue<pair<char,int>> q;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(dom[i]!=\\'.\\')q.push({dom[i],i});\\n       }\\n       while(q.empty()==false)\\n       {\\n           char ch = q.front().first;\\n           int ind = q.front().second;\\n           q.pop();\\n           if(ch==\\'L\\')\\n           {\\n               if(ind-1>=0 && dom[ind-1]==\\'.\\')\\n               {\\n                  dom[ind-1] = \\'L\\';\\n                  q.push({\\'L\\',ind-1}); \\n               }\\n           }\\n           else if(ch==\\'R\\')\\n           {\\n               if(ind+1<n && dom[ind+1]==\\'.\\')\\n               {\\n                   if(ind+2<n && dom[ind+2]==\\'L\\')\\n                       q.pop();\\n                   else{\\n                       dom[ind+1]=\\'R\\';\\n                       q.push({\\'R\\',ind+1});\\n                   }\\n               }\\n           }\\n       }\\n       return dom; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dom) {\\n       int n = dom.length(); \\n       queue<pair<char,int>> q;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(dom[i]!=\\'.\\')q.push({dom[i],i});\\n       }\\n       while(q.empty()==false)\\n       {\\n           char ch = q.front().first;\\n           int ind = q.front().second;\\n           q.pop();\\n           if(ch==\\'L\\')\\n           {\\n               if(ind-1>=0 && dom[ind-1]==\\'.\\')\\n               {\\n                  dom[ind-1] = \\'L\\';\\n                  q.push({\\'L\\',ind-1}); \\n               }\\n           }\\n           else if(ch==\\'R\\')\\n           {\\n               if(ind+1<n && dom[ind+1]==\\'.\\')\\n               {\\n                   if(ind+2<n && dom[ind+2]==\\'L\\')\\n                       q.pop();\\n                   else{\\n                       dom[ind+1]=\\'R\\';\\n                       q.push({\\'R\\',ind+1});\\n                   }\\n               }\\n           }\\n       }\\n       return dom; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905096,
                "title": "weeb-explains-python-c-2-pointers-solution",
                "content": "![image](https://assets.leetcode.com/users/images/60c692dc-d9bc-4592-bbb6-98c134b94042_1648868037.2552137.png)\\n\\nWe have 2 edge cases\\n**1st edge case**\\nif the first char is a \".\\', i.e dominoes[i] == \\'.\\', then its either :\\nAll the \\'.\\' becomes \\'L\\' **if our second pointer is \\'L\\'**\\n**or**\\nAll the \\'.\\' remain as \\'.\\' **if our second pointer is \\'R\\'**\\ni.e. lets say we have dominoes = \\'.....L\\'\\nresult = \\'LLLLLL\\'\\n**or**\\ni.e. lets say we have dominoes= \\'.....R\\'\\nresult = \\'.....R\\'\\n\\n**2nd edge case**\\nif the last char is a \".\\', i.e dominoes[len(arr)-1] == \\'.\\', then its either :\\nAll the \\'.\\' becomes \\'R\\' **if our second pointer is \\'R\\'**\\n**or**\\nAll the \\'.\\' remain as \\'.\\' **if our second pointer is \\'L\\'**\\ni.e. lets say we have dominoes = \\'R.....\\'\\nresult = \\'RRRRRR\\'\\n**or**\\ni.e. lets say we have dominoes= \\'L.....\\'\\nresult = \\'L.....\\'\\n\\nNow that the 2 edge cases are handled, it is **guaranteed** that our pointer will start and end with either an \\'L\\' or \\'R\\'\\nWith that, there are another **4 more possibilities of arrangements** which are **RR, LL, RL, LR**\\n**1st arragement : RR**\\n-All elements within RR will become \\'R\\'\\ni.e. dominoes = \"R.....R\"\\nresult = \"RRRRRR\"\\n**2nd arragement : LL**\\n-All elements within LL will become \\'L\\'\\ni.e. dominoes = \"L.....L\"\\nresult = \"LLLLLL\"\\n**3rd arragement : RL**\\n-half of the elements within RL will become \\'R\\', another half will become \\'L\\'\\nhowever, there are **2 cases to handle within this subproblem**, if we have **even** number of \\'.\\' within RL\\ni.e dominoes = \"R....L\"\\nresult = \"RRRLLL\"\\nelse, if we have **odd** number of \\'.\\' within RL\\ni.e. dominoes = \"R.....L\"\\nresult = \"RRR.LLL\" (the midpoint should remain as a \\'.\\')\\n**4th arragement : LR**\\nNo change within the elements of LR\\ni.e. dominoes = \"L.....R\"\\nresult = \"L.....R\"\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tvector<char> arr(dominoes.begin(), dominoes.end());\\n\\t\\t\\tint low = 0, high = arr.size()-1;\\n\\n\\t\\t\\tif (arr[low] == \\'.\\'){\\n\\t\\t\\t\\tfor (int i = 0; i < arr.size(); i++){\\n\\t\\t\\t\\t\\tif (arr[i] == \\'R\\'){\\n\\t\\t\\t\\t\\t\\tlow = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (arr[i] == \\'L\\'){\\n\\t\\t\\t\\t\\t\\tfor (int j = 0; j < i; j++) arr[j] = \\'L\\';\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}      \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (arr[high] == \\'.\\')\\n\\t\\t\\t\\tfor (int i = arr.size()-1; i > -1; i--){\\n\\t\\t\\t\\t\\tif (arr[i] == \\'L\\'){\\n\\t\\t\\t\\t\\t\\thigh = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (arr[i] == \\'R\\'){\\n\\t\\t\\t\\t\\t\\tfor (int j=i; j<arr.size();j++) arr[j] = \\'R\\';\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\tint i = low;\\n\\t\\t\\tfor (int j = low+1; j<high+1; j++){\\n\\t\\t\\t\\tif (arr[i] == \\'R\\' && arr[j] == \\'L\\'){\\n\\t\\t\\t\\t\\tint mid = (i+j)/2;\\n\\t\\t\\t\\t\\tint temp = j;\\n\\t\\t\\t\\t\\twhile (i != j){\\n\\t\\t\\t\\t\\t\\tif (i >= temp){\\n\\t\\t\\t\\t\\t\\t\\ti = j;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tarr[i] = \\'R\\';\\n\\t\\t\\t\\t\\t\\tarr[temp] = \\'L\\';\\n\\n\\t\\t\\t\\t\\t\\ttemp--;\\n\\t\\t\\t\\t\\t\\ti++;   \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arr[i] == \\'R\\' && arr[j] == \\'R\\'){\\n\\t\\t\\t\\t\\twhile (i != j){\\n\\t\\t\\t\\t\\t\\tarr[i] = \\'R\\';\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arr[i] == \\'L\\' && arr[j] == \\'L\\'){\\n\\t\\t\\t\\t\\twhile (i != j){\\n\\t\\t\\t\\t\\t\\tarr[i] = \\'L\\';\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (arr[i] == \\'L\\' && arr[j] == \\'R\\') i = j;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstring result = \"\";\\n\\n\\t\\t\\tfor (int i = 0; i < arr.size(); i++) result += arr[i];\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n\\n**Python** \\n\\t\\n\\tclass Solution:\\n    def pushDominoes(self, string: str) -> str:\\n        low, high = 0, len(string) - 1\\n        string = list(string)\\n        \\n        if string[low] == \".\":\\n            for i in range(len(string)):\\n                if string[i] == \"R\": \\n                    low = i\\n                    break\\n                \\n                if string[i] == \"L\":\\n                    for j in range(i):\\n                        string[j] = \"L\"\\n                    break\\n                    \\n        if string[high] == \".\":\\n            for i in range(len(string)-1,-1,-1):\\n                if string[i] == \"L\": \\n                    high = i\\n                    break\\n                \\n                if string[i] == \"R\":\\n                    for j in range(i, len(string)):\\n                        string[j] = \"R\"\\n                    break\\n        \\n        i = low\\n        for j in range(low+1, high+1):\\n            if string[i] == \"R\" and string[j] == \"L\":\\n                mid = (i+j) //2 \\n                temp = j\\n                while i != j:\\n                    if i >= temp:\\n                        i = j\\n                        break\\n                    \\n                    string[i] = \"R\"\\n                    string[temp] = \"L\"\\n                    \\n                    temp-=1\\n                    i+=1\\n            \\n            if string[i] == \"R\" and string[j] == \"R\":\\n                while i != j:\\n                    string[i] = \"R\"\\n                    i+=1\\n            \\n            if string[i] == \"L\" and string[j] == \"L\":\\n                while i != j:\\n                    string[i] = \"L\"\\n                    i+=1\\n                \\n            if string[i] == \"L\" and string[j] == \"R\":\\n                i = j\\n    \\n        return \"\".join(string)\\n\\nBruh, take a break, watch some anime instead\\nCheck out **\\u738B\\u69D8\\u30E9\\u30F3\\u30AD\\u30F3\\u30B0 (Ranking of Kings)**\\n\\n# Episodes: 23\\n# Genres: Adventure, Fantasy\\n\\nThis anime is amazing, watch it.",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tvector<char> arr(dominoes.begin(), dominoes.end());\\n\\t\\t\\tint low = 0, high = arr.size()-1;\\n\\n\\t\\t\\tif (arr[low] == \\'.\\'){\\n\\t\\t\\t\\tfor (int i = 0; i < arr.size(); i++){\\n\\t\\t\\t\\t\\tif (arr[i] == \\'R\\'){\\n\\t\\t\\t\\t\\t\\tlow = i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1667195,
                "title": "6-lines-c-linq-o-n",
                "content": "It isn\\'t a good code. But it\\'s quite short.\\n\\n```\\npublic class Solution \\n{\\n    private IEnumerable<int> DistTo(IEnumerable<char> dominoes, char R, char L) \\n    {\\n        int dist = Int32.MaxValue / 2;\\n        return dominoes\\n                .Select(domino => domino == R ? dist = 0 : (domino == L ? dist = Int32.MaxValue / 2 : ++dist))\\n                .Select(x => x < Int32.MaxValue / 2 ? x : Int32.MaxValue / 2);\\n    }\\n    \\n    public string PushDominoes(string dominoes)\\n        => String.Concat(DistTo(dominoes, \\'R\\', \\'L\\').Zip(DistTo(dominoes.Reverse(), \\'L\\', \\'R\\').Reverse(),\\n                                                        (r, l) => r < l ? \\'R\\' : (r > l ? \\'L\\' : \\'.\\')));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    private IEnumerable<int> DistTo(IEnumerable<char> dominoes, char R, char L) \\n    {\\n        int dist = Int32.MaxValue / 2;\\n        return dominoes\\n                .Select(domino => domino == R ? dist = 0 : (domino == L ? dist = Int32.MaxValue / 2 : ++dist))\\n                .Select(x => x < Int32.MaxValue / 2 ? x : Int32.MaxValue / 2);\\n    }\\n    \\n    public string PushDominoes(string dominoes)\\n        => String.Concat(DistTo(dominoes, \\'R\\', \\'L\\').Zip(DistTo(dominoes.Reverse(), \\'L\\', \\'R\\').Reverse(),\\n                                                        (r, l) => r < l ? \\'R\\' : (r > l ? \\'L\\' : \\'.\\')));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354237,
                "title": "c-easy-two-pointers-explained",
                "content": "The idea here is to use two pointer approach.\\nWe need to insert \\'L\\' in the beginning to make the process easier.\\ninitially i is pointing to beginning \\'L\\'. \\nj = i+1, continue incrementing j as long as dominoes[i]=\\'.\\' \\nAs soon we encounter \\'L\\' or \\'R\\', we stop.\\nHere are 4 possibilities:\\n1. i=\\'L\\' and j=\\'L\\' --> we fill all the characters between i and j with \\'L\\'\\n2. i=\\'R\\' and j=\\'R\\' --> we fill all the characters between i and j with \\'R\\'.\\n3. i=\\'L\\' and j=\\'R\\' --> we don\\'t do anything. All characters remain as it is.\\n4. i=\\'R\\' and j=\\'L\\' --> Here we need to fill the characters with \\'R\\' and \\'L\\' both. We calculate mid point between j-1 and i index and fill the characters as shown below.\\n\\nLastly, if j==size, that means we reached end, then check if dominoes[i]==\\'R\\' --> fill all characters till end with \\'R\\'.\\nAdjust pointers i and j. We already processed characters till j. so now i=j.\\n```\\n string pushDominoes(string dominoes) {\\n        int i, j,k, size, mid, count=0;\\n        string result;\\n        result = dominoes;\\n        dominoes.insert(dominoes.begin()+0, \\'L\\');\\n        size = dominoes.size();\\n        for(i=0; i<size-1; )\\n        {\\n           j=i+1;\\n            while(j<size && dominoes[j]==\\'.\\')\\n                j++;\\n            if(j<size)\\n            {\\n                if(dominoes[i]==\\'R\\' && dominoes[j]==\\'L\\')\\n                {\\n                    mid = ((j-1)-i)/2;\\n                    for(k=1; k<=mid; k++)\\n                    {\\n                        dominoes[i+k] = dominoes[i];\\n                        dominoes[j-k] = dominoes[j];\\n                    }\\n                }\\n                else if(dominoes[i]==\\'L\\' && dominoes[j]==\\'L\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k]=\\'L\\';\\n                }\\n                else if(dominoes[i]==\\'R\\' && dominoes[j]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            else\\n            {\\n                if(dominoes[i]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            i=j;\\n        }\\n        dominoes.erase(dominoes.begin()+0);\\n        return dominoes;\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n string pushDominoes(string dominoes) {\\n        int i, j,k, size, mid, count=0;\\n        string result;\\n        result = dominoes;\\n        dominoes.insert(dominoes.begin()+0, \\'L\\');\\n        size = dominoes.size();\\n        for(i=0; i<size-1; )\\n        {\\n           j=i+1;\\n            while(j<size && dominoes[j]==\\'.\\')\\n                j++;\\n            if(j<size)\\n            {\\n                if(dominoes[i]==\\'R\\' && dominoes[j]==\\'L\\')\\n                {\\n                    mid = ((j-1)-i)/2;\\n                    for(k=1; k<=mid; k++)\\n                    {\\n                        dominoes[i+k] = dominoes[i];\\n                        dominoes[j-k] = dominoes[j];\\n                    }\\n                }\\n                else if(dominoes[i]==\\'L\\' && dominoes[j]==\\'L\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k]=\\'L\\';\\n                }\\n                else if(dominoes[i]==\\'R\\' && dominoes[j]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            else\\n            {\\n                if(dominoes[i]==\\'R\\')\\n                {\\n                    for(k=i+1; k<j; k++)\\n                        dominoes[k] = \\'R\\';\\n                }\\n            }\\n            i=j;\\n        }\\n        dominoes.erase(dominoes.begin()+0);\\n        return dominoes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1353683,
                "title": "c-easy-clean-solution",
                "content": "**Solution I:**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        if(s.size() == 1)\\n            return s;\\n        string fans = \"\";\\n        while(1){\\n            string ans = \"\";\\n            for(int i = 0; i < s.size(); i++){\\n                if(i == 0){\\n                    if(s[i] == \\'.\\' and s[i + 1] == \\'L\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n                else if(i == s.size() - 1){\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\') ans += s[i - 1];\\n                    else ans += s[i];\\n                }\\n                else{\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\' and s[i + 1] != \\'L\\') ans += s[i - 1];\\n                    else if(s[i] == \\'.\\' and s[i + 1] == \\'L\\' and s[i - 1] != \\'R\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n            }\\n            s = ans;\\n            if(s == fans) break;\\n            else fans = s; \\n        }\\n        return fans;\\n    }\\n};\\n```\\n\\n**Solution II:**\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        ll n = s.size();\\n        if(n == 1)\\n            return s;\\n        vector<ll> r(n), l(n);\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'R\\') r[i] = 1;\\n            else if(s[i] == \\'.\\' and i > 0){\\n                if(r[i - 1] != INT_MAX) r[i] = r[i - 1] + 1;\\n                else r[i] = INT_MAX;\\n            }\\n            else r[i] = INT_MAX;     \\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(s[i] == \\'L\\') l[i] = 1;\\n            else if(s[i] == \\'.\\' and i < n - 1){\\n                if(l[i + 1] != INT_MAX) l[i] = l[i + 1] + 1;\\n                else l[i] = INT_MAX;\\n            }\\n            else l[i] = INT_MAX;\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'.\\'){\\n                if(l[i] == r[i]) ans += \\'.\\';\\n                else if(l[i] < r[i]) ans += \\'L\\';\\n                else if(l[i] > r[i]) ans += \\'R\\';\\n            }\\n            else ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        if(s.size() == 1)\\n            return s;\\n        string fans = \"\";\\n        while(1){\\n            string ans = \"\";\\n            for(int i = 0; i < s.size(); i++){\\n                if(i == 0){\\n                    if(s[i] == \\'.\\' and s[i + 1] == \\'L\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n                else if(i == s.size() - 1){\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\') ans += s[i - 1];\\n                    else ans += s[i];\\n                }\\n                else{\\n                    if(s[i] == \\'.\\' and s[i - 1] == \\'R\\' and s[i + 1] != \\'L\\') ans += s[i - 1];\\n                    else if(s[i] == \\'.\\' and s[i + 1] == \\'L\\' and s[i - 1] != \\'R\\') ans += s[i + 1];\\n                    else ans += s[i];\\n                }\\n            }\\n            s = ans;\\n            if(s == fans) break;\\n            else fans = s; \\n        }\\n        return fans;\\n    }\\n};\\n```\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        ll n = s.size();\\n        if(n == 1)\\n            return s;\\n        vector<ll> r(n), l(n);\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'R\\') r[i] = 1;\\n            else if(s[i] == \\'.\\' and i > 0){\\n                if(r[i - 1] != INT_MAX) r[i] = r[i - 1] + 1;\\n                else r[i] = INT_MAX;\\n            }\\n            else r[i] = INT_MAX;     \\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            if(s[i] == \\'L\\') l[i] = 1;\\n            else if(s[i] == \\'.\\' and i < n - 1){\\n                if(l[i + 1] != INT_MAX) l[i] = l[i + 1] + 1;\\n                else l[i] = INT_MAX;\\n            }\\n            else l[i] = INT_MAX;\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'.\\'){\\n                if(l[i] == r[i]) ans += \\'.\\';\\n                else if(l[i] < r[i]) ans += \\'L\\';\\n                else if(l[i] > r[i]) ans += \\'R\\';\\n            }\\n            else ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352429,
                "title": "simple-bfs-solution-c",
                "content": "**if you don\\'t like my solution please comment ,, do not downvote**\\n```\\n\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n     \\n        queue<int> q; //for storing the indexes\\n        \\n        for(int i=0;i<dominoes.size();i++){\\n            if(dominoes[i]==\\'L\\' || dominoes[i]==\\'R\\'){\\n                q.push(i);\\n            }\\n        }\\n        \\n        string ans = dominoes; // for keeping track of the changes\\n        \\n        while(!q.empty()){\\n            \\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++){\\n                \\n                auto p = q.front();\\n                q.pop();\\n                \\n                if(p-1>=0 && dominoes[p]==\\'L\\' && dominoes[p-1]==\\'.\\'){\\n                    \\n                    if(p-2>=0 && (dominoes[p-2]==\\'.\\' || dominoes[p-2]==\\'L\\')){\\n                        ans[p-1] = \\'L\\';\\n                        q.push(p-1);    \\n                    }\\n                    \\n                    if(p-2<0){\\n                        ans[p-1] = \\'L\\';\\n                    }\\n                    \\n                }\\n                \\n                if(p+1<dominoes.size() && dominoes[p]==\\'R\\' && dominoes[p+1]==\\'.\\'){\\n                    \\n                    if(p+2<dominoes.size() && (dominoes[p+2]==\\'.\\' || dominoes[p+2]==\\'R\\'))\\n                    {\\n                      ans[p+1] = \\'R\\';\\n                    q.push(p+1);\\n  \\n                    }         \\n                    if(p+2>=dominoes.size()){\\n                        ans[p+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            dominoes = ans; // after t = 1 in the next time stamp we will have the updated string\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n     \\n        queue<int> q; //for storing the indexes\\n        \\n        for(int i=0;i<dominoes.size();i++){\\n            if(dominoes[i]==\\'L\\' || dominoes[i]==\\'R\\'){\\n                q.push(i);\\n            }\\n        }\\n        \\n        string ans = dominoes; // for keeping track of the changes\\n        \\n        while(!q.empty()){\\n            \\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++){\\n                \\n                auto p = q.front();\\n                q.pop();\\n                \\n                if(p-1>=0 && dominoes[p]==\\'L\\' && dominoes[p-1]==\\'.\\'){\\n                    \\n                    if(p-2>=0 && (dominoes[p-2]==\\'.\\' || dominoes[p-2]==\\'L\\')){\\n                        ans[p-1] = \\'L\\';\\n                        q.push(p-1);    \\n                    }\\n                    \\n                    if(p-2<0){\\n                        ans[p-1] = \\'L\\';\\n                    }\\n                    \\n                }\\n                \\n                if(p+1<dominoes.size() && dominoes[p]==\\'R\\' && dominoes[p+1]==\\'.\\'){\\n                    \\n                    if(p+2<dominoes.size() && (dominoes[p+2]==\\'.\\' || dominoes[p+2]==\\'R\\'))\\n                    {\\n                      ans[p+1] = \\'R\\';\\n                    q.push(p+1);\\n  \\n                    }         \\n                    if(p+2>=dominoes.size()){\\n                        ans[p+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            dominoes = ans; // after t = 1 in the next time stamp we will have the updated string\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201805,
                "title": "java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        if(n <= 1)return dominoes;\\n        /* index is storing the index of every l and r\\n        we are making it of n+2 size beacuse we can have all char as r and L in dominoes and +2 becuase we are\\n        inserting L in front and R in end of string, they won\\'t make any difference but they can b used to\\n        handel these cases\\n       \\n       case:1 - (<-) L......L(<-) or (->)R....R(->) when the exert force on only on same side then all the  standing\\n\\t                  dominoes will fall in the direction same as we are exerting force. so it can be written  as LLLLL or   RRRRR.    \\n        case:2 - (<-)L.....R(->) can be neglected beacuse they won\\'t make any chang in dominoes between them.\\n        \\n        case:3 - (->)R......L(<-) so this is the case we need to care about, so in this we can further have two \\n                    two cases i). even number of (.) so first half dominoes will fall in right and second half \\n                    will fall in left and when they both meet they will be like //\\\\\\\\\\n                    second case ii). odd number of dots .  so, the mid will stand tall as both from left and \\n                    right we are exerting force and due to that it will stand tall ex, //|\\\\\\\\ */\\n        \\n        int[] index = new int[n+2];\\n        char[] symbol = new char[n+2];\\n        int len = 1;\\n        index[0] = -1;\\n        symbol[0] = \\'L\\';\\n        \\n        for(int i = 0 ; i < n; i++){\\n            if(dominoes.charAt(i) != \\'.\\'){\\n                index[len] = i;\\n                symbol[len++] = dominoes.charAt(i);\\n            }\\n        }\\n        index[len] = n;\\n        symbol[len++] = \\'R\\';\\n        \\n        char[] ans = dominoes.toCharArray();\\n        for(int k = 0; k < len-1; k++){\\n            int i = index[k] , j = index[k+1];\\n            char x = symbol[k] , y = symbol[k+1];\\n            \\n            if(x == y){\\n                // case 1\\n                for(int a = i+1; a<j; a++){\\n                    ans[a] = x;\\n                }  //case 2 will be ignored as it can\\'t make any change in stability of dominoes.\\n            }else if(x > y){\\n                //case 3\\n                for(int a = i+1; a < j ; a++){\\n                    ans[a] = a-i == j-a ? \\'.\\' : a-i < j-a ? \\'R\\' : \\'L\\';\\n                }\\n            }\\n        }\\n        return String.valueOf(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        if(n <= 1)return dominoes;\\n        /* index is storing the index of every l and r\\n        we are making it of n+2 size beacuse we can have all char as r and L in dominoes and +2 becuase we are\\n        inserting L in front and R in end of string, they won\\'t make any difference but they can b used to\\n        handel these cases\\n       \\n       case:1 - (<-) L......L(<-) or (->)R....R(->) when the exert force on only on same side then all the  standing\\n\\t                  dominoes will fall in the direction same as we are exerting force. so it can be written  as LLLLL or   RRRRR.    \\n        case:2 - (<-)L.....R(->) can be neglected beacuse they won\\'t make any chang in dominoes between them.\\n        \\n        case:3 - (->)R......L(<-) so this is the case we need to care about, so in this we can further have two \\n                    two cases i). even number of (.) so first half dominoes will fall in right and second half \\n                    will fall in left and when they both meet they will be like //\\\\\\\\\\n                    second case ii). odd number of dots .  so, the mid will stand tall as both from left and \\n                    right we are exerting force and due to that it will stand tall ex, //|\\\\\\\\ */\\n        \\n        int[] index = new int[n+2];\\n        char[] symbol = new char[n+2];\\n        int len = 1;\\n        index[0] = -1;\\n        symbol[0] = \\'L\\';\\n        \\n        for(int i = 0 ; i < n; i++){\\n            if(dominoes.charAt(i) != \\'.\\'){\\n                index[len] = i;\\n                symbol[len++] = dominoes.charAt(i);\\n            }\\n        }\\n        index[len] = n;\\n        symbol[len++] = \\'R\\';\\n        \\n        char[] ans = dominoes.toCharArray();\\n        for(int k = 0; k < len-1; k++){\\n            int i = index[k] , j = index[k+1];\\n            char x = symbol[k] , y = symbol[k+1];\\n            \\n            if(x == y){\\n                // case 1\\n                for(int a = i+1; a<j; a++){\\n                    ans[a] = x;\\n                }  //case 2 will be ignored as it can\\'t make any change in stability of dominoes.\\n            }else if(x > y){\\n                //case 3\\n                for(int a = i+1; a < j ; a++){\\n                    ans[a] = a-i == j-a ? \\'.\\' : a-i < j-a ? \\'R\\' : \\'L\\';\\n                }\\n            }\\n        }\\n        return String.valueOf(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201268,
                "title": "c-easy-one-pass-solution-using-stack",
                "content": "First of all, we see that the their are four possible combinatoins with L and R.\\n1) We encounter a L after another L\\n2) We encounter a R after an L\\n3) We encounter a L after an R\\n4) We encounter a R after another R.\\n\\nNow, of these four case, only case where there is chance of a middle element is case 3.\\nBut let me break it down case by case for you.\\n\\ncase 1 : ...L...L \\n\\tIn such case we can easily say that while going left from current point we can simply mark everthing as L until we reach the start of string or encounter the other L. whichever occurs first.\\n\\ncase 2: ....L...R... \\n\\tIn such case, we don\\'t need to do anything and simply update the values in L and R var that we use to store the position of last encounter L or R. As case 1 will make everything before L as L and case 4 will handle the dots after R. \\n\\ncase 3: ...R...L.. \\n\\tNow this one requires us to do a bit. We use a two pointer approach and take i=postion of last encounterd R and j= position of current L and do a loop while(i<j) with incrementing i and making the dots R and decrementing J and making the dots L.\\n\\nCase 4: \\n\\tA bit similar to case 1, the only catch is unlike L, since we don\\'t directly start updating all the values to \\'R\\' as soon as we encounter R, we start from the previous positon of R and make everything \\'R\\' between the two Rs. Then update the value of positon of last encountered R. \\nFor this reason, once we have iterated everything, we need to check if the top element in the stack is R, if yes, run a loop to make everything after that a R until the end of the string.\\n\\nIn all these cases, we push the encountered L or R into the stack after doing the operation.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int l=-1;//to strore the position of last encountered L\\n        int r=-1;// to store the position of last encountered R\\n        int n= dominoes.size();\\n   \\n       \\n        stack<char> s;\\n        for(int i=0; i<n;i++)\\n        {  \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                 l=i;\\n\\n                if(s.empty()||s.top()!=\\'R\\')//case 1 (and case 3 since there is nothing to be done in case 3)\\n                {\\n                   i--;//so that the next loop runs as dominoes[i] is \\'L\\'\\n                    while(i>=0&&dominoes[i]!=\\'L\\')\\n                    {\\n                        dominoes[i]=\\'L\\';i--;\\n                    }\\n                }\\n                else \\n                { \\n                    for(int i=r,j=l;i<j;i++,j--)//case 3\\n                    {\\n                        dominoes[i]=\\'R\\';\\n                        dominoes[j]=\\'L\\';\\n                    }\\n                }\\n                s.push(\\'L\\');\\n                i=l;\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            { \\n                if(!s.empty()&&s.top()==\\'R\\')\\n                    while(r<=i)\\n                    {\\n                        dominoes[r]=\\'R\\';\\n                        r++;\\n                    }\\n                r=i;\\n                s.push(\\'R\\');\\n            } \\n                \\n            \\n        }\\n        if(!s.empty()&&s.top()==\\'R\\')\\n            while(r<n)\\n                {  \\n                dominoes[r]=\\'R\\';\\n                    r++;\\n                }\\n        \\n        return dominoes;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int l=-1;//to strore the position of last encountered L\\n        int r=-1;// to store the position of last encountered R\\n        int n= dominoes.size();\\n   \\n       \\n        stack<char> s;\\n        for(int i=0; i<n;i++)\\n        {  \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                 l=i;\\n\\n                if(s.empty()||s.top()!=\\'R\\')//case 1 (and case 3 since there is nothing to be done in case 3)\\n                {\\n                   i--;//so that the next loop runs as dominoes[i] is \\'L\\'\\n                    while(i>=0&&dominoes[i]!=\\'L\\')\\n                    {\\n                        dominoes[i]=\\'L\\';i--;\\n                    }\\n                }\\n                else \\n                { \\n                    for(int i=r,j=l;i<j;i++,j--)//case 3\\n                    {\\n                        dominoes[i]=\\'R\\';\\n                        dominoes[j]=\\'L\\';\\n                    }\\n                }\\n                s.push(\\'L\\');\\n                i=l;\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            { \\n                if(!s.empty()&&s.top()==\\'R\\')\\n                    while(r<=i)\\n                    {\\n                        dominoes[r]=\\'R\\';\\n                        r++;\\n                    }\\n                r=i;\\n                s.push(\\'R\\');\\n            } \\n                \\n            \\n        }\\n        if(!s.empty()&&s.top()==\\'R\\')\\n            while(r<n)\\n                {  \\n                dominoes[r]=\\'R\\';\\n                    r++;\\n                }\\n        \\n        return dominoes;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004197,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        s = \"L\" + dominoes + \"R\"\\n\\n        p, q = 0, 1\\n        res = \"\"\\n        \\n        while q < len(s):\\n            if s[q] != \".\":\\n                if s[p] == s[q]:\\n                    res += s[p] * (q - p )\\n                    \\n                elif s[p] == \\'R\\' and s[q] == \\'L\\':\\n                    m = (p + q) // 2\\n                    if (p + q) % 2 == 0: \\n                        res += s[p] * (m - p)  + \\'.\\' +  s[q] * ( q - m - 1)\\n                    else:\\n                        res += s[p] * (m - p + 1) + s[q] * (q - m - 1)\\n                else:\\n                    res += s[p] + \\'.\\' * (q - p - 1)\\n                \\n                p = q \\n                \\n            q += 1\\n        \\n        return res[1:]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        s = \"L\" + dominoes + \"R\"\\n\\n        p, q = 0, 1\\n        res = \"\"\\n        \\n        while q < len(s):\\n            if s[q] != \".\":\\n                if s[p] == s[q]:\\n                    res += s[p] * (q - p )\\n                    \\n                elif s[p] == \\'R\\' and s[q] == \\'L\\':\\n                    m = (p + q) // 2\\n                    if (p + q) % 2 == 0: \\n                        res += s[p] * (m - p)  + \\'.\\' +  s[q] * ( q - m - 1)\\n                    else:\\n                        res += s[p] * (m - p + 1) + s[q] * (q - m - 1)\\n                else:\\n                    res += s[p] + \\'.\\' * (q - p - 1)\\n                \\n                p = q \\n                \\n            q += 1\\n        \\n        return res[1:]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 993392,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n, INT_MAX), right(n, INT_MAX);\\n        \\n        for (int i = 0, r = -1, l = -1; i < n; ++i) {\\n            // Right fall\\n            if (dominoes[i] == \\'R\\') r = i;\\n            if (dominoes[i] == \\'L\\') r = -1;\\n            if (dominoes[i] == \\'.\\' && r != -1) right[i] = i - r;\\n            \\n            // Left fall\\n            if (dominoes[n-i-1] == \\'L\\') l = n-i-1;\\n            if (dominoes[n-i-1] == \\'R\\') l = -1;\\n            if (dominoes[n-i-1] == \\'.\\' && l != -1) left[n-i-1] = l-n+i+1;\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (left[i] != right[i] && dominoes[i] == \\'.\\')\\n                dominoes[i] = left[i] < right[i] ? \\'L\\' : \\'R\\';\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> left(n, INT_MAX), right(n, INT_MAX);\\n        \\n        for (int i = 0, r = -1, l = -1; i < n; ++i) {\\n            // Right fall\\n            if (dominoes[i] == \\'R\\') r = i;\\n            if (dominoes[i] == \\'L\\') r = -1;\\n            if (dominoes[i] == \\'.\\' && r != -1) right[i] = i - r;\\n            \\n            // Left fall\\n            if (dominoes[n-i-1] == \\'L\\') l = n-i-1;\\n            if (dominoes[n-i-1] == \\'R\\') l = -1;\\n            if (dominoes[n-i-1] == \\'.\\' && l != -1) left[n-i-1] = l-n+i+1;\\n        }\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (left[i] != right[i] && dominoes[i] == \\'.\\')\\n                dominoes[i] = left[i] < right[i] ? \\'L\\' : \\'R\\';\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833768,
                "title": "c-two-passes-o-n",
                "content": "```\\nclass Solution {\\npublic:\\nstring pushDominoes(string dominoes) \\n    {\\n        vector<int> nums(dominoes.size());\\n        for(int i = 1; i < dominoes.size(); i++) \\n        {\\n            if(dominoes[i] == \\'.\\' && dominoes[i - 1] == \\'R\\')\\n            {\\n                nums[i] = nums[i - 1] + 1;\\n                dominoes[i] = \\'R\\';\\n            }\\n        }\\n\\n        for(int i  = dominoes.size() - 2; i >= 0; i--)\\n        {\\n            if(dominoes[i + 1] == \\'L\\')\\n            {\\n                if(dominoes[i] != \\'R\\')\\n                    dominoes[i] = \\'L\\';\\n                else\\n                {\\n                    int cnt = 1;\\n                    while(cnt < nums[i])\\n                    {\\n                        cnt++;\\n                        dominoes[i] = \\'L\\';\\n                        i--;\\n                    }\\n\\n                    if(nums[i] == cnt)\\n                        dominoes[i] = \\'.\\';\\n\\n                    while(nums[i]) i--;\\n                }\\n            }\\n            \\n        }\\n\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nstring pushDominoes(string dominoes) \\n    {\\n        vector<int> nums(dominoes.size());\\n        for(int i = 1; i < dominoes.size(); i++) \\n        {\\n            if(dominoes[i] == \\'.\\' && dominoes[i - 1] == \\'R\\')\\n            {\\n                nums[i] = nums[i - 1] + 1;\\n                dominoes[i] = \\'R\\';\\n            }\\n        }\\n\\n        for(int i  = dominoes.size() - 2; i >= 0; i--)\\n        {\\n            if(dominoes[i + 1] == \\'L\\')\\n            {\\n                if(dominoes[i] != \\'R\\')\\n                    dominoes[i] = \\'L\\';\\n                else\\n                {\\n                    int cnt = 1;\\n                    while(cnt < nums[i])\\n                    {\\n                        cnt++;\\n                        dominoes[i] = \\'L\\';\\n                        i--;\\n                    }\\n\\n                    if(nums[i] == cnt)\\n                        dominoes[i] = \\'.\\';\\n\\n                    while(nums[i]) i--;\\n                }\\n            }\\n            \\n        }\\n\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473226,
                "title": "go-o-n-4ms100",
                "content": "```go\\nfunc pushDominoes(dominoes string) string {\\n\\tdominoesInByteSlice := []byte(dominoes)\\n\\tlastIsRight := false\\n\\tlastIndex := 0\\n\\tfor i := 0; i < len(dominoesInByteSlice); i++ {\\n\\t\\tswitch dominoesInByteSlice[i] {\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tcount := (i - lastIndex + 1) / 2 - 1\\n\\t\\t\\t\\tfor m := lastIndex+1; m < lastIndex+1+count; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor m := i-1; m > i-1-count; m-- {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = false\\n\\t\\t\\tlastIndex = i+1\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = true\\n\\t\\t\\tlastIndex = i\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif lastIsRight {\\n\\t\\tfor m := lastIndex; m < len(dominoesInByteSlice); m++ {\\n\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn string(dominoesInByteSlice)\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc pushDominoes(dominoes string) string {\\n\\tdominoesInByteSlice := []byte(dominoes)\\n\\tlastIsRight := false\\n\\tlastIndex := 0\\n\\tfor i := 0; i < len(dominoesInByteSlice); i++ {\\n\\t\\tswitch dominoesInByteSlice[i] {\\n\\t\\tcase \\'L\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tcount := (i - lastIndex + 1) / 2 - 1\\n\\t\\t\\t\\tfor m := lastIndex+1; m < lastIndex+1+count; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor m := i-1; m > i-1-count; m-- {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'L\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = false\\n\\t\\t\\tlastIndex = i+1\\n\\t\\tcase \\'R\\':\\n\\t\\t\\tif lastIsRight {\\n\\t\\t\\t\\tfor m := lastIndex; m < i; m++ {\\n\\t\\t\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIsRight = true\\n\\t\\t\\tlastIndex = i\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif lastIsRight {\\n\\t\\tfor m := lastIndex; m < len(dominoesInByteSlice); m++ {\\n\\t\\t\\tdominoesInByteSlice[m] = \\'R\\'\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn string(dominoesInByteSlice)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132932,
                "title": "c-2-pass-scan-o-2n-13ms",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        const int n = dominoes.size();\\n        vector<int> vt(n);\\n        for(int i = 1; i < n; ++i){\\n            if(dominoes[i-1] == \\'R\\' && dominoes[i] == \\'.\\'){\\n                dominoes[i] = \\'R\\';\\n                vt[i] = vt[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = n-2, nt; i >= 0; --i){\\n            if(dominoes[i+1] == \\'L\\'){\\n                nt = vt[i+1] + 1;\\n                if(dominoes[i] == \\'.\\' || vt[i] > nt){\\n                    dominoes[i] = \\'L\\';\\n                    vt[i] = nt;\\n                }\\n                else if(dominoes[i] == \\'R\\' && vt[i] == nt){ // recover\\n                    dominoes[i] = \\'.\\';\\n                }\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n\\nint iobooster = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        const int n = dominoes.size();\\n        vector<int> vt(n);\\n        for(int i = 1; i < n; ++i){\\n            if(dominoes[i-1] == \\'R\\' && dominoes[i] == \\'.\\'){\\n                dominoes[i] = \\'R\\';\\n                vt[i] = vt[i-1] + 1;\\n            }\\n        }\\n\\n        for(int i = n-2, nt; i >= 0; --i){\\n            if(dominoes[i+1] == \\'L\\'){\\n                nt = vt[i+1] + 1;\\n                if(dominoes[i] == \\'.\\' || vt[i] > nt){\\n                    dominoes[i] = \\'L\\';\\n                    vt[i] = nt;\\n                }\\n                else if(dominoes[i] == \\'R\\' && vt[i] == nt){ // recover\\n                    dominoes[i] = \\'.\\';\\n                }\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n\\nint iobooster = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132499,
                "title": "c-4-lines-o-n-n-simulation",
                "content": "We simulate falling dominos turn-by-turn. We need a copy of the string (```s```) to make modifications so all dominos are pushed \"simultaneously\". At the end of each turn, we return the result if there are no more changes (```s == ds```).\\n\\nEach turn we run through all dominos. The ```if``` statement checks if the previous (```i - 1``` for L) or next (```i + 1``` for R) domino can be pushed: it\\'s standing and there is no domino before/after it pushing in the opposite direction.\\n```\\nstring pushDominoes(string ds) {\\n  for (string s = ds; ; s = ds) {\\n    for (auto i = 0, d = s[i] == \\'L\\' ? -1 : 1; i < s.size(); d = s[++i] == \\'L\\' ? -1 : 1)\\n      if (s[i] != \\'.\\' && i + d >= 0 && i + d < s.size() && s[i + d] == \\'.\\' &&\\n        (i + d * 2 < 0 || i + d * 2 >= s.size() || s[i + d * 2] != (s[i] == \\'L\\' ? \\'R\\' : \\'L\\'))) ds[i + d] = s[i];\\n    if (s == ds) return s;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```s```\n```s == ds```\n```if```\n```i - 1```\n```i + 1```\n```\\nstring pushDominoes(string ds) {\\n  for (string s = ds; ; s = ds) {\\n    for (auto i = 0, d = s[i] == \\'L\\' ? -1 : 1; i < s.size(); d = s[++i] == \\'L\\' ? -1 : 1)\\n      if (s[i] != \\'.\\' && i + d >= 0 && i + d < s.size() && s[i + d] == \\'.\\' &&\\n        (i + d * 2 < 0 || i + d * 2 >= s.size() || s[i + d * 2] != (s[i] == \\'L\\' ? \\'R\\' : \\'L\\'))) ds[i + d] = s[i];\\n    if (s == ds) return s;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132371,
                "title": "python-3-passes-simple-solution-using-dictionaries-228-ms",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes):\\n        res, l, r , pre_l, pre_r = \"\", {}, {}, None, None,\\n        for i, s in enumerate(dominoes):\\n            if s == \".\" and pre_r != None: r[i] = i - pre_r\\n            elif s == \"R\": pre_r = i\\n            elif s == \"L\": pre_r = None\\n        for i in range(len(dominoes) - 1, -1, -1):\\n            if dominoes[i] == \".\" and pre_l != None: l[i] = pre_l - i\\n            elif dominoes[i] == \"L\": pre_l = i\\n            elif dominoes[i] == \"R\": pre_l = None\\n        for i, s in enumerate(dominoes):\\n            if s == \"L\" or s == \"R\": res += s\\n            elif i in l and i in r:\\n                if l[i] < r[i]: res += \"L\"\\n                elif r[i] < l[i]: res += \"R\"\\n                else: res += s\\n            elif i in l: res += \"L\"\\n            elif i in r: res += \"R\"\\n            else: res += s\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes):\\n        res, l, r , pre_l, pre_r = \"\", {}, {}, None, None,\\n        for i, s in enumerate(dominoes):\\n            if s == \".\" and pre_r != None: r[i] = i - pre_r\\n            elif s == \"R\": pre_r = i\\n            elif s == \"L\": pre_r = None\\n        for i in range(len(dominoes) - 1, -1, -1):\\n            if dominoes[i] == \".\" and pre_l != None: l[i] = pre_l - i\\n            elif dominoes[i] == \"L\": pre_l = i\\n            elif dominoes[i] == \"R\": pre_l = None\\n        for i, s in enumerate(dominoes):\\n            if s == \"L\" or s == \"R\": res += s\\n            elif i in l and i in r:\\n                if l[i] < r[i]: res += \"L\"\\n                elif r[i] < l[i]: res += \"R\"\\n                else: res += s\\n            elif i in l: res += \"L\"\\n            elif i in r: res += \"R\"\\n            else: res += s\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820586,
                "title": "brute-force-with-storing-critical-points-with-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n         int n  = dominoes.size();\\n         vector<pair<char,int>> v;\\n            for(int i=0;i<n;i++){\\n                    if(dominoes[i] == \\'R\\') v.push_back({\\'R\\',i});\\n                    else if(dominoes[i] == \\'L\\') v.push_back({\\'L\\',i});\\n            }\\n           if(v.size() == 0) return dominoes;\\n             if(v[0].first == \\'L\\'){\\n                     for(int j = 0;j<=v[0].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n            for(int i=0;i<v.size()-1;i++){\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'L\\'){\\n                        int k = v[i+1].second - v[i].second-1;\\n                        for(int j=0;j<k/2;j++){\\n                            dominoes[v[i].second + j + 1] = \\'R\\';\\n                        } \\n                        for(int j = k/2+1;j<=k;j++){\\n                            dominoes[v[i].second + j] = \\'L\\';\\n                        }\\n                       \\n                        if(k%2!=0) dominoes[v[i].second + (k+1)/2] = \\'.\\';\\n                 }\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'R\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'R\\';\\n                 }\\n                 if(v[i].first == \\'L\\' && v[i+1].first == \\'L\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n                 \\n            }\\n            if(v[v.size() - 1].first == \\'R\\'){\\n                for(int j=v[v.size()-1].second;j<n;j++) dominoes[j] = \\'R\\';\\n            }\\n            return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n         int n  = dominoes.size();\\n         vector<pair<char,int>> v;\\n            for(int i=0;i<n;i++){\\n                    if(dominoes[i] == \\'R\\') v.push_back({\\'R\\',i});\\n                    else if(dominoes[i] == \\'L\\') v.push_back({\\'L\\',i});\\n            }\\n           if(v.size() == 0) return dominoes;\\n             if(v[0].first == \\'L\\'){\\n                     for(int j = 0;j<=v[0].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n            for(int i=0;i<v.size()-1;i++){\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'L\\'){\\n                        int k = v[i+1].second - v[i].second-1;\\n                        for(int j=0;j<k/2;j++){\\n                            dominoes[v[i].second + j + 1] = \\'R\\';\\n                        } \\n                        for(int j = k/2+1;j<=k;j++){\\n                            dominoes[v[i].second + j] = \\'L\\';\\n                        }\\n                       \\n                        if(k%2!=0) dominoes[v[i].second + (k+1)/2] = \\'.\\';\\n                 }\\n                 if(v[i].first == \\'R\\' && v[i+1].first == \\'R\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'R\\';\\n                 }\\n                 if(v[i].first == \\'L\\' && v[i+1].first == \\'L\\'){\\n                     for(int j=v[i].second;j<=v[i+1].second;j++) dominoes[j] = \\'L\\';\\n                 }\\n                 \\n            }\\n            if(v[v.size() - 1].first == \\'R\\'){\\n                for(int j=v[v.size()-1].second;j<n;j++) dominoes[j] = \\'R\\';\\n            }\\n            return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489355,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans=s;\\n        int n=ans.size(),r=-1;\\n        for(int i=0; i<n; i++) {\\n            if(s[i]==\\'L\\' && r==-1) {\\n                for(int l=i-1; l>=0 && s[l]==\\'.\\'; l--) {\\n                    ans[l]=\\'L\\';\\n                }\\n            }\\n            else if(s[i]==\\'R\\') {\\n                while(r!=-1 && r<i)\\n                    ans[r++]=\\'R\\';\\n                r=i;\\n            }\\n            else if(s[i]==\\'L\\') {\\n                int l=i;\\n                while(r<l) {\\n                    ans[r++]=\\'R\\';\\n                    ans[l--]=\\'L\\';\\n                }\\n                r=-1;\\n            }\\n        }\\n        while(r!=-1 && r<n)\\n            ans[r++]=\\'R\\';\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = list(dominoes)\\n        n = len(arr)\\n        l = r = -1\\n        for i, c in enumerate(arr):\\n            if c is \\'.\\':\\n                continue\\n            if c is \\'L\\':\\n                if l >= r:\\n                    while l < i:\\n                        l += 1\\n                        arr[l] = \\'L\\'\\n                else:\\n                    l = i\\n                    lo, hi = r + 1, l - 1\\n                    while lo < hi:\\n                        arr[lo] = \\'R\\'\\n                        arr[hi] = \\'L\\'\\n                        lo += 1\\n                        hi -= 1\\n            else:\\n                if r > l:\\n                    while r < i:\\n                        arr[r] = \\'R\\'\\n                        r += 1\\n                else:\\n                    r = i\\n        if r > l:\\n            while r < n:\\n                arr[r] = \\'R\\'\\n                r += 1\\n        \\n        return \\'\\'.join(arr)\\n```\\n\\n```Java []\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] dos = dominoes.toCharArray();\\n        int left = \\'L\\';\\n        int i = 0;\\n        while(i<dos.length){\\n            if(dos[i] == \\'.\\'){\\n                int j = i;\\n                while(j<dos.length && dos[j] == \\'.\\'){\\n                    j++;\\n                }\\n                int right = j>=dos.length? \\'R\\': dos[j];\\n                if(right == left){\\n                    while(i < j){\\n                        dos[i++] = (char)right;\\n                    }\\n                }else if(right == \\'R\\'){\\n                    i = j-1;\\n                }else{\\n                    j--;\\n                    while(i < j){\\n                        dos[i++] = (char)left;\\n                        dos[j--] = (char)right;\\n                    }\\n                }\\n                left = right;\\n            }else{\\n                left = dos[i];\\n            }\\n            i++;\\n        }\\n        return new String(dos);\\n    }\\n    public String pushDominoes1(String dominoes) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] dos = dominoes.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        int lastRight = -1;\\n        int lastLeft = -1;\\n\\n        for(int i = 0; i<dos.length;){\\n            if(dos[i] == \\'R\\'){\\n                while(i<dos.length && dos[i] != \\'L\\'){\\n                    stack.push(\\'R\\');\\n                    if(dos[i] == \\'R\\'){\\n                        lastRight = i;\\n                    }\\n                    i++;\\n                }\\n            }else if(dos[i] == \\'L\\'){\\n                int numOfPop = 0;\\n                if(lastLeft == -1 && lastRight == -1){\\n                    numOfPop = i;\\n                }else{\\n                    numOfPop = lastLeft > lastRight? (i- lastLeft):(i-lastRight)/2;\\n                }\\n                int count = numOfPop;\\n                while(count > 0){\\n                    stack.pop();\\n                    count--;\\n                }\\n                if(lastRight != -1 && lastRight > lastLeft && (i-lastRight)%2 == 0 && numOfPop >= 1) {\\n                    stack.push(\\'.\\');\\n                    numOfPop--;\\n                }\\n                while(count < numOfPop){\\n                    stack.push(\\'L\\');\\n                    count++;\\n                }\\n                stack.push(\\'L\\');\\n                lastLeft = i;\\n                i++;\\n            }else{\\n                stack.push(dos[i]);\\n                i++;\\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans=s;\\n        int n=ans.size(),r=-1;\\n        for(int i=0; i<n; i++) {\\n            if(s[i]==\\'L\\' && r==-1) {\\n                for(int l=i-1; l>=0 && s[l]==\\'.\\'; l--) {\\n                    ans[l]=\\'L\\';\\n                }\\n            }\\n            else if(s[i]==\\'R\\') {\\n                while(r!=-1 && r<i)\\n                    ans[r++]=\\'R\\';\\n                r=i;\\n            }\\n            else if(s[i]==\\'L\\') {\\n                int l=i;\\n                while(r<l) {\\n                    ans[r++]=\\'R\\';\\n                    ans[l--]=\\'L\\';\\n                }\\n                r=-1;\\n            }\\n        }\\n        while(r!=-1 && r<n)\\n            ans[r++]=\\'R\\';\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = list(dominoes)\\n        n = len(arr)\\n        l = r = -1\\n        for i, c in enumerate(arr):\\n            if c is \\'.\\':\\n                continue\\n            if c is \\'L\\':\\n                if l >= r:\\n                    while l < i:\\n                        l += 1\\n                        arr[l] = \\'L\\'\\n                else:\\n                    l = i\\n                    lo, hi = r + 1, l - 1\\n                    while lo < hi:\\n                        arr[lo] = \\'R\\'\\n                        arr[hi] = \\'L\\'\\n                        lo += 1\\n                        hi -= 1\\n            else:\\n                if r > l:\\n                    while r < i:\\n                        arr[r] = \\'R\\'\\n                        r += 1\\n                else:\\n                    r = i\\n        if r > l:\\n            while r < n:\\n                arr[r] = \\'R\\'\\n                r += 1\\n        \\n        return \\'\\'.join(arr)\\n```\n```Java []\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] dos = dominoes.toCharArray();\\n        int left = \\'L\\';\\n        int i = 0;\\n        while(i<dos.length){\\n            if(dos[i] == \\'.\\'){\\n                int j = i;\\n                while(j<dos.length && dos[j] == \\'.\\'){\\n                    j++;\\n                }\\n                int right = j>=dos.length? \\'R\\': dos[j];\\n                if(right == left){\\n                    while(i < j){\\n                        dos[i++] = (char)right;\\n                    }\\n                }else if(right == \\'R\\'){\\n                    i = j-1;\\n                }else{\\n                    j--;\\n                    while(i < j){\\n                        dos[i++] = (char)left;\\n                        dos[j--] = (char)right;\\n                    }\\n                }\\n                left = right;\\n            }else{\\n                left = dos[i];\\n            }\\n            i++;\\n        }\\n        return new String(dos);\\n    }\\n    public String pushDominoes1(String dominoes) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] dos = dominoes.toCharArray();\\n        Stack<Character> stack = new Stack<>();\\n        int lastRight = -1;\\n        int lastLeft = -1;\\n\\n        for(int i = 0; i<dos.length;){\\n            if(dos[i] == \\'R\\'){\\n                while(i<dos.length && dos[i] != \\'L\\'){\\n                    stack.push(\\'R\\');\\n                    if(dos[i] == \\'R\\'){\\n                        lastRight = i;\\n                    }\\n                    i++;\\n                }\\n            }else if(dos[i] == \\'L\\'){\\n                int numOfPop = 0;\\n                if(lastLeft == -1 && lastRight == -1){\\n                    numOfPop = i;\\n                }else{\\n                    numOfPop = lastLeft > lastRight? (i- lastLeft):(i-lastRight)/2;\\n                }\\n                int count = numOfPop;\\n                while(count > 0){\\n                    stack.pop();\\n                    count--;\\n                }\\n                if(lastRight != -1 && lastRight > lastLeft && (i-lastRight)%2 == 0 && numOfPop >= 1) {\\n                    stack.push(\\'.\\');\\n                    numOfPop--;\\n                }\\n                while(count < numOfPop){\\n                    stack.push(\\'L\\');\\n                    count++;\\n                }\\n                stack.push(\\'L\\');\\n                lastLeft = i;\\n                i++;\\n            }else{\\n                stack.push(dos[i]);\\n                i++;\\n            }\\n        }\\n        while(!stack.isEmpty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184854,
                "title": "java-o-n-time",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private void replace(char[] d, char c, int a, int b){\\n        while(a < b){\\n            d[a++] = c;\\n        }\\n    }\\n    public String pushDominoes(String dominoes) {\\n        char[] d = dominoes.toCharArray();\\n        int prev = -1;\\n        for(int a = 0; a < d.length; a++){\\n            if(d[a] == \\'L\\'){\\n                if(prev == -1 || d[prev] == \\'L\\'){\\n                    replace(d, \\'L\\', prev + 1, a);\\n                }else{\\n                    int diff = a - prev;\\n                    int mid = prev + diff / 2;\\n                    replace(d, \\'R\\', prev + 1, mid + (diff % 2 == 1 ? 1 : 0));\\n                    replace(d, \\'L\\', mid + 1, a);\\n                }\\n                prev = a;\\n            }else if(d[a] == \\'R\\'){\\n                if(prev != -1 && d[prev] == \\'R\\'){\\n                   replace(d, \\'R\\', prev, a);\\n                }\\n                prev = a;\\n            }\\n        }\\n        if(prev != -1 && d[prev] == \\'R\\') replace(d, \\'R\\', prev + 1, d.length);\\n        return String.valueOf(d);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    private void replace(char[] d, char c, int a, int b){\\n        while(a < b){\\n            d[a++] = c;\\n        }\\n    }\\n    public String pushDominoes(String dominoes) {\\n        char[] d = dominoes.toCharArray();\\n        int prev = -1;\\n        for(int a = 0; a < d.length; a++){\\n            if(d[a] == \\'L\\'){\\n                if(prev == -1 || d[prev] == \\'L\\'){\\n                    replace(d, \\'L\\', prev + 1, a);\\n                }else{\\n                    int diff = a - prev;\\n                    int mid = prev + diff / 2;\\n                    replace(d, \\'R\\', prev + 1, mid + (diff % 2 == 1 ? 1 : 0));\\n                    replace(d, \\'L\\', mid + 1, a);\\n                }\\n                prev = a;\\n            }else if(d[a] == \\'R\\'){\\n                if(prev != -1 && d[prev] == \\'R\\'){\\n                   replace(d, \\'R\\', prev, a);\\n                }\\n                prev = a;\\n            }\\n        }\\n        if(prev != -1 && d[prev] == \\'R\\') replace(d, \\'R\\', prev + 1, d.length);\\n        return String.valueOf(d);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973911,
                "title": "my-2-pointers-java-code",
                "content": "The code surely looks big but if you do a dry run on the example test case 2, you\\'ll realize that the logic is actually quite simple and easy to understand\\n\\n```\\nclass Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length(), start=0, end=0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while(end<n && s.charAt(end) == \\'.\\') end++;\\n        \\n\\t\\t/// to take care of inputs starting with \\'.\\', like \"...LRRL.LLRRL\"\\n        if(end<n && s.charAt(start)==\\'.\\'){\\n            if(s.charAt(end) == \\'L\\'){\\n                for(int i=start; i<end; i++) sb.setCharAt(i, \\'L\\');\\n            }\\n            start = end;\\n        }\\n        \\n        while(end<n){\\n            if(s.charAt(end)==\\'.\\'){\\n                end++;\\n                continue;\\n            }\\n            \\n            else if(s.charAt(start) == \\'L\\' && s.charAt(end) == \\'R\\') start = end;\\n            \\n            else if(s.charAt(start) == \\'R\\' && s.charAt(end) == \\'L\\'){\\n                int len = (end-start-1);\\n                int size = len;\\n                size /= 2;\\n                \\n                for(int i=start; i<=(start+size); i++){\\n                    sb.setCharAt(i, \\'R\\');\\n                }\\n                if(len % 2 == 0) for(int i=(start+size+1); i<end; i++) sb.setCharAt(i, \\'L\\'); /// \"R..L\" -> \"RRLL\"\\n                else for(int i=(start+size+2); i<end; i++) sb.setCharAt(i, \\'L\\'); /// \"R...L\" -> \"RR.LL\",\\n                \\n                start = end;\\n            }\\n            \\n            else if(s.charAt(start) == s.charAt(end)){\\n                for(int i=start+1; i<end; i++) sb.setCharAt(i, sb.charAt(start));\\n                start = end;\\n            }\\n            \\n            end++;\\n        }\\n        \\n\\t\\t/// to take care of inputs ending with \\'.\\', like \"LRRL..RR..R...\"\\n        if(end == n && s.charAt(end-1)==\\'.\\'){\\n            if(s.charAt(start) == \\'R\\'){\\n                for(int i=start+1; i<end; i++) sb.setCharAt(i, \\'R\\');\\n                start = end;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String pushDominoes(String s) {\\n        int n = s.length(), start=0, end=0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while(end<n && s.charAt(end) == \\'.\\') end++;\\n        \\n\\t\\t/// to take care of inputs starting with \\'.\\', like \"...LRRL.LLRRL\"\\n        if(end<n && s.charAt(start)==\\'.\\'){\\n            if(s.charAt(end) == \\'L\\'){\\n                for(int i=start; i<end; i++) sb.setCharAt(i, \\'L\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2930080,
                "title": "swift-fast-solution-o-n-o-1",
                "content": "# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\n    func pushDominoes(_ dominoes: String) -> String {\\n        var dominoes = Array(dominoes)\\n        var L = 0\\n        var R = 0\\n        \\n        for i in 0..<dominoes.count where dominoes[i] == \".\" {\\n            L = i - 1\\n            R = i + 1\\n            \\n            while L >= 0 && dominoes[L] == \".\" {\\n                L -= 1\\n            }\\n            \\n            while R < dominoes.count && dominoes[R] == \".\" {\\n                R += 1\\n            }\\n            \\n            if L == -1 {\\n                L = 0\\n            }\\n            \\n            if R == dominoes.count {\\n                R = dominoes.count - 1\\n            }\\n            \\n            switch (dominoes[L], dominoes[R]) {\\n            case (\".\", \"L\"), (\"L\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"L\"\\n                    L += 1\\n                }\\n            case (\"R\", \"R\"), (\"R\", \".\"):\\n                while L < R {\\n                    dominoes[R] = \"R\"\\n                    R -= 1\\n                }\\n            case (\"R\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"R\"\\n                    L += 1\\n                    dominoes[R] = \"L\"\\n                    R -= 1\\n                }\\n            default:\\n                break\\n            }\\n        }\\n        return String(dominoes)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func pushDominoes(_ dominoes: String) -> String {\\n        var dominoes = Array(dominoes)\\n        var L = 0\\n        var R = 0\\n        \\n        for i in 0..<dominoes.count where dominoes[i] == \".\" {\\n            L = i - 1\\n            R = i + 1\\n            \\n            while L >= 0 && dominoes[L] == \".\" {\\n                L -= 1\\n            }\\n            \\n            while R < dominoes.count && dominoes[R] == \".\" {\\n                R += 1\\n            }\\n            \\n            if L == -1 {\\n                L = 0\\n            }\\n            \\n            if R == dominoes.count {\\n                R = dominoes.count - 1\\n            }\\n            \\n            switch (dominoes[L], dominoes[R]) {\\n            case (\".\", \"L\"), (\"L\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"L\"\\n                    L += 1\\n                }\\n            case (\"R\", \"R\"), (\"R\", \".\"):\\n                while L < R {\\n                    dominoes[R] = \"R\"\\n                    R -= 1\\n                }\\n            case (\"R\", \"L\"):\\n                while L < R {\\n                    dominoes[L] = \"R\"\\n                    L += 1\\n                    dominoes[R] = \"L\"\\n                    R -= 1\\n                }\\n            default:\\n                break\\n            }\\n        }\\n        return String(dominoes)\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707417,
                "title": "c-o-n-space-o-n-time-complexity",
                "content": "Just Kep track of where the nearest Left and Right domino was. If left was near then it will fall towards left. Similarly for right. If both are equally near then it will be balanced condition.\\n\\n\\n```\\n string pushDominoes(string dominoes) \\n    {\\n        int sl=dominoes.length();\\n        string ans=dominoes;\\n        int left[sl];\\n        int right[sl];\\n        int r=INT_MIN,l=INT_MIN;\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                right[i]=r;\\n                if(r!=INT_MIN){r--;}\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                right[i]=1e5;\\n                r=1e5-1;\\n            }\\n            else\\n            {\\n                r=INT_MIN;\\n                right[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                left[i]=l;\\n                if(l!=INT_MIN){l--;}\\n            }\\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                left[i]=1e5;\\n                l=1e5-1;\\n            }\\n            else\\n            {\\n                l=INT_MIN;\\n                left[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(left[i]>right[i]){ans[i]=\\'L\\';}\\n            else if(left[i]<right[i]){ans[i]=\\'R\\';}\\n            else{ans[i]=\\'.\\';}\\n        }\\n        return ans;  \\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "Just Kep track of where the nearest Left and Right domino was. If left was near then it will fall towards left. Similarly for right. If both are equally near then it will be balanced condition.\\n\\n\\n```\\n string pushDominoes(string dominoes) \\n    {\\n        int sl=dominoes.length();\\n        string ans=dominoes;\\n        int left[sl];\\n        int right[sl];\\n        int r=INT_MIN,l=INT_MIN;\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                right[i]=r;\\n                if(r!=INT_MIN){r--;}\\n            }\\n            else if(dominoes[i]==\\'R\\')\\n            {\\n                right[i]=1e5;\\n                r=1e5-1;\\n            }\\n            else\\n            {\\n                r=INT_MIN;\\n                right[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=sl-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'.\\')\\n            {\\n                left[i]=l;\\n                if(l!=INT_MIN){l--;}\\n            }\\n            else if(dominoes[i]==\\'L\\')\\n            {\\n                left[i]=1e5;\\n                l=1e5-1;\\n            }\\n            else\\n            {\\n                l=INT_MIN;\\n                left[i]=INT_MIN;\\n            }\\n        }\\n        for(int i=0;i<sl;i++)\\n        {\\n            if(left[i]>right[i]){ans[i]=\\'L\\';}\\n            else if(left[i]<right[i]){ans[i]=\\'R\\';}\\n            else{ans[i]=\\'.\\';}\\n        }\\n        return ans;  \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2633178,
                "title": "simple-do-as-said-brute-force-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        vector<pair<int, int>> vec;\\n        bool r = false;\\n        int l = -1;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(r==true && l!=-1 && dominoes[i]==\\'L\\')\\n            {\\n                vec.push_back({l, i});\\n                r = false;\\n                l=-1;\\n            }\\n            \\n            if(dominoes[i]==\\'R\\')\\n            {\\n                if(r==true && l!=-1)\\n                {\\n                    while(l<i)\\n                    {\\n                        dominoes[l]=\\'R\\';\\n                        l++;\\n                    }\\n                }\\n                r = true;\\n                l = i;\\n            }\\n        }\\n        \\n        bool rr= false;\\n        int ll = -1;\\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(rr==true && ll!=-1 && dominoes[i]==\\'R\\')\\n            {\\n                //vec.push_back({l, i});\\n                rr = false;\\n                ll = -1;\\n            }\\n            \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                if(rr==true && ll!=-1)\\n                {\\n                    while(ll>i)\\n                    {\\n                        dominoes[ll]=\\'L\\';\\n                        ll--;\\n                    }\\n                }\\n                rr = true;\\n                ll = i;\\n            }\\n        }\\n        \\n        for(auto i:vec)\\n        {\\n            while(i.first<i.second)\\n            {\\n                dominoes[i.first]=\\'R\\';\\n                dominoes[i.second]=\\'L\\';\\n                i.first++;\\n                i.second--;\\n            }\\n        }\\n        \\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                int k=i;\\n                while(k>=0)\\n                {\\n                    dominoes[k]=\\'L\\';\\n                    k--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                int k=i;\\n                while(k<dominoes.size())\\n                {\\n                    dominoes[k]=\\'R\\';\\n                    k++;\\n                }\\n                break;\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        vector<pair<int, int>> vec;\\n        bool r = false;\\n        int l = -1;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(r==true && l!=-1 && dominoes[i]==\\'L\\')\\n            {\\n                vec.push_back({l, i});\\n                r = false;\\n                l=-1;\\n            }\\n            \\n            if(dominoes[i]==\\'R\\')\\n            {\\n                if(r==true && l!=-1)\\n                {\\n                    while(l<i)\\n                    {\\n                        dominoes[l]=\\'R\\';\\n                        l++;\\n                    }\\n                }\\n                r = true;\\n                l = i;\\n            }\\n        }\\n        \\n        bool rr= false;\\n        int ll = -1;\\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(rr==true && ll!=-1 && dominoes[i]==\\'R\\')\\n            {\\n                //vec.push_back({l, i});\\n                rr = false;\\n                ll = -1;\\n            }\\n            \\n            if(dominoes[i]==\\'L\\')\\n            {\\n                if(rr==true && ll!=-1)\\n                {\\n                    while(ll>i)\\n                    {\\n                        dominoes[ll]=\\'L\\';\\n                        ll--;\\n                    }\\n                }\\n                rr = true;\\n                ll = i;\\n            }\\n        }\\n        \\n        for(auto i:vec)\\n        {\\n            while(i.first<i.second)\\n            {\\n                dominoes[i.first]=\\'R\\';\\n                dominoes[i.second]=\\'L\\';\\n                i.first++;\\n                i.second--;\\n            }\\n        }\\n        \\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                int k=i;\\n                while(k>=0)\\n                {\\n                    dominoes[k]=\\'L\\';\\n                    k--;\\n                }\\n                break;\\n            }\\n        }\\n        \\n        for(int i=dominoes.size()-1;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'L\\')\\n            {\\n                break;\\n            }\\n            if(dominoes[i]==\\'R\\')\\n            {\\n                int k=i;\\n                while(k<dominoes.size())\\n                {\\n                    dominoes[k]=\\'R\\';\\n                    k++;\\n                }\\n                break;\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632491,
                "title": "time-based-simulation-queue",
                "content": "```\\nclass Solution {\\n\\t//just for debugging\\n    void  print(unordered_map<int,char> &mp) {\\n        if (mp.size() < 1) {\\n            return;\\n        }\\n        cout<<\"\\\\n\";\\n        unordered_map<int, char>:: iterator it;\\n        for(it = mp.begin(); it != mp.end(); it++) {\\n            cout<<\"[\"<<it->first<<\" \"<<it->second<<\"],\";\\n        }\\n        \\n    }\\npublic:\\n    \\n    string pushDominoes(string dominoes) {\\n        queue<int> q;\\n        for(int i = 0; i < dominoes.size(); i++) {\\n            if (dominoes[i] == \\'R\\' || dominoes[i] == \\'L\\') {\\n                q.push(i);\\n            }\\n        }\\n        /*\\n\\t\\t* every iteration of while loop is one second simulated. In that one second we will exert force on neighbour dominoe\\n\\t\\t* A Map is used to track what force is exerted on a specific neigbour\\n\\t\\t* if in that particular second we have opposing force acting on the neigbour then object would remain stand still \\n\\t\\t*/\\n\\t\\twhile (q.size() > 0) {\\n            int curSize = q.size();\\n            unordered_map<int, char> mp;    \\n            unordered_map<int, char>:: iterator it;   //int represent index of neigbour and char represent force acting on it in next second\\n            \\n            for (int i = 0; i < curSize; i++) {\\n                int pos = q.front(); q.pop();\\n               \\n      \\n                if (dominoes[pos] == \\'R\\' && (pos < dominoes.size() - 1) && dominoes[pos+1] == \\'.\\') {\\n                    it = mp.find(pos + 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'L\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                if (dominoes[pos] == \\'L\\' && pos > 0 && dominoes[pos - 1] == \\'.\\') {\\n                    it = mp.find(pos - 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'R\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos-1] = \\'L\\';\\n                    }\\n                }\\n            }\\n            //print(mp);\\n\\t\\t\\t// This step we will setup for simulating the next second;\\n            for (it = mp.begin(); it != mp.end(); it++) {\\n                    dominoes[it->first] = it->second;\\n                    q.push(it->first);\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n\\t//just for debugging\\n    void  print(unordered_map<int,char> &mp) {\\n        if (mp.size() < 1) {\\n            return;\\n        }\\n        cout<<\"\\\\n\";\\n        unordered_map<int, char>:: iterator it;\\n        for(it = mp.begin(); it != mp.end(); it++) {\\n            cout<<\"[\"<<it->first<<\" \"<<it->second<<\"],\";\\n        }\\n        \\n    }\\npublic:\\n    \\n    string pushDominoes(string dominoes) {\\n        queue<int> q;\\n        for(int i = 0; i < dominoes.size(); i++) {\\n            if (dominoes[i] == \\'R\\' || dominoes[i] == \\'L\\') {\\n                q.push(i);\\n            }\\n        }\\n        /*\\n\\t\\t* every iteration of while loop is one second simulated. In that one second we will exert force on neighbour dominoe\\n\\t\\t* A Map is used to track what force is exerted on a specific neigbour\\n\\t\\t* if in that particular second we have opposing force acting on the neigbour then object would remain stand still \\n\\t\\t*/\\n\\t\\twhile (q.size() > 0) {\\n            int curSize = q.size();\\n            unordered_map<int, char> mp;    \\n            unordered_map<int, char>:: iterator it;   //int represent index of neigbour and char represent force acting on it in next second\\n            \\n            for (int i = 0; i < curSize; i++) {\\n                int pos = q.front(); q.pop();\\n               \\n      \\n                if (dominoes[pos] == \\'R\\' && (pos < dominoes.size() - 1) && dominoes[pos+1] == \\'.\\') {\\n                    it = mp.find(pos + 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'L\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos+1] = \\'R\\';\\n                    }\\n                    \\n                }\\n                if (dominoes[pos] == \\'L\\' && pos > 0 && dominoes[pos - 1] == \\'.\\') {\\n                    it = mp.find(pos - 1);\\n\\t\\t\\t\\t\\t// here we evalute if there is already a force acting on the neigbour. If opposing force is present we remove it from the map\\n                    if (it != mp.end() && it->second ==\\'R\\') {\\n                        mp.erase(it);\\n                    } else {\\n                        mp[pos-1] = \\'L\\';\\n                    }\\n                }\\n            }\\n            //print(mp);\\n\\t\\t\\t// This step we will setup for simulating the next second;\\n            for (it = mp.begin(); it != mp.end(); it++) {\\n                    dominoes[it->first] = it->second;\\n                    q.push(it->first);\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2632464,
                "title": "faster-than-85-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/1ccbc1d8-c069-4b46-8e49-90a26f47424f_1664316389.9166017.png)\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = list(dominoes) #convert string to list\\n        i = last_point = 0 #set start point and last point which ready to being \\'L\\'\\n            \\n        while i < len(dominoes): #start cycle\\n            if dominoes[i] == \\'.\\': #go next if . in place\\n                i += 1\\n            elif dominoes[i] == \\'L\\': #if this, fill all \\'.\\' between last_point and i-1 and go next (last_point <= i forever)\\n                for j in range(last_point, i):\\n                    dominoes[j] = \\'L\\'\\n                i += 1\\n                last_point = i\\n            else: #if we in \\'R\\', check two ways: 1. it\\'s to (end or next \\'R\\') or (next \\'L\\')\\n                j = i + 1\\n                while j < len(dominoes) and dominoes[j] == \\'.\\': #check ways there\\n                    j += 1\\n                    \\n                if j == len(dominoes) or dominoes[j] == \\'R\\': #first way: fill all \\'.\\' the \\'R\\' and set next last_point after end this way\\n                    last_r = j\\n                    last_point = j + 1\\n                else: #second way: fill only half of all \\'.\\' and if count \\'.\\' is odd save 1 \\'.\\' for latter\\n                    last_r = i + 1 + (j - i - 1) // 2\\n                    last_point = j - (j - i - 1) // 2\\n                    \\n                for k in range(i+1, last_r): #filling \\'R\\' there\\n                        dominoes[k] = \\'R\\'\\n\\n                i = j #jump to next step\\n                \\n        return \\'\\'.join(dominoes) #return answer\\n\\n```\\n\\nP.S. Sry for my eng. It\\'s my first solution with comments)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        dominoes = list(dominoes) #convert string to list\\n        i = last_point = 0 #set start point and last point which ready to being \\'L\\'\\n            \\n        while i < len(dominoes): #start cycle\\n            if dominoes[i] == \\'.\\': #go next if . in place\\n                i += 1\\n            elif dominoes[i] == \\'L\\': #if this, fill all \\'.\\' between last_point and i-1 and go next (last_point <= i forever)\\n                for j in range(last_point, i):\\n                    dominoes[j] = \\'L\\'\\n                i += 1\\n                last_point = i\\n            else: #if we in \\'R\\', check two ways: 1. it\\'s to (end or next \\'R\\') or (next \\'L\\')\\n                j = i + 1\\n                while j < len(dominoes) and dominoes[j] == \\'.\\': #check ways there\\n                    j += 1\\n                    \\n                if j == len(dominoes) or dominoes[j] == \\'R\\': #first way: fill all \\'.\\' the \\'R\\' and set next last_point after end this way\\n                    last_r = j\\n                    last_point = j + 1\\n                else: #second way: fill only half of all \\'.\\' and if count \\'.\\' is odd save 1 \\'.\\' for latter\\n                    last_r = i + 1 + (j - i - 1) // 2\\n                    last_point = j - (j - i - 1) // 2\\n                    \\n                for k in range(i+1, last_r): #filling \\'R\\' there\\n                        dominoes[k] = \\'R\\'\\n\\n                i = j #jump to next step\\n                \\n        return \\'\\'.join(dominoes) #return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632350,
                "title": "c-o-n-best-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=s.size();\\n        vector<int> right(n),left(n);\\n        int r=-1,l=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')r=i;\\n            else if(s[i]==\\'L\\')r=-1;\\n            right[i]=r;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'L\\')l=i;\\n            else if(s[i]==\\'R\\')l=-1;\\n            left[i]=l;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\')\\n            {\\n                if(right[i]==-1 && left[i]==-1)\\n                    continue;\\n                if(right[i]==-1 && left[i]!=-1)s[i]=\\'L\\';\\n                else if(left[i]==-1 && right[i]!=-1)s[i]=\\'R\\';\\n                else\\n                {\\n                    if(left[i]-i<i-right[i]) s[i]=\\'L\\';\\n                    else if(i-right[i]<left[i]-i)s[i]=\\'R\\';\\n                    \\n                }\\n               \\n            }\\n        }\\n        return s;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n=s.size();\\n        vector<int> right(n),left(n);\\n        int r=-1,l=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')r=i;\\n            else if(s[i]==\\'L\\')r=-1;\\n            right[i]=r;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'L\\')l=i;\\n            else if(s[i]==\\'R\\')l=-1;\\n            left[i]=l;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'.\\')\\n            {\\n                if(right[i]==-1 && left[i]==-1)\\n                    continue;\\n                if(right[i]==-1 && left[i]!=-1)s[i]=\\'L\\';\\n                else if(left[i]==-1 && right[i]!=-1)s[i]=\\'R\\';\\n                else\\n                {\\n                    if(left[i]-i<i-right[i]) s[i]=\\'L\\';\\n                    else if(i-right[i]<left[i]-i)s[i]=\\'R\\';\\n                    \\n                }\\n               \\n            }\\n        }\\n        return s;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632144,
                "title": "o-1-space-o-n-time-c-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    void cg(string& s,char c,int st,int ed){\\n        for(int i=st;i<=ed;i++)\\n            s[i] = c;\\n    }\\n    \\n    string pushDominoes(string dm) {\\n        int n = dm.size();\\n        int st = 0;\\n        char a,b;\\n        int ok = 0;\\n        while(ok<n && dm[ok]==\\'.\\')\\n            ok++;\\n        \\n        if(ok==n)\\n            return dm;\\n            \\n        if(dm[ok]==\\'L\\'){\\n            for(int i=0;i<=ok;i++)\\n                dm[i]=\\'L\\';\\n        }\\n        \\n        \\n        a = dm[ok];\\n        st = ok;\\n        for(int i=ok+1;i<n;i++){\\n            \\n            while(i<n && dm[i]==\\'.\\')\\n                i++;\\n            \\n            if(i==n)\\n                i = n - 1;\\n            \\n            b = dm[i];\\n                \\n            if(a==\\'L\\' && b==\\'L\\')\\n                cg(dm,\\'L\\',st,i);\\n            else if(a==\\'R\\' && b==\\'R\\')\\n                cg(dm,\\'R\\',st,i);\\n            else if(a==\\'R\\' && b==\\'L\\'){\\n                int u = st,v =i;\\n                while(u<v)\\n                    dm[v--] = \\'L\\',dm[u++] = \\'R\\';\\n                \\n            }\\n            \\n            st = i;\\n            a = b;\\n        }\\n        \\n        int lst = n-1;\\n        char k;\\n        while(lst>=0){\\n            if(dm[lst]==\\'L\\' || dm[lst]==\\'R\\'){\\n                k = dm[lst];break;\\n            }\\n            lst--;\\n        }\\n        if(lst>=0 && k==\\'R\\')\\n            while(lst<n)\\n                dm[lst++] = k; \\n            \\n        return dm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void cg(string& s,char c,int st,int ed){\\n        for(int i=st;i<=ed;i++)\\n            s[i] = c;\\n    }\\n    \\n    string pushDominoes(string dm) {\\n        int n = dm.size();\\n        int st = 0;\\n        char a,b;\\n        int ok = 0;\\n        while(ok<n && dm[ok]==\\'.\\')\\n            ok++;\\n        \\n        if(ok==n)\\n            return dm;\\n            \\n        if(dm[ok]==\\'L\\'){\\n            for(int i=0;i<=ok;i++)\\n                dm[i]=\\'L\\';\\n        }\\n        \\n        \\n        a = dm[ok];\\n        st = ok;\\n        for(int i=ok+1;i<n;i++){\\n            \\n            while(i<n && dm[i]==\\'.\\')\\n                i++;\\n            \\n            if(i==n)\\n                i = n - 1;\\n            \\n            b = dm[i];\\n                \\n            if(a==\\'L\\' && b==\\'L\\')\\n                cg(dm,\\'L\\',st,i);\\n            else if(a==\\'R\\' && b==\\'R\\')\\n                cg(dm,\\'R\\',st,i);\\n            else if(a==\\'R\\' && b==\\'L\\'){\\n                int u = st,v =i;\\n                while(u<v)\\n                    dm[v--] = \\'L\\',dm[u++] = \\'R\\';\\n                \\n            }\\n            \\n            st = i;\\n            a = b;\\n        }\\n        \\n        int lst = n-1;\\n        char k;\\n        while(lst>=0){\\n            if(dm[lst]==\\'L\\' || dm[lst]==\\'R\\'){\\n                k = dm[lst];break;\\n            }\\n            lst--;\\n        }\\n        if(lst>=0 && k==\\'R\\')\\n            while(lst<n)\\n                dm[lst++] = k; \\n            \\n        return dm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632054,
                "title": "javascript-solution-sc-o-1-two-pointers",
                "content": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = dominoes.split(\\'\\');\\n    let l = 0, r = 0;\\n    while(r < dominoes.length){\\n        if(dominoes[r] === \\'L\\') while(l <= r) dominoes[l++] = \\'L\\';\\n        else if(dominoes[r] === \\'R\\'){\\n            l = r;\\n            let f = 0;\\n            r++;\\n            while(r < dominoes.length) {\\n                if(dominoes[r] === \\'R\\') {\\n                    f = 1;\\n                    break;\\n                }\\n                if(dominoes[r] === \\'L\\') break;\\n                r++;\\n            }\\n            if(r === dominoes.length || f === 1) {\\n                while(l < r) dominoes[l++] = \\'R\\';\\n                r--;\\n            }\\n            else {\\n                let dif = (r - l - 1) / 2 | 0;\\n                for(let i = 1; i <= dif; i++){\\n                    dominoes[l + i] = \\'R\\';\\n                    dominoes[r - i] = \\'L\\';\\n                }\\n                l = r + 1;\\n            }\\n        }\\n        r++;\\n    }\\n    return dominoes.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    dominoes = dominoes.split(\\'\\');\\n    let l = 0, r = 0;\\n    while(r < dominoes.length){\\n        if(dominoes[r] === \\'L\\') while(l <= r) dominoes[l++] = \\'L\\';\\n        else if(dominoes[r] === \\'R\\'){\\n            l = r;\\n            let f = 0;\\n            r++;\\n            while(r < dominoes.length) {\\n                if(dominoes[r] === \\'R\\') {\\n                    f = 1;\\n                    break;\\n                }\\n                if(dominoes[r] === \\'L\\') break;\\n                r++;\\n            }\\n            if(r === dominoes.length || f === 1) {\\n                while(l < r) dominoes[l++] = \\'R\\';\\n                r--;\\n            }\\n            else {\\n                let dif = (r - l - 1) / 2 | 0;\\n                for(let i = 1; i <= dif; i++){\\n                    dominoes[l + i] = \\'R\\';\\n                    dominoes[r - i] = \\'L\\';\\n                }\\n                l = r + 1;\\n            }\\n        }\\n        r++;\\n    }\\n    return dominoes.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631948,
                "title": "javascript-solution-use-string-prototype-replaceall",
                "content": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nfunction pushDominoes(dominoes) {\\n    while (true) {\\n        const newDominoes = dominoes.replaceAll(`R.L`, `_`).replaceAll(`.L`, `LL`).replaceAll(`R.`, `RR`).replaceAll(`_`, `R.L`);\\n        if (newDominoes === dominoes)\\n            return newDominoes;\\n        else dominoes = newDominoes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nfunction pushDominoes(dominoes) {\\n    while (true) {\\n        const newDominoes = dominoes.replaceAll(`R.L`, `_`).replaceAll(`.L`, `LL`).replaceAll(`R.`, `RR`).replaceAll(`_`, `R.L`);\\n        if (newDominoes === dominoes)\\n            return newDominoes;\\n        else dominoes = newDominoes;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631874,
                "title": "c-naive-approach-multiple-passes",
                "content": "Easy to understand, must upvote!\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        string finalDominoes(n, \\'#\\'), leftApplied = dominoes, rightApplied = dominoes;\\n        for(int i = n-1; i > 0; i--) {\\n            if(leftApplied[i] == \\'L\\' and leftApplied[i-1] == \\'.\\')\\n                leftApplied[i-1] = \\'L\\';\\n        }\\n        for(int i = 0; i < n-1; i++) {\\n            if(rightApplied[i] == \\'R\\' and rightApplied[i+1] == \\'.\\')\\n                rightApplied[i+1] = \\'R\\';\\n        }\\n        queue<int> windows; int windowCount = 0; \\n        for(int i = 0; i < n; i++) {\\n            if(leftApplied[i] == rightApplied[i])\\n                finalDominoes[i] = leftApplied[i];\\n            else if(leftApplied[i] == \\'.\\')\\n                finalDominoes[i] = rightApplied[i];\\n            else if(rightApplied[i] == \\'.\\')\\n                finalDominoes[i] = leftApplied[i];\\n            else {\\n                windowCount += 1; continue;\\n            }\\n            if(windowCount)\\n                windows.push(windowCount); \\n            windowCount = 0;\\n        }\\n        char prev = \\'\\\\0\\';\\n        for(int i = 0; i < n; i++) {\\n            if(finalDominoes[i] == \\'#\\') {\\n                int len = windows.front(); windows.pop();\\n                if(len == 1) {\\n                    finalDominoes[i] = \\'.\\';\\n                } else {\\n                    int j = i;\\n                    while(j < i + (len/2)) {    \\n                        finalDominoes[j] = prev;\\n                        j += 1;\\n                    }\\n                    if(len & 1) {\\n                        finalDominoes[j] = \\'.\\'; j += 1;\\n                    }\\n                    char remaining = (prev == \\'L\\')? \\'R\\': \\'L\\';\\n                    while(finalDominoes[j] == \\'#\\') {\\n                        finalDominoes[j] = remaining;\\n                        j += 1;\\n                    }\\n                    i = j-1;\\n                }\\n            }\\n            prev = finalDominoes[i];\\n        }\\n        return finalDominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.length();\\n        string finalDominoes(n, \\'#\\'), leftApplied = dominoes, rightApplied = dominoes;\\n        for(int i = n-1; i > 0; i--) {\\n            if(leftApplied[i] == \\'L\\' and leftApplied[i-1] == \\'.\\')\\n                leftApplied[i-1] = \\'L\\';\\n        }\\n        for(int i = 0; i < n-1; i++) {\\n            if(rightApplied[i] == \\'R\\' and rightApplied[i+1] == \\'.\\')\\n                rightApplied[i+1] = \\'R\\';\\n        }\\n        queue<int> windows; int windowCount = 0; \\n        for(int i = 0; i < n; i++) {\\n            if(leftApplied[i] == rightApplied[i])\\n                finalDominoes[i] = leftApplied[i];\\n            else if(leftApplied[i] == \\'.\\')\\n                finalDominoes[i] = rightApplied[i];\\n            else if(rightApplied[i] == \\'.\\')\\n                finalDominoes[i] = leftApplied[i];\\n            else {\\n                windowCount += 1; continue;\\n            }\\n            if(windowCount)\\n                windows.push(windowCount); \\n            windowCount = 0;\\n        }\\n        char prev = \\'\\\\0\\';\\n        for(int i = 0; i < n; i++) {\\n            if(finalDominoes[i] == \\'#\\') {\\n                int len = windows.front(); windows.pop();\\n                if(len == 1) {\\n                    finalDominoes[i] = \\'.\\';\\n                } else {\\n                    int j = i;\\n                    while(j < i + (len/2)) {    \\n                        finalDominoes[j] = prev;\\n                        j += 1;\\n                    }\\n                    if(len & 1) {\\n                        finalDominoes[j] = \\'.\\'; j += 1;\\n                    }\\n                    char remaining = (prev == \\'L\\')? \\'R\\': \\'L\\';\\n                    while(finalDominoes[j] == \\'#\\') {\\n                        finalDominoes[j] = remaining;\\n                        j += 1;\\n                    }\\n                    i = j-1;\\n                }\\n            }\\n            prev = finalDominoes[i];\\n        }\\n        return finalDominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631842,
                "title": "simple-java-solution-greedy-single-pass-solution",
                "content": "```\\n//if you found my solution usefull please upvote it\\nclass Solution \\n{\\n    public String pushDominoes(String dominoes) \\n    {\\n        StringBuilder ans=new StringBuilder(\"\");\\n        int i=0;\\n        while(i<dominoes.length())\\n        {\\n            char ch=dominoes.charAt(i);\\n            if(ch==\\'.\\')\\n            {\\n                int j=i+1;\\n                while(j<dominoes.length() && dominoes.charAt(j)!=\\'L\\' && dominoes.charAt(j)!=\\'R\\') j++;\\n                if(j<dominoes.length() && dominoes.charAt(j)==\\'L\\' )\\n                {\\n                    for(int k=i;k<=j;k++)  ans.append(\"L\");\\n                    i=j+1;\\n                }\\n                else if(j<dominoes.length() && dominoes.charAt(j)==\\'R\\')\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\".\");\\n                    i=j;\\n                }\\n                else if(j>=dominoes.length())\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\".\");\\n                    i=j;\\n                }\\n            }\\n            else if(ch==\\'R\\')\\n            {\\n                int j=i+1;\\n                while(j<dominoes.length() && dominoes.charAt(j)!=\\'L\\' && dominoes.charAt(j)!=\\'R\\') j++;\\n                if(j<dominoes.length() && dominoes.charAt(j)==\\'R\\')\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\"R\");\\n                    i=j;\\n                }\\n                else if(j<dominoes.length() && dominoes.charAt(j)==\\'L\\')\\n                {\\n                    int len=j-i+1;\\n                if(len%2==0)\\n                {\\n                    int half=len/2;\\n                    for(int k=0;k<half;k++)  ans.append(\"R\");\\n                    for(int k=0;k<half;k++)  ans.append(\"L\");\\n                }\\n                else\\n                {\\n                    int half=((len+1)/2)-1;\\n                    for(int k=0;k<half;k++)  ans.append(\"R\");\\n                    ans.append(\".\");\\n                    for(int k=0;k<half;k++)  ans.append(\"L\");\\n                }\\n                i=j+1;\\n                }\\n                else if(j>=dominoes.length())\\n                {\\n                    for(int k=i;k<j;k++)  ans.append(\"R\");\\n                    i=j;\\n                }\\n            }\\n            else if(ch==\\'L\\') \\n            {\\n                ans.append(\"L\");\\n                i++;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public String pushDominoes(String dominoes) \\n    {\\n        StringBuilder ans=new StringBuilder(\"\");\\n        int i=0;\\n        while(i<dominoes.length())\\n        {\\n            char ch=dominoes.charAt(i);\\n            if(ch==\\'.\\')\\n            {\\n                int j=i+1;\\n                while(j<dominoes.length() && dominoes.charAt(j)!=\\'L\\' && dominoes.charAt(j)!=\\'R\\') j++;\\n                if(j<dominoes.length() && dominoes.charAt(j)==\\'L\\' )\\n                {\\n                    for(int k=i;k<=j;k++)  ans.append(\"L\");\\n                    i=j+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2631809,
                "title": "python-one-liner",
                "content": "```\\n# 47.90% 30.84% (53.51% 30.84%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\'))\\n\\n```\\n\\n**Upd:**\\nTranslating \\'X\\' back to \\'R.L\\' only at last step - when no moves left.\\n\\n```\\n# 78.84% 36.51% (77.67% 33.26%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\'))\\n\\n```\\n\\n**Details:**\\n```\\n# 94.42% 34.42% (95.58% 34.42%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\ttest = dominoes.replace(\\'R.L\\', \\'X\\') # hiding edge case \\'R.L\\' with \\'X\\'\\n\\ttest = test.replace(\\'.L\\', \\'LL\\')     # falling left\\n\\ttest = test.replace(\\'R.\\', \\'RR\\')     # falling right\\n\\tif test != dominoes:                # falls happened\\n\\t\\treturn self.pushDominoes(test)  # continue pushing dominoes\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') # no falls - translating \\'X\\' back and returning final result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# 47.90% 30.84% (53.51% 30.84%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\').replace(\\'X\\', \\'R.L\\'))\\n\\n```\n```\\n# 78.84% 36.51% (77.67% 33.26%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') if dominoes == dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\') else self.pushDominoes(dominoes.replace(\\'R.L\\', \\'X\\').replace(\\'.L\\', \\'LL\\').replace(\\'R.\\', \\'RR\\'))\\n\\n```\n```\\n# 94.42% 34.42% (95.58% 34.42%)\\ndef pushDominoes(self, dominoes: str) -> str:\\n\\ttest = dominoes.replace(\\'R.L\\', \\'X\\') # hiding edge case \\'R.L\\' with \\'X\\'\\n\\ttest = test.replace(\\'.L\\', \\'LL\\')     # falling left\\n\\ttest = test.replace(\\'R.\\', \\'RR\\')     # falling right\\n\\tif test != dominoes:                # falls happened\\n\\t\\treturn self.pushDominoes(test)  # continue pushing dominoes\\n\\treturn dominoes.replace(\\'X\\', \\'R.L\\') # no falls - translating \\'X\\' back and returning final result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2631620,
                "title": "92-faster-89-less-memory-c-o-1-space-o-n-time",
                "content": "We only have to consider the interval with all ```\\'.\\'```, and handle all the cases for the same.\\nBranching in the helper function, can be evidently, a bit more clean, but the algorithm works just fine.\\nPlease upvote if you find the solution helpful.\\n***Thank You!!***\\n```\\nclass Solution {\\npublic:\\n    void func(string& s, int &last, int &idx, int &n) {\\n        if(last == -1 and idx == n) return;\\n        else if(last == -1) {\\n            if(s[idx] == \\'L\\') {\\n                for(int i=0;i<idx;i++) s[i] = \\'L\\';\\n            }\\n        }\\n        else if(idx == n) {\\n            if(s[last] == \\'R\\') {\\n                for(int i = last +1;i<n;i++) s[i] =\\'R\\';\\n            }\\n        }\\n        else {\\n            if(s[last] == \\'R\\' and s[idx] == \\'L\\') {\\n                int no_dom = idx - last - 1;\\n                for(int len = 1, i = last + 1; len <= (no_dom>>1);len++, i++)\\n                    s[i] = \\'R\\';\\n                for(int len = 1, i = idx - 1; len <= (no_dom>>1);len++, i--)\\n                    s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'R\\' and s[idx] == \\'R\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'R\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'L\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'R\\') {\\n                return;\\n            }\\n        }\\n    }\\n    string pushDominoes(string s) {\\n        int n = s.size(), idx = 0, last_left = -1;\\n        while(idx < n and s[idx] == \\'.\\') idx++;\\n        while(idx < n) {\\n            func(s, last_left, idx, n);\\n            while(idx < n and s[idx] - \\'.\\') idx++;\\n            last_left = idx - 1;\\n            while(idx < n and s[idx] == \\'.\\') idx++;\\n        }\\n        func(s, last_left, idx, n);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\'.\\'```\n```\\nclass Solution {\\npublic:\\n    void func(string& s, int &last, int &idx, int &n) {\\n        if(last == -1 and idx == n) return;\\n        else if(last == -1) {\\n            if(s[idx] == \\'L\\') {\\n                for(int i=0;i<idx;i++) s[i] = \\'L\\';\\n            }\\n        }\\n        else if(idx == n) {\\n            if(s[last] == \\'R\\') {\\n                for(int i = last +1;i<n;i++) s[i] =\\'R\\';\\n            }\\n        }\\n        else {\\n            if(s[last] == \\'R\\' and s[idx] == \\'L\\') {\\n                int no_dom = idx - last - 1;\\n                for(int len = 1, i = last + 1; len <= (no_dom>>1);len++, i++)\\n                    s[i] = \\'R\\';\\n                for(int len = 1, i = idx - 1; len <= (no_dom>>1);len++, i--)\\n                    s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'R\\' and s[idx] == \\'R\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'R\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'L\\') {\\n                for(int i=last + 1;i<idx;i++) s[i] = \\'L\\';\\n            }\\n            else if(s[last] == \\'L\\' and s[idx] == \\'R\\') {\\n                return;\\n            }\\n        }\\n    }\\n    string pushDominoes(string s) {\\n        int n = s.size(), idx = 0, last_left = -1;\\n        while(idx < n and s[idx] == \\'.\\') idx++;\\n        while(idx < n) {\\n            func(s, last_left, idx, n);\\n            while(idx < n and s[idx] - \\'.\\') idx++;\\n            last_left = idx - 1;\\n            while(idx < n and s[idx] == \\'.\\') idx++;\\n        }\\n        func(s, last_left, idx, n);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631314,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n = len(dominoes)\\n        \\n        right_force = [0] * n\\n        \\n        for i in range(n):\\n            if dominoes[i] == \\'R\\':\\n                right_force[i] = n\\n            elif dominoes[i] == \\'L\\':\\n                right_force[i] = 0\\n            else:\\n                if(i-1 >= 0):\\n                    right_force[i] = max(right_force[i-1]-1, 0)\\n\\n        left_force = [0] * n\\n        \\n        for i in range(n-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                left_force[i] = n\\n            elif dominoes[i] == \\'R\\':\\n                left_force[i] = 0\\n            else:\\n                if(i+1 < n):\\n                    left_force[i] = max(left_force[i+1]-1, 0)\\n    \\n        return \\'\\'.join(\\'.\\' if right_force[i] == left_force[i] else \\'R\\' if right_force[i] > left_force[i] else \\'L\\' for i in range(n))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n = len(dominoes)\\n        \\n        right_force = [0] * n\\n        \\n        for i in range(n):\\n            if dominoes[i] == \\'R\\':\\n                right_force[i] = n\\n            elif dominoes[i] == \\'L\\':\\n                right_force[i] = 0\\n            else:\\n                if(i-1 >= 0):\\n                    right_force[i] = max(right_force[i-1]-1, 0)\\n\\n        left_force = [0] * n\\n        \\n        for i in range(n-1, -1, -1):\\n            if dominoes[i] == \\'L\\':\\n                left_force[i] = n\\n            elif dominoes[i] == \\'R\\':\\n                left_force[i] = 0\\n            else:\\n                if(i+1 < n):\\n                    left_force[i] = max(left_force[i+1]-1, 0)\\n    \\n        return \\'\\'.join(\\'.\\' if right_force[i] == left_force[i] else \\'R\\' if right_force[i] > left_force[i] else \\'L\\' for i in range(n))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631291,
                "title": "c-fastest-submission-crisp-and-clear-dp",
                "content": "TC: O(N + N) -->~ = O(N)\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        int n=str.size();\\n        vector<int>arr(n);\\n        string ans=str;\\n        \\n        int right_force=0;\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'L\\')\\n                right_force=0;\\n            if(str[i]==\\'R\\')\\n                right_force=1;\\n            if(str[i]==\\'.\\' && right_force>0)\\n                right_force++;\\n            arr[i]=right_force;\\n        }\\n       \\n        int left_force=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(str[i]==\\'R\\') left_force=0;\\n            if(str[i]==\\'L\\') left_force=1;\\n            if(str[i]==\\'.\\')\\n            {\\n                if(left_force>0)\\n                    left_force++;\\n                \\n                if(arr[i]==0 && left_force>0)\\n                    ans[i]=\\'L\\';\\n                else if(arr[i]>0 && left_force==0)\\n                    ans[i]=\\'R\\';\\n                \\n                //force from both direction\\n                else if(arr[i]<left_force)\\n                    ans[i]=\\'R\\';\\n                else if(arr[i]>left_force) \\n                    ans[i]=\\'L\\';\\n                \\n                // equilibrium condition arr[i] == left_force \\n                else\\n                    ans[i]=\\'.\\';  // no change\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string str) {\\n        int n=str.size();\\n        vector<int>arr(n);\\n        string ans=str;\\n        \\n        int right_force=0;\\n        for(int i=0;i<n;i++){\\n            if(str[i]==\\'L\\')\\n                right_force=0;\\n            if(str[i]==\\'R\\')\\n                right_force=1;\\n            if(str[i]==\\'.\\' && right_force>0)\\n                right_force++;\\n            arr[i]=right_force;\\n        }\\n       \\n        int left_force=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(str[i]==\\'R\\') left_force=0;\\n            if(str[i]==\\'L\\') left_force=1;\\n            if(str[i]==\\'.\\')\\n            {\\n                if(left_force>0)\\n                    left_force++;\\n                \\n                if(arr[i]==0 && left_force>0)\\n                    ans[i]=\\'L\\';\\n                else if(arr[i]>0 && left_force==0)\\n                    ans[i]=\\'R\\';\\n                \\n                //force from both direction\\n                else if(arr[i]<left_force)\\n                    ans[i]=\\'R\\';\\n                else if(arr[i]>left_force) \\n                    ans[i]=\\'L\\';\\n                \\n                // equilibrium condition arr[i] == left_force \\n                else\\n                    ans[i]=\\'.\\';  // no change\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631285,
                "title": "58ms-cpp-fast-code",
                "content": "Calculating time to fall and returning net fall time.\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> l(d.size(),-1);\\n        vector<int> r(d.size(),-1);\\n        int set = 0;\\n        int lset = 0;\\n        for(int i=0,j=d.size()-1;i<d.size();i++,j--) {\\n            if(d[i] == \\'.\\') {\\n                if(set == 0) l[i] = 0;\\n                else {\\n                    l[i] = set;\\n                    set++;\\n                }\\n            } else if(d[i] == \\'R\\') {\\n                set = 1;\\n                l[i] = INT_MAX;\\n            } else if(d[i] == \\'L\\') {\\n                set = 0;\\n                l[i] = INT_MAX;\\n            }\\n            if(d[j] == \\'.\\') {\\n                if(lset == 0) r[j] = 0;\\n                else {\\n                    r[j] = lset;\\n                    lset--;\\n                }\\n            } else if(d[j] == \\'R\\') {\\n                lset = 0;\\n                r[j] = INT_MAX;\\n            } else if(d[j] == \\'L\\') {\\n                lset = -1;\\n                r[j] = INT_MAX;\\n            }\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<d.size();i++) {\\n            if(l[i] == 0 || r[i] == 0) {\\n                int res = (l[i]+r[i])*(-1);\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            } else if(l[i] == INT_MAX || r[i]==INT_MAX) {\\n                temp+=d[i];\\n            } else {\\n                int res = l[i]+r[i];\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> l(d.size(),-1);\\n        vector<int> r(d.size(),-1);\\n        int set = 0;\\n        int lset = 0;\\n        for(int i=0,j=d.size()-1;i<d.size();i++,j--) {\\n            if(d[i] == \\'.\\') {\\n                if(set == 0) l[i] = 0;\\n                else {\\n                    l[i] = set;\\n                    set++;\\n                }\\n            } else if(d[i] == \\'R\\') {\\n                set = 1;\\n                l[i] = INT_MAX;\\n            } else if(d[i] == \\'L\\') {\\n                set = 0;\\n                l[i] = INT_MAX;\\n            }\\n            if(d[j] == \\'.\\') {\\n                if(lset == 0) r[j] = 0;\\n                else {\\n                    r[j] = lset;\\n                    lset--;\\n                }\\n            } else if(d[j] == \\'R\\') {\\n                lset = 0;\\n                r[j] = INT_MAX;\\n            } else if(d[j] == \\'L\\') {\\n                lset = -1;\\n                r[j] = INT_MAX;\\n            }\\n        }\\n        string temp=\"\";\\n        for(int i=0;i<d.size();i++) {\\n            if(l[i] == 0 || r[i] == 0) {\\n                int res = (l[i]+r[i])*(-1);\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            } else if(l[i] == INT_MAX || r[i]==INT_MAX) {\\n                temp+=d[i];\\n            } else {\\n                int res = l[i]+r[i];\\n                if(res<0) temp+=\\'R\\';\\n                else if(res>0) temp+=\\'L\\';\\n                else temp+=\\'.\\';\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631133,
                "title": "c-solution-using-pointer",
                "content": "\\t\\t*********please upvote if you like **********\\n\\t\\t\\n\\t\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n   \\n    static void solve(vector<char> &v,int j,int k){\\n       if(v[j]==\\'L\\'&&v[k]==\\'L\\'){\\n           for(int i=j+1;i<k;i++){\\n               v[i]=\\'L\\';\\n           }\\n           \\n       }else if(v[j]==\\'R\\'&&v[k]==\\'R\\'){\\n            for(int i=j+1;i<k;i++){\\n               v[i]=\\'R\\';\\n           }\\n           \\n       }\\n        else if(v[j]==\\'L\\'&&v[k]==\\'R\\'){\\n\\t\\t\\t//                  do nothing\\n        }\\n        else{\\n            int diff=k-j;\\n            int mid=(j+k)/2;\\n            if(diff%2!=0){\\n               for(int i=j+1;i<=mid;i++){\\n                  v[i]=\\'R\\'; \\n               }\\n                for(int i=mid+1;i<k;i++){\\n                  v[i]=\\'L\\'; \\n               }\\n                \\n                \\n            }\\n            else{\\n                 for(int i=j+1;i<mid;i++){\\n                  v[i]=\\'R\\'; \\n               }\\n                 for(int i=mid+1;i<k;i++){\\n                  v[i]=\\'L\\'; \\n               }    \\n            }\\n            \\n        }\\n    }\\n    string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n     vector<char>v(n+2);\\n        v[0]=\\'L\\';\\n        v[n+1]=\\'R\\';\\n        for(int i=1;i<v.size()-1;i++){\\n            v[i]=dominoes[i-1]; \\n        }\\n        int j=0,k=1;\\n        while(k<v.size()){\\n            while(v[k]==\\'.\\'){\\n                k++;\\n            }\\n            if(k-j>1)\\n            solve(v,j,k);\\n            j=k;\\n            k++;\\n        }\\n        string ans=\"\";\\n        for(int i=1;i<v.size()-1;i++){\\n            ans+=v[i];\\n        }\\n        \\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n   \\n    static void solve(vector<char> &v,int j,int k){\\n       if(v[j]==\\'L\\'&&v[k]==\\'L\\'){\\n           for(int i=j+1;i<k;i++){\\n               v[i]=\\'L\\';\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2630914,
                "title": "cpp-easy-to-understand",
                "content": "# \\t*please upvote if  this solution helped you*\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tans += dominoes[0];\\n\\t\\t\\tint n = dominoes.size();\\n\\t\\t\\tpair<char,int>prev = {dominoes[0],0};\\n\\t\\t\\tfor(int i =1;i<n;i++){\\n\\t\\t\\t\\tans += dominoes[i]; \\n\\t\\t\\t\\tif(prev.first == \\'.\\' && dominoes[i] == \\'.\\') continue;\\n\\n\\t\\t\\t\\tif(prev.first == dominoes[i] ){\\n\\t\\t\\t\\t\\tfor(int j = prev.second+1;j<i;j++){\\n\\t\\t\\t\\t\\t\\tans[j] = dominoes[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\telse if(prev.first == \\'.\\' && dominoes[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tfor(int j = prev.second;j<i;j++){\\n\\t\\t\\t\\t\\t\\tans[j] = \\'L\\';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t else if(prev.first == \\'R\\' && dominoes[i] == \\'L\\'){\\n\\t\\t\\t\\t\\tint prev_idx = prev.second;\\n\\t\\t\\t\\t\\tprev_idx++;\\n\\t\\t\\t\\t\\tint curr_idx = i;\\n\\t\\t\\t\\t\\tcurr_idx--;\\n\\t\\t\\t\\t\\twhile(prev_idx < curr_idx){\\n\\t\\t\\t\\t\\t\\tans[prev_idx] = \\'R\\';\\n\\t\\t\\t\\t\\t\\tans[curr_idx] = \\'L\\';\\n\\t\\t\\t\\t\\t\\tprev_idx++;\\n\\t\\t\\t\\t\\t\\tcurr_idx--;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\t\\tif(dominoes[i] != \\'.\\') prev = {dominoes[i],i};\\n\\n\\t\\t\\t}\\n\\t\\t\\tif(prev.first == \\'R\\'){\\n\\t\\t\\t\\tfor(int i = prev.second;i<n;i++){\\n\\t\\t\\t\\t\\tans[i] = \\'R\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string dominoes) {\\n\\t\\t\\tstring ans = \"\";\\n\\t\\t\\tans += dominoes[0];\\n\\t\\t\\tint n = dominoes.size();\\n\\t\\t\\tpair<char,int>prev = {dominoes[0],0}",
                "codeTag": "Java"
            },
            {
                "id": 2630889,
                "title": "easy",
                "content": "```\\nclass Solution {\\n    public:\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int>L(n,INT_MAX);\\n        vector<int>R(n,INT_MAX);\\n        if(s[n-1]==\\'L\\')L[n-1]=0;\\n        for (int i = n-2; i >=0; i--)\\n        {\\n            if(s[i]==\\'R\\')\\n            continue;\\n            if(s[i]==\\'L\\')L[i]=0;\\n            else if(s[i]==\\'R\\')L[i]=INT_MAX;\\n            else L[i]=L[i+1]+1;\\n        }\\n\\n        if (s[0]==\\'R\\')R[0]=0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            continue;\\n            if(s[i]==\\'R\\')R[i]=0;\\n            else if(s[i]==\\'L\\')R[i]=INT_MAX;\\n            else R[i]=R[i-1]+1;\\n        }\\n\\n        string ans=\"\";\\n        for (int i = 0; i < n; i++)\\n        {\\n            if(L[i]==R[i])ans+=\\'.\\';\\n            else if(L[i]<R[i])ans+=\\'L\\';\\n            else ans+=\\'R\\';\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    string pushDominoes(string s){\\n        int n = s.length();\\n        vector<int>L(n,INT_MAX);\\n        vector<int>R(n,INT_MAX);\\n        if(s[n-1]==\\'L\\')L[n-1]=0;\\n        for (int i = n-2; i >=0; i--)\\n        {\\n            if(s[i]==\\'R\\')\\n            continue;\\n            if(s[i]==\\'L\\')L[i]=0;\\n            else if(s[i]==\\'R\\')L[i]=INT_MAX;\\n            else L[i]=L[i+1]+1;\\n        }\\n\\n        if (s[0]==\\'R\\')R[0]=0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if(s[i]==\\'L\\')\\n            continue;\\n            if(s[i]==\\'R\\')R[i]=0;\\n            else if(s[i]==\\'L\\')R[i]=INT_MAX;\\n            else R[i]=R[i-1]+1;\\n        }\\n\\n        string ans=\"\";\\n        for (int i = 0; i < n; i++)\\n        {\\n            if(L[i]==R[i])ans+=\\'.\\';\\n            else if(L[i]<R[i])ans+=\\'L\\';\\n            else ans+=\\'R\\';\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630840,
                "title": "java-two-approaches",
                "content": "### Please Upvote !!! **(\\u25E0\\u203F\\u25E0)**\\n##### Approach 1:\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] arr = new char[n + 2];\\n        arr[0] = \\'L\\'; arr[n + 1] = \\'R\\';\\n\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            arr[i] = dominoes.charAt(i - 1);\\n        }\\n\\n        int i = 0, j = 1;\\n\\n        while (j < arr.length) {\\n            while (arr[j] == \\'.\\') j++;\\n            if (j - i > 1) helper(arr, i, j);\\n            i = j++;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int idx = 1; idx < arr.length - 1; idx++) {\\n            ans.append(arr[idx]);\\n        }\\n\\n        return ans.toString();\\n    }\\n\\n    public void helper(char[] arr, int i, int j) {\\n        // case 1\\n        if (arr[i] == \\'L\\' && arr[j] == \\'L\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'L\\';\\n            }\\n        }\\n\\n        // case 2\\n        else if (arr[i] == \\'R\\' && arr[j] == \\'R\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'R\\';\\n            }\\n        }\\n\\n        // case 3\\n        else if (arr[i] == \\'L\\' && arr[j] == \\'R\\') {\\n            // do nothing\\n        }\\n\\n        // case 4\\n        // arr[i] == \\'R\\' && arr[j] == \\'L\\'\\n        else {\\n            int l = i + 1, r = j - 1;\\n            while (l < r) {\\n                arr[l++] = \\'R\\';\\n                arr[r--] = \\'L\\';\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) + O(n);\\n// SC: O(n)\\n```\\n\\n##### Approach 2:\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n\\n        int[] left = new int[n];\\n        int nearestLeftIdx = -1;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'L\\') nearestLeftIdx = i;\\n            else if (c == \\'R\\') nearestLeftIdx = -1;\\n            left[i] = nearestLeftIdx;\\n        }\\n\\n        int[] right = new int[n];\\n        int nearestRightIdx = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'R\\') nearestRightIdx = i;\\n            else if (c == \\'L\\') nearestRightIdx = -1;\\n            right[i] = nearestRightIdx;\\n        }\\n\\n        char[] ans = new char[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (dominoes.charAt(i) == \\'.\\') {\\n                int nearestLeft = left[i];\\n                int nearestRight = right[i];\\n\\n                int leftDiff = (nearestLeft == -1) ? Integer.MAX_VALUE : Math.abs(nearestLeft - i);\\n                int rightDiff = (nearestRight == -1) ? Integer.MAX_VALUE : Math.abs(nearestRight - i);\\n\\n                if (leftDiff == rightDiff) ans[i] = \\'.\\';\\n                else if (leftDiff < rightDiff) ans[i] = \\'L\\';\\n                else ans[i] = \\'R\\';  // leftDiff > rightDiff\\n            }\\n\\n            else ans[i] = dominoes.charAt(i);\\n        }\\n\\n        return new String(ans);\\n    }\\n}\\n\\n// TC: O(n + O(n) + O(n) => O(n)\\n// SC: O(n) + O(n) => O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] arr = new char[n + 2];\\n        arr[0] = \\'L\\'; arr[n + 1] = \\'R\\';\\n\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            arr[i] = dominoes.charAt(i - 1);\\n        }\\n\\n        int i = 0, j = 1;\\n\\n        while (j < arr.length) {\\n            while (arr[j] == \\'.\\') j++;\\n            if (j - i > 1) helper(arr, i, j);\\n            i = j++;\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (int idx = 1; idx < arr.length - 1; idx++) {\\n            ans.append(arr[idx]);\\n        }\\n\\n        return ans.toString();\\n    }\\n\\n    public void helper(char[] arr, int i, int j) {\\n        // case 1\\n        if (arr[i] == \\'L\\' && arr[j] == \\'L\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'L\\';\\n            }\\n        }\\n\\n        // case 2\\n        else if (arr[i] == \\'R\\' && arr[j] == \\'R\\') {\\n            for (int a = i + 1; a < j; a++) {\\n                arr[a] = \\'R\\';\\n            }\\n        }\\n\\n        // case 3\\n        else if (arr[i] == \\'L\\' && arr[j] == \\'R\\') {\\n            // do nothing\\n        }\\n\\n        // case 4\\n        // arr[i] == \\'R\\' && arr[j] == \\'L\\'\\n        else {\\n            int l = i + 1, r = j - 1;\\n            while (l < r) {\\n                arr[l++] = \\'R\\';\\n                arr[r--] = \\'L\\';\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) + O(n);\\n// SC: O(n)\\n```\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n\\n        int[] left = new int[n];\\n        int nearestLeftIdx = -1;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'L\\') nearestLeftIdx = i;\\n            else if (c == \\'R\\') nearestLeftIdx = -1;\\n            left[i] = nearestLeftIdx;\\n        }\\n\\n        int[] right = new int[n];\\n        int nearestRightIdx = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = dominoes.charAt(i);\\n            if (c == \\'R\\') nearestRightIdx = i;\\n            else if (c == \\'L\\') nearestRightIdx = -1;\\n            right[i] = nearestRightIdx;\\n        }\\n\\n        char[] ans = new char[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (dominoes.charAt(i) == \\'.\\') {\\n                int nearestLeft = left[i];\\n                int nearestRight = right[i];\\n\\n                int leftDiff = (nearestLeft == -1) ? Integer.MAX_VALUE : Math.abs(nearestLeft - i);\\n                int rightDiff = (nearestRight == -1) ? Integer.MAX_VALUE : Math.abs(nearestRight - i);\\n\\n                if (leftDiff == rightDiff) ans[i] = \\'.\\';\\n                else if (leftDiff < rightDiff) ans[i] = \\'L\\';\\n                else ans[i] = \\'R\\';  // leftDiff > rightDiff\\n            }\\n\\n            else ans[i] = dominoes.charAt(i);\\n        }\\n\\n        return new String(ans);\\n    }\\n}\\n\\n// TC: O(n + O(n) + O(n) => O(n)\\n// SC: O(n) + O(n) => O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630601,
                "title": "this-java-solution-beats-90-96-of-java-submissions",
                "content": "**Upvote if you\\'re not greedy)))**\\n```\\nclass Solution {\\n    private char[] result;\\n\\n    public String pushDominoes(String dominoes) {\\n        int len = dominoes.length();\\n        result = dominoes.toCharArray();\\n        for (int i = 0; i < len; i++) {\\n            char temp = dominoes.charAt(i);\\n            if (temp == \\'.\\') {\\n                int left = i;\\n                while (i < len && dominoes.charAt(i) == \\'.\\') {\\n                    i++;\\n                }\\n                int right = i - 1;\\n                char rChar = right == len - 1 ? \\'.\\' : dominoes.charAt(right + 1);\\n                char lChar = left == 0 ? \\'.\\' : dominoes.charAt(left - 1);\\n                if (lChar != \\'R\\' && rChar == \\'L\\') {\\n                    fillSubstringBy(left, right, \\'L\\');\\n                } else if (rChar != \\'L\\' && lChar == \\'R\\') {\\n                    fillSubstringBy(left, right, \\'R\\');\\n                } else if (lChar == \\'R\\') {\\n                    fillSubstring(left, right);\\n                }\\n            }\\n        }\\n        return new String(result);\\n    }\\n\\n    private void fillSubstring(int left, int right) {\\n        while (right > left) {\\n            result[right--] = \\'L\\';\\n            result[left++] = \\'R\\';\\n        }\\n    }\\n\\n    private void fillSubstringBy(int left, int right, char c) {\\n        for (int i = left; i <= right; i++) {\\n            result[i] = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    private char[] result;\\n\\n    public String pushDominoes(String dominoes) {\\n        int len = dominoes.length();\\n        result = dominoes.toCharArray();\\n        for (int i = 0; i < len; i++) {\\n            char temp = dominoes.charAt(i);\\n            if (temp == \\'.\\') {\\n                int left = i;\\n                while (i < len && dominoes.charAt(i) == \\'.\\') {\\n                    i++;\\n                }\\n                int right = i - 1;\\n                char rChar = right == len - 1 ? \\'.\\' : dominoes.charAt(right + 1);\\n                char lChar = left == 0 ? \\'.\\' : dominoes.charAt(left - 1);\\n                if (lChar != \\'R\\' && rChar == \\'L\\') {\\n                    fillSubstringBy(left, right, \\'L\\');\\n                } else if (rChar != \\'L\\' && lChar == \\'R\\') {\\n                    fillSubstringBy(left, right, \\'R\\');\\n                } else if (lChar == \\'R\\') {\\n                    fillSubstring(left, right);\\n                }\\n            }\\n        }\\n        return new String(result);\\n    }\\n\\n    private void fillSubstring(int left, int right) {\\n        while (right > left) {\\n            result[right--] = \\'L\\';\\n            result[left++] = \\'R\\';\\n        }\\n    }\\n\\n    private void fillSubstringBy(int left, int right, char c) {\\n        for (int i = left; i <= right; i++) {\\n            result[i] = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630599,
                "title": "c-efficent-o-n-time-o-1-space-solution-18ms",
                "content": "Testing the various corner cases is a challenge, but a essentially I grouped the string into substrings [left, right] where _right_ is the index of the next action (\\'R\\' or \\'L\\') and _left_ maybe an action.\\n\\nDepending on the which state, the return can be `memset` for quick performance;\\n|dominoes[left]|dominoes[right]|result|\\n|---|---|---|\\n|`R`|`R`|Everything between _left_ and _right_ gets filled with `R` and _left_ is set to _right_|\\n|`.`|`R`|Everything upto _right_ gets filled with `.` and _left_ is set to _right_|\\n|`L`|`R`|Everything after _left_ upto _right_ gets filled with `.` and _left_ is set to _right_|\\n|`R`|`L`|They will meet in the middle. Fill first half with `R` then add a `.` if the gap between them is odd, before filling the rest with `L`|\\n|`.` or `L`|`L`|Fill _left_ to _right_ with `L` and set _left_ to just after _right_|\\n\\nThere is some bonus, corner cases to do with the start and end, but not too much trouble. The resulting code is not a pretty as I would like, but runs fast;\\n\\n```c\\nchar * pushDominoes(char * dominoes) {\\n\\tsize_t len = strlen(dominoes);\\n\\tchar* const ret = malloc(len + 1);\\n\\tret[len] = \\'\\\\0\\';\\n\\n\\tint left = 0;\\n\\twhile (left < len) {\\n\\t\\t/* Find the next interesting action */\\n\\t\\tint right = left + 1;\\n\\t\\twhile (right < len && \\'.\\' == dominoes[right]) {\\n\\t\\t\\t++right;\\n\\t\\t}\\n\\t\\tif (right == len) { /* No other movements found before the end */\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tbreak;\\n\\t\\t} else if (\\'R\\' == dominoes[right]) {\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tleft = right;\\n\\t\\t} else if (\\'L\\' == dominoes[right]) { /* Dominoes will be toppling left */\\n\\t\\t\\tint pos = left;\\n\\t\\t\\tif (\\'R\\' == dominoes[left]) { /* Dominoes will be toppling right too */\\n\\t\\t\\t\\tint half = (right - left + 1) / 2;\\n\\t\\t\\t\\tmemset(&ret[pos], \\'R\\', half);\\n\\t\\t\\t\\tpos += half;\\n\\t\\t\\t\\tif (0 == (right - left) % 2) { /* Is there a domino in the middle */\\n\\t\\t\\t\\t\\tret[pos++] = \\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmemset(&ret[pos], \\'L\\', right - pos + 1);\\n\\t\\t\\tleft = right + 1;    \\n\\t  }\\n  }\\n  return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nchar * pushDominoes(char * dominoes) {\\n\\tsize_t len = strlen(dominoes);\\n\\tchar* const ret = malloc(len + 1);\\n\\tret[len] = \\'\\\\0\\';\\n\\n\\tint left = 0;\\n\\twhile (left < len) {\\n\\t\\t/* Find the next interesting action */\\n\\t\\tint right = left + 1;\\n\\t\\twhile (right < len && \\'.\\' == dominoes[right]) {\\n\\t\\t\\t++right;\\n\\t\\t}\\n\\t\\tif (right == len) { /* No other movements found before the end */\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tbreak;\\n\\t\\t} else if (\\'R\\' == dominoes[right]) {\\n\\t\\t\\tret[left] = dominoes[left];\\n\\t\\t\\tmemset(&ret[left + 1], (\\'R\\' == dominoes[left]) ? \\'R\\' : \\'.\\', right - left - 1);\\n\\t\\t\\tleft = right;\\n\\t\\t} else if (\\'L\\' == dominoes[right]) { /* Dominoes will be toppling left */\\n\\t\\t\\tint pos = left;\\n\\t\\t\\tif (\\'R\\' == dominoes[left]) { /* Dominoes will be toppling right too */\\n\\t\\t\\t\\tint half = (right - left + 1) / 2;\\n\\t\\t\\t\\tmemset(&ret[pos], \\'R\\', half);\\n\\t\\t\\t\\tpos += half;\\n\\t\\t\\t\\tif (0 == (right - left) % 2) { /* Is there a domino in the middle */\\n\\t\\t\\t\\t\\tret[pos++] = \\'.\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmemset(&ret[pos], \\'L\\', right - pos + 1);\\n\\t\\t\\tleft = right + 1;    \\n\\t  }\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630536,
                "title": "javascript-queue-tc-o-n-sc-o-n",
                "content": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    const dom = dominoes.split(\\'\\');\\n    const n = dom.length;\\n    let queue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (dom[i] !== \\'.\\') {\\n            queue.push([i, dom[i]]);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        const next = [];\\n        \\n        for (let idx = 0; idx < queue.length; idx++) {\\n            const [i, d] = queue[idx];\\n            if (d === \\'L\\' && i > 0 && dom[i - 1] === \\'.\\') {\\n                next.push([i - 1, \\'L\\']);\\n                dom[i - 1] = \\'L\\';\\n            } else if (d === \\'R\\' && i + 1 < n && dom[i + 1] === \\'.\\') {\\n                if (i + 2 < n && dom[i + 2] === \\'L\\') {\\n                    idx++;\\n                } else {\\n                    next.push([i + 1, \\'R\\']);\\n                    dom[i + 1] = \\'R\\';\\n                }\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return dom.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\n/**\\n * @param {string} dominoes\\n * @return {string}\\n */\\nvar pushDominoes = function(dominoes) {\\n    const dom = dominoes.split(\\'\\');\\n    const n = dom.length;\\n    let queue = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        if (dom[i] !== \\'.\\') {\\n            queue.push([i, dom[i]]);\\n        }\\n    }\\n    \\n    while (queue.length) {\\n        const next = [];\\n        \\n        for (let idx = 0; idx < queue.length; idx++) {\\n            const [i, d] = queue[idx];\\n            if (d === \\'L\\' && i > 0 && dom[i - 1] === \\'.\\') {\\n                next.push([i - 1, \\'L\\']);\\n                dom[i - 1] = \\'L\\';\\n            } else if (d === \\'R\\' && i + 1 < n && dom[i + 1] === \\'.\\') {\\n                if (i + 2 < n && dom[i + 2] === \\'L\\') {\\n                    idx++;\\n                } else {\\n                    next.push([i + 1, \\'R\\']);\\n                    dom[i + 1] = \\'R\\';\\n                }\\n            }\\n        }\\n        \\n        queue = next;\\n    }\\n    \\n    return dom.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630439,
                "title": "python-neetcode-queue-traversal",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        \\n        q=deque()\\n        dominoes=list(dominoes)\\n        for a,i in enumerate(dominoes):\\n            if i==\"L\"or i==\"R\":\\n                q.append((i,a))\\n                \\n        # print(q)\\n                \\n        while(q):\\n            val,ind=q.popleft()\\n            \\n            if val==\"R\" and ind+1<len(dominoes) and dominoes[ind+1]==\".\":\\n                if q and q[0][0]==\"L\" and ind+2==q[0][1]:\\n                    q.popleft()\\n                else:\\n                    dominoes[ind+1]=\"R\"\\n                    q.append((\"R\",ind+1))\\n                    \\n                    \\n            elif val==\"L\" and ind>0 and dominoes[ind-1]==\".\":\\n                dominoes[ind-1]=\"L\"\\n                q.append((\"L\",ind-1))\\n                \\n        return \"\".join(dominoes)\\n                \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        \\n        q=deque()\\n        dominoes=list(dominoes)\\n        for a,i in enumerate(dominoes):\\n            if i==\"L\"or i==\"R\":\\n                q.append((i,a))\\n                \\n        # print(q)\\n                \\n        while(q):\\n            val,ind=q.popleft()\\n            \\n            if val==\"R\" and ind+1<len(dominoes) and dominoes[ind+1]==\".\":\\n                if q and q[0][0]==\"L\" and ind+2==q[0][1]:\\n                    q.popleft()\\n                else:\\n                    dominoes[ind+1]=\"R\"\\n                    q.append((\"R\",ind+1))\\n                    \\n                    \\n            elif val==\"L\" and ind>0 and dominoes[ind-1]==\".\":\\n                dominoes[ind-1]=\"L\"\\n                q.append((\"L\",ind-1))\\n                \\n        return \"\".join(dominoes)\\n                \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630357,
                "title": "c-very-easy-solution-tc-o-n",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string d) {\\n\\t\\t\\tint right=-1;\\n\\t\\t\\tstring s=\"\";\\n\\t\\t\\tvector<pair<int,int>>v;\\n\\t\\t\\tfor(int i=0;i<d.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts+=\\'.\\';\\n\\t\\t\\t\\tif(d[i]==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(right!=-1 && d[i]==\\'L\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back({right,i});\\n\\t\\t\\t\\t\\tfor(int j=right;j<=i;j++)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\td[j]=\\'-\\';\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tright=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// In vector of pair we store the indexes which are right and immediate left after right \\n\\t\\t\\t// we store vector members and in between them with \\'-\\' sign to differentiate them \\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint a=v[i].first,b=v[i].second;\\n\\t\\t\\t\\t//cout<<a<<\" \"<<b<<endl;\\n\\t\\t\\t\\twhile(a<b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts[a]=\\'R\\';\\n\\t\\t\\t\\t\\ts[b]=\\'L\\';\\n\\t\\t\\t\\t\\ta++;\\n\\t\\t\\t\\t\\tb--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// we store the positions of vector members in the another string\\n\\t\\t\\tfor(int i=0;i<d.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(d[i]==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint x=i;\\n\\t\\t\\t\\t\\twhile(x<d.size() && d[x]!=\\'-\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts[x]=\\'R\\';\\n\\t\\t\\t\\t\\t\\tx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti=x;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// traverse from right whichever comes right goes to right before the vector members\\n\\t\\t\\tfor(int i=d.size()-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(d[i]==\\'L\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint x=i;\\n\\t\\t\\t\\t\\twhile(x>=0 && d[x]!=\\'-\\')\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ts[x]=\\'L\\';\\n\\t\\t\\t\\t\\t\\tx--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti=x;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t    // traverse from left whichever comes left goes to left before the vector members\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring pushDominoes(string d) {\\n\\t\\t\\tint right=-1;\\n\\t\\t\\tstring s=\"\";\\n\\t\\t\\tvector<pair<int,int>>v;\\n\\t\\t\\tfor(int i=0;i<d.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts+=\\'.\\';\\n\\t\\t\\t\\tif(d[i]==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tright=i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2630300,
                "title": "c-simple-array-question",
                "content": "\"\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        \\n        string ans;\\n        int n=dominoes.size();\\n        int left[n],right[n];\\n        int cnt=1;\\n        int i=0;\\n        while(i<n){\\n            if(cnt==1 && dominoes[i]==\\'.\\')left[i]=0;\\n            else{\\n                if(dominoes[i]==\\'R\\'){\\n                    left[i]=cnt;\\n                    cnt=2;\\n                }else if(dominoes[i]==\\'.\\'){\\n                    left[i]=cnt;\\n                    cnt++;\\n                }else{\\n                    left[i]=0;\\n                    cnt=1;\\n                }\\n            }\\n            i++;\\n        }\\n        i=n-1;\\n        cnt=1;\\n        while(i>=0){\\n            if(cnt==1 && dominoes[i]==\\'.\\')right[i]=0;\\n            else{\\n               if(dominoes[i]==\\'L\\'){\\n                    right[i]=cnt;\\n                    cnt=2;\\n                }else if(dominoes[i]==\\'.\\'){\\n                    right[i]=cnt;\\n                    cnt++;\\n                }else{\\n                    right[i]=0;\\n                    cnt=1;\\n                }\\n            }\\n            i--;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(left[i]==0 && right[i]!=0)ans+=\\'L\\';\\n            else if(left[i]!=0 && right[i]==0)ans+=\\'R\\';\\n            else if(left[i]==0 && right[i]==0 || (left[i]==right[i]))ans+=dominoes[i];\\n            else if(left[i]!=0 && right[i]!=0 && (left[i]!=right[i])){\\n                if(left[i]>right[i])ans+=\\'L\\';\\n                else ans+=\\'R\\';\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\"",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        \\n        string ans;\\n        int n=dominoes.size();\\n        int left[n],right[n];\\n        int cnt=1;\\n        int i=0;\\n        while(i<n){\\n            if(cnt==1 && dominoes[i]==\\'.\\')left[i]=0;\\n            else{\\n                if(dominoes[i]==\\'R\\'){\\n                    left[i]=cnt;\\n                    cnt=2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2630288,
                "title": "c-faster-than-99-31-two-pointer-detailed-explanation",
                "content": "Maintain two pointers **start** and **end**, and there are four cases:\\n**1. start = \\'L\\' & end = \\'R\\':** \\n* In this case, the dominoes in between these will not fall\\n* Ex: **L....R** , ans = **L....R**\\n\\n**2. start = \\'R\\' & end = \\'L\\'**\\n* In this case, the dominoes in between will fall in such a way that:\\n\\t* Dominoes near \\'R\\' will fall toward right\\n\\t* Dominoes near \\'L\\' will fall toward left\\n\\t* If there is a middle domino, it doesn\\'t fall as the forces are balanced\\n\\t* Ex1: **R..L**, ans = **RRLL**\\n\\t* Ex2: **R...L**, ans = **RR.LL**\\n\\n**3. start = \\'L & end = \\'L\\'**\\n* In this case, all the dominoes in between will fall toward left, due to the force from end domino\\n* Ex: **L...L**, ans = **LLLLL**\\n\\t\\n**4. start = \\'R\\' & end = \\'R\\'**\\n* In this case, all the dominoes in between will fall toward right, due to the force from start domino\\n* Ex: **R...R**, ans = **RRRRR**\\n\\n**Note:** Consider there is a \\'L\\' domino in the beginning and a \\'R\\' domino in the ending (adding these will not affect the answer, and it is easy for maintaining pointers. Take a few examples and you\\'ll understand this)\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n\\t\\t// Adding a domino at the end\\n        dominoes.push_back(\\'R\\');\\n\\t\\t\\n\\t\\t// Consider, there is a \\'L\\' domino at the begin\\n        int startInd = -1;\\n        char start = \\'L\\';\\n            \\n        for(int i=0; i<dominoes.size(); i++){\\n            int endInd = i;\\n            char end = dominoes[i];\\n\\t\\t\\t\\n            if(end == \\'.\\'){\\n                continue;\\n            }\\n            \\n            if(start == \\'L\\' && end == \\'R\\'){\\n                // Do nothing\\n            }\\n            else if(start == \\'R\\' && end == \\'L\\'){\\n                int len = endInd-startInd+1;\\n                int l = startInd+1, r = endInd-1;\\n                while(l<=r){\\n\\t\\t\\t\\t\\t// Middle domino\\n                    if(l == r){\\n                        dominoes[l++] = \\'.\\';\\n                    }\\n                    else{\\n                        dominoes[l++] = \\'R\\';\\n                        dominoes[r--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(start == \\'L\\' && end == \\'L\\'){\\n                int ind = endInd-1;\\n                while(ind > startInd){\\n                    dominoes[ind--] = \\'L\\';\\n                }\\n            }\\n            else{\\n                int ind = startInd+1;\\n                while(ind < endInd){\\n                    dominoes[ind++] = \\'R\\';\\n                }\\n            }\\n            start = end;\\n            startInd = endInd;\\n        }\\n        \\n\\t\\t// Removing the domino added at the end\\n        dominoes.pop_back();\\n        return dominoes;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n\\t\\t// Adding a domino at the end\\n        dominoes.push_back(\\'R\\');\\n\\t\\t\\n\\t\\t// Consider, there is a \\'L\\' domino at the begin\\n        int startInd = -1;\\n        char start = \\'L\\';\\n            \\n        for(int i=0; i<dominoes.size(); i++){\\n            int endInd = i;\\n            char end = dominoes[i];\\n\\t\\t\\t\\n            if(end == \\'.\\'){\\n                continue;\\n            }\\n            \\n            if(start == \\'L\\' && end == \\'R\\'){\\n                // Do nothing\\n            }\\n            else if(start == \\'R\\' && end == \\'L\\'){\\n                int len = endInd-startInd+1;\\n                int l = startInd+1, r = endInd-1;\\n                while(l<=r){\\n\\t\\t\\t\\t\\t// Middle domino\\n                    if(l == r){\\n                        dominoes[l++] = \\'.\\';\\n                    }\\n                    else{\\n                        dominoes[l++] = \\'R\\';\\n                        dominoes[r--] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(start == \\'L\\' && end == \\'L\\'){\\n                int ind = endInd-1;\\n                while(ind > startInd){\\n                    dominoes[ind--] = \\'L\\';\\n                }\\n            }\\n            else{\\n                int ind = startInd+1;\\n                while(ind < endInd){\\n                    dominoes[ind++] = \\'R\\';\\n                }\\n            }\\n            start = end;\\n            startInd = endInd;\\n        }\\n        \\n\\t\\t// Removing the domino added at the end\\n        dominoes.pop_back();\\n        return dominoes;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2630188,
                "title": "golang-with-two-pointers-and-comments-description",
                "content": "![image](https://assets.leetcode.com/users/images/a7d8cda3-80ac-441e-9f9a-3f5d5e8b6501_1664273362.031908.png)\\nthough it meets timelimit often, but still can pass\\nfailing testcase:\\nhttps://leetcode.com/submissions/detail/809710021/testcase/\\n\\n```\\nfunc pushDominoes(dominoes string) string {\\n    // if len is 0 or 1 nothing can be changed, return input\\n    if len(dominoes) <= 1 || !strings.ContainsRune(dominoes, \\'.\\'){\\n        return dominoes\\n    }\\n    \\n    left := 0\\n    // looking for first non-\".\" character\\n    right, lc := nextChar(dominoes)\\n    if right < 0 { // if not found, return input\\n        return dominoes\\n    }\\n    \\n    if lc == \"L\" { // if first \"L\", all on the left should be \"L\"\\n        dominoes = strings.Replace(dominoes, \".\", \"L\", right)\\n    } \\n    \\n    res := dominoes[:right+1] // copy part till first non-\".\" with needed replacement\\n    // fmt.Println(\"res before = \", res)\\n\\n    rc := lc\\n    finish := true // flag to understand if we still have what to repeat, can be replaced with check of \"res\" length\\n    for finish{\\n        finish = false\\n        lc = rc\\n        left += right+1\\n        // fmt.Println(\"dominoes[left:] = \", dominoes[left:])\\n        right, rc = nextChar(dominoes[left:])\\n        if right < 0 && lc == \"L\" { // if last char was \"L\" the rest is \".\" without changes\\n            res += strings.Repeat(\".\", len(dominoes) - left)\\n            // fmt.Println(\"break L\")\\n            break\\n        } else if right < 0 && lc == \"R\" { // if last char was \"R\" the rest is \"R\" \\n            // fmt.Println(\"break R\")\\n            res += strings.Repeat(\"R\", len(dominoes) - left)\\n            break\\n        } else if rc == lc { // if same like \"L..L\" or \"R..R\", all between should be same\\n            // fmt.Println(\"replaced same\")\\n            res += strings.Repeat(rc, right+1)\\n            // fmt.Println(\"res after replaced same = \", res)\\n            finish = true\\n        } else if lc == \"R\" && rc == \"L\"  { // if kind of \"R..L\", then half \"R\" and half \"L\" => \"RRLL\"\\n            half := right / 2\\n            res += strings.Repeat(lc, half)\\n            if right % 2 == 1 { // if odd, then middle isn\\'t changed: \"R...L\" => \"RR.LL\"\\n                res += \".\"\\n            }\\n            res += strings.Repeat(rc, half+1) // additionally copy right \"L\"\\n            // fmt.Println(\"replaced halfs\")\\n            finish = true\\n        } else { //in case of \"L..R\" copy with no changes\\n            res += dominoes[left:left+right+1]\\n            // fmt.Println(\"copy with no changes between L and R\")\\n            // fmt.Println(\"res after copy with no changes = \", res)\\n            finish = true\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc nextChar(s string)(int, string){\\n    leftL := strings.IndexByte(s,\\'L\\')\\n    leftR := strings.IndexByte(s,\\'R\\')\\n    if leftL>=0 && leftL < leftR || leftL>=0 && leftR<0{\\n        // fmt.Println(\"next = \", leftL,string(s[leftL]))\\n        return leftL,string(s[leftL])\\n    } else if leftR>=0 {\\n        // fmt.Println(\"next = \", leftR,string(s[leftR]))\\n            return leftR,string(s[leftR])\\n    } else {\\n        // fmt.Println(\"next = \", -1, \"\")\\n        return -1,\"\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pushDominoes(dominoes string) string {\\n    // if len is 0 or 1 nothing can be changed, return input\\n    if len(dominoes) <= 1 || !strings.ContainsRune(dominoes, \\'.\\'){\\n        return dominoes\\n    }\\n    \\n    left := 0\\n    // looking for first non-\".\" character\\n    right, lc := nextChar(dominoes)\\n    if right < 0 { // if not found, return input\\n        return dominoes\\n    }\\n    \\n    if lc == \"L\" { // if first \"L\", all on the left should be \"L\"\\n        dominoes = strings.Replace(dominoes, \".\", \"L\", right)\\n    } \\n    \\n    res := dominoes[:right+1] // copy part till first non-\".\" with needed replacement\\n    // fmt.Println(\"res before = \", res)\\n\\n    rc := lc\\n    finish := true // flag to understand if we still have what to repeat, can be replaced with check of \"res\" length\\n    for finish{\\n        finish = false\\n        lc = rc\\n        left += right+1\\n        // fmt.Println(\"dominoes[left:] = \", dominoes[left:])\\n        right, rc = nextChar(dominoes[left:])\\n        if right < 0 && lc == \"L\" { // if last char was \"L\" the rest is \".\" without changes\\n            res += strings.Repeat(\".\", len(dominoes) - left)\\n            // fmt.Println(\"break L\")\\n            break\\n        } else if right < 0 && lc == \"R\" { // if last char was \"R\" the rest is \"R\" \\n            // fmt.Println(\"break R\")\\n            res += strings.Repeat(\"R\", len(dominoes) - left)\\n            break\\n        } else if rc == lc { // if same like \"L..L\" or \"R..R\", all between should be same\\n            // fmt.Println(\"replaced same\")\\n            res += strings.Repeat(rc, right+1)\\n            // fmt.Println(\"res after replaced same = \", res)\\n            finish = true\\n        } else if lc == \"R\" && rc == \"L\"  { // if kind of \"R..L\", then half \"R\" and half \"L\" => \"RRLL\"\\n            half := right / 2\\n            res += strings.Repeat(lc, half)\\n            if right % 2 == 1 { // if odd, then middle isn\\'t changed: \"R...L\" => \"RR.LL\"\\n                res += \".\"\\n            }\\n            res += strings.Repeat(rc, half+1) // additionally copy right \"L\"\\n            // fmt.Println(\"replaced halfs\")\\n            finish = true\\n        } else { //in case of \"L..R\" copy with no changes\\n            res += dominoes[left:left+right+1]\\n            // fmt.Println(\"copy with no changes between L and R\")\\n            // fmt.Println(\"res after copy with no changes = \", res)\\n            finish = true\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc nextChar(s string)(int, string){\\n    leftL := strings.IndexByte(s,\\'L\\')\\n    leftR := strings.IndexByte(s,\\'R\\')\\n    if leftL>=0 && leftL < leftR || leftL>=0 && leftR<0{\\n        // fmt.Println(\"next = \", leftL,string(s[leftL]))\\n        return leftL,string(s[leftL])\\n    } else if leftR>=0 {\\n        // fmt.Println(\"next = \", leftR,string(s[leftR]))\\n            return leftR,string(s[leftR])\\n    } else {\\n        // fmt.Println(\"next = \", -1, \"\")\\n        return -1,\"\"\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630158,
                "title": "golang-two-pointers",
                "content": "```\\nfunc pushDominoes(dominoes string) string {\\n    arr := make([]byte, len(dominoes)+2)\\n    N := len(arr)\\n    arr[0] = \\'L\\'\\n    arr[N-1] = \\'R\\'\\n    for i := 0; i < len(dominoes); i++ {\\n        arr[i+1] = dominoes[i]\\n    }\\n    \\n    start := 0\\n    for end := 0; end < N; end++ {\\n        if arr[end] != \\'.\\' {\\n            convert(arr, start, end)\\n            start = end\\n        }\\n    }\\n    \\n    return string(arr[1:N-1])\\n}\\n\\nfunc convert(arr []byte, start, end int) {\\n    if arr[start] == arr[end] {\\n        // Case of L...L or R....R\\n        for i := start+1; i < end; i++ {\\n            arr[i] = arr[start]\\n        }\\n    } else if arr[start] == \\'R\\' && arr[end] == \\'L\\' {\\n        // Case of R...L\\n        for i := start+1; i < end; i++ {\\n            if i-start < end-i {\\n                arr[i] = arr[start]\\n            } else if i-start > end-i {\\n                arr[i] = arr[end]\\n            } /* else {\\n                // If i is equal distance from start and end, leave it \\'.\\'\\n            } */\\n        }\\n    } /* else {\\n        // Case of L...R\\n        // Nothing needs to be done\\n    } */\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc pushDominoes(dominoes string) string {\\n    arr := make([]byte, len(dominoes)+2)\\n    N := len(arr)\\n    arr[0] = \\'L\\'\\n    arr[N-1] = \\'R\\'\\n    for i := 0; i < len(dominoes); i++ {\\n        arr[i+1] = dominoes[i]\\n    }\\n    \\n    start := 0\\n    for end := 0; end < N; end++ {\\n        if arr[end] != \\'.\\' {\\n            convert(arr, start, end)\\n            start = end\\n        }\\n    }\\n    \\n    return string(arr[1:N-1])\\n}\\n\\nfunc convert(arr []byte, start, end int) {\\n    if arr[start] == arr[end] {\\n        // Case of L...L or R....R\\n        for i := start+1; i < end; i++ {\\n            arr[i] = arr[start]\\n        }\\n    } else if arr[start] == \\'R\\' && arr[end] == \\'L\\' {\\n        // Case of R...L\\n        for i := start+1; i < end; i++ {\\n            if i-start < end-i {\\n                arr[i] = arr[start]\\n            } else if i-start > end-i {\\n                arr[i] = arr[end]\\n            } /* else {\\n                // If i is equal distance from start and end, leave it \\'.\\'\\n            } */\\n        }\\n    } /* else {\\n        // Case of L...R\\n        // Nothing needs to be done\\n    } */\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630084,
                "title": "topic-just-for-creating-link-for-my-friend",
                "content": "```\\nvar pushDominoes = function(dominoes) {\\n  const arr = dominoes.split(\"\");\\n  \\n  let currStart = 0;\\n  let pushedToRight = false;\\n  \\n  for (let i=0; i < arr.length; i++) {\\n    if (arr[i] === \"L\" && !pushedToRight) {\\n      for (let j = currStart; j < i; j++) {\\n        arr[j] = \"L\";\\n      }\\n      currStart = i + 1;\\n    } else if (arr[i] === \"L\" && pushedToRight) {\\n      const qnty = i - currStart - 1;\\n      if (qnty % 2 ) {\\n        for (let j=currStart+1; j<currStart+Math.round(qnty/2); j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-Math.round(qnty/2); j--) {\\n          arr[j] = \"L\";\\n        }\\n      } else {\\n        for (let j=currStart+1; j<currStart+qnty/2+1; j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-qnty/2-1; j--) {\\n          arr[j] = \"L\";\\n        }\\n      }\\n      currStart = i + 1;\\n      pushedToRight = false;\\n    } else if (arr[i] === \"R\") {\\n      if (pushedToRight) {\\n        for (let j=currStart; j<i; j++) {\\n          arr[j] = \"R\";\\n        }\\n      }\\n      pushedToRight = true;\\n      currStart = i;\\n    } else {\\n      if (i === arr.length-1 && pushedToRight) {\\n        for (let j=currStart+1; j<arr.length; j++) {\\n          arr[j] = \"R\"\\n        }\\n      }\\n    }\\n  }\\n  return arr.join(\"\");\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar pushDominoes = function(dominoes) {\\n  const arr = dominoes.split(\"\");\\n  \\n  let currStart = 0;\\n  let pushedToRight = false;\\n  \\n  for (let i=0; i < arr.length; i++) {\\n    if (arr[i] === \"L\" && !pushedToRight) {\\n      for (let j = currStart; j < i; j++) {\\n        arr[j] = \"L\";\\n      }\\n      currStart = i + 1;\\n    } else if (arr[i] === \"L\" && pushedToRight) {\\n      const qnty = i - currStart - 1;\\n      if (qnty % 2 ) {\\n        for (let j=currStart+1; j<currStart+Math.round(qnty/2); j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-Math.round(qnty/2); j--) {\\n          arr[j] = \"L\";\\n        }\\n      } else {\\n        for (let j=currStart+1; j<currStart+qnty/2+1; j++) {\\n          arr[j] = \"R\";\\n        }\\n        for (let j=i-1; j>i-qnty/2-1; j--) {\\n          arr[j] = \"L\";\\n        }\\n      }\\n      currStart = i + 1;\\n      pushedToRight = false;\\n    } else if (arr[i] === \"R\") {\\n      if (pushedToRight) {\\n        for (let j=currStart; j<i; j++) {\\n          arr[j] = \"R\";\\n        }\\n      }\\n      pushedToRight = true;\\n      currStart = i;\\n    } else {\\n      if (i === arr.length-1 && pushedToRight) {\\n        for (let j=currStart+1; j<arr.length; j++) {\\n          arr[j] = \"R\"\\n        }\\n      }\\n    }\\n  }\\n  return arr.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629925,
                "title": "easy-to-understand-beginners-approach",
                "content": "Check the commented example inside code for better understanding. 1st iteration from left to right is for right push only and 2nd iteration from right to left is for left push only.\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> t1;\\n        vector<int> t2;\\n        int c1=1;\\n        int c2=1;\\n        int n = d.length();\\n        int i=0;\\n        while(i<n)\\n        {\\n            c1=1;\\n            if(d[i]==\\'R\\')\\n            {\\n                t1.push_back(0);\\n                while(i+1<n && d[i+1]==\\'.\\'){\\n                    t1.push_back(c1);\\n                    c1++;\\n                    i++;\\n                }\\n            }\\n            else{\\n                t1.push_back(0);\\n            }\\n            i++;\\n        }\\n        i = n-1;\\n        while(i>=0)\\n        {\\n            c2= 1;\\n            if(d[i]==\\'L\\')\\n            {\\n                t2.push_back(0);\\n                while(i-1>=0 && d[i-1]==\\'.\\'){\\n                    t2.push_back(c2);\\n                    c2++;\\n                    i--;\\n                }\\n            }\\n            else{\\n                t2.push_back(0);\\n            }\\n            i--;\\n        }\\n        reverse(t2.begin(),t2.end());\\n        string ans = \"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(t1[i]==t2[i] && t1[i]!=0){\\n                ans+=\\'.\\';\\n            }\\n            else if(t1[i]<t2[i]){\\n                if(t1[i]==0)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n                else{\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(t1[i]>t2[i]){\\n                if(t2[i]==0)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n                else{\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else{\\n                ans+=d[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// . L . R 1R 2R 3R L R 1R 2R L . .\\n// L L . R 3L 2L 1L L R 2L 1L L . . \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        vector<int> t1;\\n        vector<int> t2;\\n        int c1=1;\\n        int c2=1;\\n        int n = d.length();\\n        int i=0;\\n        while(i<n)\\n        {\\n            c1=1;\\n            if(d[i]==\\'R\\')\\n            {\\n                t1.push_back(0);\\n                while(i+1<n && d[i+1]==\\'.\\'){\\n                    t1.push_back(c1);\\n                    c1++;\\n                    i++;\\n                }\\n            }\\n            else{\\n                t1.push_back(0);\\n            }\\n            i++;\\n        }\\n        i = n-1;\\n        while(i>=0)\\n        {\\n            c2= 1;\\n            if(d[i]==\\'L\\')\\n            {\\n                t2.push_back(0);\\n                while(i-1>=0 && d[i-1]==\\'.\\'){\\n                    t2.push_back(c2);\\n                    c2++;\\n                    i--;\\n                }\\n            }\\n            else{\\n                t2.push_back(0);\\n            }\\n            i--;\\n        }\\n        reverse(t2.begin(),t2.end());\\n        string ans = \"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(t1[i]==t2[i] && t1[i]!=0){\\n                ans+=\\'.\\';\\n            }\\n            else if(t1[i]<t2[i]){\\n                if(t1[i]==0)\\n                {\\n                    ans+=\\'L\\';\\n                }\\n                else{\\n                    ans+=\\'R\\';\\n                }\\n            }\\n            else if(t1[i]>t2[i]){\\n                if(t2[i]==0)\\n                {\\n                    ans+=\\'R\\';\\n                }\\n                else{\\n                    ans+=\\'L\\';\\n                }\\n            }\\n            else{\\n                ans+=d[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// . L . R 1R 2R 3R L R 1R 2R L . .\\n// L L . R 3L 2L 1L L R 2L 1L L . . \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629886,
                "title": "go-dynamic-programming",
                "content": "```\\nfunc fall(l, c, r rune) rune {\\n\\tif c == \\'.\\' {\\n\\t\\tif l == \\'R\\' && r == \\'L\\' {\\n\\t\\t\\treturn \\'.\\'\\n\\t\\t}\\n\\t\\tif l == \\'R\\' {\\n\\t\\t\\treturn \\'R\\'\\n\\t\\t}\\n\\t\\tif r == \\'L\\' {\\n\\t\\t\\treturn \\'L\\'\\n\\t\\t}\\n\\t}\\n\\treturn c\\n}\\n\\nfunc pushIteration(dominoes string) string {\\n\\tresult := make([]rune, len(dominoes))\\n\\tif len(dominoes) == 1 {\\n\\t\\treturn dominoes\\n\\t}\\n\\tdominoesR := []rune(dominoes)\\n\\tfor i := 0; i < len(dominoesR); i++ {\\n\\t\\tswitch i {\\n\\t\\tcase 0:\\n\\t\\t\\tresult[i] = fall(\\'.\\', dominoesR[i], dominoesR[i+1])\\n\\t\\tcase len(dominoes) - 1:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], \\'.\\')\\n\\t\\tdefault:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], dominoesR[i+1])\\n\\t\\t}\\n\\t}\\n\\treturn string(result)\\n}\\n\\nfunc pushDominoes(dominoes string) string {\\n\\tpreviousIteration := pushIteration(dominoes)\\n\\tfor previousIteration != dominoes {\\n\\t\\tpreviousIteration = dominoes\\n\\t\\tdominoes = pushIteration(dominoes)\\n\\t}\\n\\treturn dominoes\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc fall(l, c, r rune) rune {\\n\\tif c == \\'.\\' {\\n\\t\\tif l == \\'R\\' && r == \\'L\\' {\\n\\t\\t\\treturn \\'.\\'\\n\\t\\t}\\n\\t\\tif l == \\'R\\' {\\n\\t\\t\\treturn \\'R\\'\\n\\t\\t}\\n\\t\\tif r == \\'L\\' {\\n\\t\\t\\treturn \\'L\\'\\n\\t\\t}\\n\\t}\\n\\treturn c\\n}\\n\\nfunc pushIteration(dominoes string) string {\\n\\tresult := make([]rune, len(dominoes))\\n\\tif len(dominoes) == 1 {\\n\\t\\treturn dominoes\\n\\t}\\n\\tdominoesR := []rune(dominoes)\\n\\tfor i := 0; i < len(dominoesR); i++ {\\n\\t\\tswitch i {\\n\\t\\tcase 0:\\n\\t\\t\\tresult[i] = fall(\\'.\\', dominoesR[i], dominoesR[i+1])\\n\\t\\tcase len(dominoes) - 1:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], \\'.\\')\\n\\t\\tdefault:\\n\\t\\t\\tresult[i] = fall(dominoesR[i-1], dominoesR[i], dominoesR[i+1])\\n\\t\\t}\\n\\t}\\n\\treturn string(result)\\n}\\n\\nfunc pushDominoes(dominoes string) string {\\n\\tpreviousIteration := pushIteration(dominoes)\\n\\tfor previousIteration != dominoes {\\n\\t\\tpreviousIteration = dominoes\\n\\t\\tdominoes = pushIteration(dominoes)\\n\\t}\\n\\treturn dominoes\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629872,
                "title": "o-n-time",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        st=\".\"\\n        ct=0\\n        arr=[]\\n        for a in dominoes:\\n            if(a==\".\"):\\n                ct+=1\\n            elif(a==\"R\"):\\n                arr.append(st+str(ct))\\n                st=\"R\"\\n                ct=1\\n            elif(a==\"L\"):\\n                if(st==\"R\"):\\n                    ct+=1\\n                    arr.append(\"R\"+str(ct//2))\\n                    arr.append(\".\"+str(ct%2))\\n                    arr.append(\"L\"+str(ct//2))\\n                elif(st==\".\"):\\n                    arr.append(\"L\"+str(ct+1))\\n                ct=0\\n                st=\".\"\\n        arr.append(st+str(ct))\\n        # print(arr)\\n        ans=\"\"\\n        for a in arr:\\n            ans+=a[0]*int(a[1:])\\n        return(ans)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        st=\".\"\\n        ct=0\\n        arr=[]\\n        for a in dominoes:\\n            if(a==\".\"):\\n                ct+=1\\n            elif(a==\"R\"):\\n                arr.append(st+str(ct))\\n                st=\"R\"\\n                ct=1\\n            elif(a==\"L\"):\\n                if(st==\"R\"):\\n                    ct+=1\\n                    arr.append(\"R\"+str(ct//2))\\n                    arr.append(\".\"+str(ct%2))\\n                    arr.append(\"L\"+str(ct//2))\\n                elif(st==\".\"):\\n                    arr.append(\"L\"+str(ct+1))\\n                ct=0\\n                st=\".\"\\n        arr.append(st+str(ct))\\n        # print(arr)\\n        ans=\"\"\\n        for a in arr:\\n            ans+=a[0]*int(a[1:])\\n        return(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629585,
                "title": "c-easy-momentum-physics-solution-o-n",
                "content": "**basically we give each domino a force vector which show how much force is applied in which direction. if value its negative its falling left and vice versa**\\n**its like equating all forces in mechanism**\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        \\n        vector<int> values(d.size(),0);\\n        for(int i=0;i<d.size();i++){\\n           if (d[i] == \\'R\\')\\n        {\\n           \\n            int val = d.size();\\n            values[i]=d.size()+1;\\n            int j = i + 1;\\n            while (j<d.size() && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val--;\\n                j++;\\n            }\\n        }\\n        if (d[i] == \\'L\\')\\n        {\\n            int val = -d.size();\\n            values[i] += (val-1);\\n            int j = i - 1;\\n\\n            while (j>=0 && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val++;\\n                j--;\\n            }\\n        }\\n        }\\n        for(int i=0;i<d.size();i++){\\n            if(values[i]<0){\\n                d[i]=\\'L\\';\\n            }\\n            else if(values[i]>0){\\n                d[i]=\\'R\\';\\n            }\\n            else{\\n                d[i]=\\'.\\';\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        \\n        vector<int> values(d.size(),0);\\n        for(int i=0;i<d.size();i++){\\n           if (d[i] == \\'R\\')\\n        {\\n           \\n            int val = d.size();\\n            values[i]=d.size()+1;\\n            int j = i + 1;\\n            while (j<d.size() && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val--;\\n                j++;\\n            }\\n        }\\n        if (d[i] == \\'L\\')\\n        {\\n            int val = -d.size();\\n            values[i] += (val-1);\\n            int j = i - 1;\\n\\n            while (j>=0 && d[j] == \\'.\\')\\n            {\\n\\n                values[j] += val;\\n                val++;\\n                j--;\\n            }\\n        }\\n        }\\n        for(int i=0;i<d.size();i++){\\n            if(values[i]<0){\\n                d[i]=\\'L\\';\\n            }\\n            else if(values[i]>0){\\n                d[i]=\\'R\\';\\n            }\\n            else{\\n                d[i]=\\'.\\';\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629493,
                "title": "c-easy-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int force = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\') force = n;\\n            else if(dominoes[i] == \\'L\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n        force = 0;\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\') force = n;\\n            else if(dominoes[i] == \\'R\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n        string ans;\\n        for(auto f : forces){\\n            ans.push_back(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int force = 0;\\n        for(int i = 0; i < n; i++){\\n            if(dominoes[i] == \\'R\\') force = n;\\n            else if(dominoes[i] == \\'L\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] += force;\\n        }\\n        force = 0;\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes[i] == \\'L\\') force = n;\\n            else if(dominoes[i] == \\'R\\') force = 0;\\n            else force = max(force - 1, 0);\\n            forces[i] -= force;\\n        }\\n        string ans;\\n        for(auto f : forces){\\n            ans.push_back(f > 0 ? \\'R\\' : f < 0 ? \\'L\\' : \\'.\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629448,
                "title": "simple-c-solution-force-calculation-clean-code-o-n-2-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int> force(n,0);\\n        \\n        int f=0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'R\\') f = n;\\n            else if(s[i] == \\'L\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] += f;\\n        }\\n        \\n        f=0;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(s[i] == \\'L\\') f = n;\\n            else if(s[i] == \\'R\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] -= f;\\n        }\\n        \\n        s = \"\";\\n        for(int f : force) {\\n            if(f == 0) s+=\\'.\\';\\n            else if(f > 0) s+=\\'R\\';\\n            else s+=\\'L\\';\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        int n = s.size();\\n        vector<int> force(n,0);\\n        \\n        int f=0;\\n        for(int i = 0; i < n; i++) {\\n            if(s[i] == \\'R\\') f = n;\\n            else if(s[i] == \\'L\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] += f;\\n        }\\n        \\n        f=0;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(s[i] == \\'L\\') f = n;\\n            else if(s[i] == \\'R\\') f = 0;\\n            else f = max(f-1, 0);\\n            force[i] -= f;\\n        }\\n        \\n        s = \"\";\\n        for(int f : force) {\\n            if(f == 0) s+=\\'.\\';\\n            else if(f > 0) s+=\\'R\\';\\n            else s+=\\'L\\';\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629446,
                "title": "2-way-traversal-solution-in-tc-o-n",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        dominoes=list(dominoes)\\n        flag=0\\n        for i in range(n-1,-1,-1):\\n            if dominoes[i]==\"L\":\\n                ct=1\\n                flag=1\\n            elif dominoes[i]==\".\" and flag==1:\\n                dominoes[i]=ct\\n                ct+=1\\n            elif dominoes[i]==\"R\":\\n                flag=0\\n            else:\\n                dominoes[i]=0\\n        flagr=0\\n        for i in range(n):\\n            if dominoes[i]==\"R\":\\n                ctr=1\\n                flagr=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)<abs(dominoes[i]) or dominoes[i]==\".\":\\n                dominoes[i]=\"R\"\\n                ctr+=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)==abs(dominoes[i]):\\n                dominoes[i]=\".\"\\n            elif flagr==1 and dominoes[i]==0:\\n                dominoes[i]=\"R\"\\n            elif dominoes[i]==\"L\":\\n                flagr=0\\n            elif dominoes[i]==0:\\n                dominoes[i]=\".\"\\n            else:\\n                dominoes[i]=\"L\"\\n        return \"\".join(dominoes)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        n=len(dominoes)\\n        dominoes=list(dominoes)\\n        flag=0\\n        for i in range(n-1,-1,-1):\\n            if dominoes[i]==\"L\":\\n                ct=1\\n                flag=1\\n            elif dominoes[i]==\".\" and flag==1:\\n                dominoes[i]=ct\\n                ct+=1\\n            elif dominoes[i]==\"R\":\\n                flag=0\\n            else:\\n                dominoes[i]=0\\n        flagr=0\\n        for i in range(n):\\n            if dominoes[i]==\"R\":\\n                ctr=1\\n                flagr=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)<abs(dominoes[i]) or dominoes[i]==\".\":\\n                dominoes[i]=\"R\"\\n                ctr+=1\\n            elif str(dominoes[i]).isdigit() and flagr==1 and abs(ctr)==abs(dominoes[i]):\\n                dominoes[i]=\".\"\\n            elif flagr==1 and dominoes[i]==0:\\n                dominoes[i]=\"R\"\\n            elif dominoes[i]==\"L\":\\n                flagr=0\\n            elif dominoes[i]==0:\\n                dominoes[i]=\".\"\\n            else:\\n                dominoes[i]=\"L\"\\n        return \"\".join(dominoes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629354,
                "title": "c-2-pointer-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int temp = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            if(dominoes[i] == \\'R\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'L\\')\\n                temp = 0;\\n            else\\n                temp = max(temp - 1, 0);\\n            forces[i] += temp;\\n        }\\n        temp = 0;\\n        for(int i = n - 1;i >= 0; i--)\\n        {\\n            if(dominoes[i] == \\'L\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'R\\')\\n                temp = 0;\\n            else \\n                temp = max(temp - 1, 0);\\n            forces[i] -= temp;\\n        }\\n        string ans = \"\";\\n        for(int i = 0 ; i < forces.size(); i++)\\n        {\\n            if(forces[i] > 0)\\n                ans += \\'R\\';\\n            else if(forces[i] < 0)\\n                ans += \\'L\\';\\n            else \\n                ans += \\'.\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int n = dominoes.size();\\n        vector<int> forces(n, 0);\\n        int temp = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            if(dominoes[i] == \\'R\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'L\\')\\n                temp = 0;\\n            else\\n                temp = max(temp - 1, 0);\\n            forces[i] += temp;\\n        }\\n        temp = 0;\\n        for(int i = n - 1;i >= 0; i--)\\n        {\\n            if(dominoes[i] == \\'L\\')\\n                temp = n;\\n            else if(dominoes[i] == \\'R\\')\\n                temp = 0;\\n            else \\n                temp = max(temp - 1, 0);\\n            forces[i] -= temp;\\n        }\\n        string ans = \"\";\\n        for(int i = 0 ; i < forces.size(); i++)\\n        {\\n            if(forces[i] > 0)\\n                ans += \\'R\\';\\n            else if(forces[i] < 0)\\n                ans += \\'L\\';\\n            else \\n                ans += \\'.\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629351,
                "title": "find-positions-of-r-l-easy-explanation",
                "content": "considerd the string \\n\\n\".L.R...LR..L..\"\\n\\nIf an R is followed by L then they will fall toward themselve\\nif an R is not followed by L then it will fall toward right (all domino after that index)\\nif an L is not backed by R then it wall fall toward left  (all domino before that index)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans = \"\";\\n        vector<int> left; // store \\'L\\' index \\n        vector<int> right; // store \\'R\\' index\\n        vector<pair<int,int>> lr; // store R....L type index\\n         \\n        for(int i = 0;i<s.length();i++)\\n        {\\n                if(s[i] == \\'L\\') // L is not backed by and R\\n                        left.push_back(i);\\n                else if(s[i] == \\'R\\') // Here two condition exist, may be L is present after this or not present\\n                {\\n                   int x = i;    \\n                   int j = i;    \\n                   bool flag = false;     \\n                   for( j = i+1;j<s.length();j++)\\n                     if(s[j] ==\\'L\\') // If L is present then a pair is found\\n                     {\\n                             flag = true;\\n                             lr.push_back({x,j});\\n                             break;\\n                     }\\n                     else if(s[j] == \\'R\\') // If R is present after R then store in right index\\n                     {\\n                             right.push_back(x);\\n                             x = j;\\n                     }\\n                     if(!flag) right.push_back(x);  \\n                     i = j;       \\n                }\\n        }\\n        \\n        \\n        for(auto &[a,b] : lr) // Fire deal with R.....L type substring\\n        {\\n                int x = (a+b)/2;\\n                if((b-a+1)%2 != 0){\\n                for(int i = a;i<x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';\\n                }\\n                else\\n                {\\n                for(int i = a;i<=x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';        \\n                }\\n        }\\n     \\n        \\n        for(int i = 0;i<left.size();i++) // Dealing with \\'L\\' type substring\\n        {\\n                int j = left[i]-1;\\n                while(j >= 0 && s[j] == \\'.\\')\\n                        s[j--] = \\'L\\';\\n        }\\n         \\n        for(int i = right.size()-1;i>=0;i--) // Dealing with \\'R\\' type substring\\n        {\\n               int j = right[i]+1;\\n               while(j <s.size() && s[j] == \\'.\\')\\n                        s[j++] = \\'R\\'; \\n        }\\n        \\n\\n            \\n            \\n            \\n            return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        string ans = \"\";\\n        vector<int> left; // store \\'L\\' index \\n        vector<int> right; // store \\'R\\' index\\n        vector<pair<int,int>> lr; // store R....L type index\\n         \\n        for(int i = 0;i<s.length();i++)\\n        {\\n                if(s[i] == \\'L\\') // L is not backed by and R\\n                        left.push_back(i);\\n                else if(s[i] == \\'R\\') // Here two condition exist, may be L is present after this or not present\\n                {\\n                   int x = i;    \\n                   int j = i;    \\n                   bool flag = false;     \\n                   for( j = i+1;j<s.length();j++)\\n                     if(s[j] ==\\'L\\') // If L is present then a pair is found\\n                     {\\n                             flag = true;\\n                             lr.push_back({x,j});\\n                             break;\\n                     }\\n                     else if(s[j] == \\'R\\') // If R is present after R then store in right index\\n                     {\\n                             right.push_back(x);\\n                             x = j;\\n                     }\\n                     if(!flag) right.push_back(x);  \\n                     i = j;       \\n                }\\n        }\\n        \\n        \\n        for(auto &[a,b] : lr) // Fire deal with R.....L type substring\\n        {\\n                int x = (a+b)/2;\\n                if((b-a+1)%2 != 0){\\n                for(int i = a;i<x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';\\n                }\\n                else\\n                {\\n                for(int i = a;i<=x;i++)\\n                        s[i] = \\'R\\';\\n                for(int i= x+1;i<b;i++)\\n                        s[i] = \\'L\\';        \\n                }\\n        }\\n     \\n        \\n        for(int i = 0;i<left.size();i++) // Dealing with \\'L\\' type substring\\n        {\\n                int j = left[i]-1;\\n                while(j >= 0 && s[j] == \\'.\\')\\n                        s[j--] = \\'L\\';\\n        }\\n         \\n        for(int i = right.size()-1;i>=0;i--) // Dealing with \\'R\\' type substring\\n        {\\n               int j = right[i]+1;\\n               while(j <s.size() && s[j] == \\'.\\')\\n                        s[j++] = \\'R\\'; \\n        }\\n        \\n\\n            \\n            \\n            \\n            return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629263,
                "title": "java-easy-to-understand-well-commented-left-and-right-array-calculating-force",
                "content": "\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // will calculate the force on every domino in this \\n        //+ve force means domino would fall right and -ve force means domino would fall left\\n        \\n        int n = dominoes.length(); //length of dominoes array and max. force that can be applied on any domino\\n        //calculate right force | +Ve force\\n        int force = 0;\\n        int[] forces = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(dominoes.charAt(i) == \\'R\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'L\\'){\\n                force = 0;\\n            }\\n            forces[i] = force;\\n            if(force == 0) continue;\\n            force--;\\n        }\\n        \\n        //calculate left force | -Ve force\\n        force = 0;  // starting force would be zero\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes.charAt(i) == \\'L\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'R\\'){\\n                force = 0;\\n            }\\n            forces[i] -= force; \\n            if(force == 0) continue;\\n            force--; //less neg force overtime\\n        }\\n        \\n        //calculating total force and making answer acc. to that\\n        //if total force is +ve then domino will fall right => \\'R\\'\\n        //if total force is -ve then domino will fall left => \\'L\\'\\n        //else it will stand still => \\'.\\'\\n        char[] ans = new char[n];\\n        int index = 0;\\n        \\n        for(int totalForce: forces){\\n            char current = \\'.\\';\\n            if(totalForce > 0){\\n                current = \\'R\\';\\n            } else if(totalForce < 0){\\n                current = \\'L\\';\\n            }\\n            \\n            ans[index] = current;\\n            index++;\\n        }\\n        \\n        \\n        return new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        // will calculate the force on every domino in this \\n        //+ve force means domino would fall right and -ve force means domino would fall left\\n        \\n        int n = dominoes.length(); //length of dominoes array and max. force that can be applied on any domino\\n        //calculate right force | +Ve force\\n        int force = 0;\\n        int[] forces = new int[n];\\n        for(int i = 0; i < n; i++){\\n            if(dominoes.charAt(i) == \\'R\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'L\\'){\\n                force = 0;\\n            }\\n            forces[i] = force;\\n            if(force == 0) continue;\\n            force--;\\n        }\\n        \\n        //calculate left force | -Ve force\\n        force = 0;  // starting force would be zero\\n        for(int i = n-1; i >= 0; i--){\\n            if(dominoes.charAt(i) == \\'L\\'){\\n                force = n;\\n            } else if(dominoes.charAt(i) == \\'R\\'){\\n                force = 0;\\n            }\\n            forces[i] -= force; \\n            if(force == 0) continue;\\n            force--; //less neg force overtime\\n        }\\n        \\n        //calculating total force and making answer acc. to that\\n        //if total force is +ve then domino will fall right => \\'R\\'\\n        //if total force is -ve then domino will fall left => \\'L\\'\\n        //else it will stand still => \\'.\\'\\n        char[] ans = new char[n];\\n        int index = 0;\\n        \\n        for(int totalForce: forces){\\n            char current = \\'.\\';\\n            if(totalForce > 0){\\n                current = \\'R\\';\\n            } else if(totalForce < 0){\\n                current = \\'L\\';\\n            }\\n            \\n            ans[index] = current;\\n            index++;\\n        }\\n        \\n        \\n        return new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629224,
                "title": "using-two-pointer",
                "content": "\\n```\\nstring pushDominoes(string s) {\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')\\n            {\\n                int j=i+1;\\n                while(j<n && s[j]==\\'.\\')\\n                    j++;\\n                //if(j==i+1) continue;\\n                if(j==n)\\n                {\\n                    i++;\\n                    while(i<n){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                }\\n                else if(s[j]==\\'L\\')\\n                {\\n                    int k=j;\\n                    i++;k--;\\n                    while(i<k)\\n                    {\\n                        s[i]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                        i++;\\n                        k--;\\n                    }\\n                    i=j;\\n                }\\n                else\\n                {\\n                    while(i<j){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                    i--;\\n                }\\n                    \\n            }\\n            else if(s[i]==\\'L\\')\\n            {\\n\\n                int j=i;\\n                while(j-1>0 && s[j-1]==\\'.\\' && s[j-2]!=\\'R\\')\\n                {\\n                    s[j-1]=\\'L\\';\\n                    j--;\\n                }\\n                 if(j-1==0 && s[j-1]==\\'.\\')\\n                  s[j-1]=\\'L\\';\\n                    \\n            }\\n        }\\n        return s;\\n    }",
                "solutionTags": [
                    "Two Pointers",
                    "String"
                ],
                "code": "\\n```\\nstring pushDominoes(string s) {\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'R\\')\\n            {\\n                int j=i+1;\\n                while(j<n && s[j]==\\'.\\')\\n                    j++;\\n                //if(j==i+1) continue;\\n                if(j==n)\\n                {\\n                    i++;\\n                    while(i<n){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                }\\n                else if(s[j]==\\'L\\')\\n                {\\n                    int k=j;\\n                    i++;k--;\\n                    while(i<k)\\n                    {\\n                        s[i]=\\'R\\';\\n                        s[k]=\\'L\\';\\n                        i++;\\n                        k--;\\n                    }\\n                    i=j;\\n                }\\n                else\\n                {\\n                    while(i<j){\\n                        s[i]=\\'R\\';\\n                        i++;\\n                    }\\n                    i--;\\n                }\\n                    \\n            }\\n            else if(s[i]==\\'L\\')\\n            {\\n\\n                int j=i;\\n                while(j-1>0 && s[j-1]==\\'.\\' && s[j-2]!=\\'R\\')\\n                {\\n                    s[j-1]=\\'L\\';\\n                    j--;\\n                }\\n                 if(j-1==0 && s[j-1]==\\'.\\')\\n                  s[j-1]=\\'L\\';\\n                    \\n            }\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2629148,
                "title": "simple-python-solution-using-queue",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        domino=list(dominoes)\\n        q=deque()\\n        for i,d in enumerate(domino):\\n            if d!=\".\":\\n                q.append((i,d))\\n        while q:\\n            i,d=q.popleft()\\n            if d==\"L\" and i>0 and domino[i-1]==\".\":\\n                q.append((i-1,\"L\"))\\n                domino[i-1]=\"L\"\\n            elif d==\"R\":\\n                if i+1<len(domino) and domino[i+1]==\".\":\\n                    if i+2<len(domino) and domino[i+2]==\"L\":\\n                        q.popleft()\\n                    else:\\n                        q.append((i+1,\"R\"))\\n                        domino[i+1]=\"R\"\\n        return \\'\\'.join(map(str,domino))\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        domino=list(dominoes)\\n        q=deque()\\n        for i,d in enumerate(domino):\\n            if d!=\".\":\\n                q.append((i,d))\\n        while q:\\n            i,d=q.popleft()\\n            if d==\"L\" and i>0 and domino[i-1]==\".\":\\n                q.append((i-1,\"L\"))\\n                domino[i-1]=\"L\"\\n            elif d==\"R\":\\n                if i+1<len(domino) and domino[i+1]==\".\":\\n                    if i+2<len(domino) and domino[i+2]==\"L\":\\n                        q.popleft()\\n                    else:\\n                        q.append((i+1,\"R\"))\\n                        domino[i+1]=\"R\"\\n        return \\'\\'.join(map(str,domino))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2629088,
                "title": "c-o-n-complexity-explained-using-comments",
                "content": "```\\n/* Lets take example2 to understand the concept\\n                             \". L . R . . . L R . . L . .\"\\n\\t\\tFirstly we\\'ll do prefix count of how many will fall towards right and left.\\n\\t\\tWe\\'ll maintain 2 vectors right and left.\\n\\t\\t\\n\\t\\tFor right vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from left to right\\n\\t\\t2) If dominoes[i] == \\'L\\' then it won\\'t fall towards right so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'R\\' then it will fall towards right only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"R R . R\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'R\\' as a starting point of dominoes which will fall towards right\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 1st index so we\\'ll increment value by 1. As this will also fall on right only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on left as some dominoes maybe\\n\\t\\t\\tfalling on left. That we\\'ll consider once we find all the indexes with respect to \\'R\\' dominoes.\\n\\t\\t\\t\\n\\t\\tSimilarly, For left vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from right to left\\n\\t\\t2) If dominoes[i] == \\'R\\' then it won\\'t fall towards left so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'L\\' then it will fall towards left only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"L L . L\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'L\\' as a starting point of dominoes which will fall towards left\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 3rd index so we\\'ll increment value by 1. As this will also fall on left only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on right as some dominoes maybe\\n\\t\\t\\tfalling on right. That we\\'ll consider once we find all the indexes with respect to \\'L\\' dominoes.\\n\\t\\t\\t\\n\\t\\tNow, coming back to example2. Here, we\\'ll firstly find right and left vector.\\n\\t\\tAfterwards we\\'ll perform some operations.\\n\\t\\t                                \". L . R . . . L R . . L . .\"\\n\\t\\t\\t\\t\\t\\t\\t\\t right - 0 0 0 1 2 3 4 0 1 2 3 0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  left - 2 1 0 0 4 3 2 1 0 3 2 1 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t1) Now, if left[i]==0 && right[i]==0, it means it\\'ll be stable So, we\\'ll append \\'.\\' in ans.\\n\\t\\t2) Again, if either is non-zero and another is 0 then it\\'ll fall in favor of non-zero direction\\n\\t\\t3) And if both are non-zero then it\\'ll fall in favor of that direction which have a minimum\\n\\t\\t   value at that particular index. And if both have equal values then it\\'ll remain stable.\\n\\t\\t   Example - if right[i]=2 and left[i]=3 then it\\'ll fall towards right because all dominoes are\\n\\t\\t   simultaneously falling, so domino of this particular index will fall to that direction\\n\\t\\t   in which it has minimum value.\\n*/\\nstring pushDominoes(string s) {\\n        int n=s.length(), cnt=1;\\n        vector<int> left(n), right(n);\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'R\\')\\n                cnt=1, right[i]=cnt++;\\n            else if((i==0 && s[i]==\\'.\\')||s[i]==\\'L\\')\\n                right[i]=0, cnt=1;\\n            else if(i!=0 && s[i]==\\'.\\' && right[i-1]!=0)\\n                right[i]=cnt++;\\n            else\\n                right[i]=0;\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'L\\')\\n                cnt=1, left[i]=cnt++;\\n            else if((i==n-1 && s[i]==\\'.\\')||s[i]==\\'R\\')\\n                left[i]=0, cnt=1;\\n            else if(i!=n-1 && s[i]==\\'.\\' && left[i+1]!=0)\\n                left[i]=cnt++;\\n            else\\n                left[i]=0;\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            if(left[i]!=0 && right[i]==0)\\n                ans+=\"L\";\\n            else if(left[i]==0 && right[i]!=0)\\n                ans+=\"R\";\\n            else if(left[i]==0 && right[i]==0)\\n                ans+=\".\";\\n            else {\\n                if(left[i]<right[i])\\n                    ans+=\"L\";\\n                else if(right[i]<left[i])\\n                    ans+=\"R\";\\n                else\\n                    ans+=\".\";\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t/* I tried my best to deliver explanation. I hope it helped you to understand, if you face any issue please do\\n\\task in comments. Thanks!! */",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* Lets take example2 to understand the concept\\n                             \". L . R . . . L R . . L . .\"\\n\\t\\tFirstly we\\'ll do prefix count of how many will fall towards right and left.\\n\\t\\tWe\\'ll maintain 2 vectors right and left.\\n\\t\\t\\n\\t\\tFor right vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from left to right\\n\\t\\t2) If dominoes[i] == \\'L\\' then it won\\'t fall towards right so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'R\\' then it will fall towards right only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"R R . R\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'R\\' as a starting point of dominoes which will fall towards right\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 1st index so we\\'ll increment value by 1. As this will also fall on right only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on left as some dominoes maybe\\n\\t\\t\\tfalling on left. That we\\'ll consider once we find all the indexes with respect to \\'R\\' dominoes.\\n\\t\\t\\t\\n\\t\\tSimilarly, For left vector before that there are few considerations we need to keep in mind\\n\\t\\t1) We\\'ll traverse dominoes string from right to left\\n\\t\\t2) If dominoes[i] == \\'R\\' then it won\\'t fall towards left so count=0 at ith index.\\n\\t\\t3) If dominoes[i] == \\'L\\' then it will fall towards left only so **count=1** at every ith index.\\n\\t\\t    For example - dominoes string = \"L L . L\"\\n\\t\\t\\t                        count =  1 1 2 1\\n\\t\\t\\tHere, As we are considering every \\'L\\' as a starting point of dominoes which will fall towards left\\n\\t\\t\\tAnd for now you can ignore how does 2 comes at 2nd index (We\\'ll discuss this in next point).\\n\\t\\t\\t*I hope I made myself clear about this particular case*\\n\\t\\t4) If dominoes[i] == \\'.\\' then we have to check if last index is non-zero or not. As In case 2) we have\\n\\t\\t    non-zero value at 3rd index so we\\'ll increment value by 1. As this will also fall on left only. Otherwise\\n\\t\\t\\tit\\'ll be 0 only.\\n\\t\\t\\tNote - Yah, there maybe case arising in your mind what if it falls on right as some dominoes maybe\\n\\t\\t\\tfalling on right. That we\\'ll consider once we find all the indexes with respect to \\'L\\' dominoes.\\n\\t\\t\\t\\n\\t\\tNow, coming back to example2. Here, we\\'ll firstly find right and left vector.\\n\\t\\tAfterwards we\\'ll perform some operations.\\n\\t\\t                                \". L . R . . . L R . . L . .\"\\n\\t\\t\\t\\t\\t\\t\\t\\t right - 0 0 0 1 2 3 4 0 1 2 3 0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  left - 2 1 0 0 4 3 2 1 0 3 2 1 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t1) Now, if left[i]==0 && right[i]==0, it means it\\'ll be stable So, we\\'ll append \\'.\\' in ans.\\n\\t\\t2) Again, if either is non-zero and another is 0 then it\\'ll fall in favor of non-zero direction\\n\\t\\t3) And if both are non-zero then it\\'ll fall in favor of that direction which have a minimum\\n\\t\\t   value at that particular index. And if both have equal values then it\\'ll remain stable.\\n\\t\\t   Example - if right[i]=2 and left[i]=3 then it\\'ll fall towards right because all dominoes are\\n\\t\\t   simultaneously falling, so domino of this particular index will fall to that direction\\n\\t\\t   in which it has minimum value.\\n*/\\nstring pushDominoes(string s) {\\n        int n=s.length(), cnt=1;\\n        vector<int> left(n), right(n);\\n        for(int i=0;i<n;i++) {\\n            if(s[i]==\\'R\\')\\n                cnt=1, right[i]=cnt++;\\n            else if((i==0 && s[i]==\\'.\\')||s[i]==\\'L\\')\\n                right[i]=0, cnt=1;\\n            else if(i!=0 && s[i]==\\'.\\' && right[i-1]!=0)\\n                right[i]=cnt++;\\n            else\\n                right[i]=0;\\n        }\\n        for(int i=n-1;i>=0;i--) {\\n            if(s[i]==\\'L\\')\\n                cnt=1, left[i]=cnt++;\\n            else if((i==n-1 && s[i]==\\'.\\')||s[i]==\\'R\\')\\n                left[i]=0, cnt=1;\\n            else if(i!=n-1 && s[i]==\\'.\\' && left[i+1]!=0)\\n                left[i]=cnt++;\\n            else\\n                left[i]=0;\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            if(left[i]!=0 && right[i]==0)\\n                ans+=\"L\";\\n            else if(left[i]==0 && right[i]!=0)\\n                ans+=\"R\";\\n            else if(left[i]==0 && right[i]==0)\\n                ans+=\".\";\\n            else {\\n                if(left[i]<right[i])\\n                    ans+=\"L\";\\n                else if(right[i]<left[i])\\n                    ans+=\"R\";\\n                else\\n                    ans+=\".\";\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t/* I tried my best to deliver explanation. I hope it helped you to understand, if you face any issue please do\\n\\task in comments. Thanks!! */",
                "codeTag": "Unknown"
            },
            {
                "id": 2629078,
                "title": "python3-o-n-pythonic-two-pointers",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = list(\\'L\\' + dominoes + \\'R\\')\\n        l, r = 0, 1\\n        while r < len(res):\\n            if res[r] == \\'.\\':\\n                r += 1\\n                continue\\n            elif res[r] == \\'L\\' and res[l] == \\'R\\':\\n                h = (r - l - 1) // 2\\n                res[l+1:l+1+h] = [\\'R\\'] * h\\n                res[r-h:r] = [\\'L\\'] * h\\n            elif res[l] == res[r]:\\n                res[l+1:r] = [res[l]] * (r - l - 1)\\n            l, r = r, r + 1\\n        return \\'\\'.join(res[1:-1])        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        res = list(\\'L\\' + dominoes + \\'R\\')\\n        l, r = 0, 1\\n        while r < len(res):\\n            if res[r] == \\'.\\':\\n                r += 1\\n                continue\\n            elif res[r] == \\'L\\' and res[l] == \\'R\\':\\n                h = (r - l - 1) // 2\\n                res[l+1:l+1+h] = [\\'R\\'] * h\\n                res[r-h:r] = [\\'L\\'] * h\\n            elif res[l] == res[r]:\\n                res[l+1:r] = [res[l]] * (r - l - 1)\\n            l, r = r, r + 1\\n        return \\'\\'.join(res[1:-1])        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628947,
                "title": "c-bfs",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    string pushDominoes(string& dominoes) {\\n        \\n        int n = dominoes.size();\\n        vector<int> l( n, INT_MAX );\\n        vector<int> r( n, INT_MAX );\\n        \\n        queue< int > qr;\\n        queue< int > ql;\\n        \\n        for( int i=0; i<dominoes.size() ;i++ ){\\n            if( dominoes[i] == \\'R\\' ){\\n                r[i] = 0;\\n                qr.push(i);\\n            }\\n            else if( dominoes[i] == \\'L\\' ){\\n                l[i] = 0;\\n                ql.push(i);\\n            }\\n        }\\n        while( !ql.empty() ){\\n            int i = ql.front();\\n            ql.pop();\\n            \\n            if( i > 0 && dominoes[i-1] == \\'.\\' && 1+l[i] < l[i-1] ){\\n                l[i-1] = 1 + l[i];\\n                ql.push(i-1);\\n            }\\n        }\\n        while( !qr.empty() ){\\n            int i = qr.front();\\n            qr.pop();\\n            \\n            if( i < n-1 && dominoes[i+1] == \\'.\\' && 1 + r[i] < r[i+1] ){\\n                r[i+1] = 1 + r[i];\\n                qr.push(i+1);\\n            }\\n        }\\n        \\n        for( int i =0; i<n ;i++ ){\\n            if( l[i] < r[i] ){\\n                dominoes[i] = \\'L\\';\\n            }\\n            else if( l[i] == r[i] ){\\n                dominoes[i] = \\'.\\';\\n            }\\n            else{\\n                dominoes[i] = \\'R\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    string pushDominoes(string& dominoes) {\\n        \\n        int n = dominoes.size();\\n        vector<int> l( n, INT_MAX );\\n        vector<int> r( n, INT_MAX );\\n        \\n        queue< int > qr;\\n        queue< int > ql;\\n        \\n        for( int i=0; i<dominoes.size() ;i++ ){\\n            if( dominoes[i] == \\'R\\' ){\\n                r[i] = 0;\\n                qr.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2628922,
                "title": "simulation-in-a-while-loop",
                "content": "Not sure if it is a good solution, but my approach is just do simulation.\\nThe simulation is in the while loop, every time a push do only one forward unitl there is no pushes. like the description said\\n\\n\"each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\"\\n\\n```\\nclass Solution:\\n    def pushDominoes(self, dominoes : str) -> str:\\n        dom = list(dominoes)\\n        ls, rs = set(), set()\\n        for i, c in enumerate(dom):\\n            if c==\\'L\\':ls.add(i)\\n            elif c==\\'R\\':rs.add(i)\\n        \\n        while ls or rs:            \\n            newls = set()\\n            for i in ls:\\n                if i-1>=0 and dom[i-1]==\\'.\\':\\n                    if (i-2) in rs:\\n                        rs.remove(i-2)\\n                    else:\\n                        dom[i-1]=\"L\"\\n                        newls.add(i-1)\\n            \\n            newrs = set()\\n            for i in rs:\\n                if i+1<len(dom) and dom[i+1]==\".\":\\n                    dom[i+1]=\"R\"\\n                    newrs.add(i+1)\\n            ls = newls\\n            rs = newrs\\n                \\n        return \"\".join(dom)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dominoes : str) -> str:\\n        dom = list(dominoes)\\n        ls, rs = set(), set()\\n        for i, c in enumerate(dom):\\n            if c==\\'L\\':ls.add(i)\\n            elif c==\\'R\\':rs.add(i)\\n        \\n        while ls or rs:            \\n            newls = set()\\n            for i in ls:\\n                if i-1>=0 and dom[i-1]==\\'.\\':\\n                    if (i-2) in rs:\\n                        rs.remove(i-2)\\n                    else:\\n                        dom[i-1]=\"L\"\\n                        newls.add(i-1)\\n            \\n            newrs = set()\\n            for i in rs:\\n                if i+1<len(dom) and dom[i+1]==\".\":\\n                    dom[i+1]=\"R\"\\n                    newrs.add(i+1)\\n            ls = newls\\n            rs = newrs\\n                \\n        return \"\".join(dom)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628893,
                "title": "c-solution",
                "content": "1. There are just three condition `[L...R],[R..L],[L...L]` we need to care about \\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s,int left=-1,int right = -1) {\\n        for(int i= 0; i <= s.size(); ++i) {\\n            if(i == s.size() or s[i] == \\'R\\'){ // [R..L]\\n              if (right != left)for(int j = right; j < i; s[j++] = \\'R\\');\\n              right = i;\\n            }else if(s[i] == \\'L\\'){\\n                if (left == right) for(int j = left + 1; j < i; s[j++] = \\'L\\');//[L...L]\\n                else //[R...L]\\n                   for(int low = right + 1, high = i - 1;low < high;s[low++] = \\'R\\', s[high--] = \\'L\\');\\n                 left = right = i;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s,int left=-1,int right = -1) {\\n        for(int i= 0; i <= s.size(); ++i) {\\n            if(i == s.size() or s[i] == \\'R\\'){ // [R..L]\\n              if (right != left)for(int j = right; j < i; s[j++] = \\'R\\');\\n              right = i;\\n            }else if(s[i] == \\'L\\'){\\n                if (left == right) for(int j = left + 1; j < i; s[j++] = \\'L\\');//[L...L]\\n                else //[R...L]\\n                   for(int low = right + 1, high = i - 1;low < high;s[low++] = \\'R\\', s[high--] = \\'L\\');\\n                 left = right = i;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628850,
                "title": "java-solution-100-faster-and-easy-code",
                "content": "```\\nclass Solution {\\n  public String pushDominoes(String dominoes) {\\n    char[] s = dominoes.toCharArray();\\n    int L = -1;\\n    int R = -1;\\n\\n    for (int i = 0; i <= dominoes.length(); ++i)\\n      if (i == dominoes.length() || s[i] == \\'R\\') {\\n        if (L < R)\\n          while (R < i)\\n            s[R++] = \\'R\\';\\n        R = i;\\n      } else if (s[i] == \\'L\\') {\\n        if (R < L || L == -1 && R == -1) {\\n          if (L == -1 && R == -1)\\n            ++L;\\n          while (L < i)\\n            s[L++] = \\'L\\';\\n        } else {\\n          int l = R + 1;\\n          int r = i - 1;\\n          while (l < r) {\\n            s[l++] = \\'R\\';\\n            s[r--] = \\'L\\';\\n          }\\n        }\\n        L = i;\\n      }\\n\\n    return new String(s);\\n  }\\n}\\n```\\n// If you like the solution pls upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public String pushDominoes(String dominoes) {\\n    char[] s = dominoes.toCharArray();\\n    int L = -1;\\n    int R = -1;\\n\\n    for (int i = 0; i <= dominoes.length(); ++i)\\n      if (i == dominoes.length() || s[i] == \\'R\\') {\\n        if (L < R)\\n          while (R < i)\\n            s[R++] = \\'R\\';\\n        R = i;\\n      } else if (s[i] == \\'L\\') {\\n        if (R < L || L == -1 && R == -1) {\\n          if (L == -1 && R == -1)\\n            ++L;\\n          while (L < i)\\n            s[L++] = \\'L\\';\\n        } else {\\n          int l = R + 1;\\n          int r = i - 1;\\n          while (l < r) {\\n            s[l++] = \\'R\\';\\n            s[r--] = \\'L\\';\\n          }\\n        }\\n        L = i;\\n      }\\n\\n    return new String(s);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628717,
                "title": "java-easy-solution-easy-to-understand-100-faster-push-dominoes",
                "content": "## Upvote the solution if you liked it \\uD83D\\uDC4D\\n\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] dArray = dominoes.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && dArray[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = dArray[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        dArray[l]=\\'R\\';\\n                        dArray[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        dArray[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        dArray[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(dArray);\\n    }\\n}\\n```\\n\\n### If you liked the solution and it worked for you then please upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        int n = dominoes.length();\\n        char[] dArray = dominoes.toCharArray();\\n        char start = \\'.\\';\\n        char last = \\'.\\';\\n        int stidx = 0;\\n        int i = 0;\\n        while(i<n){\\n            stidx = i;\\n            while(i<n && dArray[i]==\\'.\\'){\\n                i++;\\n            }\\n            if(i<n){\\n                last = dArray[i];\\n            }\\n            if(i-stidx>0){\\n                if(start==\\'R\\' && last==\\'L\\'){\\n                    int l = stidx;\\n                    int r = i-1;\\n                    while(l<r){\\n                        dArray[l]=\\'R\\';\\n                        dArray[r]=\\'L\\';\\n                        l++;\\n                        r--;\\n                        \\n                    }\\n                   \\n                }\\n                else if(last==\\'L\\'){\\n                    int l = i-1;\\n                    while(l>=stidx){\\n                        dArray[l]=\\'L\\';\\n                        l--;\\n                    }\\n                }\\n                else if(start==\\'R\\'){\\n                    int r = stidx;\\n                    while(r<i){\\n                        dArray[r]=\\'R\\';\\n                        r++;\\n                    }   \\n                }\\n            }\\n            \\n            start = last;\\n            i++;\\n            last = \\'.\\';\\n        }\\n        return new String(dArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573350,
                "title": "c-95-time-99-99-memory-tricky-two-pointer-explain-comments",
                "content": "The n^2 solution to this problem is easy but it was difficult for me to find a way to not do so much repeated work. I came up with this idea: \\nMaintain the position of the closest domino pointing RIGHT. If we encounter a left domino along the way, the position of the closest domino pointing right is INFINITY because the left cancels it out.\\n\\nLook for the closest domino pointing LEFT. We do this by iterating ahead of our current position. If there is a right domino along the way, the position of the closest domino opint left is INFINITY because the right cancels it out.\\nImportant: We only need to redo this step if closestLeft is BEHIND our current position, because if the closestLeft for i = 3 is index 9, it will also be the closest left for indices 4...8.\\n\\nNow we know the positions of our closest right and left dominos. So for any given \\'.\\', we just need to check the absolute distance from the closestLeft or closestRight domino and set it to that one. If they are equidistant, then we do not change the \\'.\\'.\\n\\n```\\n    string pushDominoes(string d) {\\n        const int INF = 10e5;\\n        int closestLeft = INF; // in front\\n        int closestRight = INF; // behind\\n        int j = 0;\\n        for(int i = 0; i < d.length(); i++){\\n            if(closestLeft <= i || (j <= i && closestLeft == INF)){ // find the closest left domino if it exists \\n                j = i;\\n                while(j < d.length()){ // dont redo calculation if closestleft is >= i because the answer remains the same\\n                        // do redo if closestleft <= i OR j <= i AND closestLeft = infinity\\n                        if(d[j] == \\'L\\'){\\n                            closestLeft = j;\\n                            break;\\n                        }\\n                        if(d[j] == \\'R\\'){\\n                            closestLeft = INF;\\n                            break;\\n                        }\\n                        j++;\\n                    }\\n            }\\n            if(closestLeft < i) closestLeft = INF; // closestLeft does not exist if it\\'s behind the domino because it can never push it\\n            \\n            if(d[i] == \\'R\\') closestRight = i; // do this before checking if it\\'s a \\'.\\' because it might mistakenly update it\\n            else if(d[i] == \\'L\\') closestRight = INF;\\n    \\n            if(d[i] == \\'.\\'){\\n                if(abs(closestLeft-i) < abs(closestRight-i)) d[i] = \\'L\\'; // left is closer in absolute distance so it will reach this domino first\\n                else if(abs(closestLeft-i) > abs(closestRight-i)) d[i] = \\'R\\'; // right is closer in absolute distance so it will reach this domino first \\n            }\\n        }\\n        return d;\\n    }",
                "solutionTags": [],
                "code": "The n^2 solution to this problem is easy but it was difficult for me to find a way to not do so much repeated work. I came up with this idea: \\nMaintain the position of the closest domino pointing RIGHT. If we encounter a left domino along the way, the position of the closest domino pointing right is INFINITY because the left cancels it out.\\n\\nLook for the closest domino pointing LEFT. We do this by iterating ahead of our current position. If there is a right domino along the way, the position of the closest domino opint left is INFINITY because the right cancels it out.\\nImportant: We only need to redo this step if closestLeft is BEHIND our current position, because if the closestLeft for i = 3 is index 9, it will also be the closest left for indices 4...8.\\n\\nNow we know the positions of our closest right and left dominos. So for any given \\'.\\', we just need to check the absolute distance from the closestLeft or closestRight domino and set it to that one. If they are equidistant, then we do not change the \\'.\\'.\\n\\n```\\n    string pushDominoes(string d) {\\n        const int INF = 10e5;\\n        int closestLeft = INF; // in front\\n        int closestRight = INF; // behind\\n        int j = 0;\\n        for(int i = 0; i < d.length(); i++){\\n            if(closestLeft <= i || (j <= i && closestLeft == INF)){ // find the closest left domino if it exists \\n                j = i;\\n                while(j < d.length()){ // dont redo calculation if closestleft is >= i because the answer remains the same\\n                        // do redo if closestleft <= i OR j <= i AND closestLeft = infinity\\n                        if(d[j] == \\'L\\'){\\n                            closestLeft = j;\\n                            break;\\n                        }\\n                        if(d[j] == \\'R\\'){\\n                            closestLeft = INF;\\n                            break;\\n                        }\\n                        j++;\\n                    }\\n            }\\n            if(closestLeft < i) closestLeft = INF; // closestLeft does not exist if it\\'s behind the domino because it can never push it\\n            \\n            if(d[i] == \\'R\\') closestRight = i; // do this before checking if it\\'s a \\'.\\' because it might mistakenly update it\\n            else if(d[i] == \\'L\\') closestRight = INF;\\n    \\n            if(d[i] == \\'.\\'){\\n                if(abs(closestLeft-i) < abs(closestRight-i)) d[i] = \\'L\\'; // left is closer in absolute distance so it will reach this domino first\\n                else if(abs(closestLeft-i) > abs(closestRight-i)) d[i] = \\'R\\'; // right is closer in absolute distance so it will reach this domino first \\n            }\\n        }\\n        return d;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2433602,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring pushDominoes(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<int> l(n, 0), r;\\n\\t\\tint ct = 0;\\n\\t\\tfor (auto &e : s) {\\n\\t\\t\\tif (e == \\'R\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'L\\') ct = 0;\\n\\t\\t\\tr.push_back(ct);\\n\\t\\t}\\n\\t\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\t\\tchar e = s[i];\\n\\t\\t\\tif (e == \\'L\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'R\\') ct = 0;\\n\\t\\t\\tl[i] = ct;\\n\\t\\t}\\n\\t\\tstring ans;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (s[i] == \\'.\\') {\\n\\t\\t\\t\\tif (l[i] == r[i]) ans.push_back(\\'.\\');\\n\\t\\t\\t\\telse if (l[i] == 0) ans.push_back(\\'R\\');\\n\\t\\t\\t\\telse if (r[i] == 0) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse if (l[i] < r[i]) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse  ans.push_back(\\'R\\');\\n\\t\\t\\t}\\n\\t\\t\\telse ans.push_back(s[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring pushDominoes(string s) {\\n\\t\\tint n = s.size();\\n\\t\\tvector<int> l(n, 0), r;\\n\\t\\tint ct = 0;\\n\\t\\tfor (auto &e : s) {\\n\\t\\t\\tif (e == \\'R\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'L\\') ct = 0;\\n\\t\\t\\tr.push_back(ct);\\n\\t\\t}\\n\\t\\tfor (int i = n - 1; i >= 0; --i) {\\n\\t\\t\\tchar e = s[i];\\n\\t\\t\\tif (e == \\'L\\') {\\n\\t\\t\\t\\tct = 1;\\n\\t\\t\\t}\\n\\t\\t\\telse if (ct && e == \\'.\\') {\\n\\t\\t\\t\\tct++;\\n\\t\\t\\t}\\n\\t\\t\\telse if (e == \\'R\\') ct = 0;\\n\\t\\t\\tl[i] = ct;\\n\\t\\t}\\n\\t\\tstring ans;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (s[i] == \\'.\\') {\\n\\t\\t\\t\\tif (l[i] == r[i]) ans.push_back(\\'.\\');\\n\\t\\t\\t\\telse if (l[i] == 0) ans.push_back(\\'R\\');\\n\\t\\t\\t\\telse if (r[i] == 0) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse if (l[i] < r[i]) ans.push_back(\\'L\\');\\n\\t\\t\\t\\telse  ans.push_back(\\'R\\');\\n\\t\\t\\t}\\n\\t\\t\\telse ans.push_back(s[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404263,
                "title": "prefix-suffix-method-c-easiest-ace-solution",
                "content": "**\\n##  **********``**\\n \\n \\n string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n      vector<int> pre(n, 0);\\n      vector<int> suff(n, 0);\\n      \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'){\\n                for(int j=i+1; j<n; j++){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else pre[j]=pre[j-1]+1;\\n                }\\n            }\\n           \\n        }\\n        \\n          for(int i=n-1; i>=0; i--){\\n            if(dominoes[i]==\\'L\\'){\\n                for(int j=i-1; j>=0; j--){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else suff[j]=suff[j+1]+1;\\n                }\\n            }\\n           \\n        } \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\') continue;\\n          if((pre[i]==0&&suff[i]==0)||pre[i]==suff[i]) continue;\\n            \\n            if(pre[i]!=0&&suff[i]!=0){\\n                if(pre[i]>suff[i]) dominoes[i]=\\'L\\';\\n                if(pre[i]<suff[i]) dominoes[i]=\\'R\\';\\n                else continue;\\n            }\\n            else{\\n                \\n              if(pre[i]==0) dominoes[i]=\\'L\\';\\n                else{\\n                    dominoes[i]=\\'R\\';\\n                }\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "**\\n##  **********``**\\n \\n \\n string pushDominoes(string dominoes) {\\n        int n=dominoes.size();\\n      vector<int> pre(n, 0);\\n      vector<int> suff(n, 0);\\n      \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'){\\n                for(int j=i+1; j<n; j++){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else pre[j]=pre[j-1]+1;\\n                }\\n            }\\n           \\n        }\\n        \\n          for(int i=n-1; i>=0; i--){\\n            if(dominoes[i]==\\'L\\'){\\n                for(int j=i-1; j>=0; j--){\\n                    if(dominoes[j]!=\\'.\\') break;\\n                    else suff[j]=suff[j+1]+1;\\n                }\\n            }\\n           \\n        } \\n        for(int i=0; i<n; i++){\\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\') continue;\\n          if((pre[i]==0&&suff[i]==0)||pre[i]==suff[i]) continue;\\n            \\n            if(pre[i]!=0&&suff[i]!=0){\\n                if(pre[i]>suff[i]) dominoes[i]=\\'L\\';\\n                if(pre[i]<suff[i]) dominoes[i]=\\'R\\';\\n                else continue;\\n            }\\n            else{\\n                \\n              if(pre[i]==0) dominoes[i]=\\'L\\';\\n                else{\\n                    dominoes[i]=\\'R\\';\\n                }\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2394442,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def pushDominoes(self, dom: str) -> str:\\n        from collections import deque\\n        n = len(dom)\\n        d = set()\\n        q = deque()\\n        arr = [0 for i in range(n)]\\n        for i in range(n):\\n            if dom[i] == \"L\":\\n                arr[i] = -1\\n                d.add(i)\\n                q.append((i,\"L\"))\\n            if dom[i] == \"R\":\\n                arr[i] = 1\\n                d.add(i)\\n                q.append((i,\"R\"))\\n        while q:\\n            t1 = set()\\n            for _ in range(len(q)):\\n                t = q.popleft()\\n                if t[1] == \"L\":\\n                    if t[0]-1 >= 0 and t[0]-1 not in d:\\n                        t1.add(t[0]-1)\\n                        arr[t[0]-1] -= 1\\n                else:\\n                    if t[0]+1 < n and t[0]+1 not in d:\\n                        t1.add(t[0]+1)\\n                        arr[t[0]+1] += 1\\n            for val in t1:\\n                d.add(val)\\n                if arr[val] > 0:\\n                    q.append((val,\"R\"))\\n                elif arr[val]<0:\\n                    q.append((val,\"L\"))\\n        ans = \"\"\\n        for val in arr:\\n            if val<0:\\n                ans += \"L\"\\n            elif val>0:\\n                ans += \"R\"\\n            else:\\n                ans += \".\"\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def pushDominoes(self, dom: str) -> str:\\n        from collections import deque\\n        n = len(dom)\\n        d = set()\\n        q = deque()\\n        arr = [0 for i in range(n)]\\n        for i in range(n):\\n            if dom[i] == \"L\":\\n                arr[i] = -1\\n                d.add(i)\\n                q.append((i,\"L\"))\\n            if dom[i] == \"R\":\\n                arr[i] = 1\\n                d.add(i)\\n                q.append((i,\"R\"))\\n        while q:\\n            t1 = set()\\n            for _ in range(len(q)):\\n                t = q.popleft()\\n                if t[1] == \"L\":\\n                    if t[0]-1 >= 0 and t[0]-1 not in d:\\n                        t1.add(t[0]-1)\\n                        arr[t[0]-1] -= 1\\n                else:\\n                    if t[0]+1 < n and t[0]+1 not in d:\\n                        t1.add(t[0]+1)\\n                        arr[t[0]+1] += 1\\n            for val in t1:\\n                d.add(val)\\n                if arr[val] > 0:\\n                    q.append((val,\"R\"))\\n                elif arr[val]<0:\\n                    q.append((val,\"L\"))\\n        ans = \"\"\\n        for val in arr:\\n            if val<0:\\n                ans += \"L\"\\n            elif val>0:\\n                ans += \"R\"\\n            else:\\n                ans += \".\"\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375230,
                "title": "c-easy-and-understanding-solution",
                "content": "```\\npublic class Solution {\\n    public string PushDominoes(string dominoes) {\\n        char[] elements = dominoes.ToCharArray();\\n        int length = elements.Length;\\n        int[] forces = new int[length];\\n        \\n        int force = 0;\\n        for(int i = 0; i < length; i++) {\\n            if(elements[i] == \\'R\\') {\\n                force = length;\\n            } else if(elements[i] == \\'L\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] += force;\\n        }\\n        \\n        force = 0;\\n        for(int i = length - 1; i >= 0; i--) {\\n            if(elements[i] == \\'L\\') {\\n                force = length;\\n            } else if(elements[i] == \\'R\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] -= force;\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        foreach(int f in forces) {\\n            if(f > 0) {\\n                builder.Append(\\'R\\');\\n            } else if(f < 0) {\\n                builder.Append(\\'L\\');\\n            } else {\\n                builder.Append(\\'.\\');\\n            }\\n        }\\n        \\n        return builder.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string PushDominoes(string dominoes) {\\n        char[] elements = dominoes.ToCharArray();\\n        int length = elements.Length;\\n        int[] forces = new int[length];\\n        \\n        int force = 0;\\n        for(int i = 0; i < length; i++) {\\n            if(elements[i] == \\'R\\') {\\n                force = length;\\n            } else if(elements[i] == \\'L\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] += force;\\n        }\\n        \\n        force = 0;\\n        for(int i = length - 1; i >= 0; i--) {\\n            if(elements[i] == \\'L\\') {\\n                force = length;\\n            } else if(elements[i] == \\'R\\') {\\n                force = 0;\\n            } else {\\n                force = Math.Max(force - 1, 0);\\n            }\\n            \\n            forces[i] -= force;\\n        }\\n        \\n        StringBuilder builder = new StringBuilder();\\n        foreach(int f in forces) {\\n            if(f > 0) {\\n                builder.Append(\\'R\\');\\n            } else if(f < 0) {\\n                builder.Append(\\'L\\');\\n            } else {\\n                builder.Append(\\'.\\');\\n            }\\n        }\\n        \\n        return builder.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315751,
                "title": "c-easy-to-understand-shitty-code-two-pointers-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n=d.size();\\n        int i=0;\\n        int j=0;\\n        string s(n,\\'.\\');\\n        if(d==s)\\n        return d;\\n        while(j<n)\\n        {\\n            if(d[j]==\\'.\\')\\n            {\\n                i=j;\\n                while(j<n&&d[j]==\\'.\\')\\n                {\\n                    j++;\\n                }\\n        \\n                if(i==0)\\n                {\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else if(j==n)\\n                {\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(d[j]==\\'L\\'&&d[i-1]==\\'R\\')\\n                    {\\n                        int len=j-(i-1)+1;\\n                        if(len%2==0)\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            }\\n                        }\\n                        else\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            } \\n                        }\\n                    }\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            j++;\\n        }\\n        return d;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        int n=d.size();\\n        int i=0;\\n        int j=0;\\n        string s(n,\\'.\\');\\n        if(d==s)\\n        return d;\\n        while(j<n)\\n        {\\n            if(d[j]==\\'.\\')\\n            {\\n                i=j;\\n                while(j<n&&d[j]==\\'.\\')\\n                {\\n                    j++;\\n                }\\n        \\n                if(i==0)\\n                {\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else if(j==n)\\n                {\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(d[j]==\\'L\\'&&d[i-1]==\\'R\\')\\n                    {\\n                        int len=j-(i-1)+1;\\n                        if(len%2==0)\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            }\\n                        }\\n                        else\\n                        {\\n                            int z=len/2;\\n                            int k=z;\\n                            --i;\\n                            while(z--)\\n                            {\\n                                d[i++]=\\'R\\';\\n                            }\\n                            while(k--)\\n                            {\\n                                d[j--]=\\'L\\';\\n                            } \\n                        }\\n                    }\\n                    if(d[j]==\\'L\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'L\\';\\n                            i++;\\n                        }\\n                    }\\n                    if(d[i-1]==\\'R\\')\\n                    {\\n                        while(i<j)\\n                        {\\n                            d[i]=\\'R\\';\\n                            i++;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            j++;\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241066,
                "title": "easy-to-understand-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        //now what to do\\n        queue<int> q;\\n        for(int i=0;i<d.size();i++)\\n            if(d[i]!=\\'.\\')q.push(i);\\n        \\n        //last updated\\n        while(!q.empty())\\n        {\\n            int size=q.size(),last=-2;\\n            while(size--)\\n            {\\n                char dir=d[q.front()];\\n                int nxt=(dir==\\'L\\')?q.front()-1:q.front()+1;\\n                q.pop();\\n                if(last==nxt&&dir!=d[nxt])//then update to .\\n                    d[nxt]=\\'.\\';\\n                else if(nxt>=0&&nxt<d.size()&&d[nxt]==\\'.\\')//then only we will update\\n                {\\n                    d[nxt]=dir;\\n                    q.push(nxt);\\n                    last=nxt;\\n                }\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string d) {\\n        //now what to do\\n        queue<int> q;\\n        for(int i=0;i<d.size();i++)\\n            if(d[i]!=\\'.\\')q.push(i);\\n        \\n        //last updated\\n        while(!q.empty())\\n        {\\n            int size=q.size(),last=-2;\\n            while(size--)\\n            {\\n                char dir=d[q.front()];\\n                int nxt=(dir==\\'L\\')?q.front()-1:q.front()+1;\\n                q.pop();\\n                if(last==nxt&&dir!=d[nxt])//then update to .\\n                    d[nxt]=\\'.\\';\\n                else if(nxt>=0&&nxt<d.size()&&d[nxt]==\\'.\\')//then only we will update\\n                {\\n                    d[nxt]=dir;\\n                    q.push(nxt);\\n                    last=nxt;\\n                }\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988884,
                "title": "simple-multi-source-bfs-with-python",
                "content": "This problem has simple graph-based formulation. Let\\'s consider dominoes to be vertices where every pair of adjecent dominoes are connected with an edge. In such graph spread of falling dominoes can be viewed as breadth-first-search from multiple sources. The sources here are \\'L\\' or \\'R\\' - pushed dominoes.\\nAs we know, breadth-first-search explores all nodes at the present depth prior to moving on to the nodes at the next depth level. Extra memory used for queue (deque in Python), which is needed to keep track of the nodes that were encountered but not yet explored.\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        qq = deque() # BFS candidate queue\\n        mp = {\\'L\\': -1, \\'R\\': 1} # Define mapping from the letter to the search direction\\n        was = [0 for _ in range(len(dominoes))] # To mark visited nodes with depths\\n        res = list(dominoes)\\n        # Add to queue nodes with \\'L\\' or \\'R\\' as a sources\\n        for i, x in enumerate(dominoes): \\n            if x != \\'.\\':\\n                qq.append((i, 1, x))\\n                was[i] = -1\\n\\t\\t# BFS\\n        while qq: \\n            idx, depth, direction = qq.popleft()\\n            if idx < 0 or idx >= len(res): # Check whether the borders are exceeded\\n                continue\\n            if was[idx] == depth: # Check if this node is pushed from both sides\\n                res[idx] = \\'.\\'\\n            elif was[idx] <= 0: # Check if this node haven\\'t been visited\\n                was[idx] = depth\\n                qq.append((idx + mp[direction], depth + 1, direction))\\n                res[idx] = direction\\n        return \\'\\'.join(res)\\n```\\nThis solution has O(n) time complexity because each node is visited no more than 3 times (ones in for loop and at most twice in BFS). Also here we use O(n) extra memory for queue, depths and result.",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        qq = deque() # BFS candidate queue\\n        mp = {\\'L\\': -1, \\'R\\': 1} # Define mapping from the letter to the search direction\\n        was = [0 for _ in range(len(dominoes))] # To mark visited nodes with depths\\n        res = list(dominoes)\\n        # Add to queue nodes with \\'L\\' or \\'R\\' as a sources\\n        for i, x in enumerate(dominoes): \\n            if x != \\'.\\':\\n                qq.append((i, 1, x))\\n                was[i] = -1\\n\\t\\t# BFS\\n        while qq: \\n            idx, depth, direction = qq.popleft()\\n            if idx < 0 or idx >= len(res): # Check whether the borders are exceeded\\n                continue\\n            if was[idx] == depth: # Check if this node is pushed from both sides\\n                res[idx] = \\'.\\'\\n            elif was[idx] <= 0: # Check if this node haven\\'t been visited\\n                was[idx] = depth\\n                qq.append((idx + mp[direction], depth + 1, direction))\\n                res[idx] = direction\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932475,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] str = dominoes.toCharArray();\\n        int n = str.length;\\n        Queue<Pair> que = new LinkedList<>();\\n        for(int i = 0; i < n ; i++) \\n            if(str[i] != \\'.\\') que.add(new Pair(i, str[i]));\\n        \\n        while(!que.isEmpty()) {\\n            Pair rem = que.remove();\\n            if(rem.c == \\'L\\'){\\n                if(rem.i - 1 >= 0 && str[rem.i - 1] == \\'.\\') {\\n                    int nidx = rem.i - 1;\\n                    str[nidx] = \\'L\\';\\n                    que.add(new Pair(nidx, \\'L\\'));\\n                }\\n            } else {\\n                if(rem.i + 1 < n && str[rem.i + 1] == \\'.\\') {\\n                    if(rem.i + 2 < n && str[rem.i + 2] == \\'L\\') que.remove();\\n                    else {\\n                        int nidx = rem.i + 1;\\n                        str[nidx] = \\'R\\';\\n                        que.add(new Pair(nidx, \\'R\\'));\\n                    }\\n                }\\n            }\\n        }\\n        return new String(str);\\n    }\\n    \\n    class Pair {\\n        int i;\\n        char c;\\n        Pair(int i, char c) {\\n            this.i = i;\\n            this.c = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] str = dominoes.toCharArray();\\n        int n = str.length;\\n        Queue<Pair> que = new LinkedList<>();\\n        for(int i = 0; i < n ; i++) \\n            if(str[i] != \\'.\\') que.add(new Pair(i, str[i]));\\n        \\n        while(!que.isEmpty()) {\\n            Pair rem = que.remove();\\n            if(rem.c == \\'L\\'){\\n                if(rem.i - 1 >= 0 && str[rem.i - 1] == \\'.\\') {\\n                    int nidx = rem.i - 1;\\n                    str[nidx] = \\'L\\';\\n                    que.add(new Pair(nidx, \\'L\\'));\\n                }\\n            } else {\\n                if(rem.i + 1 < n && str[rem.i + 1] == \\'.\\') {\\n                    if(rem.i + 2 < n && str[rem.i + 2] == \\'L\\') que.remove();\\n                    else {\\n                        int nidx = rem.i + 1;\\n                        str[nidx] = \\'R\\';\\n                        que.add(new Pair(nidx, \\'R\\'));\\n                    }\\n                }\\n            }\\n        }\\n        return new String(str);\\n    }\\n    \\n    class Pair {\\n        int i;\\n        char c;\\n        Pair(int i, char c) {\\n            this.i = i;\\n            this.c = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788135,
                "title": "java-easy-approach-with-comments",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String d) {\\n        int n = d.length();\\n        char[] arr = new char[n+2];//+2 as we will placed a dummy domino L on left and R on right\\n        arr[0] = \\'L\\';\\n        arr[arr.length-1] = \\'R\\';\\n        \\n        for(int i = 1; i < arr.length-1 ; i++){\\n            arr[i] = d.charAt(i-1);//as we put 1 and last so we start from 1 but char is at 0 so i-1    \\n        }\\n        \\n        int i = 0 , j = 1;//using two pointers we will find the posn for the pairs of dominoes\\n        while(j < arr.length){\\n            while(arr[j] == \\'.\\') \\n                j++;//till we found a L Or R move j ahead\\n            if(j - i > 1){\\n                solve(arr, i , j);//after finding it pass the index of it and its pair means i\\n            }\\n            i = j;//i will become j as its L|R\\n            j++;//and j againg will go in search for its pair\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t//As first one was dummy just to make pairing and same for the last one so skip them in main ans\\n        for(int k = 1;k < arr.length-1; k++){\\n            sb.append(arr[k]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    \\n    private void solve(char[] arr , int i , int j){\\n        //#1 when there is L ... L then all in between will be L only \\\\\\\\\\\\\\\\\\\\\\n        if(arr[i] == \\'L\\' && arr[j] == \\'L\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'L\\';\\n            }\\n        }\\n        \\n        //#2 when there is R ... R then all in between will be R only /////\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'R\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'R\\';\\n            }\\n        }\\n        \\n        //#3 when there is L....R then both will not affect in bet as \\\\...../\\n        else if(arr[i] == \\'L\\' && arr[j] == \\'R\\'){\\n            //do nothing and chill\\n        }\\n        \\n        //#4 when there is R....L then two more cases as\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'L\\'){\\n            int diff = j - i;//the space in between those two\\n            int mid = (i + j) / 2;\\n            if(diff % 2 == 0){//if diff is even then R ... L r at 2and l at 6 then 6-2=4 so RR.LL //|\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k < mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k == mid){\\n                        //do nothing\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(diff % 2 != 0){//if diff is odd then R .... L r at 2and l at 7 then 7-2=5 so RRRLLL ///\\\\\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k <= mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String d) {\\n        int n = d.length();\\n        char[] arr = new char[n+2];//+2 as we will placed a dummy domino L on left and R on right\\n        arr[0] = \\'L\\';\\n        arr[arr.length-1] = \\'R\\';\\n        \\n        for(int i = 1; i < arr.length-1 ; i++){\\n            arr[i] = d.charAt(i-1);//as we put 1 and last so we start from 1 but char is at 0 so i-1    \\n        }\\n        \\n        int i = 0 , j = 1;//using two pointers we will find the posn for the pairs of dominoes\\n        while(j < arr.length){\\n            while(arr[j] == \\'.\\') \\n                j++;//till we found a L Or R move j ahead\\n            if(j - i > 1){\\n                solve(arr, i , j);//after finding it pass the index of it and its pair means i\\n            }\\n            i = j;//i will become j as its L|R\\n            j++;//and j againg will go in search for its pair\\n        }\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t//As first one was dummy just to make pairing and same for the last one so skip them in main ans\\n        for(int k = 1;k < arr.length-1; k++){\\n            sb.append(arr[k]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    \\n    private void solve(char[] arr , int i , int j){\\n        //#1 when there is L ... L then all in between will be L only \\\\\\\\\\\\\\\\\\\\\\n        if(arr[i] == \\'L\\' && arr[j] == \\'L\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'L\\';\\n            }\\n        }\\n        \\n        //#2 when there is R ... R then all in between will be R only /////\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'R\\'){\\n            for(int k = i + 1; k < j; k++){//from i+1 till just before j\\n                arr[k] = \\'R\\';\\n            }\\n        }\\n        \\n        //#3 when there is L....R then both will not affect in bet as \\\\...../\\n        else if(arr[i] == \\'L\\' && arr[j] == \\'R\\'){\\n            //do nothing and chill\\n        }\\n        \\n        //#4 when there is R....L then two more cases as\\n        else if(arr[i] == \\'R\\' && arr[j] == \\'L\\'){\\n            int diff = j - i;//the space in between those two\\n            int mid = (i + j) / 2;\\n            if(diff % 2 == 0){//if diff is even then R ... L r at 2and l at 6 then 6-2=4 so RR.LL //|\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k < mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k == mid){\\n                        //do nothing\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n            else if(diff % 2 != 0){//if diff is odd then R .... L r at 2and l at 7 then 7-2=5 so RRRLLL ///\\\\\\\\\\\\\\n                for(int k = i+1; k < j; k++){\\n                    if(k <= mid){\\n                        arr[k] = \\'R\\';\\n                    }else if(k > mid){\\n                        arr[k] = \\'L\\';\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787549,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] ch = dominoes.toCharArray();\\n        //pos, power, time\\n        int len = ch.length;\\n        //\\u4EE3\\u8868\\u53D7\\u529B\\u65F6\\u95F4\\n        int[] time = new int[len];\\n\\n        //\\u4EE3\\u8868\\u6700\\u65B0\\u72B6\\u6001\\n        // char[] update = new char[len];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        for(int i = 0; i < len; i ++){\\n            if(ch[i] == \\'.\\')\\n                continue;\\n            int dir = (ch[i] == \\'L\\') ? -1 : 1;\\n            queue.offer(new int[]{i, dir, 1});\\n            time[i] = 1;\\n        }\\n\\n        while(! queue.isEmpty()){\\n            //\\u6BCF\\u4E00\\u8F6E--> \\u4E00\\u4E2A\\u65F6\\u95F4\\u70B9time\\n            int[] info = queue.poll();\\n            int pos = info[0];\\n            int dir = info[1];\\n            int hour = info[2];\\n\\n            int npos = pos + dir;\\n            if((ch[pos] == \\'.\\') || npos < 0 || npos > len - 1)\\n               continue;\\n\\n            //\\u5224\\u65AD\\u662F\\u5426\\u9996\\u6B21\\u53D7\\u529B\\n            if(time[npos] == 0){\\n                time[npos] = hour + 1;\\n                ch[npos] = ((dir == -1) ? \\'L\\' : \\'R\\');\\n                queue.offer(new int[]{npos, dir, hour + 1});\\n            }else if(time[npos] == hour + 1){\\n                ch[npos] = \\'.\\';\\n            }\\n            \\n        }\\n\\n        // return new String(update);\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        char[] ch = dominoes.toCharArray();\\n        //pos, power, time\\n        int len = ch.length;\\n        //\\u4EE3\\u8868\\u53D7\\u529B\\u65F6\\u95F4\\n        int[] time = new int[len];\\n\\n        //\\u4EE3\\u8868\\u6700\\u65B0\\u72B6\\u6001\\n        // char[] update = new char[len];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n\\n        for(int i = 0; i < len; i ++){\\n            if(ch[i] == \\'.\\')\\n                continue;\\n            int dir = (ch[i] == \\'L\\') ? -1 : 1;\\n            queue.offer(new int[]{i, dir, 1});\\n            time[i] = 1;\\n        }\\n\\n        while(! queue.isEmpty()){\\n            //\\u6BCF\\u4E00\\u8F6E--> \\u4E00\\u4E2A\\u65F6\\u95F4\\u70B9time\\n            int[] info = queue.poll();\\n            int pos = info[0];\\n            int dir = info[1];\\n            int hour = info[2];\\n\\n            int npos = pos + dir;\\n            if((ch[pos] == \\'.\\') || npos < 0 || npos > len - 1)\\n               continue;\\n\\n            //\\u5224\\u65AD\\u662F\\u5426\\u9996\\u6B21\\u53D7\\u529B\\n            if(time[npos] == 0){\\n                time[npos] = hour + 1;\\n                ch[npos] = ((dir == -1) ? \\'L\\' : \\'R\\');\\n                queue.offer(new int[]{npos, dir, hour + 1});\\n            }else if(time[npos] == hour + 1){\\n                ch[npos] = \\'.\\';\\n            }\\n            \\n        }\\n\\n        // return new String(update);\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772330,
                "title": "c-bfs-dp-o-n",
                "content": "**Idea**\\nFinal state of a domino depends upon the time of `left` and `right` force applied on it.\\n* if time of left force <time of right force, then state of that domino will be `L`\\n* if time of left force >time of right force, then state of that domino will be `R`\\n* if time of left force = time of right force **(balanced state)**, then state of that domino will be `.`\\n\\nThis can be done using bfs.\\n**Time complexity**: O(n) , **Space complexity**: O(n)\\n```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        vector<bool> vis(s.size(),0); // to track the processed indices\\n        vector<int> left(s.size(),INT_MAX);  // to store time of left force on index i\\n        vector<int> right(s.size(),INT_MAX);  // to store time of right force on index i\\n        queue<int> q;  // to store the under process indices\\n        \\n        for(int i = 0; i<s.size();++i){  // initialize all the initial state of\\n            if(s[i]==\\'L\\'){               //  left and right with time 0\\n               q.push(i); vis[i] = 1; left[i] = 0;\\n            }\\n            if(s[i]==\\'R\\'){\\n               q.push(i); vis[i] = 1; right[i] = 0;\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int t = q.size();\\n            while(t--){\\n                int i = q.front(); q.pop();\\n                if(left[i]<right[i]){\\n                    s[i]=\\'L\\'; \\n                    if(i-1>=0){  // state \\'L\\' will always push its previous index to left\\n                        left[i-1]=min(left[i]+1,left[i-1]);  // store the min time of left force\\n                        if(vis[i-1]==0){\\n                            vis[i-1]=1; q.push(i-1);\\n                        }\\n                    }\\n                }\\n                else if(right[i]<left[i]){ \\n                    s[i]=\\'R\\';\\n                    if(i+1<s.size()){   // state \\'R\\' will always push its next index to right\\n                        right[i+1] = min(right[i]+1,right[i+1]);   // store the min time of right force\\n                        if(vis[i+1]==0){\\n                            vis[i+1]=1; q.push(i+1);\\n                        }\\n                    }\\n                }\\n                else s[i]=\\'.\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string s) {\\n        vector<bool> vis(s.size(),0); // to track the processed indices\\n        vector<int> left(s.size(),INT_MAX);  // to store time of left force on index i\\n        vector<int> right(s.size(),INT_MAX);  // to store time of right force on index i\\n        queue<int> q;  // to store the under process indices\\n        \\n        for(int i = 0; i<s.size();++i){  // initialize all the initial state of\\n            if(s[i]==\\'L\\'){               //  left and right with time 0\\n               q.push(i); vis[i] = 1; left[i] = 0;\\n            }\\n            if(s[i]==\\'R\\'){\\n               q.push(i); vis[i] = 1; right[i] = 0;\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            int t = q.size();\\n            while(t--){\\n                int i = q.front(); q.pop();\\n                if(left[i]<right[i]){\\n                    s[i]=\\'L\\'; \\n                    if(i-1>=0){  // state \\'L\\' will always push its previous index to left\\n                        left[i-1]=min(left[i]+1,left[i-1]);  // store the min time of left force\\n                        if(vis[i-1]==0){\\n                            vis[i-1]=1; q.push(i-1);\\n                        }\\n                    }\\n                }\\n                else if(right[i]<left[i]){ \\n                    s[i]=\\'R\\';\\n                    if(i+1<s.size()){   // state \\'R\\' will always push its next index to right\\n                        right[i+1] = min(right[i]+1,right[i+1]);   // store the min time of right force\\n                        if(vis[i+1]==0){\\n                            vis[i+1]=1; q.push(i+1);\\n                        }\\n                    }\\n                }\\n                else s[i]=\\'.\\';\\n            }\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706706,
                "title": "python-o-n-with-detailed-comments-explaining",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = [[position, 1] for position in dominoes] #form = [[falling direction, seconds needed to fall]]\\n            #R means its already falling to right \\n            #L means its already falling to left\\n            #r means its standing still but the dominoe next to it is potentially falling to right\\n            #we need r because when there is dominoes falling from left this r may be changed to L or .\\n            #it will be changed to . if the dominoe falling to L is as far from it as the domnoe falling to right\\n            #it will be changed to L if the dominoe falling to L is closer to it than the one falling to right\\n            #by closer we mean it takes less seconds\\n            #the array we are keeping stores seconds needed for each dominoe to fall to a direction\\n            #in the case of . the seconds are trash meaning we don\\'t really care about them\\n            #in the end we change all dominoes with r to R\\n            #NOTE: this code may be simplified but i am lazy to simplify it :P\\n\\t\\t\\t\\n        for right in range(0,len(dominoes) - 1):\\n            next_direction, next_seconds = arr[right + 1]\\n            curr_direction, curr_seconds = arr[right]\\n            if curr_direction in (\"R\", \"r\") and next_direction == \".\":\\n                arr[right + 1] = [\\'r\\', curr_seconds + 1]\\n        \\n        for left in range(len(dominoes) - 1, 0, -1):\\n            next_direction, next_seconds = arr[left - 1]\\n            curr_direction, curr_seconds = arr[left]\\n            if curr_direction in (\"L\", \\'l\\'):\\n                if next_direction == \\'.\\':\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 < next_seconds:\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 == next_seconds:\\n                    arr[left - 1] = [\\'.\\', 1]\\n        res = \\'\\'\\n        for i in range(0,len(arr)):\\n            direction = arr[i][0]\\n            if direction == \"r\":\\n                res += \"R\"\\n            else:\\n                res += direction\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def pushDominoes(self, dominoes: str) -> str:\\n        arr = [[position, 1] for position in dominoes] #form = [[falling direction, seconds needed to fall]]\\n            #R means its already falling to right \\n            #L means its already falling to left\\n            #r means its standing still but the dominoe next to it is potentially falling to right\\n            #we need r because when there is dominoes falling from left this r may be changed to L or .\\n            #it will be changed to . if the dominoe falling to L is as far from it as the domnoe falling to right\\n            #it will be changed to L if the dominoe falling to L is closer to it than the one falling to right\\n            #by closer we mean it takes less seconds\\n            #the array we are keeping stores seconds needed for each dominoe to fall to a direction\\n            #in the case of . the seconds are trash meaning we don\\'t really care about them\\n            #in the end we change all dominoes with r to R\\n            #NOTE: this code may be simplified but i am lazy to simplify it :P\\n\\t\\t\\t\\n        for right in range(0,len(dominoes) - 1):\\n            next_direction, next_seconds = arr[right + 1]\\n            curr_direction, curr_seconds = arr[right]\\n            if curr_direction in (\"R\", \"r\") and next_direction == \".\":\\n                arr[right + 1] = [\\'r\\', curr_seconds + 1]\\n        \\n        for left in range(len(dominoes) - 1, 0, -1):\\n            next_direction, next_seconds = arr[left - 1]\\n            curr_direction, curr_seconds = arr[left]\\n            if curr_direction in (\"L\", \\'l\\'):\\n                if next_direction == \\'.\\':\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 < next_seconds:\\n                    arr[left - 1] = [\\'L\\', curr_seconds + 1]\\n                elif next_direction == \"r\" and curr_seconds + 1 == next_seconds:\\n                    arr[left - 1] = [\\'.\\', 1]\\n        res = \\'\\'\\n        for i in range(0,len(arr)):\\n            direction = arr[i][0]\\n            if direction == \"r\":\\n                res += \"R\"\\n            else:\\n                res += direction\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656430,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        //method 2 based on distance\\n        int n=dominoes.size();\\n        vector<int> right(n,INT_MAX),left(n,INT_MAX);\\n        \\n        //fill right\\n        if(dominoes[0]==\\'R\\') right[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\') continue;\\n            else if(dominoes[i]==\\'R\\') right[i]=0;\\n            else if(right[i-1]!=INT_MAX) right[i]=right[i-1]+1;\\n            else right[i]=INT_MAX;\\n        }\\n        //fill left\\n        if(dominoes[n-1]==\\'L\\') left[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\') continue;\\n            else if(dominoes[i]==\\'L\\') left[i]=0;\\n            else if(left[i+1]!=INT_MAX) left[i]=left[i+1]+1;\\n            else left[i]=INT_MAX;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]!=right[i])\\n            {\\n                dominoes[i]=left[i]<right[i]?\\'L\\':\\'R\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        //method 2 based on distance\\n        int n=dominoes.size();\\n        vector<int> right(n,INT_MAX),left(n,INT_MAX);\\n        \\n        //fill right\\n        if(dominoes[0]==\\'R\\') right[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(dominoes[i]==\\'L\\') continue;\\n            else if(dominoes[i]==\\'R\\') right[i]=0;\\n            else if(right[i-1]!=INT_MAX) right[i]=right[i-1]+1;\\n            else right[i]=INT_MAX;\\n        }\\n        //fill left\\n        if(dominoes[n-1]==\\'L\\') left[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(dominoes[i]==\\'R\\') continue;\\n            else if(dominoes[i]==\\'L\\') left[i]=0;\\n            else if(left[i+1]!=INT_MAX) left[i]=left[i+1]+1;\\n            else left[i]=INT_MAX;\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]!=right[i])\\n            {\\n                dominoes[i]=left[i]<right[i]?\\'L\\':\\'R\\';\\n            }\\n        }\\n        return dominoes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415904,
                "title": "easy-c-faster-than-97-algorithm",
                "content": "Algorithm:\\n\\nOnly four cases:\\n\\nAny character can be between\\n1. \"L\" and \"L\"  --> All in betweens would be \"L\" too.\\n2. \"L\" and \"R\"  --> All from [L, R] would remain as it is(no effect)\\n3. \"R\" and \"L\" --> would depend either the number of dots between are even or odd, iff even then half R\\'s would come and half L\\'s would come, iff odd then half R\\'s followed by a dot and half L\\'s. (I have taken one less L than half because it would be taken care of in one of other 3 cases).\\n4. \"R\" and \"R\"  --> All in betweens would be \"R\" too.\\n\\n\\texcept for those which are in beginning or end, for those explicitly add one \"L\" at beginnig and one \"R\" at end, because they are not gonna make any difference and we won\\'t need to handle that case explicitly.\\n\\tFinally remove first char and last char which we added and return the string.\\n\\t\\n\\tCode: \\n\\t\\n\\t\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n    string pushDominoes(string dominoes) {\\n        string helper = \"L\" + dominoes + \"R\";\\n        int lo = 0, hi = 1;\\n        string ans = \"\";\\n        while(hi <= helper.length()){\\n            bool flag = true;\\n            while(helper[hi] == \\'.\\'){\\n                hi++;\\n                if(hi == helper.length()){\\n                    break;\\n                }\\n            }\\n            if(hi == helper.length()){\\n                break;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'L\\'){\\n                while(lo < hi){\\n                    ans += \\'L\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += helper[lo];\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += \\'R\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'L\\'){\\n                int count = 0;\\n                while(lo <= hi){\\n                    count++;\\n                    lo++;\\n                }\\n                flag = false;\\n                if(count % 2 == 0){\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                } else {\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    ans += \\'.\\';\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                lo--;\\n                hi++;\\n            }\\n        }\\n        \\n        return ans.substr(1, ans.length()-1); \\n        \\n    }\\n\\t};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n    string pushDominoes(string dominoes) {\\n        string helper = \"L\" + dominoes + \"R\";\\n        int lo = 0, hi = 1;\\n        string ans = \"\";\\n        while(hi <= helper.length()){\\n            bool flag = true;\\n            while(helper[hi] == \\'.\\'){\\n                hi++;\\n                if(hi == helper.length()){\\n                    break;\\n                }\\n            }\\n            if(hi == helper.length()){\\n                break;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'L\\'){\\n                while(lo < hi){\\n                    ans += \\'L\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'L\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += helper[lo];\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'R\\'){\\n                while(lo < hi){\\n                    ans += \\'R\\';\\n                    lo++;\\n                }\\n                flag = false;\\n                hi++;\\n            }\\n            if(flag && helper[lo] == \\'R\\' && helper[hi] == \\'L\\'){\\n                int count = 0;\\n                while(lo <= hi){\\n                    count++;\\n                    lo++;\\n                }\\n                flag = false;\\n                if(count % 2 == 0){\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                } else {\\n                    for(int i=0;i<count/2;i++){\\n                        ans += \\'R\\';\\n                    }\\n                    ans += \\'.\\';\\n                    for(int i=0;i<(count/2)-1;i++){\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                lo--;\\n                hi++;\\n            }\\n        }\\n        \\n        return ans.substr(1, ans.length()-1); \\n        \\n    }\\n\\t};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380406,
                "title": "solved-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string mainstr=dominoes;\\n        int n=dominoes.length();\\n        queue<int>q;\\n        for(int i=0;i<dominoes.length();i++)\\n        {  \\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\')\\n            {q.push(i);}\\n        }\\n        \\n        while(!q.empty())\\n        {\\n           \\n            int size=q.size();\\n            string str=mainstr;\\n            while(size)\\n            {\\n                size--;\\n                int ind=q.front();\\n                q.pop();\\n               if(mainstr[ind]==\\'L\\')\\n               {\\n                   int index=ind-1;\\n                   if(index>=0&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index-1<0||mainstr[index-1]!=\\'R\\'){str[index]=\\'L\\';q.push(index);}\\n                       \\n                   }\\n                       \\n               }\\n            else\\n            {\\n                 int index=ind+1;\\n                   if(index<n&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index+1>=n||mainstr[index+1]!=\\'L\\'){str[index]=\\'R\\';q.push(index);}\\n                       \\n                   }\\n            }\\n                \\n              \\n                \\n            }\\n            mainstr=str;\\n        }\\n        return mainstr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        string mainstr=dominoes;\\n        int n=dominoes.length();\\n        queue<int>q;\\n        for(int i=0;i<dominoes.length();i++)\\n        {  \\n            if(dominoes[i]==\\'R\\'||dominoes[i]==\\'L\\')\\n            {q.push(i);}\\n        }\\n        \\n        while(!q.empty())\\n        {\\n           \\n            int size=q.size();\\n            string str=mainstr;\\n            while(size)\\n            {\\n                size--;\\n                int ind=q.front();\\n                q.pop();\\n               if(mainstr[ind]==\\'L\\')\\n               {\\n                   int index=ind-1;\\n                   if(index>=0&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index-1<0||mainstr[index-1]!=\\'R\\'){str[index]=\\'L\\';q.push(index);}\\n                       \\n                   }\\n                       \\n               }\\n            else\\n            {\\n                 int index=ind+1;\\n                   if(index<n&&mainstr[index]==\\'.\\')\\n                   {\\n                      \\n                       if(index+1>=n||mainstr[index+1]!=\\'L\\'){str[index]=\\'R\\';q.push(index);}\\n                       \\n                   }\\n            }\\n                \\n              \\n                \\n            }\\n            mainstr=str;\\n        }\\n        return mainstr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356829,
                "title": "c-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int N = dominoes.size();\\n        queue<int> todo;\\n        vector<int> fallLevel(N, -1);\\n        // Get currently falling dominoes\\n        for (int i = 0; i < N; i++) {\\n            if (dominoes[i] != \\'.\\') {\\n                todo.push(i); // { index, fall level }\\n                fallLevel[i] = 0; // { fall level }\\n            }\\n        }\\n        \\n        while (!todo.empty()) {\\n            int curIndex = todo.front();\\n            todo.pop();\\n            if (dominoes[curIndex] == \\'L\\') {\\n                if (isStatic(curIndex - 1, N, dominoes)) {\\n                    todo.push( curIndex - 1 );\\n                    dominoes[curIndex - 1] = \\'L\\';\\n                    fallLevel[curIndex - 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n            else if (dominoes[curIndex] == \\'R\\') {\\n                if (isStatic(curIndex + 1, N, dominoes)) {\\n                    todo.push( curIndex + 1 );\\n                    dominoes[curIndex + 1] = \\'R\\';\\n                    fallLevel[curIndex + 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n        }\\n        \\n        // Last pass for middle dominoes\\n        for (int i = 1; i < N - 1; i++) {\\n            if (fallLevel[i - 1] == fallLevel[i + 1] && fallLevel[i] != 0 && dominoes[i - 1] != dominoes[i + 1]) {\\n                dominoes[i] = \\'.\\';\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n    \\n    bool isStatic(int index, int &N, string &dominoes) {\\n        if (index < 0 || index >= N || dominoes[index] != \\'.\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string pushDominoes(string dominoes) {\\n        int N = dominoes.size();\\n        queue<int> todo;\\n        vector<int> fallLevel(N, -1);\\n        // Get currently falling dominoes\\n        for (int i = 0; i < N; i++) {\\n            if (dominoes[i] != \\'.\\') {\\n                todo.push(i); // { index, fall level }\\n                fallLevel[i] = 0; // { fall level }\\n            }\\n        }\\n        \\n        while (!todo.empty()) {\\n            int curIndex = todo.front();\\n            todo.pop();\\n            if (dominoes[curIndex] == \\'L\\') {\\n                if (isStatic(curIndex - 1, N, dominoes)) {\\n                    todo.push( curIndex - 1 );\\n                    dominoes[curIndex - 1] = \\'L\\';\\n                    fallLevel[curIndex - 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n            else if (dominoes[curIndex] == \\'R\\') {\\n                if (isStatic(curIndex + 1, N, dominoes)) {\\n                    todo.push( curIndex + 1 );\\n                    dominoes[curIndex + 1] = \\'R\\';\\n                    fallLevel[curIndex + 1] = fallLevel[curIndex] + 1;\\n                }\\n            }\\n        }\\n        \\n        // Last pass for middle dominoes\\n        for (int i = 1; i < N - 1; i++) {\\n            if (fallLevel[i - 1] == fallLevel[i + 1] && fallLevel[i] != 0 && dominoes[i - 1] != dominoes[i + 1]) {\\n                dominoes[i] = \\'.\\';\\n            }\\n        }\\n        \\n        return dominoes;\\n    }\\n    \\n    bool isStatic(int index, int &N, string &dominoes) {\\n        if (index < 0 || index >= N || dominoes[index] != \\'.\\') {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354143,
                "title": "java-simple-and-easy-to-understand-solution-t-o-n-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String pushDominoes(String dominoes) {\\n        \\n        StringBuilder sb = new StringBuilder(dominoes);\\n        \\n        int n = sb.length();\\n        \\n        \\n        //mark true for all the unpushed block, after pushing a bloch in right direction\\n        char prev = \\'.\\';\\n        boolean[] forward = new boolean[n];\\n        for(int i = 0; i < n; i++){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'R\\') forward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        //mark true for all the unpushed block, after pushing a block in left direction\\n        prev = \\'.\\';\\n        boolean[] backward  = new boolean[n];\\n        for(int i = n - 1; i >= 0; i--){\\n            char c = dominoes.charAt(i);\\n            if(c == \\'.\\'){\\n                if(prev == \\'L\\') backward[i] = true; \\n            }else{\\n                prev = c;\\n            }\\n        }\\n        \\n        int i = 0;\\n        while(i < n){\\n            if(backward[i] && !forward[i]){\\n                //fall block as there is force in left direction\\n                sb.setCharAt(i++, \\'L\\');\\n                \\n            }else if(!backward[i] && forward[i]){\\n                //fall block as there is force in right direction\\n                sb.setCharAt(i++, \\'R\\');\\n                \\n            }else if(backward[i] && forward[i]){\\n                //fall block as there is force in both  direction\\n                int j = (i + 1);\\n                while(j < n && backward[j] && forward[j]){\\n                    j++;\\n                }\\n                pushDominoesInBetween(sb, i, j - 1);\\n                i = j;\\n            }else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    \\n    private void pushDominoesInBetween(StringBuilder sb, int l, int r){\\n        while(l < r){\\n            sb.setCharAt(l++, \\'R\\');\\n            sb.setCharAt(r--, \\'L\\');\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1790122,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            },
            {
                "id": 1572223,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            },
            {
                "id": 2077061,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            },
            {
                "id": 2053538,
                "content": [
                    {
                        "username": "veecos",
                        "content": "Think of the \".\" dominoes in terms of how far away they are from the influential dominoes. Think of distance as influence and only the nearest influential domino can exert control. Add all influences for both directions."
                    },
                    {
                        "username": "suhit",
                        "content": "Why is it that for this as input ,\\n\\ninput : \".L.R...LR..L..\"\\n\\nthis is not the correct output? \\noutput : \"LL.RRR.LRR.L..\"\\n\\nand this is the correct output? \\nexpected : \"LL.RR.LLRRLL..\"\\n\\nCan someone please explain? \\nWouldn\\'t there be a cascading effect?"
                    },
                    {
                        "username": "q121212",
                        "content": "just draw and separate to blocks. Each block is independent because either nothing falls on each other inside it, or only what falls inside it: \n( | \\ )  ( | / | | | \\ )   ( / | | \\ )   ( | | )\nthe same in result: (LL) (.RR.LL) (RRLL) (..)"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "yes, there is cascading effect but you are missing one point, that is at every second both left and right dominoes collapsing. So at index 3 right collapses to right and at index 7 left also collapses to left at the same time, again for indices 4 and 6  4 collapses to 5 and  6 collapses to 5 also since both are collapsing to 5 and question stated that they both have equal forces, therefore 5 remains stbale..........\\nHope I was able to clear your doubt\\uD83D\\uDE00"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Anyone was asked this as an interview question?"
                    },
                    {
                        "username": "pcRipper",
                        "content": "The worst thing on leetcode - lack of standard test cases"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Vowels Permutation",
        "question_content": "<p>Given an integer <code>n</code>, your task is to count how many strings of length <code>n</code> can be formed under the following rules:</p>\n\n<ul>\n\t<li>Each character is a lower case vowel&nbsp;(<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>)</li>\n\t<li>Each vowel&nbsp;<code>&#39;a&#39;</code> may only be followed by an <code>&#39;e&#39;</code>.</li>\n\t<li>Each vowel&nbsp;<code>&#39;e&#39;</code> may only be followed by an <code>&#39;a&#39;</code>&nbsp;or an <code>&#39;i&#39;</code>.</li>\n\t<li>Each vowel&nbsp;<code>&#39;i&#39;</code> <strong>may not</strong> be followed by another <code>&#39;i&#39;</code>.</li>\n\t<li>Each vowel&nbsp;<code>&#39;o&#39;</code> may only be followed by an <code>&#39;i&#39;</code> or a&nbsp;<code>&#39;u&#39;</code>.</li>\n\t<li>Each vowel&nbsp;<code>&#39;u&#39;</code> may only be followed by an <code>&#39;a&#39;.</code></li>\n</ul>\n\n<p>Since the answer&nbsp;may be too large,&nbsp;return it modulo <code>10^9 + 7.</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> All possible strings are: &quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; and &quot;u&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> All possible strings are: &quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and &quot;ua&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:&nbsp;</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5\n<strong>Output:</strong> 68</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 398222,
                "title": "detailed-explanation-using-graphs-with-pictures-o-n",
                "content": "# Intuition\\nLet us visualize this as a graph problem. From the above rules, we can create a directed graph where an edge between characters `first` and `second` imply that it is permissible to write `second` immediately after first. Hence, the question converts to, **Given a directed graph, how many paths of length `n` are there?** \\n\\n![image](https://assets.leetcode.com/users/just__a__visitor/image_1570334589.png)\\n\\nNow, Let us say that `dp[n][char]` denotes the number of directed paths of length `n` which end at a particular vertex `char`. Then, we know that the last vertex in our path was `char`. However, let\\'s focus on the last second vertex. It could have been any of the vertex which has a direct edge to `char`. Hence, if we can find the number of paths of length `n-1` ending at these vertices, then we can append `char` at the end of every path and we would have exhausted all possibilites.\\n\\nHence, `dp[n+1][x] = sum of all dp[n][y]` such that there is a directed edge from `y` to `x`. \\n\\n```cpp\\nclass Solution\\n{\\npublic:\\n    int countVowelPermutation(int n);\\n};\\n\\nint Solution :: countVowelPermutation(int n)\\n{\\n    vector<vector<long>> dp(n+1, vector<long>(5, 0));\\n    \\n    int MOD = 1e9 + 7;\\n    \\n    /* dp[i][j] denotes the number of valid strings of length i */\\n    \\n    for(int i = 0; i < 5; i++)\\n        dp[1][i] = 1;\\n    \\n    for(int i = 1; i < n; i++)\\n    {\\n        dp[i+1][0] = (dp[i][1] + dp[i][2] + dp[i][4]) %MOD;\\n        \\n        dp[i+1][1] = (dp[i][0] + dp[i][2]) % MOD;\\n        \\n        dp[i+1][2] = (dp[i][1] + dp[i][3]) % MOD;\\n        \\n        dp[i+1][3] = dp[i][2];\\n        \\n        dp[i+1][4] = (dp[i][2] + dp[i][3]) % MOD;\\n    }\\n    \\n    int res = 0;\\n    for(int i = 0; i < 5; i++)\\n        res = (res + dp[n][i]) % MOD;\\n    \\n    return res;\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution\\n{\\npublic:\\n    int countVowelPermutation(int n);\\n};\\n\\nint Solution :: countVowelPermutation(int n)\\n{\\n    vector<vector<long>> dp(n+1, vector<long>(5, 0));\\n    \\n    int MOD = 1e9 + 7;\\n    \\n    /* dp[i][j] denotes the number of valid strings of length i */\\n    \\n    for(int i = 0; i < 5; i++)\\n        dp[1][i] = 1;\\n    \\n    for(int i = 1; i < n; i++)\\n    {\\n        dp[i+1][0] = (dp[i][1] + dp[i][2] + dp[i][4]) %MOD;\\n        \\n        dp[i+1][1] = (dp[i][0] + dp[i][2]) % MOD;\\n        \\n        dp[i+1][2] = (dp[i][1] + dp[i][3]) % MOD;\\n        \\n        dp[i+1][3] = dp[i][2];\\n        \\n        dp[i+1][4] = (dp[i][2] + dp[i][3]) % MOD;\\n    }\\n    \\n    int res = 0;\\n    for(int i = 0; i < 5; i++)\\n        res = (res + dp[n][i]) % MOD;\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398286,
                "title": "simple-python-with-diagram",
                "content": "Each vowel allows some number of subsequent characters. These transitions are like a tree. This problem is asking, \"what\\'s the width of the tree with height *n*?\"\\n\\n![image](https://assets.leetcode.com/users/elliotp/image_1570334689.png)\\n\\nMy solution keeps track of the number of each vowel at a level in this tree. To calculate say \\'A\\', we calculate how many nodes in the previous level produce \\'A\\'. This is the number of \\'E\\', \\'I\\', and \\'U\\' nodes.\\n\\n```\\ndef count_vowel_permutations(n):\\n    a, e, i, o, u = 1, 1, 1, 1, 1\\n    for _ in range(n - 1):\\n        a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n    return (a + e + i + o + u) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\ndef count_vowel_permutations(n):\\n    a, e, i, o, u = 1, 1, 1, 1, 1\\n    for _ in range(n - 1):\\n        a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n    return (a + e + i + o + u) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2390275,
                "title": "c-clean-code-well-explained",
                "content": "Each vowel allows some number of subsequent characters. These transitions are like a tree. This problem is asking, \"what\\'s the width of the tree with height n?\"\\n\\n\\n![image](https://assets.leetcode.com/users/images/6423763e-0cb1-4ecd-af60-a979c08d01b7_1659839040.3599339.png)\\n\\nMy solution keeps track of the number of each vowel at a level in this tree. To calculate say \\'A\\', we calculate how many nodes in the previous level produce \\'A\\'. This is the number of \\'E\\', \\'I\\', and \\'U\\' nodes.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n         long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```\\n\\n**IF YOU LIKE MY SOLUTION THEN JUST PLEASE PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n         long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315039,
                "title": "optimization-from-brute-force-to-dp-to-o-1-time-solutions-explained",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe need to form a string of length `n` with vowels. We are also given some **initial rules or mappings** which tells us what character will come after the current character. We need to return the total number of different strings we can form.\\n\\nLet\\'s try to solve this problem starting with the brute-force appraoch. We can **start with any of the 5 vowels** and thereafter we have the choice to **choose next vowel depending on what\\'s allowed after the previous vowel** in the given mappings. The given mappings state what vowels are allowed after a given vowel -\\n\\n```\\nstart   =>  a / e / i / o / u   # start denotes 1st character of string which can be any vowel\\na       =>  e\\ne       =>  a / i\\ni       =>  a / e / o / u\\no       =>  i / u\\nu       =>  a\\n```\\n\\nSo, we will follow this approach. At each index, we will try choosing all vowels allowed after the previous one. The start will be denoted by `s` (any vowel is allowed after it).\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\npublic:\\n    int countVowelPermutation(int n) {\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        int ans = 0;\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            ans = (ans + solve(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>Alternate Concise Implementation</b></summary>\\n\\n---\\n\\nThis is just a bit more concise version of above code. The mappings are converted to from chars to integer as `a:0, e:1, i:2, o:3, u:4, s:5`.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5, int ans = 0) {\\n        if(!rem) return 1;\\n        for(auto c : mappings[prev])\\n            ans = (ans + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(5<sup>N</sup>)</code>\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n</details>\\n</blockquote>\\n\\n\\n***Time Complexity :*** **<code>O(5<sup>N</sup>)</code>**, at each index we have maximum of 5 choices with us. There are total of `n` indices. Thus `5*5*5...N times` = <code>O(5<sup>N</sup>)</code>.\\n***Space Complexity :*** **`O(N)`**, required for recursive stack. Max recursive depth at any point will be `N`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Top-Down Recursive)***\\n\\nWe can observe does a lot of repeated calculations. The total number of possible strings when we know the previous character `prev` and remaining length `rem` will always be constant. So there\\'s no need to repeat the same calculation. We can store the calculated result  for a given state and reuse it in the future. Thus, we can optimize the solution using **dynamic programming**.\\n\\nWe will maintain a dp array of length `n+1` for each vowel. Here, *`dp[prev_vowel][rem]`* will denote the number of strings that can be formed when previous character was `prev_vowel` and number of characters still required is equal to `rem`. Each time, we will try all vowels possible at current index and explore the further path. We will store the calculated result in `dp[prev][rem]` and reuse it whenever required in future recursive calls.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\n    unordered_map<char, vector<int>> dp;\\npublic:\\n    int countVowelPermutation(int n) {\\n        dp[\\'s\\'] = dp[\\'a\\'] = dp[\\'e\\'] = dp[\\'i\\'] = dp[\\'o\\'] = dp[\\'u\\'] = vector<int>(n+1);\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        if(dp[prev][rem]) return dp[prev][rem];       // if result already calculated for current state, directly return it\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            dp[prev][rem] = (dp[prev][rem] + solve(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u2714\\uFE0F Alternate Concise Implementation (Faster Runtime)</b></summary>\\n\\n---\\n\\nI used the previous solution for better readability. But this solution should give a lot better runtime than the previous implementation since we are avoiding the use of hashmap and thus reducing the constant factor signifincantly.\\n\\nThe mappings are converted to from chars to integer as `a:0, e:1, i:2, o:3, u:4, s:5`.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    int dp[6][20001]{};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5) {\\n        if(!rem) return 1;                        \\n        if(dp[prev][rem]) return dp[prev][rem];       \\n        for(auto c : mappings[prev])\\n            dp[prev][rem] = (dp[prev][rem] + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O(N)`\\n***Space Complexity :*** `O(N)`\\n\\n---\\n---\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** **`O(N)`**, we will be calculating the total possible strings for a given vowels when `rem` characters are requried, only once. Thus, each vowel will make a max of `N` recursive calls. Hence the total time complexity becomes `O(5*N) = O(N)`\\n***Space Complexity :*** **`O(N)`**, `O(N)` space is required by recursive stack. Further, a total of `O(5*N)` space is used by `dp`. Thus the total space complexity becomes `O(N) + O(5*N) = O(N)`\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Bottom-Up Iterative)***\\n\\nWe can also solve this using iterative DP. Here we will start with the state for `n = 1` where we can form 1 string using each vowel at start. We will use the previous states to calculate the result for next. Here *`dp[k][i]`* will denote the number of possible strings of length `i` that end at vowel numbered - `k`. Here, I have just converted from vowel character mappings to integer mappings like -\\n```\\n0 (a)       =>  1\\n1 (e)       =>  0 / 2\\n2 (i)       =>  0 / 1 / 3 / 4\\n3 (o)       =>  2 / 4\\n4 (u)       =>  0\\n```\\n\\nEach time, we use the stored number of strings possible for length `i-1` to calculate for length `i`. We will use only those state for `dp[k]` from which it is allowed to use `k`th vowel at next position.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long dp[5][n+1], ans = 0;\\n        dp[0][1] = dp[1][1] = dp[2][1] = dp[3][1] = dp[4][1] = 1;\\n        for(int i = 2; i <= n; i++) {\\n            dp[0][i] =  dp[1][i-1];\\n            dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % MOD;\\n            dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % MOD;\\n            dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % MOD;\\n            dp[4][i] =  dp[0][i-1];\\n        }\\n        for(int i=0; i < 5; i++) \\n            ans = (ans + dp[i][n]) % MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space-Optimized DP)***\\n\\nWe can observe that at any point of time we are only using the previous state of each `dp[i]`. So, we can don\\'t need to store all the states and further optimize the solution by storing only the state for previous length for each vowel.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Pre-compute DP)***\\n\\nJust precompute the answers for all `N` at the start and use the globally stored result for all test cases instead of repeating the calculation for each test case. Also since in this case the algorithm performs the same operations for any test cases, by definition, it is a constant time and space solution since it doesn\\'t depend on input :).\\n\\n```\\nint vowelPerms[20001];\\nauto _ = []{\\n    const int MOD = 1e9 + 7;\\n\\tlong a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n\\tvowelPerms[1] = 5;\\n\\tfor (int j = 2; j <= 20000; j++) {\\n\\t\\ta_new =  e;\\n\\t\\te_new = (a + i) % MOD;\\n\\t\\ti_new = (a + e + o + u) % MOD;\\n\\t\\to_new = (i + u) % MOD;\\n\\t\\tu_new =  a;\\n\\t\\ta = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n\\t\\tvowelPerms[j] = (a + e + i + o + u) % MOD;\\n\\t}\\n\\treturn true;\\n}();  // IIFE\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        return vowelPerms[n];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(1)`**, time required by `countVowelPermutation()` doesn\\'t depend on input `n`. The pre-computation time complexity in this case is `O(MAX_N) = O(20000) = O(1)`. This solution would be more efficient than `Solution-IV` when there are multiple queries / test-cases that we need to solve for.\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstart   =>  a / e / i / o / u   # start denotes 1st character of string which can be any vowel\\na       =>  e\\ne       =>  a / i\\ni       =>  a / e / o / u\\no       =>  i / u\\nu       =>  a\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\npublic:\\n    int countVowelPermutation(int n) {\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        int ans = 0;\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            ans = (ans + solve(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5, int ans = 0) {\\n        if(!rem) return 1;\\n        for(auto c : mappings[prev])\\n            ans = (ans + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\n    unordered_map<char, vector<int>> dp;\\npublic:\\n    int countVowelPermutation(int n) {\\n        dp[\\'s\\'] = dp[\\'a\\'] = dp[\\'e\\'] = dp[\\'i\\'] = dp[\\'o\\'] = dp[\\'u\\'] = vector<int>(n+1);\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        if(dp[prev][rem]) return dp[prev][rem];       // if result already calculated for current state, directly return it\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            dp[prev][rem] = (dp[prev][rem] + solve(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    int dp[6][20001]{};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5) {\\n        if(!rem) return 1;                        \\n        if(dp[prev][rem]) return dp[prev][rem];       \\n        for(auto c : mappings[prev])\\n            dp[prev][rem] = (dp[prev][rem] + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\n```\\n0 (a)       =>  1\\n1 (e)       =>  0 / 2\\n2 (i)       =>  0 / 1 / 3 / 4\\n3 (o)       =>  2 / 4\\n4 (u)       =>  0\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long dp[5][n+1], ans = 0;\\n        dp[0][1] = dp[1][1] = dp[2][1] = dp[3][1] = dp[4][1] = 1;\\n        for(int i = 2; i <= n; i++) {\\n            dp[0][i] =  dp[1][i-1];\\n            dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % MOD;\\n            dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % MOD;\\n            dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % MOD;\\n            dp[4][i] =  dp[0][i-1];\\n        }\\n        for(int i=0; i < 5; i++) \\n            ans = (ans + dp[i][n]) % MOD;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\n```\\nint vowelPerms[20001];\\nauto _ = []{\\n    const int MOD = 1e9 + 7;\\n\\tlong a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n\\tvowelPerms[1] = 5;\\n\\tfor (int j = 2; j <= 20000; j++) {\\n\\t\\ta_new =  e;\\n\\t\\te_new = (a + i) % MOD;\\n\\t\\ti_new = (a + e + o + u) % MOD;\\n\\t\\to_new = (i + u) % MOD;\\n\\t\\tu_new =  a;\\n\\t\\ta = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n\\t\\tvowelPerms[j] = (a + e + i + o + u) % MOD;\\n\\t}\\n\\treturn true;\\n}();  // IIFE\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        return vowelPerms[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398173,
                "title": "c-bottom-up-recursive-dps-o-n-and-matrix-exponentiation-o-logn",
                "content": "**Observation**\\nThe question gives us a map of the vowels that can come after each vowel, we use this mapping to get the number of strings that\\ncan be formed by those \\'ending\\' vowels.\\n* `a` can only be added after `i`, `e` and `u`. Thus strings ending with `a` in the next step will be sum of strings ending with `i`, `u` and `e` in the current step.\\n* `e` can only be added after `a` and `i`. Thus strings ending with `e` in the next step will be sum of strings ending with `i` and `a` in the current step.\\n* `i` can only be added after `o` and `e`. Thus strings ending with `i` in the next step will be sum of strings ending with `o` and  `e` in the current step.\\n* `o` can only be added after `i`. Thus strings ending with `o` in the next step will be equal to strings ending with `i` in the current step.\\n* `u` can only be added after `i` and `o`. Thus strings ending with `u` in the next step will be equal to strings ending with `i` and `o` in the current step.\\n\\nWe do this for all the other vowels and repeat this N-1 times to get our answer.\\n\\n**Solution**\\n*Bottom-up:*\\nWith inversed relationships as explained above (Totally depends on how you imagine the subproblems/DP).\\n```\\nstatic vector<vector<int>> relation={{1,2,4},{0,2},{1,3},{2},{2,3}};  //Relationships(can be followed after) of each vowel with others\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) \\n    {\\n        int MOD=1e9+7;\\n        vector<long long> vowels(5,1),vowels_copy;      //When N=1 all vowels are used once to for 1 letter strings\\n        long long result=0;\\n        while(--n)\\n        {\\n            vowels_copy=vowels;\\n            for(int i=0;i<5;i++)                         //Characters \\'a\\' \\'e\\' \\'i\\' \\'o\\' \\'u\\'.\\n            {\\n                vowels[i]=0;\\n                for(int &r:relation[i])\\n                    vowels[i]+=vowels_copy[r],vowels[i]%=MOD;  //Add the strings that end with characters that can have \\'i\\' after them.\\n            }\\n        }\\n        for(long long &i:vowels)\\n            result+=i,result%=MOD;\\n        return result;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(1)`\\nTime: `O(n)`\\n\\n*Top-Down (Recursive):*\\n```\\nstatic vector<vector<int>> relation={{1},{0,2},{0,1,3,4},{2,4},{0}};  //Relationships(followed by) of each vowel with others\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    vector<vector<int>> memo;\\n    int dp(int n,int v)                         //\\'v\\' represents the vowel\\n    {\\n        if(n==1)\\n            return 1;\\n        if(memo[n][v]!=-1)\\n            return memo[n][v];\\n        memo[n][v]=0;\\n        for(int &i:relation[v])\\n            memo[n][v]+=dp(n-1,i),memo[n][v]%=MOD;\\n        return memo[n][v];\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        int result=0;\\n        memo.resize(n+1,vector<int>(5,-1));\\n        for(int i=0;i<5;i++)\\n            result+=dp(n,i),result%=MOD;\\n        return result;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(n)`\\nTime: `O(n)`\\n\\n*Matrix Exponentiation:*\\nThis problem basically boils down to number of paths of length N in a directed graph.\\n```\\n//Matrix exponentiation.\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    vector<vector<int>> Multiply(vector<vector<int>> &l,vector<vector<int>> &r) //Multiply two matrices applying MOD.\\n    {\\n        vector<vector<int>> result(l.size(),vector<int>(r[0].size(),0));\\n        for(int i=0;i<l.size();i++)\\n            for(int j=0;j<r[0].size();j++)\\n                for(int k=0;k<l[0].size();k++)\\n                    result[i][j]+=(long long)l[i][k]*r[k][j]%MOD,result[i][j]%=MOD;\\n        return result;\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        vector<vector<int>> M={ {0,1,0,0,0},      //Adjacency matrix of graph of the problem.\\n                                {1,0,1,0,0},\\n                                {1,1,0,1,1},\\n                                {0,0,1,0,1},\\n                                {1,0,0,0,0}},result(5,vector<int>(5));\\n        for(int i=0;i<5;i++)   //Create identity Matrix.\\n            result[i][i]=1;\\n        int sum=0;\\n        n--;\\n        while(n)    //log(n) Multiplication.\\n        {\\n            if(n&1)\\n                result=Multiply(M,result);\\n            n>>=1;\\n            M=Multiply(M,M);\\n        }\\n        for(vector<int> &i:result)          //Result holds M^(N-1).\\n            for(int &j:i)\\n                sum+=j,sum%=MOD;\\n        return sum;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(1).`\\nTime: `O(logn).` Exponentiation.",
                "solutionTags": [],
                "code": "```\\nstatic vector<vector<int>> relation={{1,2,4},{0,2},{1,3},{2},{2,3}};  //Relationships(can be followed after) of each vowel with others\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) \\n    {\\n        int MOD=1e9+7;\\n        vector<long long> vowels(5,1),vowels_copy;      //When N=1 all vowels are used once to for 1 letter strings\\n        long long result=0;\\n        while(--n)\\n        {\\n            vowels_copy=vowels;\\n            for(int i=0;i<5;i++)                         //Characters \\'a\\' \\'e\\' \\'i\\' \\'o\\' \\'u\\'.\\n            {\\n                vowels[i]=0;\\n                for(int &r:relation[i])\\n                    vowels[i]+=vowels_copy[r],vowels[i]%=MOD;  //Add the strings that end with characters that can have \\'i\\' after them.\\n            }\\n        }\\n        for(long long &i:vowels)\\n            result+=i,result%=MOD;\\n        return result;\\n    }\\n};\\n```\n```\\nstatic vector<vector<int>> relation={{1},{0,2},{0,1,3,4},{2,4},{0}};  //Relationships(followed by) of each vowel with others\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    vector<vector<int>> memo;\\n    int dp(int n,int v)                         //\\'v\\' represents the vowel\\n    {\\n        if(n==1)\\n            return 1;\\n        if(memo[n][v]!=-1)\\n            return memo[n][v];\\n        memo[n][v]=0;\\n        for(int &i:relation[v])\\n            memo[n][v]+=dp(n-1,i),memo[n][v]%=MOD;\\n        return memo[n][v];\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        int result=0;\\n        memo.resize(n+1,vector<int>(5,-1));\\n        for(int i=0;i<5;i++)\\n            result+=dp(n,i),result%=MOD;\\n        return result;\\n    }\\n};\\n```\n```\\n//Matrix exponentiation.\\nclass Solution {\\npublic:\\n    int MOD=1e9+7;\\n    vector<vector<int>> Multiply(vector<vector<int>> &l,vector<vector<int>> &r) //Multiply two matrices applying MOD.\\n    {\\n        vector<vector<int>> result(l.size(),vector<int>(r[0].size(),0));\\n        for(int i=0;i<l.size();i++)\\n            for(int j=0;j<r[0].size();j++)\\n                for(int k=0;k<l[0].size();k++)\\n                    result[i][j]+=(long long)l[i][k]*r[k][j]%MOD,result[i][j]%=MOD;\\n        return result;\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        vector<vector<int>> M={ {0,1,0,0,0},      //Adjacency matrix of graph of the problem.\\n                                {1,0,1,0,0},\\n                                {1,1,0,1,1},\\n                                {0,0,1,0,1},\\n                                {1,0,0,0,0}},result(5,vector<int>(5));\\n        for(int i=0;i<5;i++)   //Create identity Matrix.\\n            result[i][i]=1;\\n        int sum=0;\\n        n--;\\n        while(n)    //log(n) Multiplication.\\n        {\\n            if(n&1)\\n                result=Multiply(M,result);\\n            n>>=1;\\n            M=Multiply(M,M);\\n        }\\n        for(vector<int> &i:result)          //Result holds M^(N-1).\\n            for(int &j:i)\\n                sum+=j,sum%=MOD;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315113,
                "title": "c-java-python-top-down-dp-bottom-up-dp-picture-explain-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Top down DP or DFS with Memoization**\\n- Let dfs to try all possible result result. When we reach a valid possible way, return 1. Use memoization to cache the sub-problem result, so it doesn\\'t need compute again.\\n\\n<iframe src=\"https://leetcode.com/playground/M7T4Y2FE/shared\" frameBorder=\"0\" width=\"100%\" height=\"410\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n- Convert the **Next relationship** into **Previous Relationship**, then do Bottom Up DP.\\n- Let `dp[i][j]` is number of valid permutation strings length `i` that ends at vowel `j`, where `1 <= i <= n`, `0 <= j <= 4`.\\n- When `i = 1`, there is 1 string using each vowel at start, so `dp[i][j] = 1`, for all j `0 <= j <= 4`.\\n- Iterate `i` from `2` to `n`, follow the rules to count the number of strings that end in each vowel.\\n- The answer is sum of `dp[n][j]`, for all j `0 <= j <= 4`.\\n- Since there is up to 2 dp states (previous state, current state), so we can just use `dp[5]` and `prevDP[5]` which can optimize space to `(1)`.\\n\\n![image](https://assets.leetcode.com/users/images/ff5632ef-3c7b-4d13-810a-5e113913ef90_1625392545.5214822.png)\\n\\n<iframe src=\"https://leetcode.com/playground/aT3aLG3n/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`\\n\\n\\nIf you think this post is useful, I\\'m happy if you **give a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Top down DP or DFS with Memoization**\\n- Let dfs to try all possible result result. When we reach a valid possible way, return 1. Use memoization to cache the sub-problem result, so it doesn\\'t need compute again.\\n\\n<iframe src=\"https://leetcode.com/playground/M7T4Y2FE/shared\" frameBorder=\"0\" width=\"100%\" height=\"410\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bottom up DP**\\n- Convert the **Next relationship** into **Previous Relationship**, then do Bottom Up DP.\\n- Let `dp[i][j]` is number of valid permutation strings length `i` that ends at vowel `j`, where `1 <= i <= n`, `0 <= j <= 4`.\\n- When `i = 1`, there is 1 string using each vowel at start, so `dp[i][j] = 1`, for all j `0 <= j <= 4`.\\n- Iterate `i` from `2` to `n`, follow the rules to count the number of strings that end in each vowel.\\n- The answer is sum of `dp[n][j]`, for all j `0 <= j <= 4`.\\n- Since there is up to 2 dp states (previous state, current state), so we can just use `dp[5]` and `prevDP[5]` which can optimize space to `(1)`.\\n\\n![image](https://assets.leetcode.com/users/images/ff5632ef-3c7b-4d13-810a-5e113913ef90_1625392545.5214822.png)\\n\\n<iframe src=\"https://leetcode.com/playground/aT3aLG3n/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`\\n\\n\\nIf you think this post is useful, I\\'m happy if you **give a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 1315077,
                "title": "python-2-solution-dp-and-matrix-power-explained",
                "content": "Let us reformulate problem statement: we can have the following cases:\\n1. If last letter is `a`, then previous letters can be `e, i, u`\\n2. If last letter is `e`, then previous letters can be `a, i`\\n3. If last letter is `i`, then previous letters can be `e, o`\\n4. If last letter is `o`, then previous letter can be only `i`\\n5. If last letter is `u`, then previous letters can be `i, o`.\\n\\nSo, we just keep 5 states for letters `a, e, i, o, u` and update it `n-1` times.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def countVowelPermutation(self, n):\\n        a, e, i, o, u, M = 1, 1, 1, 1, 1, 10**9 + 7\\n        for _ in range(n-1):\\n            a, e, i, o, u = (e + i + u)%M, (a + i)%M, (e + o)%M, i%M, (i + o)%M\\n        \\n        return (a + e + i + o + u)%M \\n```\\n\\n#### Solution 2\\nActually what we have in this problem is linear recurrent and it can be solved using power of matrices. Let `mat` be matrix of possible transitions, then what we need to do is just multiply starting vector `[1, 1, 1, 1, 1]` by this matrix `n-1` times, or which is equivalent for this problem is sum of elements of matrix `mat^{n-1}`.\\n\\n#### Complexity\\nTime complexity is `O(m^3*log n) = O(125 * log n)`, where `m` is order of our reccurence. It is `O(log n)` but with quite big constant so I prefer to make this more careful analysis. Space complexity is `O(m^2) = O(25)`.\\n\\n#### Code\\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n): \\n        def power(mat, n, M):\\n            result = np.eye(len(mat), dtype = int)\\n            while n > 0:\\n                if n%2: result = np.dot(mat, result) % M\\n                mat = np.dot(mat, mat) % M\\n                n //= 2\\n            return result\\n        \\n        M = 10**9 + 7\\n        mat = np.matrix([[0,1,0,0,0], [1,0,1,0,0], [1,1,0,1,1], [0,0,1,0,1], [1,0,0,0,0]])      \\n        return np.sum(power(mat, n-1, M)) % M\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def countVowelPermutation(self, n):\\n        a, e, i, o, u, M = 1, 1, 1, 1, 1, 10**9 + 7\\n        for _ in range(n-1):\\n            a, e, i, o, u = (e + i + u)%M, (a + i)%M, (e + o)%M, i%M, (i + o)%M\\n        \\n        return (a + e + i + o + u)%M \\n```\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n): \\n        def power(mat, n, M):\\n            result = np.eye(len(mat), dtype = int)\\n            while n > 0:\\n                if n%2: result = np.dot(mat, result) % M\\n                mat = np.dot(mat, mat) % M\\n                n //= 2\\n            return result\\n        \\n        M = 10**9 + 7\\n        mat = np.matrix([[0,1,0,0,0], [1,0,1,0,0], [1,1,0,1,1], [0,0,1,0,1], [1,0,0,0,0]])      \\n        return np.sum(power(mat, n-1, M)) % M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398406,
                "title": "super-easy-to-understand-java-code",
                "content": "```\\n    public int countVowelPermutation(int n) {\\n        int MOD = 1000_000_007;\\n                \\n        long[][] dp = new long[n + 1][5]; // dp[i][j] := a string of length \\'i\\' ends with a vowel represented by index \\'j\\'\\n        \\n        // vowel & index mapping\\n        // a: 0\\n        // e: 1\\n        // i: 2\\n        // o: 3\\n        // u: 4\\n        \\n\\t\\t// Initialize dp\\n\\t\\t// \\'a\\': dp[1][0] = 1\\n\\t\\t// \\'e\\': dp[1][1] = 1\\n\\t\\t// \\'i\\': dp[1][2] = 1\\n\\t\\t// \\'o\\': dp[1][3] = 1\\n\\t\\t// \\'u\\': dp[1][4] = 1\\n        for(int i = 0; i < 5; i ++){\\n            dp[1][i] = 1; \\n        }\\n        \\n        // Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n        // Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n        // Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n        // Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n        // Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n        // === In other words: \\n        // \\'a\\' can be followed by {\\'e\\'}\\n        // \\'e\\' can be followed by {\\'a\\', \\'i\\'}\\n        // \\'i\\' can be followed by {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}\\n        // \\'o\\' can be followed by {\\'i\\', \\'u\\'}\\n        // \\'u\\' can be followed by {\\'a\\'}\\n        // === In other words:\\n        // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n        // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n        // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n        // \\'o\\' can follow {\\'i\\'}\\n        // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n        \\n        \\n\\t\\t// State transition\\n        for(int i = 2; i <= n; i ++){\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % MOD; // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD; // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % MOD; // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n            dp[i][3] = (dp[i - 1][2]) % MOD; // \\'o\\' can follow {\\'i\\'}\\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % MOD; // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n        }\\n        \\n        long count = 0;\\n        \\n        for(long d : dp[n]){\\n            count += d;\\n            count %= MOD;\\n        }\\n \\n        return (int) count;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int countVowelPermutation(int n) {\\n        int MOD = 1000_000_007;\\n                \\n        long[][] dp = new long[n + 1][5]; // dp[i][j] := a string of length \\'i\\' ends with a vowel represented by index \\'j\\'\\n        \\n        // vowel & index mapping\\n        // a: 0\\n        // e: 1\\n        // i: 2\\n        // o: 3\\n        // u: 4\\n        \\n\\t\\t// Initialize dp\\n\\t\\t// \\'a\\': dp[1][0] = 1\\n\\t\\t// \\'e\\': dp[1][1] = 1\\n\\t\\t// \\'i\\': dp[1][2] = 1\\n\\t\\t// \\'o\\': dp[1][3] = 1\\n\\t\\t// \\'u\\': dp[1][4] = 1\\n        for(int i = 0; i < 5; i ++){\\n            dp[1][i] = 1; \\n        }\\n        \\n        // Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n        // Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n        // Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n        // Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n        // Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n        // === In other words: \\n        // \\'a\\' can be followed by {\\'e\\'}\\n        // \\'e\\' can be followed by {\\'a\\', \\'i\\'}\\n        // \\'i\\' can be followed by {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}\\n        // \\'o\\' can be followed by {\\'i\\', \\'u\\'}\\n        // \\'u\\' can be followed by {\\'a\\'}\\n        // === In other words:\\n        // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n        // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n        // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n        // \\'o\\' can follow {\\'i\\'}\\n        // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n        \\n        \\n\\t\\t// State transition\\n        for(int i = 2; i <= n; i ++){\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % MOD; // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD; // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % MOD; // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n            dp[i][3] = (dp[i - 1][2]) % MOD; // \\'o\\' can follow {\\'i\\'}\\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % MOD; // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n        }\\n        \\n        long count = 0;\\n        \\n        for(long d : dp[n]){\\n            count += d;\\n            count %= MOD;\\n        }\\n \\n        return (int) count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398213,
                "title": "c-java-o-n-knight-dialer",
                "content": "# Intuition\\nIt sounds very similar to [935. Knight Dialer](https://leetcode.com/problems/knight-dialer/). Check out [my explanations](https://leetcode.com/problems/knight-dialer/discuss/189251/C%2B%2B-5-lines-DP) to that problem.\\n\\nThe idea here is to accumulate combinations that ends with a particular letter. We use an array to store counts for each letter. \\n\\nNow, for a string of size ```n + 1```, the combination that ends with \\'a\\', for example, will be the sum of combinations for letters \\'e\\', \\'i\\' and \\'u\\' for string of size ```n```.\\n\\n> Since we only need to know counts for size ```n``` to calculate counts for ```n + 1```, we can minimize our memory complexity by using two arrays. \\n### C++\\n> Note that I am using a two-dimensional vector ```v[2][5]``` to store counts. First dimension separates count for ```n``` and ```n + 1```. I am using modulo operation (```(n + 1) % 2``` and ```(n % 2)```) to virtually \"swap\" source and destination for every iteration.\\n```\\nint countVowelPermutation(int n) {\\n  // \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'\\n  vector<vector<int>> moves = { {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, { 0 } }, v(2, vector<int>(5, 1));\\n  while (--n > 0) {\\n    for (auto i = 0; i < 5; ++i)\\n      v[(n + 1) % 2][i] = accumulate(begin(moves[i]), end(moves[i]), 0,\\n        [&](int s, int j) {return (s + v[n % 2][j]) % 1000000007; });\\n  }\\n  return accumulate(begin(v[0]), end(v[0]), 0, [](int s, int n) { return (s + n) % 1000000007; });\\n}\\n```\\n### Java\\n```\\npublic int countVowelPermutation(int n) {\\n  int[][] moves = { {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, { 0 } };\\n  int[] v = { 1, 1, 1, 1, 1 };\\n  while (--n > 0) {\\n    int[] v1 = { 0, 0, 0, 0, 0 };\\n    for (int i = 0; i < 5; ++i) {\\n      for (int j : moves[i])\\n        v1[j] = (v1[j] + v[i]) % 1000000007;\\n    }\\n    v = v1;\\n  }\\n  return (int)(((long)v[0] + v[1] + v[2] + v[3] + v[4]) % 1000000007);\\n}\\n```\\n**Python 3**\\nTop-down, just for fun.\\n```python\\nclass Solution:\\n    follow = {\"a\": \"e\", \"e\": \"ai\", \"i\": \"aeuo\", \"u\": \"a\", \"o\": \"iu\", \"\": \"aeiuo\"}\\n    @cache\\n    def countVowelPermutation(self, n: int, last: chr = \"\") -> int:\\n        return (\\n            1\\n            if n == 0\\n            else sum(self.countVowelPermutation(n - 1, ch) for ch in self.follow[last])\\n            % 1000000007\\n        )\\n```\\n## Complexity Analysis\\nTime: O(n). For each iteration, we do 10 operations.\\nMemory: O(1).",
                "solutionTags": [],
                "code": "```n + 1```\n```n```\n```n```\n```n + 1```\n```v[2][5]```\n```n```\n```n + 1```\n```(n + 1) % 2```\n```(n % 2)```\n```\\nint countVowelPermutation(int n) {\\n  // \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'\\n  vector<vector<int>> moves = { {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, { 0 } }, v(2, vector<int>(5, 1));\\n  while (--n > 0) {\\n    for (auto i = 0; i < 5; ++i)\\n      v[(n + 1) % 2][i] = accumulate(begin(moves[i]), end(moves[i]), 0,\\n        [&](int s, int j) {return (s + v[n % 2][j]) % 1000000007; });\\n  }\\n  return accumulate(begin(v[0]), end(v[0]), 0, [](int s, int n) { return (s + n) % 1000000007; });\\n}\\n```\n```\\npublic int countVowelPermutation(int n) {\\n  int[][] moves = { {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, { 0 } };\\n  int[] v = { 1, 1, 1, 1, 1 };\\n  while (--n > 0) {\\n    int[] v1 = { 0, 0, 0, 0, 0 };\\n    for (int i = 0; i < 5; ++i) {\\n      for (int j : moves[i])\\n        v1[j] = (v1[j] + v[i]) % 1000000007;\\n    }\\n    v = v1;\\n  }\\n  return (int)(((long)v[0] + v[1] + v[2] + v[3] + v[4]) % 1000000007);\\n}\\n```\n```python\\nclass Solution:\\n    follow = {\"a\": \"e\", \"e\": \"ai\", \"i\": \"aeuo\", \"u\": \"a\", \"o\": \"iu\", \"\": \"aeiuo\"}\\n    @cache\\n    def countVowelPermutation(self, n: int, last: chr = \"\") -> int:\\n        return (\\n            1\\n            if n == 0\\n            else sum(self.countVowelPermutation(n - 1, ch) for ch in self.follow[last])\\n            % 1000000007\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398231,
                "title": "dynamic-programming-in-python-with-in-depth-explanation-and-diagrams",
                "content": "This question is probably more of a medium than a hard, however it is a great example of dynamic programming!\\n\\nFirstly, we can represent valid strings as a state machine using the information we\\'re given.\\n\\n![image](https://assets.leetcode.com/users/hai_dee/image_1570335214.png)\\n\\nIn order to count how many valid strings there are of length n, we need to use dynamic programming. One way of doing this is to start with strings of length 1, and then consider adding 1 letter at a time, until we have n letters.\\n\\nSo, we iterate from 1 to n, and at each step we determine how many strings of the current length could end with each letter, by extending the strings one size smaller.  With ```n=1```, there is exactly ```1``` option for each (the string containing only that letter).\\n\\nFor ```n = 2```, we now need to think about which letters the current letter we\\u2019re considering could have followed. For example, an \\u201Ca\\u201D is could appear after an \\u201Ce\\u201D, \\u201Ci\\u201D, or \\u201Cu\\u201D, but not after an \\u201Ca\\u201D or an \\u201Co\\u201D as the information we\\u2019re given forbids this. Therefore, the number of strings ending in an \\u201Ca\\u201D is the sum of all the strings whose previous letter was \\u201Ce\\u201D, \\u201Ci\\u201D, or \\u201Cu\\u201D.\\n\\nWe then need to look at our diagram above, to determine what letters each letter could have come out of (look at the arrows in the diagram in reverse to obtain this information).\\n\\n* ```\\u201Ca\\u201D``` can follow any of ```{\\u201Ce\\u201D, \\u201Ci\\u201D, \\u201Cu\\u201D}```.\\n* ```\\u201Ce\\u201D``` can follow any of ```{\\u201Ca\\u201D, \\u201Ci\\u201D}```.\\n* ```\\u201Ci\\u201D``` can follow any of ```{\\u201Ce\\u201D, \\u201Co\\u201D}```.\\n* ```\\u201Co\\u201D``` can follow ```{\\u201Ci\\u201D}```.\\n\\u201C ```\\u201Cu\\u201D``` can follow any of ```{\\u201Ci, \\u201Co\\u201D}```.\\n\\nThe following diagram shows the cells we\\u2019re adding for strings that end in \\u201Ca\\u201D of each size. For example, the number of length-5 strings that end in \\u201Ca\\u201D is the sum of all length-4 strings that end in \\u201Ce\\u201D (9), \\u201Ci\\u201D (7), and \\u201Cu\\u201D (5), which adds to 21.\\n\\n![image](https://assets.leetcode.com/users/hai_dee/image_1570334625.png)\\n\\n\\nIf we need to know how many strings are of length 7, we can add the 7th column ```77 + 65 + 45 + 25 + 37 = 249```. \\n\\n# Code in Python\\n\\nTo implement this in code, we simply need to build up the table shown above.  This code uses ```O(n)``` space for clarity, it is possible to optimise it to use ```O(1)``` space though.\\n\\n```py\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp_array = [[0] * 5 for _ in range(n + 1)]\\n        dp_array[1] = [1, 1, 1, 1, 1]\\n        for i in range(2, n + 1):\\n            # a is allowed to follow e, i, or u.\\n            dp_array[i][0] = dp_array[i - 1][1] + dp_array[i - 1][2] + dp_array[i - 1][4]\\n            # e is allowed to follow a or i.\\n            dp_array[i][1] = dp_array[i - 1][0] +  dp_array[i - 1][2]\\n            # i is allowed to follow e or o.\\n            dp_array[i][2] = dp_array[i - 1][1] + dp_array[i - 1][3]\\n            # o is allowed to follow i\\n            dp_array[i][3] = dp_array[i - 1][2]\\n            # u is allowed to follow i or o.\\n            dp_array[i][4] = dp_array[i - 1][2] + dp_array[i - 1][3]\\n        return sum(dp_array[n]) % ((10 ** 9) + 7)\\n````\\n# Cost of the algorithm\\n\\nThe cost of this algorithm is ```n * 5```, which in big-oh notation simplifies down to ```O(n)```. It uses ```O(n)``` space to hold the generated table.\\n\\nWe can easily optimise it to ```O(1)``` space by only keeping track of the previous column rather than all columns.\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```n=1```\n```1```\n```n = 2```\n```\\u201Ca\\u201D```\n```{\\u201Ce\\u201D, \\u201Ci\\u201D, \\u201Cu\\u201D}```\n```\\u201Ce\\u201D```\n```{\\u201Ca\\u201D, \\u201Ci\\u201D}```\n```\\u201Ci\\u201D```\n```{\\u201Ce\\u201D, \\u201Co\\u201D}```\n```\\u201Co\\u201D```\n```{\\u201Ci\\u201D}```\n```\\u201Cu\\u201D```\n```{\\u201Ci, \\u201Co\\u201D}```\n```77 + 65 + 45 + 25 + 37 = 249```\n```O(n)```\n```O(1)```\n```py\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp_array = [[0] * 5 for _ in range(n + 1)]\\n        dp_array[1] = [1, 1, 1, 1, 1]\\n        for i in range(2, n + 1):\\n            # a is allowed to follow e, i, or u.\\n            dp_array[i][0] = dp_array[i - 1][1] + dp_array[i - 1][2] + dp_array[i - 1][4]\\n            # e is allowed to follow a or i.\\n            dp_array[i][1] = dp_array[i - 1][0] +  dp_array[i - 1][2]\\n            # i is allowed to follow e or o.\\n            dp_array[i][2] = dp_array[i - 1][1] + dp_array[i - 1][3]\\n            # o is allowed to follow i\\n            dp_array[i][3] = dp_array[i - 1][2]\\n            # u is allowed to follow i or o.\\n            dp_array[i][4] = dp_array[i - 1][2] + dp_array[i - 1][3]\\n        return sum(dp_array[n]) % ((10 ** 9) + 7)\\n```\n```n * 5```\n```O(n)```\n```O(n)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1315044,
                "title": "count-vowels-permutation-optimization-from-brute-force-to-dp-to-o-1-time-solution-explained",
                "content": "\\u274C ***Solution - I (Brute-Force)***\\n\\nWe need to form a string of length `n` with vowels. We are also given some **initial rules or mappings** which tells us what character will come after the current character. We need to return the total number of different strings we can form.\\n\\nLet\\'s try to solve this problem starting with the brute-force appraoch. We can **start with any of the 5 vowels** and thereafter we have the choice to **choose next vowel depending on what\\'s allowed after the previous vowel** in the given mappings. The given mappings state what vowels are allowed after a given vowel -\\n\\n```\\nstart   =>  a / e / i / o / u   # start denotes 1st character of string which can be any vowel\\na       =>  e\\ne       =>  a / i\\ni       =>  a / e / o / u\\no       =>  i / u\\nu       =>  a\\n```\\n\\nSo, we will follow this approach. At each index, we will try choosing all vowels allowed after the previous one. The start will be denoted by `s` (any vowel is allowed after it).\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\npublic:\\n    int countVowelPermutation(int n) {\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        int ans = 0;\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            ans = (ans + solve(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>Alternate Concise Implementation</b></summary>\\n\\n---\\n\\nThis is just a bit more concise version of above code. The mappings are converted to from chars to integer as `a:0, e:1, i:2, o:3, u:4, s:5`.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5, int ans = 0) {\\n        if(!rem) return 1;\\n        for(auto c : mappings[prev])\\n            ans = (ans + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(5<sup>N</sup>)</code>\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n---\\n\\n</details>\\n</blockquote>\\n\\n\\n***Time Complexity :*** **<code>O(5<sup>N</sup>)</code>**, at each index we have maximum of 5 choices with us. There are total of `n` indices. Thus `5*5*5...N times` = <code>O(5<sup>N</sup>)</code>.\\n***Space Complexity :*** **`O(N)`**, required for recursive stack. Max recursive depth at any point will be `N`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Top-Down Recursive)***\\n\\nWe can observe does a lot of repeated calculations. The total number of possible strings when we know the previous character `prev` and remaining length `rem` will always be constant. So there\\'s no need to repeat the same calculation. We can store the calculated result  for a given state and reuse it in the future. Thus, we can optimize the solution using **dynamic programming**.\\n\\nWe will maintain a dp array of length `n+1` for each vowel. Here, *`dp[prev_vowel][rem]`* will denote the number of strings that can be formed when previous character was `prev_vowel` and number of characters still required is equal to `rem`. Each time, we will try all vowels possible at current index and explore the further path. We will store the calculated result in `dp[prev][rem]` and reuse it whenever required in future recursive calls.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\n    unordered_map<char, vector<int>> dp;\\npublic:\\n    int countVowelPermutation(int n) {\\n        dp[\\'s\\'] = dp[\\'a\\'] = dp[\\'e\\'] = dp[\\'i\\'] = dp[\\'o\\'] = dp[\\'u\\'] = vector<int>(n+1);\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        if(dp[prev][rem]) return dp[prev][rem];       // if result already calculated for current state, directly return it\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            dp[prev][rem] = (dp[prev][rem] + solve(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u2714\\uFE0F Alternate Concise Implementation (Faster Runtime)</b></summary>\\n\\n---\\n\\nI used the previous solution for better readability. But this solution should give a lot better runtime than the previous implementation since we are avoiding the use of hashmap and thus reducing the constant factor signifincantly.\\n\\nThe mappings are converted to from chars to integer as `a:0, e:1, i:2, o:3, u:4, s:5`.\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    int dp[6][20001]{};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5) {\\n        if(!rem) return 1;                        \\n        if(dp[prev][rem]) return dp[prev][rem];       \\n        for(auto c : mappings[prev])\\n            dp[prev][rem] = (dp[prev][rem] + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** `O(N)`\\n***Space Complexity :*** `O(N)`\\n\\n---\\n---\\n\\n</details>\\n</blockquote>\\n\\n***Time Complexity :*** **`O(N)`**, we will be calculating the total possible strings for a given vowels when `rem` characters are requried, only once. Thus, each vowel will make a max of `N` recursive calls. Hence the total time complexity becomes `O(5*N) = O(N)`\\n***Space Complexity :*** **`O(N)`**, `O(N)` space is required by recursive stack. Further, a total of `O(5*N)` space is used by `dp`. Thus the total space complexity becomes `O(N) + O(5*N) = O(N)`\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Bottom-Up Iterative)***\\n\\nWe can also solve this using iterative DP. Here we will start with the state for `n = 1` where we can form 1 string using each vowel at start. We will use the previous states to calculate the result for next. Here *`dp[k][i]`* will denote the number of possible strings of length `i` that end at vowel numbered - `k`. Here, I have just converted from vowel character mappings to integer mappings like -\\n```\\n0 (a)       =>  1\\n1 (e)       =>  0 / 2\\n2 (i)       =>  0 / 1 / 3 / 4\\n3 (o)       =>  2 / 4\\n4 (u)       =>  0\\n```\\n\\nEach time, we use the stored number of strings possible for length `i-1` to calculate for length `i`. We will use only those state for `dp[k]` from which it is allowed to use `k`th vowel at next position.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long dp[5][n+1], ans = 0;\\n        dp[0][1] = dp[1][1] = dp[2][1] = dp[3][1] = dp[4][1] = 1;\\n        for(int i = 2; i <= n; i++) {\\n            dp[0][i] =  dp[1][i-1];\\n            dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % MOD;\\n            dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % MOD;\\n            dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % MOD;\\n            dp[4][i] =  dp[0][i-1];\\n        }\\n        for(int i=0; i < 5; i++) \\n            ans = (ans + dp[i][n]) % MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space-Optimized DP)***\\n\\nWe can observe that at any point of time we are only using the previous state of each `dp[i]`. So, we can don\\'t need to store all the states and further optimize the solution by storing only the state for previous length for each vowel.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Pre-compute DP)***\\n\\nJust precompute the answers for all `N` at the start and use the globally stored result for all test cases instead of repeating the calculation for each test case. Also since in this case the algorithm performs the same operations for any test cases, by definition, it is a constant time and space solution since it doesn\\'t depend on input :).\\n\\n```\\nint vowelPerms[20001];\\nauto _ = []{\\n    const int MOD = 1e9 + 7;\\n\\tlong a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n\\tvowelPerms[1] = 5;\\n\\tfor (int j = 2; j <= 20000; j++) {\\n\\t\\ta_new =  e;\\n\\t\\te_new = (a + i) % MOD;\\n\\t\\ti_new = (a + e + o + u) % MOD;\\n\\t\\to_new = (i + u) % MOD;\\n\\t\\tu_new =  a;\\n\\t\\ta = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n\\t\\tvowelPerms[j] = (a + e + i + o + u) % MOD;\\n\\t}\\n\\treturn true;\\n}();  // IIFE\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        return vowelPerms[n];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(1)`**, time required doesn\\'t depend on input.\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nstart   =>  a / e / i / o / u   # start denotes 1st character of string which can be any vowel\\na       =>  e\\ne       =>  a / i\\ni       =>  a / e / o / u\\no       =>  i / u\\nu       =>  a\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\npublic:\\n    int countVowelPermutation(int n) {\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        int ans = 0;\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            ans = (ans + solve(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5, int ans = 0) {\\n        if(!rem) return 1;\\n        for(auto c : mappings[prev])\\n            ans = (ans + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const unordered_map<char, vector<char>> mappings{ {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'} }, // start\\n                                                      {\\'a\\', {\\'e\\'}                     }, \\n                                                      {\\'e\\', {\\'a\\', \\'i\\'}                }, \\n                                                      {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}      }, \\n                                                      {\\'o\\', {\\'i\\', \\'u\\'}                },\\n                                                      {\\'u\\', {\\'a\\'}                     }  };\\n    unordered_map<char, vector<int>> dp;\\npublic:\\n    int countVowelPermutation(int n) {\\n        dp[\\'s\\'] = dp[\\'a\\'] = dp[\\'e\\'] = dp[\\'i\\'] = dp[\\'o\\'] = dp[\\'u\\'] = vector<int>(n+1);\\n        return solve(n, \\'s\\');                         // start with s\\n    }\\n    int solve(int rem, char prev) {\\n        if(rem == 0) return 1;                        // no need to pick further. We have formed 1 string of length = n.\\n        if(dp[prev][rem]) return dp[prev][rem];       // if result already calculated for current state, directly return it\\n        for(auto c : mappings.at(prev))               // try each vowel allowed after prev character\\n            dp[prev][rem] = (dp[prev][rem] + solve(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    int dp[6][20001]{};\\npublic:\\n    int countVowelPermutation(int rem, int prev = 5) {\\n        if(!rem) return 1;                        \\n        if(dp[prev][rem]) return dp[prev][rem];       \\n        for(auto c : mappings[prev])\\n            dp[prev][rem] = (dp[prev][rem] + countVowelPermutation(rem - 1, c)) % MOD;  \\n        return dp[prev][rem];\\n    }\\n};\\n```\n```\\n0 (a)       =>  1\\n1 (e)       =>  0 / 2\\n2 (i)       =>  0 / 1 / 3 / 4\\n3 (o)       =>  2 / 4\\n4 (u)       =>  0\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long dp[5][n+1], ans = 0;\\n        dp[0][1] = dp[1][1] = dp[2][1] = dp[3][1] = dp[4][1] = 1;\\n        for(int i = 2; i <= n; i++) {\\n            dp[0][i] =  dp[1][i-1];\\n            dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % MOD;\\n            dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % MOD;\\n            dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % MOD;\\n            dp[4][i] =  dp[0][i-1];\\n        }\\n        for(int i=0; i < 5; i++) \\n            ans = (ans + dp[i][n]) % MOD;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\n```\\nint vowelPerms[20001];\\nauto _ = []{\\n    const int MOD = 1e9 + 7;\\n\\tlong a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n\\tvowelPerms[1] = 5;\\n\\tfor (int j = 2; j <= 20000; j++) {\\n\\t\\ta_new =  e;\\n\\t\\te_new = (a + i) % MOD;\\n\\t\\ti_new = (a + e + o + u) % MOD;\\n\\t\\to_new = (i + u) % MOD;\\n\\t\\tu_new =  a;\\n\\t\\ta = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n\\t\\tvowelPerms[j] = (a + e + i + o + u) % MOD;\\n\\t}\\n\\treturn true;\\n}();  // IIFE\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        return vowelPerms[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391936,
                "title": "python-detailed-explanation-fast-than-91-less-than-93-dp-fast-math",
                "content": "**Appreciate if you could upvote this solution**\\n\\nMethod: `DP`\\nSince the maximum length of the words is `n` and there are total `5` vowels, we could create a `dp[n][5]` matrix first.\\nThus, dp[i][j] means the number of strings of length `i` that ends with the `j`-th vowel so `dp[i]` is the result for word with `n = i`\\n\\nBasically, the result of word with `n = i` is depending on the result of word with `n = i - 1` so it can be solved by dynamic programming.\\nTherefore, for each row `dp[i][j]` is depending on the row `dp[i - 1][j]`\\n```\\ncan only follow:\\n - a -> e, i and u\\n - e -> a and i\\n - i -> e and o\\n - o -> i\\n - u -> i and o\\n```\\nCode:\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        # dp[i][j] means the number of strings of length i that ends with the j-th vowel.\\n        dp = [[1] * 5] + [[0] * (5) for _ in range(n - 1)]\\n        moduler = math.pow(10, 9) + 7\\n        for i in range(1, n):\\n            # For vowel a\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % moduler\\n            # For vowel e\\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % moduler\\n            # For vowel i\\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % moduler\\n            # For vowel o\\n            dp[i][3] = (dp[i - 1][2]) % moduler\\n            # For vowel u\\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % moduler\\n            \\n        return int(sum(dp[-1]) % moduler)\\n```\\n\\n**Time complexity**: `O(n)` \\n**Space complexity**: `O(n^2)` \\n\\n<br/>\\n\\nAs stated as above, for each row `dp[i][j]` is depending on the row `dp[i - 1][j]` only.\\nThus, we do need to store the row less than `i - 1` so the space complexity could be lower\\n\\nCode:\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        moduler = math.pow(10, 9) + 7\\n        a, e, i, o, u = [1] * 5\\n        for _ in range(n - 1):\\n            a, e, i, o, u = map(lambda x: x % moduler, [(e + i + u), (a + i), (e + o), (i), (i + o)])\\n        return int((a + e + i+ o + u) % moduler)\\n```\\n**Time complexity**: `O(n)` \\n**Space complexity**: `O(1)` \\n<br/>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ncan only follow:\\n - a -> e, i and u\\n - e -> a and i\\n - i -> e and o\\n - o -> i\\n - u -> i and o\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        # dp[i][j] means the number of strings of length i that ends with the j-th vowel.\\n        dp = [[1] * 5] + [[0] * (5) for _ in range(n - 1)]\\n        moduler = math.pow(10, 9) + 7\\n        for i in range(1, n):\\n            # For vowel a\\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % moduler\\n            # For vowel e\\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % moduler\\n            # For vowel i\\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % moduler\\n            # For vowel o\\n            dp[i][3] = (dp[i - 1][2]) % moduler\\n            # For vowel u\\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % moduler\\n            \\n        return int(sum(dp[-1]) % moduler)\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        moduler = math.pow(10, 9) + 7\\n        a, e, i, o, u = [1] * 5\\n        for _ in range(n - 1):\\n            a, e, i, o, u = map(lambda x: x % moduler, [(e + i + u), (a + i), (e + o), (i), (i + o)])\\n        return int((a + e + i+ o + u) % moduler)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391230,
                "title": "elegant-dp-solution-not-hard-should-be-easy-medium",
                "content": "## Approach\\nSeeing the question the first approach you would think of is DP to build up to a n character string. There are a few constraints on which character can come after the other. The below table represents the same. Also I have mapped the vowels to the numbers 0 to 4 for ease in implementation.\\n```text\\n a(0) - e            - 1\\n e(1) - a, i         - 0, 2\\n i(2) - a, e, o, u   - 0, 1, 3, 4\\n o(3) - i, u         - 2, 4\\n u(4) - a            - 0\\n```\\nThe above is mapping of \\'before - after\\'(character preceding to character succeding). For the dp we need the after - before mapping so we will reverse this. \\n**Note:** You can also solve it just using the \\'before - after\\', I found the \\'after - before\\' mapping more intuitive so used it.\\n\\n```text\\n 0 - 1, 2, 4\\n 1 - 0, 2\\n 2 - 1, 3\\n 3 - 2\\n 4 - 2, 3\\n```\\n\\nNow for the dp. We are going to use a 2D dp array, where `dp[i][j]` represents the number of strings where the last character, ie. the i<sup>th</sup> character is the j<sup>th</sup> vowel. As we saw above the j<sup>th</sup> vowel can have only certain characters preceding it. For example, when` j = 3`, which is the vowel `o`, the previous characters can only be one of `[2, 4]` which is the letters `[i, u]`. Hence,\\n```text\\n dp[i][j] = \\u2211(dp[i-1][k])  for all kth vowels which are permitted to precede the jth vowel\\n```\\n___\\n\\n## Implementation\\nWe store the above mapping in the array, `validPrev`. As mentioned above, note how we don\\'t have to use any characters instead we are using `a as 0, e as 1, i as 2, o as 3 and u as 4.`\\n```cpp\\n#define ll long long\\n#define mod (ll)((ll)(1e9) + 7)\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<ll>> dp(n, vector<ll> (5, 1));\\n        vector<vector<ll>> validPrev = {{1, 2, 4}, {0, 2}, {1, 3}, {2}, {2, 3}};\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = 0; j < 5; ++j) {\\n                dp[i][j] = 0;\\n                for(auto k: validPrev[j])\\n                    dp[i][j] = (dp[i][j] + dp[i-1][k])%mod;\\n            }\\n        }\\n        ll ans = 0;\\n        for(auto n : dp.back()) ans = (ans + n)%mod;\\n        return ans;\\n    }\\n};\\n```\\n\\nWe can optimise the space usage above, since the current dp row only needs the last row for calculating the result.\\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<ll> last(5, 1), cur(5, 0);\\n        vector<vector<ll>> validPrev = {{1, 2, 4}, {0, 2}, {1, 3}, {2}, {2, 3}};\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = 0; j < 5; ++j) \\n                for(auto k: validPrev[j])\\n                    cur[j] = (cur[j] + last[k])%mod;\\n            last = cur;\\n            cur = {0, 0, 0, 0, 0};\\n        }\\n        ll ans = 0;\\n        for(auto n : last) ans = (ans + n)%mod;\\n        return ans;\\n    }\\n};\\n```\\nIn general, whenever you can have a lot of ifs and elses in your code try replacing them with a relationship-map using arrays or hash maps and loop through the array or hash-map instead. Another example would be problems related to traversing a grid, like dfs, bfs or spiral matrix series. You will have a lot easier time implementing a shorter solution and make a lot less mistakes as well.\\n\\nDo leave a like if you found this post informative. Thank you for reading : )\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```text\\n a(0) - e            - 1\\n e(1) - a, i         - 0, 2\\n i(2) - a, e, o, u   - 0, 1, 3, 4\\n o(3) - i, u         - 2, 4\\n u(4) - a            - 0\\n```\n```text\\n 0 - 1, 2, 4\\n 1 - 0, 2\\n 2 - 1, 3\\n 3 - 2\\n 4 - 2, 3\\n```\n```text\\n dp[i][j] = \\u2211(dp[i-1][k])  for all kth vowels which are permitted to precede the jth vowel\\n```\n```cpp\\n#define ll long long\\n#define mod (ll)((ll)(1e9) + 7)\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<ll>> dp(n, vector<ll> (5, 1));\\n        vector<vector<ll>> validPrev = {{1, 2, 4}, {0, 2}, {1, 3}, {2}, {2, 3}};\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = 0; j < 5; ++j) {\\n                dp[i][j] = 0;\\n                for(auto k: validPrev[j])\\n                    dp[i][j] = (dp[i][j] + dp[i-1][k])%mod;\\n            }\\n        }\\n        ll ans = 0;\\n        for(auto n : dp.back()) ans = (ans + n)%mod;\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<ll> last(5, 1), cur(5, 0);\\n        vector<vector<ll>> validPrev = {{1, 2, 4}, {0, 2}, {1, 3}, {2}, {2, 3}};\\n        for(int i = 1; i < n; ++i) {\\n            for(int j = 0; j < 5; ++j) \\n                for(auto k: validPrev[j])\\n                    cur[j] = (cur[j] + last[k])%mod;\\n            last = cur;\\n            cur = {0, 0, 0, 0, 0};\\n        }\\n        ll ans = 0;\\n        for(auto n : last) ans = (ans + n)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391146,
                "title": "c-recursive-dp-memoized-solution",
                "content": "**1. Recursive Brute Force Solution (Gives TLE)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int n, int i, char c){\\n        \\n        if(i==n) return 1;\\n        \\n        int count = 0;\\n        \\n        if(c==\\'a\\'){\\n\\t\\t// after a only e is allowed\\n            count += f(n, i+1, \\'e\\');\\n        }\\n        \\n        if(c==\\'e\\'){\\n\\t\\t// after e only a and i are allowed\\n            count += f(n, i+1, \\'a\\');\\n            count += f(n, i+1, \\'i\\');\\n        }\\n        if(c==\\'i\\'){\\n\\t\\t// after i except i everything is allowed\\n            count += f(n, i+1, \\'a\\');\\n            count += f(n, i+1, \\'e\\');\\n            count += f(n, i+1, \\'o\\');\\n            count += f(n, i+1, \\'u\\');\\n        }\\n        if(c==\\'o\\'){\\n\\t\\t// after o only i and u are allowed\\n            count += f(n, i+1, \\'i\\');\\n            count += f(n, i+1, \\'u\\');\\n        }\\n        \\n        if(c==\\'u\\'){\\n\\t\\t// after u only a is allowed\\n            count += f(n, i+1, \\'a\\');\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    int countVowelPermutation(int n) {\\n\\t\\n\\t\\t//call for each starting from each vowel after that for changing the character values our recursive call will take care of\\n        return f(n, 1, \\'a\\')  + f(n, 1, \\'e\\') + f(n, 1, \\'i\\') + f(n, 1, \\'o\\') + f(n, 1, \\'u\\'); \\n        \\n    }\\n};\\n```\\n\\n**2. DP Memoized Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int MOD=1e9+7;\\n\\n    long long int f(int n, int i, char c, vector<vector<int>> &dp, unordered_map<char, int> &mp){\\n        \\n        if(i==n) return 1;\\n        \\n        long long count = 0;\\n        \\n        if(dp[mp[c]][i]!=-1) return dp[mp[c]][i]%MOD;\\n        \\n        if(c==\\'a\\'){\\n\\t\\t// after a only e is allowed\\n            count += f(n, i+1, \\'e\\', dp, mp);\\n        }\\n        \\n        if(c==\\'e\\'){\\n\\t\\t// after e only a and i are allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n            count += f(n, i+1, \\'i\\', dp, mp);\\n        }\\n        if(c==\\'i\\'){\\n\\t\\t// after i everthing except i is allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n            count += f(n, i+1, \\'e\\', dp, mp);\\n            count += f(n, i+1, \\'o\\', dp, mp);\\n            count += f(n, i+1, \\'u\\', dp, mp);\\n        }\\n        if(c==\\'o\\'){\\n\\t\\t// after o only i and u are allowed\\n            count += f(n, i+1, \\'i\\', dp, mp);\\n            count += f(n, i+1, \\'u\\', dp, mp);\\n        }\\n        \\n        if(c==\\'u\\'){\\n\\t\\t// after u only a is allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n        }\\n        \\n        return dp[mp[c]][i] = count%MOD;\\n        \\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        \\n\\t\\t// map to convert char to int for using in dp vector for memoization purpose\\n        unordered_map<char, int> mp;\\n        mp[\\'a\\'] = 0;\\n        mp[\\'e\\'] = 1;\\n        mp[\\'i\\'] = 2;\\n        mp[\\'o\\'] = 3;\\n        mp[\\'u\\'] = 4;\\n        \\n        vector<vector<int>> dp(5, vector<int>(n+1, -1));\\n\\t\\t\\n\\t\\t\\t\\t//call for each starting from each vowel after that for changing the character values our recursive call will take care of\\n\\n        long long cnt = f(n, 1, \\'a\\', dp, mp) + f(n, 1, \\'e\\', dp, mp) + f(n, 1, \\'i\\', dp, mp) + f(n, 1, \\'o\\', dp, mp) + f(n, 1, \\'u\\', dp, mp); \\n        \\n        return cnt%MOD;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int n, int i, char c){\\n        \\n        if(i==n) return 1;\\n        \\n        int count = 0;\\n        \\n        if(c==\\'a\\'){\\n\\t\\t// after a only e is allowed\\n            count += f(n, i+1, \\'e\\');\\n        }\\n        \\n        if(c==\\'e\\'){\\n\\t\\t// after e only a and i are allowed\\n            count += f(n, i+1, \\'a\\');\\n            count += f(n, i+1, \\'i\\');\\n        }\\n        if(c==\\'i\\'){\\n\\t\\t// after i except i everything is allowed\\n            count += f(n, i+1, \\'a\\');\\n            count += f(n, i+1, \\'e\\');\\n            count += f(n, i+1, \\'o\\');\\n            count += f(n, i+1, \\'u\\');\\n        }\\n        if(c==\\'o\\'){\\n\\t\\t// after o only i and u are allowed\\n            count += f(n, i+1, \\'i\\');\\n            count += f(n, i+1, \\'u\\');\\n        }\\n        \\n        if(c==\\'u\\'){\\n\\t\\t// after u only a is allowed\\n            count += f(n, i+1, \\'a\\');\\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    int countVowelPermutation(int n) {\\n\\t\\n\\t\\t//call for each starting from each vowel after that for changing the character values our recursive call will take care of\\n        return f(n, 1, \\'a\\')  + f(n, 1, \\'e\\') + f(n, 1, \\'i\\') + f(n, 1, \\'o\\') + f(n, 1, \\'u\\'); \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int MOD=1e9+7;\\n\\n    long long int f(int n, int i, char c, vector<vector<int>> &dp, unordered_map<char, int> &mp){\\n        \\n        if(i==n) return 1;\\n        \\n        long long count = 0;\\n        \\n        if(dp[mp[c]][i]!=-1) return dp[mp[c]][i]%MOD;\\n        \\n        if(c==\\'a\\'){\\n\\t\\t// after a only e is allowed\\n            count += f(n, i+1, \\'e\\', dp, mp);\\n        }\\n        \\n        if(c==\\'e\\'){\\n\\t\\t// after e only a and i are allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n            count += f(n, i+1, \\'i\\', dp, mp);\\n        }\\n        if(c==\\'i\\'){\\n\\t\\t// after i everthing except i is allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n            count += f(n, i+1, \\'e\\', dp, mp);\\n            count += f(n, i+1, \\'o\\', dp, mp);\\n            count += f(n, i+1, \\'u\\', dp, mp);\\n        }\\n        if(c==\\'o\\'){\\n\\t\\t// after o only i and u are allowed\\n            count += f(n, i+1, \\'i\\', dp, mp);\\n            count += f(n, i+1, \\'u\\', dp, mp);\\n        }\\n        \\n        if(c==\\'u\\'){\\n\\t\\t// after u only a is allowed\\n            count += f(n, i+1, \\'a\\', dp, mp);\\n        }\\n        \\n        return dp[mp[c]][i] = count%MOD;\\n        \\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        \\n\\t\\t// map to convert char to int for using in dp vector for memoization purpose\\n        unordered_map<char, int> mp;\\n        mp[\\'a\\'] = 0;\\n        mp[\\'e\\'] = 1;\\n        mp[\\'i\\'] = 2;\\n        mp[\\'o\\'] = 3;\\n        mp[\\'u\\'] = 4;\\n        \\n        vector<vector<int>> dp(5, vector<int>(n+1, -1));\\n\\t\\t\\n\\t\\t\\t\\t//call for each starting from each vowel after that for changing the character values our recursive call will take care of\\n\\n        long long cnt = f(n, 1, \\'a\\', dp, mp) + f(n, 1, \\'e\\', dp, mp) + f(n, 1, \\'i\\', dp, mp) + f(n, 1, \\'o\\', dp, mp) + f(n, 1, \\'u\\', dp, mp); \\n        \\n        return cnt%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390729,
                "title": "java-easy-solution-with-explanation-dp",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    private long[][] dp;\\n    private int mod = (int)1e9 + 7;\\n    \\n    public int countVowelPermutation(int n) {\\n        dp = new long[6][n+1];\\n        if(n == 1) return 5;\\n        \\n        for(int i = 0; i < 5; i++)\\n            dp[i][0] = 1;       \\n\\t\\t\\t\\n        helper(n,\\'z\\');        \\n        return (int)dp[5][n];\\n    }\\n    \\n    private long helper(int n, char vowel)\\n    {\\n        long ans = 0;\\n        if(n == 0) return 1;\\n        \\n        if(vowel == \\'z\\') // we are using z for our convenience just to add Permutations of all Vowels\\n        {\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'e\\') + helper(n-1,\\'i\\') + helper(n-1,\\'o\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[5][n] = ans;\\n        }\\n        // from here as per our assumptions of Vowels we will make calls & store results\\n        else if(vowel == \\'a\\') // for Nth number we would store Result for \"a\" in dp[0][n]\\n        {\\n            if(dp[0][n] != 0) return dp[0][n];\\n            ans = (ans + helper(n-1,\\'e\\'))%mod;\\n            dp[0][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'e\\') // for Nth number we would store Result for \"e\" in dp[1][n]\\n        {\\n            if(dp[1][n] != 0) return dp[1][n];\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'i\\'))%mod;\\n            dp[1][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'i\\') // for Nth number we would store Result for \"i\" in dp[2][n]\\n        {\\n            if(dp[2][n] != 0) return dp[2][n];\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'e\\') + helper(n-1,\\'o\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[2][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'o\\') // for Nth number we would store Result for \"o\" in dp[3][n]\\n        {\\n            if(dp[3][n] != 0) return dp[3][n];\\n            ans = (ans + helper(n-1,\\'i\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[3][n] = ans;    \\n        }\\n           \\n        else // for Nth number we would store Result for \"u\" in dp[4][n]\\n        {\\n            if(dp[4][n] != 0) return dp[4][n];\\n            ans = (ans + helper(n-1,\\'a\\'))%mod;\\n            dp[4][n] = ans;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private long[][] dp;\\n    private int mod = (int)1e9 + 7;\\n    \\n    public int countVowelPermutation(int n) {\\n        dp = new long[6][n+1];\\n        if(n == 1) return 5;\\n        \\n        for(int i = 0; i < 5; i++)\\n            dp[i][0] = 1;       \\n\\t\\t\\t\\n        helper(n,\\'z\\');        \\n        return (int)dp[5][n];\\n    }\\n    \\n    private long helper(int n, char vowel)\\n    {\\n        long ans = 0;\\n        if(n == 0) return 1;\\n        \\n        if(vowel == \\'z\\') // we are using z for our convenience just to add Permutations of all Vowels\\n        {\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'e\\') + helper(n-1,\\'i\\') + helper(n-1,\\'o\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[5][n] = ans;\\n        }\\n        // from here as per our assumptions of Vowels we will make calls & store results\\n        else if(vowel == \\'a\\') // for Nth number we would store Result for \"a\" in dp[0][n]\\n        {\\n            if(dp[0][n] != 0) return dp[0][n];\\n            ans = (ans + helper(n-1,\\'e\\'))%mod;\\n            dp[0][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'e\\') // for Nth number we would store Result for \"e\" in dp[1][n]\\n        {\\n            if(dp[1][n] != 0) return dp[1][n];\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'i\\'))%mod;\\n            dp[1][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'i\\') // for Nth number we would store Result for \"i\" in dp[2][n]\\n        {\\n            if(dp[2][n] != 0) return dp[2][n];\\n            ans = (ans + helper(n-1,\\'a\\') + helper(n-1,\\'e\\') + helper(n-1,\\'o\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[2][n] = ans;\\n        }\\n            \\n        else if(vowel == \\'o\\') // for Nth number we would store Result for \"o\" in dp[3][n]\\n        {\\n            if(dp[3][n] != 0) return dp[3][n];\\n            ans = (ans + helper(n-1,\\'i\\') + helper(n-1,\\'u\\'))%mod;\\n            dp[3][n] = ans;    \\n        }\\n           \\n        else // for Nth number we would store Result for \"u\" in dp[4][n]\\n        {\\n            if(dp[4][n] != 0) return dp[4][n];\\n            ans = (ans + helper(n-1,\\'a\\'))%mod;\\n            dp[4][n] = ans;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390336,
                "title": "python-two-solutions-one-programmer",
                "content": "**Solution**:\\nTop-down dp:\\nReduce the problem down to its sub-problem until n is 1. Return 1 when n is 1. Then, sum up counts returned by all sub-problems.\\n![image](https://assets.leetcode.com/users/images/5fc73e4f-e469-4b32-b230-b0bf19a0d8fc_1659841322.2767086.jpeg)\\n\\n    \\nBottom-up dp:\\nInitialize the counts of all vowels to 1. Iterate from 1 to n and add up the counts of vowels based on previous vowels counts.\\n![image](https://assets.leetcode.com/users/images/bba151cf-c1fa-4269-806d-13d3f1631e71_1659841327.3679676.jpeg)\\n\\n\\n**Complexity**:\\n    Time: O(n)\\n    Space: O(n) for top-down and O(1) for bottom-up\\n\\n```\\n# Top-down dp solution\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        # A mapper mapped characters to their next characters\\n        mapper = {\\n            \"\": [\"a\", \"e\", \"i\", \"o\", \"u\"],\\n            \"a\": \"e\",\\n            \"e\": [\"a\", \"i\"],\\n            \"i\": [\"a\", \"e\", \"o\", \"u\"],\\n            \"o\": [\"i\", \"u\"],\\n            \"u\": [\"a\"],\\n        }\\n\\n        @lru_cache(None)\\n        def dp(n, c):\\n\\n            # If n == 1, we have reach base case and thus, return 1\\n            if n == 1:\\n                return 1\\n\\n            # Initialize the total to 0\\n            total = 0\\n\\n            # Recursively solve sub-problems until n is reduced to 1\\n            for char in mapper[c]:\\n                total = (total + dp(n - 1, char)) % 1000000007\\n\\n            return total\\n\\n        # Add 1 to n since we started with empty string instead of recursively called dp on each vowel\\n        return dp(n + 1, \"\")\\n```\\n\\n```\\n# Bottom-up dp solution\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        # Initialize all vowels counts to 1\\n\\t\\t# This is n==1 case\\n        a, e, i, o, u = 1, 1, 1, 1, 1\\n\\n        # Iterate from 2 to n\\n        for _ in range(2, n + 1):\\n            a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n\\n        # Return the sum of all counts of all vowels\\n        return (a + e + i + o + u) % 1000000007\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Top-down dp solution\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        # A mapper mapped characters to their next characters\\n        mapper = {\\n            \"\": [\"a\", \"e\", \"i\", \"o\", \"u\"],\\n            \"a\": \"e\",\\n            \"e\": [\"a\", \"i\"],\\n            \"i\": [\"a\", \"e\", \"o\", \"u\"],\\n            \"o\": [\"i\", \"u\"],\\n            \"u\": [\"a\"],\\n        }\\n\\n        @lru_cache(None)\\n        def dp(n, c):\\n\\n            # If n == 1, we have reach base case and thus, return 1\\n            if n == 1:\\n                return 1\\n\\n            # Initialize the total to 0\\n            total = 0\\n\\n            # Recursively solve sub-problems until n is reduced to 1\\n            for char in mapper[c]:\\n                total = (total + dp(n - 1, char)) % 1000000007\\n\\n            return total\\n\\n        # Add 1 to n since we started with empty string instead of recursively called dp on each vowel\\n        return dp(n + 1, \"\")\\n```\n```\\n# Bottom-up dp solution\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        # Initialize all vowels counts to 1\\n\\t\\t# This is n==1 case\\n        a, e, i, o, u = 1, 1, 1, 1, 1\\n\\n        # Iterate from 2 to n\\n        for _ in range(2, n + 1):\\n            a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n\\n        # Return the sum of all counts of all vowels\\n        return (a + e + i + o + u) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315114,
                "title": "count-vowels-permutation-graph-dp-w-explanation",
                "content": "***\\u2705 Solution 1:(DFS Graph -- Accepted)***\\n***\\n**Approach:**\\n```\\n1) If we carefully observe the conditions, then we came to know that every vowel is connected to some other vowels,\\ni.e, there is some directed edges from one vowel to another.\\n2) Once we are able to come up with directed graph, then we can calculate number of permutations by considering\\neach vowel as the source vertex (i.e, the first Character in permutation) and then traversing the directed graph from \\nthe soure vertex.\\n\\nok, so what is the relation between the vowels,\\nLet\\'s see,\\nWe will map the vowels to numbers:\\n    a:0\\n    e:1\\n    i:2\\n    o:3\\n    u:4\\n\\nSo the directed graph becomes,\\n    a:{e}       or      0->{1}      \\n    e:{a,i}     or      1->{0,2}\\n    i:{a,e,o,u} or      2->{0,1,3,4}\\n    o:{i,u}     or      3->{2,4}\\n    u:{a}       or      4->{0}    \\n```\\n![image](https://assets.leetcode.com/users/images/002ca3a8-dc62-4d45-be85-85df7d8283d4_1625391110.6797729.png)\\n![image](https://assets.leetcode.com/users/images/6733b86d-9914-482f-b28c-d4a22e0a1b80_1625390283.8115134.png) \\n\\n\\n\\n***\\n**C++:**\\n```\\n/*\\nWe will map the vowels to numbers:\\n    a:0\\n    e:1\\n    i:2\\n    o:3\\n    u:4\\n\\nSo the directed graph becomes,\\n    a:{e}       or      0->{1}      \\n    e:{a,i}     or      1->{0,2}\\n    i:{a,e,o,u} or      2->{0,1,3,4}\\n    o:{i,u}     or      3->{2,4}\\n    u:{a}       or      4->{0}    \\n    \\n    \\n*/\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int dp[5][20002];\\n    int add(int a,int b)\\n    {\\n        return (a%mod + b%mod)%mod;\\n    }\\n//     Initialize the graph\\n    vector<vector<int>> graph = { {1}, {0,2}, {0,1,3,4}, {2,4}, {0}};\\n    \\n    int dfs(int src,int n)\\n    {\\n        if(n==1)\\n            return 1;\\n        if(dp[src][n] != -1)\\n            return dp[src][n];\\n        int res=0;\\n        for(auto child:graph[src])\\n            res = add(res, dfs(child,n-1));\\n        return dp[src][n] = res;\\n    }\\n    \\n    int countVowelPermutation(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        for(int i=0;i<5;i++)\\n            ans = add(ans, dfs(i,n));\\n        return ans;\\n    }\\n};\\n```\\n\\n***\\u2705 Solution 2:(Top Down DP -- Accepted)***\\n***\\n**Approach:**\\n```\\n1) We will try to explore all the possibilities of forming permutation by following the conditions.\\n2) If we have n=3, at every index we can put either of the characters i.e, [a,e,i,o,u]\\n3) But while putting the character at a particular index we will check the character in previous position,\\nand compare it with the given condition,\\n4) If condition satisifies, only after that we will consider the current character at current index, \\nelse we will discard the character,\\n\\nTIME COMPLEXITY: O(N*6)~O(N)\\nSpace Complexity : O(N)\\n```\\n***\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int add(int a,int b)\\n    {\\n        return (a%mod + b%mod)%mod;\\n    }\\n    \\n    int charToIntIndex(char ch)\\n    {\\n        switch(ch)\\n        {\\n            case \\'a\\':\\n                return 0;\\n            case \\'e\\':\\n                return 1;\\n            case \\'i\\':\\n                return 2;\\n            case \\'o\\':\\n                return 3;\\n            case \\'u\\':\\n                return 4;\\n            case \\'#\\':\\n                return 5;\\n        }\\n        // we will never be hitting this case due to conditions mentioned in question.\\n        return 6;\\n    }\\n    int dp[20004][6];\\n    int go(int n,char prev=\\'#\\')\\n    {\\n        if(n==0)\\n            return 1;\\n        if(dp[n][charToIntIndex(prev)]!=-1)\\n            return dp[n][charToIntIndex(prev)];\\n        int res=0;\\n        for(char i:{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'})\\n        {\\n            if(prev==\\'#\\')\\n            {\\n                res=add(res,go(n-1,i));\\n            }\\n            else\\n            {\\n                if(prev==\\'a\\' and i==\\'e\\')\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'e\\' and (i==\\'a\\' or i==\\'i\\'))\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'i\\' and i!=\\'i\\')\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'o\\' and (i==\\'i\\' or i==\\'u\\'))\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'u\\' and i==\\'a\\')\\n                    res=add(res,go(n-1,i));\\n            }\\n        }\\n        return dp[n][charToIntIndex(prev)]=res;\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return go(n);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n1) If we carefully observe the conditions, then we came to know that every vowel is connected to some other vowels,\\ni.e, there is some directed edges from one vowel to another.\\n2) Once we are able to come up with directed graph, then we can calculate number of permutations by considering\\neach vowel as the source vertex (i.e, the first Character in permutation) and then traversing the directed graph from \\nthe soure vertex.\\n\\nok, so what is the relation between the vowels,\\nLet\\'s see,\\nWe will map the vowels to numbers:\\n    a:0\\n    e:1\\n    i:2\\n    o:3\\n    u:4\\n\\nSo the directed graph becomes,\\n    a:{e}       or      0->{1}      \\n    e:{a,i}     or      1->{0,2}\\n    i:{a,e,o,u} or      2->{0,1,3,4}\\n    o:{i,u}     or      3->{2,4}\\n    u:{a}       or      4->{0}    \\n```\n```\\n/*\\nWe will map the vowels to numbers:\\n    a:0\\n    e:1\\n    i:2\\n    o:3\\n    u:4\\n\\nSo the directed graph becomes,\\n    a:{e}       or      0->{1}      \\n    e:{a,i}     or      1->{0,2}\\n    i:{a,e,o,u} or      2->{0,1,3,4}\\n    o:{i,u}     or      3->{2,4}\\n    u:{a}       or      4->{0}    \\n    \\n    \\n*/\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    int dp[5][20002];\\n    int add(int a,int b)\\n    {\\n        return (a%mod + b%mod)%mod;\\n    }\\n//     Initialize the graph\\n    vector<vector<int>> graph = { {1}, {0,2}, {0,1,3,4}, {2,4}, {0}};\\n    \\n    int dfs(int src,int n)\\n    {\\n        if(n==1)\\n            return 1;\\n        if(dp[src][n] != -1)\\n            return dp[src][n];\\n        int res=0;\\n        for(auto child:graph[src])\\n            res = add(res, dfs(child,n-1));\\n        return dp[src][n] = res;\\n    }\\n    \\n    int countVowelPermutation(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int ans = 0;\\n        for(int i=0;i<5;i++)\\n            ans = add(ans, dfs(i,n));\\n        return ans;\\n    }\\n};\\n```\n```\\n1) We will try to explore all the possibilities of forming permutation by following the conditions.\\n2) If we have n=3, at every index we can put either of the characters i.e, [a,e,i,o,u]\\n3) But while putting the character at a particular index we will check the character in previous position,\\nand compare it with the given condition,\\n4) If condition satisifies, only after that we will consider the current character at current index, \\nelse we will discard the character,\\n\\nTIME COMPLEXITY: O(N*6)~O(N)\\nSpace Complexity : O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    static const int mod = 1e9+7;\\n    int add(int a,int b)\\n    {\\n        return (a%mod + b%mod)%mod;\\n    }\\n    \\n    int charToIntIndex(char ch)\\n    {\\n        switch(ch)\\n        {\\n            case \\'a\\':\\n                return 0;\\n            case \\'e\\':\\n                return 1;\\n            case \\'i\\':\\n                return 2;\\n            case \\'o\\':\\n                return 3;\\n            case \\'u\\':\\n                return 4;\\n            case \\'#\\':\\n                return 5;\\n        }\\n        // we will never be hitting this case due to conditions mentioned in question.\\n        return 6;\\n    }\\n    int dp[20004][6];\\n    int go(int n,char prev=\\'#\\')\\n    {\\n        if(n==0)\\n            return 1;\\n        if(dp[n][charToIntIndex(prev)]!=-1)\\n            return dp[n][charToIntIndex(prev)];\\n        int res=0;\\n        for(char i:{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'})\\n        {\\n            if(prev==\\'#\\')\\n            {\\n                res=add(res,go(n-1,i));\\n            }\\n            else\\n            {\\n                if(prev==\\'a\\' and i==\\'e\\')\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'e\\' and (i==\\'a\\' or i==\\'i\\'))\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'i\\' and i!=\\'i\\')\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'o\\' and (i==\\'i\\' or i==\\'u\\'))\\n                    res=add(res,go(n-1,i));\\n                if(prev==\\'u\\' and i==\\'a\\')\\n                    res=add(res,go(n-1,i));\\n            }\\n        }\\n        return dp[n][charToIntIndex(prev)]=res;\\n    }\\n    int countVowelPermutation(int n) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return go(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506516,
                "title": "c-o-n-time-o-1-space-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\tlong a=1,e=1,i=1,o=1,u=1;\\n\\t\\t\\tint mod=1e9+7;\\n\\t\\t\\tfor(int j=2;j<=n;j++){\\n\\t\\t\\t\\tlong A=(e+u+i)%mod;\\n\\t\\t\\t\\tlong E=(a+i)%mod;\\n\\t\\t\\t\\tlong I=(e+o)%mod;\\n\\t\\t\\t\\tlong O=i%mod;\\n\\t\\t\\t\\tlong U=(o+i)%mod;\\n\\t\\t\\t\\ta=A;\\n\\t\\t\\t\\te=E;\\n\\t\\t\\t\\ti=I;\\n\\t\\t\\t\\to=O;\\n\\t\\t\\t\\tu=U;\\n\\t\\t\\t}\\n\\t\\t\\treturn (a+e+i+o+u)%mod;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\tlong a=1,e=1,i=1,o=1,u=1;\\n\\t\\t\\tint mod=1e9+7;\\n\\t\\t\\tfor(int j=2;j<=n;j++){\\n\\t\\t\\t\\tlong A=(e+u+i)%mod;\\n\\t\\t\\t\\tlong E=(a+i)%mod;\\n\\t\\t\\t\\tlong I=(e+o)%mod;\\n\\t\\t\\t\\tlong O=i%mod;\\n\\t\\t\\t\\tlong U=(o+i)%mod;\\n\\t\\t\\t\\ta=A;\\n\\t\\t\\t\\te=E;\\n\\t\\t\\t\\ti=I;\\n\\t\\t\\t\\to=O;\\n\\t\\t\\t\\tu=U;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2391945,
                "title": "java-simple-and-clean",
                "content": "**Explantion :**\\n\\nwe can create Lenght N strings from Length N-1 string by applying the defined rules to it.\\n\\nStrings that have ended in \"a\" can only create strings with \"e\" ending.\\nStrings that have ended in \"e\" can create strings ending with \"a\"  or \"i\"\\n.....\\n\\n\\nThis way we can say that at next step how many strings we would have that ends in each vowel.\\nWe keep a track of endings at each step and go to the next step till we find the desired length.\\n\\n\\nI hope this solution is helpful to you.\\n**I really appericate if you could give me an upvote.** <3\\n\\n**Solution :**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[] vowels = new long[5];\\n        Arrays.fill(vowels, 1);\\n        int mod = (int) (Math.pow(10, 9) + 7);\\n        while (n > 1) {\\n            long[] temp = new long[5];\\n            temp[0] = (vowels[1] + vowels[2] + vowels[4]) % mod;\\n            temp[1] = vowels[0] + vowels[2] % mod;\\n            temp[2] = vowels[1] + vowels[3] % mod;\\n            temp[3] = vowels[2] % mod;\\n            temp[4] = vowels[2] + vowels[3] % mod;\\n            vowels = temp;\\n            n--;\\n        }\\n        return (int) ((vowels[0] + vowels[1] + vowels[2] + vowels[3] + vowels[4]) % mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[] vowels = new long[5];\\n        Arrays.fill(vowels, 1);\\n        int mod = (int) (Math.pow(10, 9) + 7);\\n        while (n > 1) {\\n            long[] temp = new long[5];\\n            temp[0] = (vowels[1] + vowels[2] + vowels[4]) % mod;\\n            temp[1] = vowels[0] + vowels[2] % mod;\\n            temp[2] = vowels[1] + vowels[3] % mod;\\n            temp[3] = vowels[2] % mod;\\n            temp[4] = vowels[2] + vowels[3] % mod;\\n            vowels = temp;\\n            n--;\\n        }\\n        return (int) ((vowels[0] + vowels[1] + vowels[2] + vowels[3] + vowels[4]) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390614,
                "title": "c-easy-to-undestand-memoization-proper-explanantion",
                "content": "**Approach:-** This is the simple question based on the **dynamic programming memoization approch**.\\n-->This question is based on picking the vowels charecters by taking care of Previous taken charecter.\\n-->Based on the Previous taken chatecter value we will make decison for whhich value we will take this time ,according to given condition.\\n\\n-->Insted of taking charecter we will take values from 1 to 5,for charecter integral representation.\\n-->Dp state variable are Pre and count.\\n-->Pre will help us in taking care of previous taken value.\\n-->Count will keep count of the length of the string we have formed.\\n-->If count become n ,then this is the one of the way to form string.(Base condition of recursive function solve).\\n\\n**-->Time Complexity:- O(n*5).**\\n**-->Space Complexity:-O(n*6).**\\n```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int Pre,int count,int &n,vector<vector<int>>&dp)\\n    {\\n        if(count==n)//Base Condition:- If count become n ,then this is the one of the way to form string.\\n            return 1;\\n        \\n        if(dp[count][Pre]!=-1) return dp[count][Pre]%mod;//Memoization\\n        int ans=0;\\n        for(int i=1;i<=5;i++)\\n        {\\n            if(Pre==1 && i==2) //If previous taken is a\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==2 && (i==1 || i==3)) //If previous is e\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==3 && i!=3) //If previous taken is i\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==4 && (i==3 || i==5)) //If previous taken is o\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==5 && i==1) //If previous taken is u.\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n        }\\n        return dp[count][Pre]=ans%mod; //store the value in Dp table.\\n    }\\n    int countVowelPermutation(int n) {\\n        \\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(6,-1)); //Dp table:- Initially all values is -1;\\n        for(int i=1;i<=5;i++)\\n        {\\n         ans= (ans%mod + solve(i,1,n,dp)%mod)%mod; //Call function solve for every vowel taking 1st place.\\n        }\\n        \\n        return ans%mod; // return ans;\\n    }\\n};\\n```\\nI**f you find it helpful . Please upvote.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int solve(int Pre,int count,int &n,vector<vector<int>>&dp)\\n    {\\n        if(count==n)//Base Condition:- If count become n ,then this is the one of the way to form string.\\n            return 1;\\n        \\n        if(dp[count][Pre]!=-1) return dp[count][Pre]%mod;//Memoization\\n        int ans=0;\\n        for(int i=1;i<=5;i++)\\n        {\\n            if(Pre==1 && i==2) //If previous taken is a\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==2 && (i==1 || i==3)) //If previous is e\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==3 && i!=3) //If previous taken is i\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==4 && (i==3 || i==5)) //If previous taken is o\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n            else if(Pre==5 && i==1) //If previous taken is u.\\n                ans=(ans%mod+solve(i,count+1,n,dp)%mod)%mod;\\n        }\\n        return dp[count][Pre]=ans%mod; //store the value in Dp table.\\n    }\\n    int countVowelPermutation(int n) {\\n        \\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(6,-1)); //Dp table:- Initially all values is -1;\\n        for(int i=1;i<=5;i++)\\n        {\\n         ans= (ans%mod + solve(i,1,n,dp)%mod)%mod; //Call function solve for every vowel taking 1st place.\\n        }\\n        \\n        return ans%mod; // return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398453,
                "title": "my-screencast",
                "content": "https://www.youtube.com/watch?v=-tyZnoKU7qs&feature=youtu.be",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=-tyZnoKU7qs&feature=youtu.be",
                "codeTag": "Unknown"
            },
            {
                "id": 2393137,
                "title": "simple-short-explained-solution",
                "content": "**YOU CAN WATCH THIS VIDEO FOR THE EXPLANATION**\\n\\nhttps://www.youtube.com/watch?v=EveRd84f8NM\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 870640,
                "title": "simple-100-faster-than-other-c-with-runtime-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        unsigned long long int a=1,e=1,i=1,o=1,u=1;\\n        unsigned long long int updated_a,updated_e,updated_i,updated_o,updated_u;\\n        for(int ind=2;ind<=n;ind++)\\n        {\\n            updated_a=(e);     // modulo dividing is to handle large values\\n            updated_e=(a+i)%1000000007;\\n            updated_i=(a+e+u+o)%1000000007;\\n            updated_o=(i+u)%1000000007;\\n            updated_u=(a);\\n         \\n            a=updated_a;                   //updating a,e,i,o,u value for each iteration\\n            e=updated_e;\\n            i=updated_i;\\n            o=updated_o;\\n            u=updated_u;\\n        }\\n        return (a+e+i+o+u)%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        unsigned long long int a=1,e=1,i=1,o=1,u=1;\\n        unsigned long long int updated_a,updated_e,updated_i,updated_o,updated_u;\\n        for(int ind=2;ind<=n;ind++)\\n        {\\n            updated_a=(e);     // modulo dividing is to handle large values\\n            updated_e=(a+i)%1000000007;\\n            updated_i=(a+e+u+o)%1000000007;\\n            updated_o=(i+u)%1000000007;\\n            updated_u=(a);\\n         \\n            a=updated_a;                   //updating a,e,i,o,u value for each iteration\\n            e=updated_e;\\n            i=updated_i;\\n            o=updated_o;\\n            u=updated_u;\\n        }\\n        return (a+e+i+o+u)%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398177,
                "title": "short-python-dp-solution",
                "content": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        prevs = {\\'a\\':1, \\'e\\':1, \\'i\\':1, \\'o\\':1, \\'u\\':1}\\n        for i in range(1, n):\\n            cur = defaultdict(int)\\n            for prev, count in prevs.items():\\n                if prev == \\'a\\':\\n                    cur[\\'e\\'] += count\\n                elif prev == \\'e\\':\\n                    for nextch in [\\'a\\', \\'i\\']:\\n                        cur[nextch] += count\\n                elif prev == \\'i\\':\\n                    for nextch in [\\'a\\', \\'e\\', \\'o\\', \\'u\\']:\\n                        cur[nextch] += count \\n                elif prev == \\'o\\':\\n                    for nextch in [\\'i\\', \\'u\\']:\\n                        cur[nextch] += count\\n                elif prev == \\'u\\':\\n                    cur[\\'a\\'] += count\\n            prevs = cur\\n        return sum(prevs.values()) % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        prevs = {\\'a\\':1, \\'e\\':1, \\'i\\':1, \\'o\\':1, \\'u\\':1}\\n        for i in range(1, n):\\n            cur = defaultdict(int)\\n            for prev, count in prevs.items():\\n                if prev == \\'a\\':\\n                    cur[\\'e\\'] += count\\n                elif prev == \\'e\\':\\n                    for nextch in [\\'a\\', \\'i\\']:\\n                        cur[nextch] += count\\n                elif prev == \\'i\\':\\n                    for nextch in [\\'a\\', \\'e\\', \\'o\\', \\'u\\']:\\n                        cur[nextch] += count \\n                elif prev == \\'o\\':\\n                    for nextch in [\\'i\\', \\'u\\']:\\n                        cur[nextch] += count\\n                elif prev == \\'u\\':\\n                    cur[\\'a\\'] += count\\n            prevs = cur\\n        return sum(prevs.values()) % 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 404441,
                "title": "why-not-binary-matrix-exponentiation",
                "content": "Indexing vowels such as `v = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}`, let\\'s say `a[i][j]` represents number of words of length `i` starting with the letter `v[j]`. The rule is \\n`a[i + 1] = M * a[i]`, where `*` means matrix multiplication, and\\n```\\nM = [0, 1, 0, 0, 0,\\n\\t1, 0, 1, 0, 0,\\n\\t1, 1, 0, 1, 1,\\n\\t0, 0, 1, 0, 1,\\n\\t1, 0, 0, 0, 0]\\n``` \\nas follows from the statement. So we need to multiply `M^{n - 1}` by the initial vector `a[1] = [1, 1, 1, 1, 1]` to get `a[n]` and then count its sum. Fast matrix exponentiation computes `M^{n - 1}` in `O(log n)` time complexity.\\n`log n < 15` in task constraints, and even with matrix multiplication in `5 ^ 3 = 125` , which is not a small constant, total algorithm is faster than any dynamic approach taking linear time complexity.",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nM = [0, 1, 0, 0, 0,\\n\\t1, 0, 1, 0, 0,\\n\\t1, 1, 0, 1, 1,\\n\\t0, 0, 1, 0, 1,\\n\\t1, 0, 0, 0, 0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 398224,
                "title": "easy-peasy-python-o-logn-matrix-rank",
                "content": "\\t\\nIn this question, first we create matrix which represents whether I can go from any vowel to any other vowel. Now, we know that rank of the matrix can tell in how many ways I can go from one vowel to the other vowels after n jumps.\\n\\nMore explanation here:\\nhttps://math.stackexchange.com/questions/1890620/finding-path-lengths-by-the-power-of-adjacency-matrix-of-an-undirected-graph\\n\\t\\n\\timport numpy as np\\n\\tclass Solution:\\n\\t\\tdef countVowelPermutation(self, n: int) -> int:        \\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tif n == 1: return 5\\n\\t\\t\\tM = np.matrix([[0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [1,1,0,1,1], [0,0,1,0,1], [1,0,0,0,0]])\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tN = n - 1\\n\\t\\t\\twhile N > 0:\\n\\t\\t\\t\\tif N % 2: \\n\\t\\t\\t\\t\\tres = res * M % mod\\n\\n\\t\\t\\t\\tM = M * M % mod\\n\\n\\t\\t\\t\\tN //= 2\\n\\n\\t\\t\\treturn int(np.sum(res)) % mod",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "\\t\\nIn this question, first we create matrix which represents whether I can go from any vowel to any other vowel. Now, we know that rank of the matrix can tell in how many ways I can go from one vowel to the other vowels after n jumps.\\n\\nMore explanation here:\\nhttps://math.stackexchange.com/questions/1890620/finding-path-lengths-by-the-power-of-adjacency-matrix-of-an-undirected-graph\\n\\t\\n\\timport numpy as np\\n\\tclass Solution:\\n\\t\\tdef countVowelPermutation(self, n: int) -> int:        \\n\\t\\t\\tmod = 10**9 + 7\\n\\t\\t\\tif n == 1: return 5\\n\\t\\t\\tM = np.matrix([[0, 1, 0, 0, 0], [1, 0, 1, 0, 0], [1,1,0,1,1], [0,0,1,0,1], [1,0,0,0,0]])\\n\\n\\t\\t\\tres = 1\\n\\t\\t\\tN = n - 1\\n\\t\\t\\twhile N > 0:\\n\\t\\t\\t\\tif N % 2: \\n\\t\\t\\t\\t\\tres = res * M % mod\\n\\n\\t\\t\\t\\tM = M * M % mod\\n\\n\\t\\t\\t\\tN //= 2\\n\\n\\t\\t\\treturn int(np.sum(res)) % mod",
                "codeTag": "Java"
            },
            {
                "id": 1314992,
                "title": "c-simple-and-short-solution-o-n-tc-o-1-sc-0ms-faster-than-100",
                "content": "We use variables to save the number of strings ending with that letter.\\nWe check the rules and see for each letter after which letter it can appear.\\nWe use the second variables because we have to update in parallel.\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390077,
                "title": "99-63-faster-python3-solution",
                "content": "![image](https://assets.leetcode.com/users/images/31b5b3f8-ce32-48c0-adda-2f0e6022f2c3_1659832065.6120718.png)\\n\\n**Success Details: **\\n*Runtime: 65 ms, faster than 99.63% of Python3 online submissions for Count Vowels Permutation.\\nMemory Usage: 14 MB, less than 80.85% of Python3 online submissions for Count Vowels Permutation.*\\n\\ncode: \\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        MOD =  pow(10,9) + 7\\n        def multiply(a, b):\\n            \\n            result = [ [0] * len(b[0]) for _ in range(len(a))]\\n#           This is just simple matrix multiplicaiton\\n            for i in range(len(a)):\\n                for j in range(len(b[0])):\\n                    for k in range(len(a[0])):\\n                        result[i][j] += (a[i][k] * b[k][j]) % MOD\\n                        result[i][j] %= MOD\\n            return result\\n        \\n        \\n        adjacency_matrix = [\\n            [0,1,0,0,0],\\n            [1,0,1,0,0],\\n            [1,1,0,1,1],\\n            [0,0,1,0,1],\\n            [1,0,0,0,0]\\n        ]\\n        \\n        result = [[0]*5 for _ in range(5)]\\n        for i in range(5):\\n            result[i][i] = 1\\n        \\n        s = 0\\n        n -= 1\\n        while n:\\n            if n & 1:\\n                result = multiply(adjacency_matrix,result)\\n            n >>= 1\\n            adjacency_matrix = multiply(adjacency_matrix,adjacency_matrix)\\n        \\n        for i in range(5):\\n            s += sum(result[i])\\n        \\n        return s % MOD \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        MOD =  pow(10,9) + 7\\n        def multiply(a, b):\\n            \\n            result = [ [0] * len(b[0]) for _ in range(len(a))]\\n#           This is just simple matrix multiplicaiton\\n            for i in range(len(a)):\\n                for j in range(len(b[0])):\\n                    for k in range(len(a[0])):\\n                        result[i][j] += (a[i][k] * b[k][j]) % MOD\\n                        result[i][j] %= MOD\\n            return result\\n        \\n        \\n        adjacency_matrix = [\\n            [0,1,0,0,0],\\n            [1,0,1,0,0],\\n            [1,1,0,1,1],\\n            [0,0,1,0,1],\\n            [1,0,0,0,0]\\n        ]\\n        \\n        result = [[0]*5 for _ in range(5)]\\n        for i in range(5):\\n            result[i][i] = 1\\n        \\n        s = 0\\n        n -= 1\\n        while n:\\n            if n & 1:\\n                result = multiply(adjacency_matrix,result)\\n            n >>= 1\\n            adjacency_matrix = multiply(adjacency_matrix,adjacency_matrix)\\n        \\n        for i in range(5):\\n            s += sum(result[i])\\n        \\n        return s % MOD \\n```",
                "codeTag": "Java"
            },
            {
                "id": 526467,
                "title": "python-o-1-aux-space-by-dp-70-w-comment",
                "content": "Python O(1) aux space by DP.\\n\\n---\\n\\n**Hint**:\\n\\nBuild a bottom-up dynamic programming with the **transition rule** defined in [description.](https://leetcode.com/problems/count-vowels-permutation/)\\n\\nEach character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n\\nEach vowel \\'**a**\\' may only be followed by an \\'**e**\\'.\\n\\nEach vowel \\'**e**\\' may only be followed by an \\'**a**\\' or an \\'**i**\\'.\\n\\nEach vowel \\'**i**\\' may **not** be followed by another \\'**i**\\'.\\n\\nEach vowel \\'**o**\\' may only be followed by an \\'**i**\\' or a \\'**u**\\'.\\n\\nEach vowel \\'**u**\\' may only be followed by an \\'**a**\\'.\\n\\n---\\n\\n**Optimal substructure**:\\nNext permutation ending with \\'**a**\\' = current permutation ending with \\'**e**\\' + current permutation ending with \\'**i**\\' + current permutation ending with \\'**u**\\'.\\n\\nNext permutation ending with \\'**e**\\' = current permutation ending with \\'**a**\\' + current permutation ending with \\'**i**\\'.\\n\\nNext permutation ending with \\'**i**\\' = current permutation ending with \\'**e**\\' + current permutation ending with \\'**o**\\'.\\n\\nNext permutation ending with \\'**o**\\' = current permutation ending with \\'**i**\\'.\\n\\nNext permutation ending with \\'**u**\\' = current permutation ending with \\'**i**\\' + current permutation ending with \\'**o**\\'.\\n\\n---\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        modulo = 10**9 + 7\\n        \\n        # initialization for length of permutation = 1\\n        (a, e, i, o, u) = (1, 1, 1, 1, 1)\\n        \\n        length_of_permutation = 2\\n        while length_of_permutation <= n:\\n            \\n            # update total method count by transition rule\\n            end_with_a = e + i + u\\n    \\n            end_with_e = a + i\\n\\n            end_with_i = e + o\\n           \\n            end_with_o = i\\n   \\n            end_with_u = i + o\\n\\t\\t\\t\\n\\t\\t\\t# update method count of ending with a e i o u\\n            (a, e, i, o, u) = (end_with_a, end_with_e, end_with_i, end_with_o, end_with_u )\\n            \\n        \\n            length_of_permutation += 1\\n        \\n\\n        return (a + e + i + o + u) % modulo\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        modulo = 10**9 + 7\\n        \\n        # initialization for length of permutation = 1\\n        (a, e, i, o, u) = (1, 1, 1, 1, 1)\\n        \\n        length_of_permutation = 2\\n        while length_of_permutation <= n:\\n            \\n            # update total method count by transition rule\\n            end_with_a = e + i + u\\n    \\n            end_with_e = a + i\\n\\n            end_with_i = e + o\\n           \\n            end_with_o = i\\n   \\n            end_with_u = i + o\\n\\t\\t\\t\\n\\t\\t\\t# update method count of ending with a e i o u\\n            (a, e, i, o, u) = (end_with_a, end_with_e, end_with_i, end_with_o, end_with_u )\\n            \\n        \\n            length_of_permutation += 1\\n        \\n\\n        return (a + e + i + o + u) % modulo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390060,
                "title": "c-top-down-dfs-dp-dry-compliant",
                "content": "Solved LIVE ON twitch.  Everyday 6pm PT. Except for saturdays (4pm PT).  Link in profile.\\n\\n\\n```\\nclass Solution {\\n    int MOD = 1e9+7;\\n    int dfs(int n, char last, vector<vector<int>>& memo) {\\n        if(n == 0) return 1;\\n        \\n        if(memo[n][last] != -1) return memo[n][last];\\n        int total = 0;\\n        if(last == \\'a\\') {\\n            total = (total + dfs(n-1, \\'e\\', memo)) % MOD ;\\n        } else if(last == \\'e\\') {\\n            total = (total + dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n        } else if(last == \\'i\\') {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'e\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'o\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        } else if(last == \\'o\\') {\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        } else if(last == \\'u\\') {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n        } else {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'e\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'o\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        }\\n        \\n        return memo[n][last] = total;\\n    }\\n    \\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> memo(n+1, vector<int>(130, -1));\\n        return dfs(n, \\'.\\', memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1e9+7;\\n    int dfs(int n, char last, vector<vector<int>>& memo) {\\n        if(n == 0) return 1;\\n        \\n        if(memo[n][last] != -1) return memo[n][last];\\n        int total = 0;\\n        if(last == \\'a\\') {\\n            total = (total + dfs(n-1, \\'e\\', memo)) % MOD ;\\n        } else if(last == \\'e\\') {\\n            total = (total + dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n        } else if(last == \\'i\\') {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'e\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'o\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        } else if(last == \\'o\\') {\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        } else if(last == \\'u\\') {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n        } else {\\n            total = (total +  dfs(n-1, \\'a\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'e\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'i\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'o\\', memo))% MOD;\\n            total = (total +  dfs(n-1, \\'u\\', memo))% MOD;\\n        }\\n        \\n        return memo[n][last] = total;\\n    }\\n    \\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> memo(n+1, vector<int>(130, -1));\\n        return dfs(n, \\'.\\', memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400370,
                "title": "java-dp-solution-recursive-iterative",
                "content": "Once you find how every vowel can be generated depending on existing vowels, it could be straightforward to get this formula:\\n\\n`a` = `e` + `i` + `u`\\n`e` = `a` + `i`\\n`i` = `e` + `o`\\n`o` = `i`\\n`u` = `i` + `o`\\n\\nGet new result based on previous step, which is a classic DP problem.\\n\\n**Recursive:**\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        long sum = 0;\\n        long[] v = new long[]{1, 1, 1, 1, 1}; // a-0, e-1, i-2, o-3, u-4\\n        for (long i : iterate(v, n - 1)) \\n            sum = (sum + i) % mod;\\n        return (int) sum;\\n    }\\n    \\n    public long[] iterate(long[] v, int n) {\\n        if (n == 0) return v;\\n        long[] v1 = new long[5];\\n        v1[0] = (v[1] + v[2] + v[4]) % mod;\\n        v1[1] = (v[0] + v[2]) % mod;\\n        v1[2] = (v[1] + v[3]) % mod;\\n        v1[3] = v[2];\\n        v1[4] = (v[2] + v[3]) % mod;\\n        return iterate(v1, n - 1);\\n    }\\n}\\n```\\n\\n**Iterative:**\\n```\\npublic int countVowelPermutation(int n) {\\n    int mod = 1000000007;\\n    long sum = 0;\\n    long[] v = new long[]{1, 1, 1, 1, 1}; // a-0, e-1, i-2, o-3, u-4\\n    for (int i = 1; i < n; i++) {\\n        long[] v1 = new long[5];\\n        v1[0] = (v[1] + v[2] + v[4]) % mod;\\n        v1[1] = (v[0] + v[2]) % mod;\\n        v1[2] = (v[1] + v[3]) % mod;\\n        v1[3] = v[2];\\n        v1[4] = (v[2] + v[3]) % mod;\\n        v = v1;\\n    }\\n    for (long i : v) \\n        sum = (sum + i) % mod;\\n    return (int) sum;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        long sum = 0;\\n        long[] v = new long[]{1, 1, 1, 1, 1}; // a-0, e-1, i-2, o-3, u-4\\n        for (long i : iterate(v, n - 1)) \\n            sum = (sum + i) % mod;\\n        return (int) sum;\\n    }\\n    \\n    public long[] iterate(long[] v, int n) {\\n        if (n == 0) return v;\\n        long[] v1 = new long[5];\\n        v1[0] = (v[1] + v[2] + v[4]) % mod;\\n        v1[1] = (v[0] + v[2]) % mod;\\n        v1[2] = (v[1] + v[3]) % mod;\\n        v1[3] = v[2];\\n        v1[4] = (v[2] + v[3]) % mod;\\n        return iterate(v1, n - 1);\\n    }\\n}\\n```\n```\\npublic int countVowelPermutation(int n) {\\n    int mod = 1000000007;\\n    long sum = 0;\\n    long[] v = new long[]{1, 1, 1, 1, 1}; // a-0, e-1, i-2, o-3, u-4\\n    for (int i = 1; i < n; i++) {\\n        long[] v1 = new long[5];\\n        v1[0] = (v[1] + v[2] + v[4]) % mod;\\n        v1[1] = (v[0] + v[2]) % mod;\\n        v1[2] = (v[1] + v[3]) % mod;\\n        v1[3] = v[2];\\n        v1[4] = (v[2] + v[3]) % mod;\\n        v = v1;\\n    }\\n    for (long i : v) \\n        sum = (sum + i) % mod;\\n    return (int) sum;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392315,
                "title": "python-o-n-tc-o-1-sc-faster-than-99",
                "content": "The problem should indeed be Easy-Mid, as there\\'s nothing difficult about it.\\n\\nYou have rules for letters following each other:\\n```\\na -> e\\ne -> [a, i]\\ni -> [a, e, o, u]\\no -> [i, u]\\nu -> [a]\\n```\\n\\nThis basically means that you can apply the DP approach, start with strings of length 1 (one possible permutation for each letter, five together), and then keep separate track of number of permutations for strings of length `l` depending on which letter they start. Finally, when `l` equals `n`, you just sum the separate permutations together, thus achieving the required result.\\n\\nOne key thing to note is that you don\\'t need to keep the whole DP array, as on each step you only refer to the previous step. So space complexity can be reduced to O(1).\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = 1\\n        e = 1\\n        i = 1\\n        o = 1\\n        u = 1\\n        BIG_VAL = 1000000007\\n\\n        n -= 1\\n\\n        while n:\\n            new_a = e\\n            new_e = (a + i) % BIG_VAL\\n            new_i = (a + e + o + u) % BIG_VAL\\n            new_o = (i + u) % BIG_VAL\\n            new_u = a\\n\\n            a = new_a\\n            e = new_e\\n            i = new_i\\n            o = new_o\\n            u = new_u\\n\\n            n -= 1\\n        \\n        return (a + e + i + o + u) % BIG_VAL\\n```\\nPlease upvote the post if you found it useful \\uD83D\\uDE04",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\na -> e\\ne -> [a, i]\\ni -> [a, e, o, u]\\no -> [i, u]\\nu -> [a]\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = 1\\n        e = 1\\n        i = 1\\n        o = 1\\n        u = 1\\n        BIG_VAL = 1000000007\\n\\n        n -= 1\\n\\n        while n:\\n            new_a = e\\n            new_e = (a + i) % BIG_VAL\\n            new_i = (a + e + o + u) % BIG_VAL\\n            new_o = (i + u) % BIG_VAL\\n            new_u = a\\n\\n            a = new_a\\n            e = new_e\\n            i = new_i\\n            o = new_o\\n            u = new_u\\n\\n            n -= 1\\n        \\n        return (a + e + i + o + u) % BIG_VAL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391513,
                "title": "c-0ms-fast-than-100-no-dp-created-comments-added",
                "content": "Please upvote if you found it helpful :)\\n```\\nint countVowelPermutation(int n) {\\n\\tlong long int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1e9 + 7;\\n\\tfor (int k = 2; k <= n; k++) {\\n\\t\\t// these new variables store the prev values for each of the vowels\\n\\t\\tlong long int ta = a, ti = i, te = e, to = o, tu = u;\\n\\t\\t\\n\\t\\t// using the previous values of vowels, I get the new values of each increased length\\n\\t\\ta = te;\\n\\t\\te = ta + ti;\\n\\t\\ti = ta + te + to + tu;\\n\\t\\to = ti + tu;\\n\\t\\tu = ta;\\n\\t\\t\\n\\t\\t// to keep the range to not exceed 1e9+7, we do mod for each of the value \\n\\t\\ta %= mod, e %= mod, i %= mod, o %= mod, u %= mod;\\n\\t}\\n\\treturn (a + e + i + o + u) % mod;\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/7d8e65e4-42eb-42fc-af8e-f26f7b272b9a_1659853169.8933198.png)\\nLet me know if you need a detailed explanation on this.\\n",
                "solutionTags": [],
                "code": "```\\nint countVowelPermutation(int n) {\\n\\tlong long int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1e9 + 7;\\n\\tfor (int k = 2; k <= n; k++) {\\n\\t\\t// these new variables store the prev values for each of the vowels\\n\\t\\tlong long int ta = a, ti = i, te = e, to = o, tu = u;\\n\\t\\t\\n\\t\\t// using the previous values of vowels, I get the new values of each increased length\\n\\t\\ta = te;\\n\\t\\te = ta + ti;\\n\\t\\ti = ta + te + to + tu;\\n\\t\\to = ti + tu;\\n\\t\\tu = ta;\\n\\t\\t\\n\\t\\t// to keep the range to not exceed 1e9+7, we do mod for each of the value \\n\\t\\ta %= mod, e %= mod, i %= mod, o %= mod, u %= mod;\\n\\t}\\n\\treturn (a + e + i + o + u) % mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391126,
                "title": "count-vowels-permutation-using-dynamic-programming-tc-o-n-daily-leetcoding-day7-aug22",
                "content": "![image](https://assets.leetcode.com/users/images/6634c7a6-bc17-433b-a5d1-943ba14adc5d_1659849068.4076242.jpeg)\\n# **KeyPoint : We are making the string backwards.**\\n**Suppose we want to make a string of size k;\\nthen \\'a\\' can be added at with all the string of size (k-1) starting with \\'e\\';\\nsimilarly \\'e\\' with all string of size (k-1) starting with \\'a\\' and \\'i\\';\\nsimilarly \\'i\\' with \\'a\\',\\'e\\',\\'o\\',\\'u\\';\\nand \\'o\\' with \\'i\\' & \\'u\\'\\nand \\'u\\' with \\'a\\'**\\n\\n**Code Section:**\\n```\\nconst unsigned int m = 1000000007;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n       if(n==1)\\n           return 5;\\n        \\n       vector<int> v(5,1);int ans=0;\\n       while(n-1)\\n       {\\n          vector<int> temp(5,0);\\n          for(int i=0;i<5;i++)\\n              temp[i]=v[i];\\n          \\n          v[4]=temp[0]%m;\\n          v[3]=(temp[2]%m+temp[4]%m)%m;\\n          v[2]=(temp[0]%m+temp[1]%m+temp[3]%m+temp[4]%m)%m;\\n          v[1]=(temp[0]%m+temp[2]%m)%m;\\n          v[0]=(temp[1]%m);\\n          n--;\\n          \\n          if(n-1==0)\\n              for(auto &x:v){\\n                  ans+=x%m;\\n                  ans%=m;\\n              }\\n\\n          \\n       }\\n       return ans%m;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n       if(n==1)\\n           return 5;\\n        \\n       vector<int> v(5,1);int ans=0;\\n       while(n-1)\\n       {\\n          vector<int> temp(5,0);\\n          for(int i=0;i<5;i++)\\n              temp[i]=v[i];\\n          \\n          v[4]=temp[0]%m;\\n          v[3]=(temp[2]%m+temp[4]%m)%m;\\n          v[2]=(temp[0]%m+temp[1]%m+temp[3]%m+temp[4]%m)%m;\\n          v[1]=(temp[0]%m+temp[2]%m)%m;\\n          v[0]=(temp[1]%m);\\n          n--;\\n          \\n          if(n-1==0)\\n              for(auto &x:v){\\n                  ans+=x%m;\\n                  ans%=m;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 2390017,
                "title": "daily-leetcoding-challenge-august-day-7",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-vowels-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Bottom-up)\n\n  \n**Approach 2:** Dynamic Programming (Bottom-up) with Optimized Space\n\n  \n**Approach 3:** Dynamic Programming (Top-down, Recursion)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/count-vowels-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** Dynamic Programming (Bottom-up)\n**Approach 2:** Dynamic Programming (Bottom-up) with Optimized Space\n**Approach 3:** Dynamic Programming (Top-down, Recursion)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1315096,
                "title": "c-dp-solution-explained-100-time-98-space",
                "content": "The problem is tricky because it might tempt you to do some backtracking DFS magic, but given the possible size of `n`, you might not exactly be set for success with this approach.\\n\\nA better one comes from storing previous results - one from each letter: we will build our `dp` matrix in this guise, with the first index (the row one) representing the length of the current permutation minus `1` (since we will use a `0` indexed matrix) and the second one (the column) representing the last number in it (normalising the `\"aeiou\"` range into a `0 - 4` one), so for example `dp[7][3]` will represent all the permutations of `8` characters we can have terminating with the letter `o`.\\n\\nWe are then going to create a `dp` matrix with `n` rows and `5` columns and set the very first column values all to `1` (ie: using only one number, you can have only one combination).\\n\\nLooping `n - 1` times, we can iteratively compute all the other values, with the following approach, according to the specs:\\n* `prev` is always going to be the current index minus `1`;\\n* `\\'a\\'` can only follow `\\'e\\'`, `\\'i\\'` and `\\'u\\'`, so we will have that `dp[i][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4])`;\\n* `\\'e\\'` can only follow `\\'a\\'`, and `\\'i\\'`, so we will have that `dp[i][1] = moduloReduce(dp[prev][0] + dp[prev][2])`;\\n* `\\'i\\'` can only follow `\\'e\\'`, and `\\'o\\'`, so we will have that `dp[i][2] = moduloReduce(dp[prev][1] + dp[prev][3])`;\\n* `\\'o\\'` can only follow `\\'i\\'`, so we will have that `dp[i][3] = dp[prev][2]` (notice we do not even need to call `moduloReduce` for this one);\\n* `\\'u\\'` can only follow `\\'i\\'` and `\\'o\\'`, so we will have that `dp[i][4] = moduloReduce(dp[prev][2] + dp[prev][3])`.\\n\\nNow, a few words on `moduloReduce`: this function takes a number `n` and while it is `>= modVal`, it just subtract this value from `n` - that is actually cheaper ([in this case](https://leetcode.com/problems/count-vowels-permutation/discuss/1315096/C++-DP-Solution-Explained-100-Time-~98-Space/997684)) than calling the modulo operator on it all the time!\\n\\nOnce done, we sum the partial results of the last column, again calling `moduloReduce` on said sum and we are done :)\\n\\nThe code:\\n\\n```cpp\\nstatic constexpr int modVal = 1000000007;\\n\\nclass Solution {\\n    long moduloReduce(long n) {\\n        while (n > modVal) n -= modVal;\\n        return n;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        long dp[n][5];\\n        // initialising dp\\n        for (int i = 0; i < 5; i++) dp[0][i] = 1;\\n        // computing all the following steps\\n        for (int i = 1, prev = 0; i < n; i++) {\\n            // case \\'a\\' - which can only follow \\'e\\', \\'i\\' and \\'u\\':\\n            dp[i][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4]);\\n            // case \\'e\\' - which can only follow \\'a\\' and \\'i\\':\\n            dp[i][1] = moduloReduce(dp[prev][0] + dp[prev][2]);\\n            // case \\'i\\' - which can only follow \\'e\\' and \\'o\\':\\n            dp[i][2] = moduloReduce(dp[prev][1] + dp[prev][3]);\\n            // case \\'o\\' - which can only follow \\'i\\':\\n            dp[i][3] = dp[prev][2];\\n            // case \\'u\\' - which can only follow \\'i\\' and \\'o\\':\\n            dp[i][4] = moduloReduce(dp[prev][2] + dp[prev][3]);\\n            // updating prev\\n            prev = i;\\n        }\\n        return moduloReduce(dp[--n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4]);\\n    }\\n};\\n```\\n\\nBut, wait a moment: do we really need `n` rows in our matrix?\\n\\nProbably not, since we are always advancing to one row, using the previous one.\\n\\nThen we can refactor and save a lot more memory \\uD83C\\uDF89 :\\n\\n```cpp\\nstatic constexpr int modVal = 1000000007;\\n\\nclass Solution {\\n    long moduloReduce(long n) {\\n        while (n > modVal) n -= modVal;\\n        return n;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        long dp[2][5];\\n        int prev = 0;\\n        // initialising dp\\n        for (int i = 0; i < 5; i++) dp[0][i] = 1;\\n        // computing all the following steps\\n        for (int i = 1, curr = 1; i < n; i++) {\\n            // case \\'a\\' - which can only follow \\'e\\', \\'i\\' and \\'u\\':\\n            dp[curr][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4]);\\n            // case \\'e\\' - which can only follow \\'a\\' and \\'i\\':\\n            dp[curr][1] = moduloReduce(dp[prev][0] + dp[prev][2]);\\n            // case \\'i\\' - which can only follow \\'e\\' and \\'o\\':\\n            dp[curr][2] = moduloReduce(dp[prev][1] + dp[prev][3]);\\n            // case \\'o\\' - which can only follow \\'i\\':\\n            dp[curr][3] = dp[prev][2];\\n            // case \\'u\\' - which can only follow \\'i\\' and \\'o\\':\\n            dp[curr][4] = moduloReduce(dp[prev][2] + dp[prev][3]);\\n            // updating prev and curr\\n            prev = curr;\\n            curr = !curr;\\n        }\\n        return moduloReduce(dp[prev][0] + dp[prev][1] + dp[prev][2] + dp[prev][3] + dp[prev][4]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```cpp\\nstatic constexpr int modVal = 1000000007;\\n\\nclass Solution {\\n    long moduloReduce(long n) {\\n        while (n > modVal) n -= modVal;\\n        return n;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        long dp[n][5];\\n        // initialising dp\\n        for (int i = 0; i < 5; i++) dp[0][i] = 1;\\n        // computing all the following steps\\n        for (int i = 1, prev = 0; i < n; i++) {\\n            // case \\'a\\' - which can only follow \\'e\\', \\'i\\' and \\'u\\':\\n            dp[i][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4]);\\n            // case \\'e\\' - which can only follow \\'a\\' and \\'i\\':\\n            dp[i][1] = moduloReduce(dp[prev][0] + dp[prev][2]);\\n            // case \\'i\\' - which can only follow \\'e\\' and \\'o\\':\\n            dp[i][2] = moduloReduce(dp[prev][1] + dp[prev][3]);\\n            // case \\'o\\' - which can only follow \\'i\\':\\n            dp[i][3] = dp[prev][2];\\n            // case \\'u\\' - which can only follow \\'i\\' and \\'o\\':\\n            dp[i][4] = moduloReduce(dp[prev][2] + dp[prev][3]);\\n            // updating prev\\n            prev = i;\\n        }\\n        return moduloReduce(dp[--n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4]);\\n    }\\n};\\n```\n```cpp\\nstatic constexpr int modVal = 1000000007;\\n\\nclass Solution {\\n    long moduloReduce(long n) {\\n        while (n > modVal) n -= modVal;\\n        return n;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        long dp[2][5];\\n        int prev = 0;\\n        // initialising dp\\n        for (int i = 0; i < 5; i++) dp[0][i] = 1;\\n        // computing all the following steps\\n        for (int i = 1, curr = 1; i < n; i++) {\\n            // case \\'a\\' - which can only follow \\'e\\', \\'i\\' and \\'u\\':\\n            dp[curr][0] = moduloReduce(dp[prev][1] + dp[prev][2] + dp[prev][4]);\\n            // case \\'e\\' - which can only follow \\'a\\' and \\'i\\':\\n            dp[curr][1] = moduloReduce(dp[prev][0] + dp[prev][2]);\\n            // case \\'i\\' - which can only follow \\'e\\' and \\'o\\':\\n            dp[curr][2] = moduloReduce(dp[prev][1] + dp[prev][3]);\\n            // case \\'o\\' - which can only follow \\'i\\':\\n            dp[curr][3] = dp[prev][2];\\n            // case \\'u\\' - which can only follow \\'i\\' and \\'o\\':\\n            dp[curr][4] = moduloReduce(dp[prev][2] + dp[prev][3]);\\n            // updating prev and curr\\n            prev = curr;\\n            curr = !curr;\\n        }\\n        return moduloReduce(dp[prev][0] + dp[prev][1] + dp[prev][2] + dp[prev][3] + dp[prev][4]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150639,
                "title": "stupid-simple-python",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = e = i = o = u = 1\\n        for _ in range(n - 1):\\n            a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n        \\n        return  (a + e + i + o + u) % (10 ** 9 + 7)\\n```\\n80% faster and 95% less space than other python",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = e = i = o = u = 1\\n        for _ in range(n - 1):\\n            a, e, i, o, u = e + i + u, a + i, e + o, i, i + o\\n        \\n        return  (a + e + i + o + u) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412036,
                "title": "python-simple-forward-dynamic-programming",
                "content": "```python\\ndef countVowelPermutation(self, n: int) -> int:\\n\\tMOD = 10**9 + 7\\n\\tvowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n\\tallowed_next = {\\n\\t\\t\\'a\\': [\\'e\\'],\\n\\t\\t\\'e\\': [\\'a\\', \\'i\\'],\\n\\t\\t\\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n\\t\\t\\'o\\': [\\'i\\', \\'u\\'],\\n\\t\\t\\'u\\': [\\'a\\']\\n\\t}       \\n\\t# dp[i][v] - number of possible strings of length i+1 (since we\\n\\t# start with i=0) that end with vowel v.\\n\\tdp = [collections.defaultdict(int) for i in range(n)]\\n\\tfor v in vowels:\\n\\t\\tdp[0][v] = 1\\n\\tfor i in range(n-1):\\n\\t\\tfor v in vowels:\\n\\t\\t\\tfor next_v in allowed_next[v]:\\n\\t\\t\\t\\tdp[i+1][next_v] = (dp[i+1][next_v] + dp[i][v])%MOD\\n\\treturn sum(dp[n-1].values())%MOD\\n```",
                "solutionTags": [],
                "code": "```python\\ndef countVowelPermutation(self, n: int) -> int:\\n\\tMOD = 10**9 + 7\\n\\tvowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n\\tallowed_next = {\\n\\t\\t\\'a\\': [\\'e\\'],\\n\\t\\t\\'e\\': [\\'a\\', \\'i\\'],\\n\\t\\t\\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n\\t\\t\\'o\\': [\\'i\\', \\'u\\'],\\n\\t\\t\\'u\\': [\\'a\\']\\n\\t}       \\n\\t# dp[i][v] - number of possible strings of length i+1 (since we\\n\\t# start with i=0) that end with vowel v.\\n\\tdp = [collections.defaultdict(int) for i in range(n)]\\n\\tfor v in vowels:\\n\\t\\tdp[0][v] = 1\\n\\tfor i in range(n-1):\\n\\t\\tfor v in vowels:\\n\\t\\t\\tfor next_v in allowed_next[v]:\\n\\t\\t\\t\\tdp[i+1][next_v] = (dp[i+1][next_v] + dp[i][v])%MOD\\n\\treturn sum(dp[n-1].values())%MOD\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 399280,
                "title": "super-easy-5-line-python-solution-o-n-time-o-1-space",
                "content": "borrow the idea from LC 70\\nthe number of strings of length n is only determined  by previous state (the number of each character in all the strings of length n-1)\\nnotice the rules, \\'a\\' will only follow after \\'e\\',\\'i\\',\\'u\\', so update `a = e+i+u`, same to all the vowels\\n```\\ndef countVowelPermutation(self, n: int) -> int:\\n\\ta,e,i,o,u = 1,1,1,1,1\\n\\t#store the number of each vowels\\n\\tfor _ in range(1,n):\\n\\t\\ta,e,i,o,u = e+i+u,a+i,e+o,i,i+o\\n\\treturn (a+e+i+o+u)% 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n\\ta,e,i,o,u = 1,1,1,1,1\\n\\t#store the number of each vowels\\n\\tfor _ in range(1,n):\\n\\t\\ta,e,i,o,u = e+i+u,a+i,e+o,i,i+o\\n\\treturn (a+e+i+o+u)% 1000000007\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2450820,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=EveRd84f8NM\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\nint countVowelPermutation(int n) {\\nlong a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\nlong a2, e2, i2, o2, u2;\\n\\n    for (int j = 2; j <= n; j++) {\\n        a2 = (e + i + u) % mod;\\n        e2 = (a + i) % mod;\\n        i2 = (e + o) % mod;\\n        o2 = i;\\n        u2 = (o + i) % mod;\\n        \\n        a = a2, e = e2, i = i2, o = o2, u = u2;\\n    }\\n    \\n    return (a + e + i + o + u) % mod;\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long [][] dp = new long[5][n+1];\\n        int mod=1000000007;\\n        for(int i=0;i<5;i++){\\n            dp[i][0]=0;\\n            dp[i][1]=1;\\n        }  \\n        for(int i=2;i<n+1;i++){\\n            dp[0][i]=(dp[1][i-1]+dp[2][i-1]+dp[4][i-1])%mod;   //for ending with \\'a\\'\\n            dp[1][i]=(dp[0][i-1]+dp[2][i-1])%mod;                     //for ending with \\'e\\'\\n            dp[2][i]=(dp[1][i-1]+dp[3][i-1])%mod;                 //for ending with \\'i\\'\\n            dp[3][i]=(dp[2][i-1])%mod;                       //for ending with \\'o\\'\\n            dp[4][i]=(dp[2][i-1]+dp[3][i-1])%mod;                   //for ending with \\'u\\'\\n        }  \\n        return (int)((dp[0][n]+dp[1][n]+dp[2][n]+dp[3][n]+dp[4][n])%mod);     //return sum  but in integer format\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={\\'a\\':1,\\'e\\':1,\\'i\\':1,\\'o\\':1,\\'u\\':1}\\n        \\n        for i in range(n-1):\\n            dp1={}\\n            for c in \\'aeiou\\':\\n                if c==\\'a\\':\\n                    dp1[c]=dp[\\'e\\']\\n                elif c==\\'e\\':\\n                    dp1[c]=dp[\\'a\\']+dp[\\'i\\']\\n                elif c==\"i\":\\n                    dp1[c]=dp[\\'a\\']+dp[\\'e\\']+dp[\\'o\\']+dp[\\'u\\']\\n                elif c==\\'o\\':\\n                    dp1[c]=dp[\\'i\\']+dp[\\'u\\']\\n                elif c==\\'u\\':\\n                    dp1[c]=dp[\\'a\\']\\n                    \\n            dp=dp1\\n        mod=10**9+7    \\n        return sum(dp.values())%mod\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint countVowelPermutation(int n) {\\nlong a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\nlong a2, e2, i2, o2, u2;\\n\\n    for (int j = 2; j <= n; j++) {\\n        a2 = (e + i + u) % mod;\\n        e2 = (a + i) % mod;\\n        i2 = (e + o) % mod;\\n        o2 = i;\\n        u2 = (o + i) % mod;\\n        \\n        a = a2, e = e2, i = i2, o = o2, u = u2;\\n    }\\n    \\n    return (a + e + i + o + u) % mod;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long [][] dp = new long[5][n+1];\\n        int mod=1000000007;\\n        for(int i=0;i<5;i++){\\n            dp[i][0]=0;\\n            dp[i][1]=1;\\n        }  \\n        for(int i=2;i<n+1;i++){\\n            dp[0][i]=(dp[1][i-1]+dp[2][i-1]+dp[4][i-1])%mod;   //for ending with \\'a\\'\\n            dp[1][i]=(dp[0][i-1]+dp[2][i-1])%mod;                     //for ending with \\'e\\'\\n            dp[2][i]=(dp[1][i-1]+dp[3][i-1])%mod;                 //for ending with \\'i\\'\\n            dp[3][i]=(dp[2][i-1])%mod;                       //for ending with \\'o\\'\\n            dp[4][i]=(dp[2][i-1]+dp[3][i-1])%mod;                   //for ending with \\'u\\'\\n        }  \\n        return (int)((dp[0][n]+dp[1][n]+dp[2][n]+dp[3][n]+dp[4][n])%mod);     //return sum  but in integer format\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={\\'a\\':1,\\'e\\':1,\\'i\\':1,\\'o\\':1,\\'u\\':1}\\n        \\n        for i in range(n-1):\\n            dp1={}\\n            for c in \\'aeiou\\':\\n                if c==\\'a\\':\\n                    dp1[c]=dp[\\'e\\']\\n                elif c==\\'e\\':\\n                    dp1[c]=dp[\\'a\\']+dp[\\'i\\']\\n                elif c==\"i\":\\n                    dp1[c]=dp[\\'a\\']+dp[\\'e\\']+dp[\\'o\\']+dp[\\'u\\']\\n                elif c==\\'o\\':\\n                    dp1[c]=dp[\\'i\\']+dp[\\'u\\']\\n                elif c==\\'u\\':\\n                    dp1[c]=dp[\\'a\\']\\n                    \\n            dp=dp1\\n        mod=10**9+7    \\n        return sum(dp.values())%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430917,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n**Watch this video \\uD83E\\uDC83 for the better explanation of the code.**\\n\\nhttps://www.youtube.com/watch?v=EveRd84f8NM\\n\\n\\n**Also you can SUBSCRIBE  \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.**\\n**C++**\\n```\\nclass Solution {\\npublic:\\nint countVowelPermutation(int n) {\\nlong a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\nlong a2, e2, i2, o2, u2;\\n\\n    for (int j = 2; j <= n; j++) {\\n        a2 = (e + i + u) % mod;\\n        e2 = (a + i) % mod;\\n        i2 = (e + o) % mod;\\n        o2 = i;\\n        u2 = (o + i) % mod;\\n        \\n        a = a2, e = e2, i = i2, o = o2, u = u2;\\n    }\\n    \\n    return (a + e + i + o + u) % mod;\\n}\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long [][] dp = new long[5][n+1];\\n        int mod=1000000007;\\n        for(int i=0;i<5;i++){\\n            dp[i][0]=0;\\n            dp[i][1]=1;\\n        }  \\n        for(int i=2;i<n+1;i++){\\n            dp[0][i]=(dp[1][i-1]+dp[2][i-1]+dp[4][i-1])%mod;   //for ending with \\'a\\'\\n            dp[1][i]=(dp[0][i-1]+dp[2][i-1])%mod;                     //for ending with \\'e\\'\\n            dp[2][i]=(dp[1][i-1]+dp[3][i-1])%mod;                 //for ending with \\'i\\'\\n            dp[3][i]=(dp[2][i-1])%mod;                       //for ending with \\'o\\'\\n            dp[4][i]=(dp[2][i-1]+dp[3][i-1])%mod;                   //for ending with \\'u\\'\\n        }  \\n        return (int)((dp[0][n]+dp[1][n]+dp[2][n]+dp[3][n]+dp[4][n])%mod);     //return sum  but in integer format\\n    }\\n}\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={\\'a\\':1,\\'e\\':1,\\'i\\':1,\\'o\\':1,\\'u\\':1}\\n        \\n        for i in range(n-1):\\n            dp1={}\\n            for c in \\'aeiou\\':\\n                if c==\\'a\\':\\n                    dp1[c]=dp[\\'e\\']\\n                elif c==\\'e\\':\\n                    dp1[c]=dp[\\'a\\']+dp[\\'i\\']\\n                elif c==\"i\":\\n                    dp1[c]=dp[\\'a\\']+dp[\\'e\\']+dp[\\'o\\']+dp[\\'u\\']\\n                elif c==\\'o\\':\\n                    dp1[c]=dp[\\'i\\']+dp[\\'u\\']\\n                elif c==\\'u\\':\\n                    dp1[c]=dp[\\'a\\']\\n                    \\n            dp=dp1\\n        mod=10**9+7    \\n        return sum(dp.values())%mod\\n```\\n**Please do UPVOTE to motivate me to solve more daily challenges like this !!**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint countVowelPermutation(int n) {\\nlong a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\nlong a2, e2, i2, o2, u2;\\n\\n    for (int j = 2; j <= n; j++) {\\n        a2 = (e + i + u) % mod;\\n        e2 = (a + i) % mod;\\n        i2 = (e + o) % mod;\\n        o2 = i;\\n        u2 = (o + i) % mod;\\n        \\n        a = a2, e = e2, i = i2, o = o2, u = u2;\\n    }\\n    \\n    return (a + e + i + o + u) % mod;\\n}\\n};\\n```\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long [][] dp = new long[5][n+1];\\n        int mod=1000000007;\\n        for(int i=0;i<5;i++){\\n            dp[i][0]=0;\\n            dp[i][1]=1;\\n        }  \\n        for(int i=2;i<n+1;i++){\\n            dp[0][i]=(dp[1][i-1]+dp[2][i-1]+dp[4][i-1])%mod;   //for ending with \\'a\\'\\n            dp[1][i]=(dp[0][i-1]+dp[2][i-1])%mod;                     //for ending with \\'e\\'\\n            dp[2][i]=(dp[1][i-1]+dp[3][i-1])%mod;                 //for ending with \\'i\\'\\n            dp[3][i]=(dp[2][i-1])%mod;                       //for ending with \\'o\\'\\n            dp[4][i]=(dp[2][i-1]+dp[3][i-1])%mod;                   //for ending with \\'u\\'\\n        }  \\n        return (int)((dp[0][n]+dp[1][n]+dp[2][n]+dp[3][n]+dp[4][n])%mod);     //return sum  but in integer format\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={\\'a\\':1,\\'e\\':1,\\'i\\':1,\\'o\\':1,\\'u\\':1}\\n        \\n        for i in range(n-1):\\n            dp1={}\\n            for c in \\'aeiou\\':\\n                if c==\\'a\\':\\n                    dp1[c]=dp[\\'e\\']\\n                elif c==\\'e\\':\\n                    dp1[c]=dp[\\'a\\']+dp[\\'i\\']\\n                elif c==\"i\":\\n                    dp1[c]=dp[\\'a\\']+dp[\\'e\\']+dp[\\'o\\']+dp[\\'u\\']\\n                elif c==\\'o\\':\\n                    dp1[c]=dp[\\'i\\']+dp[\\'u\\']\\n                elif c==\\'u\\':\\n                    dp1[c]=dp[\\'a\\']\\n                    \\n            dp=dp1\\n        mod=10**9+7    \\n        return sum(dp.values())%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391599,
                "title": "c-explained-without-dp",
                "content": "![image](https://assets.leetcode.com/users/images/eddd9e58-7224-47c6-8a3b-e426606a22a6_1659854627.9822836.jpeg)\\n```\\n\\n\\nUpvote for the effort <<<<<< if u understood \\n\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n       \\n        \\n        \\n        \\n       \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n            \\n            \\n            /* say for n==2\\n       a2=3;\\n       e2=2;\\n       i2=2;\\n       02=1;\\n       u2=2;\\n       now update all values and go for next iteration\\n       \\n       \\n       \\n         */\\n            \\n            \\n            \\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nUpvote for the effort <<<<<< if u understood \\n\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n       \\n        \\n        \\n        \\n       \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n            \\n            \\n            /* say for n==2\\n       a2=3;\\n       e2=2;\\n       i2=2;\\n       02=1;\\n       u2=2;\\n       now update all values and go for next iteration\\n       \\n       \\n       \\n         */\\n            \\n            \\n            \\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391014,
                "title": "c-easy-dp-solution-with-matrix-beats-100",
                "content": "```\\n\\t{\\n\\tconst int mod=1000000007;\\n\\tlong long int arr[n][5];\\n\\tfor(int i=0;i<5;i++)\\n\\t{\\n\\t\\tarr[0][i]=1;\\n\\t}\\n\\tfor(int i=1;i<n;i++)\\n\\t{\\n\\t\\tarr[i][0]=arr[i-1][1]+arr[i-1][2]+arr[i-1][4];\\n\\t\\tarr[i][0]%=mod;\\n\\t\\tarr[i][1]=arr[i-1][0]+arr[i-1][2];  \\n\\t\\tarr[i][1]%=mod;\\n\\t\\tarr[i][2]=arr[i-1][1]+arr[i-1][3];\\n\\t\\tarr[i][2]%=mod;\\n\\t\\tarr[i][3]=arr[i-1][2];\\n\\t\\tarr[i][3]%=mod;\\n\\t\\tarr[i][4]=arr[i-1][2]+arr[i-1][3];\\n\\t\\tarr[i][4]%=mod;\\n\\t}\\n\\tlong long int ans=0;\\n\\tfor(int i=0;i<5;i++)\\n\\t{\\n\\t\\tans+=arr[n-1][i];\\n\\t\\tans%=mod;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\n\\t{\\n\\tconst int mod=1000000007;\\n\\tlong long int arr[n][5];\\n\\tfor(int i=0;i<5;i++)\\n\\t{\\n\\t\\tarr[0][i]=1;\\n\\t}\\n\\tfor(int i=1;i<n;i++)\\n\\t{\\n\\t\\tarr[i][0]=arr[i-1][1]+arr[i-1][2]+arr[i-1][4];\\n\\t\\tarr[i][0]%=mod;\\n\\t\\tarr[i][1]=arr[i-1][0]+arr[i-1][2];  \\n\\t\\tarr[i][1]%=mod;\\n\\t\\tarr[i][2]=arr[i-1][1]+arr[i-1][3];\\n\\t\\tarr[i][2]%=mod;\\n\\t\\tarr[i][3]=arr[i-1][2];\\n\\t\\tarr[i][3]%=mod;\\n\\t\\tarr[i][4]=arr[i-1][2]+arr[i-1][3];\\n\\t\\tarr[i][4]%=mod;\\n\\t}\\n\\tlong long int ans=0;\\n\\tfor(int i=0;i<5;i++)\\n\\t{\\n\\t\\tans+=arr[n-1][i];\\n\\t\\tans%=mod;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315768,
                "title": "count-vowels-permutation-math-bottom-up-dp-w-explanation",
                "content": "The core idea is calculating the numbers of strings ended with each vowel recursively. Based on the problem, we can create a string of length `n+1` from a string of length `n`, so when we need to find the answer of the problem for input `n + 1`, we only need to know the answer for input `n`. Therefore, instead of using a table to save values from `1` to `n`, we compute in a bottom-up manner and use temporary variables to save memory. Below is the implementation of the idea (Runtime: 136ms, Memory Usage: 14.2MB)\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 1000000007\\n        j = 1\\n        A, E, I, O , U = 1, 1, 1, 1, 1 # base case for n = 1\\n        while j < n:\\n            prev_A, prev_E, prev_I, prev_O, prev_U = A, E, I, O, U\\n            A = prev_E + prev_I + prev_U\\n            E = prev_A + prev_I\\n            I = prev_E + prev_O\\n            O = prev_I\\n            U = prev_I + prev_O\\n            if A >= mod: A %= mod\\n            if E >= mod: E %= mod\\n            if I >= mod: I %= mod\\n            if O >= mod: O %= mod\\n            if U >= mod: U %= mod\\n            j += 1\\n        return (A + E + I + O + U) % mod\\n```\\nI went further to improve the solution using a little bit Math. Instead of breaking into 5 components, I tried to find a recursive formula to directly computed the answer. Suppose that `(x) = (x_1, x_2, ..., x_n)` is a sequence of answers for the problem. I would find the recursive equation for `(x)`. This can be done using the recursive relation we have from the previous solution, from which I got that `x_n = x_{n-1} + 2x_{n-2} - x_{n-3} + x_{n-4}`, and all I needed left was answers for `n = {1, 2, 3, 4}` and building up the solution in the similar way to the first solution. (Runtime: 88ms, Memory Usage: 14MB)\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 1000000007\\n        j = 4\\n        x = deque([5, 10, 19, 35])\\n        while j < n:\\n            x.append((x[3] + 2*x[2] - x[1] + x[0]) % mod)\\n            x.popleft()\\n            j += 1\\n        return x[n - 1] if n < 5 else x[-1]\\n```\\nThis is also my first post. Thank you for reading and please upvote if you like the solutions! Happy coding!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 1000000007\\n        j = 1\\n        A, E, I, O , U = 1, 1, 1, 1, 1 # base case for n = 1\\n        while j < n:\\n            prev_A, prev_E, prev_I, prev_O, prev_U = A, E, I, O, U\\n            A = prev_E + prev_I + prev_U\\n            E = prev_A + prev_I\\n            I = prev_E + prev_O\\n            O = prev_I\\n            U = prev_I + prev_O\\n            if A >= mod: A %= mod\\n            if E >= mod: E %= mod\\n            if I >= mod: I %= mod\\n            if O >= mod: O %= mod\\n            if U >= mod: U %= mod\\n            j += 1\\n        return (A + E + I + O + U) % mod\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 1000000007\\n        j = 4\\n        x = deque([5, 10, 19, 35])\\n        while j < n:\\n            x.append((x[3] + 2*x[2] - x[1] + x[0]) % mod)\\n            x.popleft()\\n            j += 1\\n        return x[n - 1] if n < 5 else x[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527942,
                "title": "java-bottom-up-dp",
                "content": "```\\npublic int countVowelPermutation(int n) {\\n        int mod = (int) (1e9 + 7);\\n        if (n == 0) return 1;\\n        if (n == 1) return 5;\\n        long[][] dp = new long[n+1][5];\\n        for (int i = 0; i < 5; i++) {\\n            dp[1][i] = 1;\\n        }\\n\\t\\t// for i + 1, just add new char to the head of old string.\\n        for (int i = 1; i < n; i++) {\\n            dp[i+1][0] = (dp[i][1]) % mod; \\n            dp[i+1][1] = (dp[i][0] + dp[i][2]) % mod;\\n            dp[i+1][2] = (dp[i][0] + dp[i][1] + dp[i][3] + dp[i][4]) % mod;\\n            dp[i+1][3] = (dp[i][2] + dp[i][4]) % mod;\\n            dp[i+1][4] = (dp[i][0]) % mod;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 5; i++) {\\n            res = (res +dp[n][i]) % mod;\\n        }\\n        return (int) res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countVowelPermutation(int n) {\\n        int mod = (int) (1e9 + 7);\\n        if (n == 0) return 1;\\n        if (n == 1) return 5;\\n        long[][] dp = new long[n+1][5];\\n        for (int i = 0; i < 5; i++) {\\n            dp[1][i] = 1;\\n        }\\n\\t\\t// for i + 1, just add new char to the head of old string.\\n        for (int i = 1; i < n; i++) {\\n            dp[i+1][0] = (dp[i][1]) % mod; \\n            dp[i+1][1] = (dp[i][0] + dp[i][2]) % mod;\\n            dp[i+1][2] = (dp[i][0] + dp[i][1] + dp[i][3] + dp[i][4]) % mod;\\n            dp[i+1][3] = (dp[i][2] + dp[i][4]) % mod;\\n            dp[i+1][4] = (dp[i][0]) % mod;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 5; i++) {\\n            res = (res +dp[n][i]) % mod;\\n        }\\n        return (int) res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410448,
                "title": "python-4-liner-should-not-be-a-hard-problem",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a,e,i,o,u = 1,1,1,1,1\\n        for j in range(2, n+1):\\n            a,e,i,o,u = e+i+u, a+i,e+o, i, i+o\\n        return (a+e+i+o+u) % (10**9 +7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a,e,i,o,u = 1,1,1,1,1\\n        for j in range(2, n+1):\\n            a,e,i,o,u = e+i+u, a+i,e+o, i, i+o\\n        return (a+e+i+o+u) % (10**9 +7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566976,
                "title": "c-dp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int &n,vector<vector<int>> &dp,vector<vector<char>> &g,char c,int &mod){\\n    if(i>=n){\\n        // cout<<\" \"<<str<<\" \";\\n        return 1;\\n    }\\n    if(dp[i][c-\\'a\\'] != -1)return dp[i][c-\\'a\\'];\\n    int a = 0;\\n    for(auto &j: g[c-\\'a\\']){\\n        a = (a+solve(i+1,n,dp,g,j,mod))%mod;\\n    }\\n    return dp[i][c-\\'a\\'] = a;\\n}\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n,vector<int>(26,-1));\\n        vector<vector<char>> g(26);\\n        g[\\'b\\'-\\'a\\']  = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        g[\\'a\\'-\\'a\\'] = {\\'e\\'};\\n        g[\\'e\\'-\\'a\\'] = {\\'a\\',\\'i\\'};\\n        g[\\'i\\'-\\'a\\'] = {\\'a\\',\\'e\\',\\'o\\',\\'u\\'};\\n        g[\\'o\\'-\\'a\\'] = {\\'i\\',\\'u\\'};\\n        g[\\'u\\'-\\'a\\'] = {\\'a\\'};\\n        int mod = 1e9+7;\\n        return solve(0,n,dp,g,\\'b\\',mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int &n,vector<vector<int>> &dp,vector<vector<char>> &g,char c,int &mod){\\n    if(i>=n){\\n        // cout<<\" \"<<str<<\" \";\\n        return 1;\\n    }\\n    if(dp[i][c-\\'a\\'] != -1)return dp[i][c-\\'a\\'];\\n    int a = 0;\\n    for(auto &j: g[c-\\'a\\']){\\n        a = (a+solve(i+1,n,dp,g,j,mod))%mod;\\n    }\\n    return dp[i][c-\\'a\\'] = a;\\n}\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n,vector<int>(26,-1));\\n        vector<vector<char>> g(26);\\n        g[\\'b\\'-\\'a\\']  = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        g[\\'a\\'-\\'a\\'] = {\\'e\\'};\\n        g[\\'e\\'-\\'a\\'] = {\\'a\\',\\'i\\'};\\n        g[\\'i\\'-\\'a\\'] = {\\'a\\',\\'e\\',\\'o\\',\\'u\\'};\\n        g[\\'o\\'-\\'a\\'] = {\\'i\\',\\'u\\'};\\n        g[\\'u\\'-\\'a\\'] = {\\'a\\'};\\n        int mod = 1e9+7;\\n        return solve(0,n,dp,g,\\'b\\',mod);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3040891,
                "title": "python-4-solutions-slowly-getting-better-thought-process-beats-99",
                "content": "# \\u2705 First approach : recursivity (Too slow)\\n\\n```\\noptions={\"a\":\"e\",\"e\":\"ai\",\"i\":\"aeou\",\"o\":\"iu\",\"u\":\"a\"}\\n\\nalphabet = \"aeiou\"\\n\\ndef count(s, n):\\n    if n==0:\\n        return 1\\n    return sum([count(options[c],n-1) for c in s])\\n    \\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        return count(alphabet,n)\\n```\\n\\nDespite its corectness, this implementation  is way too slow, let\\'s use dynamic programming\\n\\n---\\n\\n\\n---\\n\\n\\n# \\u2705 Second approach : dynamic programming (Beats 49%)\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0 for _ in range(5)] for _ in range(n)]\\n        mat[0]=[1]*5\\n\\n        for i in range(1,n):\\n            mat[i][0] = mat[i-1][1] + mat[i-1][2] + mat[i-1][4]\\n            mat[i][1] = mat[i-1][0] + mat[i-1][2]\\n            mat[i][2] = mat[i-1][1] + mat[i-1][3]\\n            mat[i][3] = mat[i-1][2]\\n            mat[i][4] = mat[i-1][2] + mat[i-1][3]\\n\\n        return sum(mat[n-1]) % (10 **9 +7)\\n```\\n\\nWe see that the i_th line only depends of the i-1_th line, we can simplify the calculation and the space required using matrix exponentiation.\\n\\n---\\n\\n\\n---\\n\\n\\n# Third approach : linear algebra\\n\\nWe can reprenst the rules by this $5\\\\times 5$ matrix where there is a 1 at `i,j` if ith voyel can have jth voyell behind it\\n\\nfor example `u` can have `i` and `o` behind it so $a_{5,2}=a_{5,3}=1$\\n\\n$$A= \\\\begin{bmatrix} 0 & 1 & 1 & 0 & 1 \\\\\\\\ 1 & 0 & 1 & 0 & 0 \\\\\\\\ 0 & 1 & 0 & 1 & 0 \\\\\\\\ 0 & 0 & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 1 & 1 & 0 \\\\end{bmatrix} $$\\n\\nThe answer is the sum of all the values of this matrix\\n\\n$A^n \\\\cdot X_0 = \\\\begin{bmatrix} 0 & 1 & 1 & 0 & 1 \\\\\\\\ 1 & 0 & 1 & 0 & 0 \\\\\\\\ 0 & 1 & 0 & 1 & 0 \\\\\\\\ 0 & 0 & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 1 & 1 & 0 \\\\end{bmatrix}^n \\\\begin{bmatrix} 1 \\\\\\\\ 1 \\\\\\\\ 1 \\\\\\\\ 1 \\\\\\\\ 1 \\\\end{bmatrix}\\n$\\n\\nLet\\'s calculate it\\n\\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```\\n\\nThe results are wrong for n > 50. It must be an issue with int overflow or the moudlo.\\n\\n# \\u2705Last approach (Beats 99%)\\nUsing chat gpt as an assistant, I found a way to keep the values of the matrix not too high.\\nAI really is astonishing when used precisely.\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = np.array([[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]],dtype=int)\\n        result = np.eye(5,dtype=int)\\n        n-=1\\n        while n:\\n            if n % 2:\\n                result = np.dot(result, mat) % (10**9+7)\\n            mat = np.dot(mat, mat) % (10**9+7)\\n            n //= 2\\n        return np.sum(result) % (10**9+7)\\n```\\n\\nDo not hesitate to contact me if I made mistakes or if you have question ! \\uD83D\\uDE00\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\noptions={\"a\":\"e\",\"e\":\"ai\",\"i\":\"aeou\",\"o\":\"iu\",\"u\":\"a\"}\\n\\nalphabet = \"aeiou\"\\n\\ndef count(s, n):\\n    if n==0:\\n        return 1\\n    return sum([count(options[c],n-1) for c in s])\\n    \\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        return count(alphabet,n)\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0 for _ in range(5)] for _ in range(n)]\\n        mat[0]=[1]*5\\n\\n        for i in range(1,n):\\n            mat[i][0] = mat[i-1][1] + mat[i-1][2] + mat[i-1][4]\\n            mat[i][1] = mat[i-1][0] + mat[i-1][2]\\n            mat[i][2] = mat[i-1][1] + mat[i-1][3]\\n            mat[i][3] = mat[i-1][2]\\n            mat[i][4] = mat[i-1][2] + mat[i-1][3]\\n\\n        return sum(mat[n-1]) % (10 **9 +7)\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = np.array([[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]],dtype=int)\\n        result = np.eye(5,dtype=int)\\n        n-=1\\n        while n:\\n            if n % 2:\\n                result = np.dot(result, mat) % (10**9+7)\\n            mat = np.dot(mat, mat) % (10**9+7)\\n            n //= 2\\n        return np.sum(result) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393093,
                "title": "c-solution-with-easy-explanation",
                "content": "In the below solution, character \\'a\\' is denoted as 0, character \\'e\\' is denoted as 1, character \\'i\\' is denoted as 2, character \\'o\\' is denoted as 3, character \\'u\\' is denoted as 4.\\nSo whenever we add a character, we pass the corresponding number to the function which describes what character was inserted before, so that we can take the next decision.\\n```\\nclass Solution {\\npublic:\\n    char arr[5] = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int dp[100000][5];  //This dp denotes the no of string of particular length ending \\n\\t//with particular vowel. For eg. dp[i][j] denotes the total no of string of length i \\n\\t//which ends with vowel j.\\n    int mod = 1e9 + 7;\\n    int find(int n, int i){\\n        if(n == 1)return 1;  //return when string size is 1\\n        if(dp[n][i] != -1)return dp[n][i];\\n        dp[n][i] = 0;\\n\\t\\tif(i == 0){ //when the last character of string is \\'a\\'   \\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 1))% mod;\\n        }\\n        else if(i == 1){    //when the last character of string is \\'e\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 2))% mod;\\n        }\\n\\t\\telse if(i == 2){   //when the last character of string is \\'i\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 1))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 3))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 4))% mod;\\n        }\\n\\t\\telse if(i == 3){     //when the last character of string is \\'o\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 2))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 4))% mod;\\n        }\\n        else{   //when the last character of string is \\'u\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n        }\\n        return dp[n][i];\\n    }\\n    int countVowelPermutation(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        int res = 0;\\n        for(int i=0; i<5; i++){\\n            res += find(n, i);  \\n            res = res%mod;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char arr[5] = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int dp[100000][5];  //This dp denotes the no of string of particular length ending \\n\\t//with particular vowel. For eg. dp[i][j] denotes the total no of string of length i \\n\\t//which ends with vowel j.\\n    int mod = 1e9 + 7;\\n    int find(int n, int i){\\n        if(n == 1)return 1;  //return when string size is 1\\n        if(dp[n][i] != -1)return dp[n][i];\\n        dp[n][i] = 0;\\n\\t\\tif(i == 0){ //when the last character of string is \\'a\\'   \\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 1))% mod;\\n        }\\n        else if(i == 1){    //when the last character of string is \\'e\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 2))% mod;\\n        }\\n\\t\\telse if(i == 2){   //when the last character of string is \\'i\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 1))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 3))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 4))% mod;\\n        }\\n\\t\\telse if(i == 3){     //when the last character of string is \\'o\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 2))% mod;\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 4))% mod;\\n        }\\n        else{   //when the last character of string is \\'u\\'\\n            dp[n][i] = (dp[n][i] % mod + find(n-1, 0))% mod;\\n        }\\n        return dp[n][i];\\n    }\\n    int countVowelPermutation(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        int res = 0;\\n        for(int i=0; i<5; i++){\\n            res += find(n, i);  \\n            res = res%mod;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393032,
                "title": "dp-using-striver-s-logic-recursive-and-memoization",
                "content": "Naive recursive sol:\\n\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n        \\n    unordered_map<char, vector<char>> mappings {\\n        {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}},\\n        {\\'a\\', {\\'e\\'}},\\n        {\\'e\\', {\\'a\\', \\'i\\'}},\\n        {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}},\\n        {\\'o\\', {\\'i\\', \\'u\\'}},\\n        {\\'u\\', {\\'a\\'}}\\n    };\\n    public:\\n    \\n    int f(int idx, char prev)\\n    {\\n        if(idx == 0)\\n            return 1;\\n        \\n        int ans = 0;\\n        for(auto c: mappings.at(prev))\\n            ans = (ans + f(idx-1, c));\\n        \\n        return ans;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        return f(n, \\'s\\');\\n    }\\n};\\n```\\n\\nMemoization solution: the unordered map is replaced with a 2d vector mapping where key is now an index, so s==5\\na==4 and so on..\\nThis was done so handling of 2d DP array would be simple\\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;   \\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    \\n    public:\\n    \\n    int f(int idx, int prev, vector<vector<int>> &dp)\\n    {\\n        if(idx == 0)\\n            return 1;\\n        \\n        if(dp[prev][idx] != -1)\\n           return dp[prev][idx];\\n        \\n        dp[prev][idx] = 0;\\n        for(auto c : mappings[prev])\\n            dp[prev][idx] = (dp[prev][idx] + f(idx - 1, c, dp)) % MOD;  \\n        \\n        return (dp[prev][idx]);\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(6, vector<int> (n+1, -1));\\n        int ans = f(n, 5, dp);\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you have any doubts, do mention them in comments!",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    const int MOD = 1e9 + 7;\\n        \\n    unordered_map<char, vector<char>> mappings {\\n        {\\'s\\', {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}},\\n        {\\'a\\', {\\'e\\'}},\\n        {\\'e\\', {\\'a\\', \\'i\\'}},\\n        {\\'i\\', {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}},\\n        {\\'o\\', {\\'i\\', \\'u\\'}},\\n        {\\'u\\', {\\'a\\'}}\\n    };\\n    public:\\n    \\n    int f(int idx, char prev)\\n    {\\n        if(idx == 0)\\n            return 1;\\n        \\n        int ans = 0;\\n        for(auto c: mappings.at(prev))\\n            ans = (ans + f(idx-1, c));\\n        \\n        return ans;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        return f(n, \\'s\\');\\n    }\\n};\\n```\n```\\nclass Solution {\\n    const int MOD = 1e9 + 7;   \\n    const vector<vector<int>> mappings{{1}, {0,2}, {0,1,3,4}, {2,4}, {0}, {0,1,2,3,4}};\\n    \\n    public:\\n    \\n    int f(int idx, int prev, vector<vector<int>> &dp)\\n    {\\n        if(idx == 0)\\n            return 1;\\n        \\n        if(dp[prev][idx] != -1)\\n           return dp[prev][idx];\\n        \\n        dp[prev][idx] = 0;\\n        for(auto c : mappings[prev])\\n            dp[prev][idx] = (dp[prev][idx] + f(idx - 1, c, dp)) % MOD;  \\n        \\n        return (dp[prev][idx]);\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(6, vector<int> (n+1, -1));\\n        int ans = f(n, 5, dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392471,
                "title": "python-dp-explained-super-easy-to-understand",
                "content": "We need to generate some vowels permutations given the constraints.\\n\\nAt any point we take a decision of the character to fill next, and we have some `k` characters left to fill after the decision we made, until we get to length `n`.\\n\\nSo for example, `n=5`\\nWe could start the permutation with `\\'ae\\'` or `\\'ie\\'`\\n\\nNote that we need to fill 3 more characters, and the last character is the same, hence we have a recurring `subproblem`. Let\\'s use DP to avoid recalculating sub problems.\\n\\n`dp[i, c]` - is the number of valid permutations for string of length `i` with last character `c`\\n\\nThe final result would be the sum all permutations starting at any `vowel` with length `n`.\\n\\nOne more thing is that we create `vowel_transition` dictionary to assist us in valid transitions given the constraints.\\n\\n# Top-down\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        MOD = 10**9+7\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vowel_transition = {\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        \\n        @lru_cache(None)\\n        def dp_memo(i, c):\\n            if i == 1: return 1\\n            return sum([dp_memo(i-1, vowel) for vowel in vowel_transition[c]])\\n        \\n        ans = 0\\n        for vowel in vowels: ans = (ans + dp_memo(n, vowel)) % MOD\\n        return ans\\n```\\n\\n# Bottom-up\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        MOD = 10**9+7\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vowel_transition = {\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        \\n        # 26 columns for a to z characters easy access\\n        dp = [[0 for _ in range(26)] for _ in range(n + 1)]\\n        \\n        # base case\\n        for v in vowels: dp[1][ord(v) - ord(\\'a\\')] = 1\\n        \\n        \\n        for i in range(2, n+1):\\n            for vowel in vowels:\\n                ord_index = ord(vowel) - ord(\\'a\\')\\n                for prev_vowel in vowel_transition[vowel]:\\n                    dp[i][ord_index] = (dp[i][ord_index] + dp[i-1][ord(prev_vowel) - ord(\\'a\\')]) % MOD\\n            \\n            \\n        ans = 0\\n        for v in vowels: ans = (ans + dp[n][ord(v) - ord(\\'a\\')]) % MOD\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        MOD = 10**9+7\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vowel_transition = {\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        \\n        @lru_cache(None)\\n        def dp_memo(i, c):\\n            if i == 1: return 1\\n            return sum([dp_memo(i-1, vowel) for vowel in vowel_transition[c]])\\n        \\n        ans = 0\\n        for vowel in vowels: ans = (ans + dp_memo(n, vowel)) % MOD\\n        return ans\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\n        MOD = 10**9+7\\n        vowels = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        vowel_transition = {\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': [\\'a\\', \\'e\\', \\'o\\', \\'u\\'],\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        \\n        # 26 columns for a to z characters easy access\\n        dp = [[0 for _ in range(26)] for _ in range(n + 1)]\\n        \\n        # base case\\n        for v in vowels: dp[1][ord(v) - ord(\\'a\\')] = 1\\n        \\n        \\n        for i in range(2, n+1):\\n            for vowel in vowels:\\n                ord_index = ord(vowel) - ord(\\'a\\')\\n                for prev_vowel in vowel_transition[vowel]:\\n                    dp[i][ord_index] = (dp[i][ord_index] + dp[i-1][ord(prev_vowel) - ord(\\'a\\')]) % MOD\\n            \\n            \\n        ans = 0\\n        for v in vowels: ans = (ans + dp[n][ord(v) - ord(\\'a\\')]) % MOD\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391251,
                "title": "c-solution-time-o-n-memory-o-1-easy-to-understand-dynamic-programming",
                "content": "```C#\\npublic class Solution {\\n    private static ulong _mod = 1000000007;\\n    public int CountVowelPermutation(int n) {\\n        ulong a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n        for (int iter = 1; iter < n; iter++) {\\n            ulong nextA = e + i + u, nextE = a + i, nextI = e + o, nextO = i, nextU = i + o;\\n            a = nextA % _mod;\\n            e = nextE % _mod;\\n            i = nextI % _mod;\\n            o = nextO % _mod;\\n            u = nextU % _mod;\\n        }\\n        \\n        return (int)((a + e + i + o + u) % _mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```C#\\npublic class Solution {\\n    private static ulong _mod = 1000000007;\\n    public int CountVowelPermutation(int n) {\\n        ulong a = 1, e = 1, i = 1, o = 1, u = 1;\\n\\n        for (int iter = 1; iter < n; iter++) {\\n            ulong nextA = e + i + u, nextE = a + i, nextI = e + o, nextO = i, nextU = i + o;\\n            a = nextA % _mod;\\n            e = nextE % _mod;\\n            i = nextI % _mod;\\n            o = nextO % _mod;\\n            u = nextU % _mod;\\n        }\\n        \\n        return (int)((a + e + i + o + u) % _mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390194,
                "title": "java-solution-using-tabulation-method-full-explained",
                "content": "The question here is pretty simple , and all we have to do is use the things exactly as they have said in the question.\\nThe question tells us the characters can be followed by how many and which characters , and we have to **tell the number of permutations we can make using that of length n.** For each character that is given , since it can only be followed by the mentioned characters all we have to do is **multiply the no. of options we have to the n-1 strings which end with that specific character.** To make matter simple , let us understand this concept using an example.\\nNow **let us take n = 2,** and take character *\\'a\\'* for now. Its mentioned that it can only be followed by *\\'e\\'* , hence we can multiply all the strings of n-1 length which end with *\\'a\\'* by 1 as we only have one option here.\\nFor character *\\'e\\'* , we can multiply the n-1 strings that end with *\\'e\\'* by 2 as we have two options that is *\\'a\\'* and *\\'i\\'*.\\nFor character *\\'i\\'*, similarly we can multiply by 4. and so on. \\nHere at each step , **in order to find the strings ending with a specific character for next call we can just add number of strings that are currently having the option to add that specific character.**\\nEg. **take n = 3,**\\nStrings ending with *\\'a\\'* -> (options to add at the end of previous string ) which is in this case is 3 -> (*e , i , u*) * (options we have i.e. 1 which is *\\'e\\'* ).\\nStrings ending with *\\'e\\'* ->(options to add at the end of previous string ) which is in this case is 2 -> (*a , i* ) * (options we have i.e. 2 which is *\\'a\\'* and *\\'i \\'* ).\\nStrings ending with *\\'i\\'* ->(options to add at the end of previous string ) which is in this case is 2 -> (*e, o*) * (options we have i.e. 4 which is *\\'a\\',\\'e\\',\\'o\\',\\'u\\'* ).\\nSimilarly for u and o. We can clearly get the answer 19 for n=3 from above calculation which is correct.\\nThe pattern here can be recognized quite easily and hence recursion can be used where base case will be when n==1 , as we can accomadate any single character only when we have length 1. But recursion will be not be optimal , hence we will use tabulation.\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        \\n\\t\\t// long dp of length n used to handle big test cases and using mod efficiently\\n        long []dp = new long[n];\\n        long mod = (long)1e9+7;\\n\\t\\t// base case\\n        long ia = 1,ie = 1,ii = 1,io = 1,iu = 1; \\n        dp[0] = 5;\\n        \\n        for( int i=1; i<n; i++ ){\\n\\t\\t\\t// simply calculating current strings of length i by using previous string and current options values\\n            long tot = ((ia*1) + (ie*2) + (ii*4) + (io*2) + (iu*1))%mod;\\n            \\n\\t\\t\\t// finding out new values of strings ending with a specific character by using previous values\\n            long na = (ie+ii+iu)%mod;\\n            long ne = (ia + ii)%mod;\\n            long ni = (ie + io)%mod;\\n            long no = ii%mod;\\n            long nu = (ii+io)%mod;\\n            \\n            \\n            ia = na;\\n            ie = ne;\\n            ii = ni;\\n            io = no;\\n            iu = nu;\\n            \\n\\t\\t\\t// assigning value to dp\\n            dp[i] = tot;\\n        }\\n        \\n        return (int)dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        \\n\\t\\t// long dp of length n used to handle big test cases and using mod efficiently\\n        long []dp = new long[n];\\n        long mod = (long)1e9+7;\\n\\t\\t// base case\\n        long ia = 1,ie = 1,ii = 1,io = 1,iu = 1; \\n        dp[0] = 5;\\n        \\n        for( int i=1; i<n; i++ ){\\n\\t\\t\\t// simply calculating current strings of length i by using previous string and current options values\\n            long tot = ((ia*1) + (ie*2) + (ii*4) + (io*2) + (iu*1))%mod;\\n            \\n\\t\\t\\t// finding out new values of strings ending with a specific character by using previous values\\n            long na = (ie+ii+iu)%mod;\\n            long ne = (ia + ii)%mod;\\n            long ni = (ie + io)%mod;\\n            long no = ii%mod;\\n            long nu = (ii+io)%mod;\\n            \\n            \\n            ia = na;\\n            ie = ne;\\n            ii = ni;\\n            io = no;\\n            iu = nu;\\n            \\n\\t\\t\\t// assigning value to dp\\n            dp[i] = tot;\\n        }\\n        \\n        return (int)dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390084,
                "title": "c-easy-to-understand-beating-98",
                "content": "class Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int64_t mod = (1\\'000\\'000\\'007);\\n        if (n == 1) return 5;\\n        int64_t a = 1, e = 1, i = 1, o = 1, u = 1;\\n        while (n > 1) {\\n            int64_t new_e  = (a + i ) % mod;\\n            int64_t new_a = (e + u + i) % mod;\\n            int64_t new_i = (e + o) % mod;\\n            int64_t new_o = i;\\n            int64_t new_u = (i + o) % mod;\\n            a = new_a, e = new_e, i = new_i, o = new_o, u = new_u;\\n            n--;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int64_t mod = (1\\'000\\'000\\'007);\\n        if (n == 1) return 5;\\n        int64_t a = 1, e = 1, i = 1, o = 1, u = 1;\\n        while (n > 1) {\\n            int64_t new_e  = (a + i ) % mod;\\n            int64_t new_a = (e + u + i) % mod;\\n            int64_t new_i = (e + o) % mod;\\n            int64_t new_o = i;\\n            int64_t new_u = (i + o) % mod;\\n            a = new_a, e = new_e, i = new_i, o = new_o, u = new_u;\\n            n--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1509696,
                "title": "java-dp-recursion-memoization-scales-beyond-n-2-10-4",
                "content": "```\\nclass Solution {\\n    \\n    private static Map<String, Long> memoizedPermutations = new HashMap<>();\\n    private static int MOD = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        return (int) ((helper(n, \\'a\\') + helper(n, \\'e\\') + helper(n, \\'i\\') + helper(n, \\'o\\') + helper(n, \\'u\\')) % MOD);\\n    }\\n    \\n    private long helper(int n, char currentChar) {\\n        if (n == 1) return 1L;\\n        String key = String.valueOf(n) + String.valueOf(currentChar);\\n        long val = memoizedPermutations.getOrDefault(key, -1L);\\n        if (val != -1L) return val;\\n        switch (currentChar) {\\n            case \\'a\\':\\n                val = helper(n-1, \\'e\\');\\n                break;\\n            case \\'e\\':\\n                val = (helper(n-1, \\'a\\') + helper(n-1, \\'i\\'));\\n                break;\\n            case \\'i\\':\\n                val = (helper(n-1, \\'a\\') + helper(n-1, \\'e\\') + helper(n-1, \\'o\\') + helper(n-1, \\'u\\'));\\n                break;\\n            case \\'o\\':\\n                val = (helper(n-1, \\'i\\') + helper(n-1, \\'u\\'));\\n                break;\\n            case \\'u\\':\\n                val = (helper(n-1, \\'a\\'));\\n                break;\\n            default :\\n                // throw new IllegalArgumentException(\"Character can only be one of the vowels - \\'a\\', \\'e\\', \\'i\\', \\'o\\' and \\'u\\'.\");\\n                return 0;\\n        }\\n        memoizedPermutations.put(key, val % MOD);\\n        return val;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    private static Map<String, Long> memoizedPermutations = new HashMap<>();\\n    private static int MOD = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        return (int) ((helper(n, \\'a\\') + helper(n, \\'e\\') + helper(n, \\'i\\') + helper(n, \\'o\\') + helper(n, \\'u\\')) % MOD);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1476536,
                "title": "c-dp-explanation",
                "content": "Lets just write the cases which are acceptable\\n\\n```\\nae\\nea  ei\\nia  ie  io  iu\\noi  ou\\nua\\n```\\nTherefore, for any \\'a\\' we can have \\'e\\', \\'i\\', \\'u\\' as the predecessor. Lets write for each vowel\\n```\\na --> e  i  u             dp[i][0] = dp[i-1][1] + dp[i-1][2] + dp[i-1][4]\\ne --> i  a                dp[i][1] = dp[i-1][2] + dp[i-1][0]\\ni --> e  o                dp[i][2] = dp[i-1][1] + dp[i-1][3]\\no --> i                   dp[i][3] = dp[i-1][2]\\nu --> o  i                dp[i][4] = dp[i-1][3] + dp[i-1][2]\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<long long int> > dp(n, vector<long long int>(5,0));\\n        int mod = 1e9+7;\\n        \\n        for(int i=0;i<5;i++){\\n            dp[0][i]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            dp[i][0] = (dp[i-1][1] + dp[i-1][2] + dp[i-1][4])%mod;\\n            \\n            dp[i][1] = (dp[i-1][2] + dp[i-1][0])%mod;\\n            \\n            dp[i][2] = (dp[i-1][1] + dp[i-1][3])%mod;\\n            \\n            dp[i][3] = (dp[i-1][2])%mod;\\n            \\n            dp[i][4] = (dp[i-1][3] + dp[i-1][2])%mod;\\n        }\\n        \\n        long long int sum=0;\\n        \\n        for(int i=0;i<5;i++){\\n            sum+=dp[n-1][i];\\n            sum%=mod;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nae\\nea  ei\\nia  ie  io  iu\\noi  ou\\nua\\n```\n```\\na --> e  i  u             dp[i][0] = dp[i-1][1] + dp[i-1][2] + dp[i-1][4]\\ne --> i  a                dp[i][1] = dp[i-1][2] + dp[i-1][0]\\ni --> e  o                dp[i][2] = dp[i-1][1] + dp[i-1][3]\\no --> i                   dp[i][3] = dp[i-1][2]\\nu --> o  i                dp[i][4] = dp[i-1][3] + dp[i-1][2]\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<long long int> > dp(n, vector<long long int>(5,0));\\n        int mod = 1e9+7;\\n        \\n        for(int i=0;i<5;i++){\\n            dp[0][i]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            dp[i][0] = (dp[i-1][1] + dp[i-1][2] + dp[i-1][4])%mod;\\n            \\n            dp[i][1] = (dp[i-1][2] + dp[i-1][0])%mod;\\n            \\n            dp[i][2] = (dp[i-1][1] + dp[i-1][3])%mod;\\n            \\n            dp[i][3] = (dp[i-1][2])%mod;\\n            \\n            dp[i][4] = (dp[i-1][3] + dp[i-1][2])%mod;\\n        }\\n        \\n        long long int sum=0;\\n        \\n        for(int i=0;i<5;i++){\\n            sum+=dp[n-1][i];\\n            sum%=mod;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413566,
                "title": "explained-clean-o-n-dp-remaining-choices-depends-on-previous-choice",
                "content": "Each vowel has only specific vowels allowed in next position, we will make this mapping and call it `adj` \\n```\\n\\'a\\': [\\'e\\'],\\n\\'e\\': [\\'a\\', \\'i\\'],\\n\\'i\\':  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'],\\n\\'o\\': [\\'i\\', \\'u\\'],\\n\\'u\\': [\\'a\\']\\n```\\nI have to pick `N` chars\\n--> At the given moment, I have a choice of picking any char which is adjacent to previous ...\\n\\n## So what is the state/relation ?\\n\\n- Answer depends on `N` and `prev` \\n\\n```\\nDP(prev, N) = ? = ans\\nans = 0\\nfor vowel in adj[prev]:\\n  ans += DP(vowel, N - 1)\\n```\\n\\n## \\uD83D\\uDE01What about base case ?\\nOnly one possible way of length zero, `\\'\\'` \\n- i.e. empty string so..\\n- `if N == 0: return 1`\\n\\n\\n## What is our final answer ?\\nInitially we can pick any `vowel` \\n- let base case be represented as `prev = 0`\\nso `adj[0] = [ \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' ]`\\nand our final answer is `DP(prev=0, N)`\\n## yayy but why DP ?\\n- same state can be reached multiple times.... \\n\\t- overlapping subproblems \\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        self.adj = {\\n            \\'0\\': list(vowels),\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': list(vowels - {\\'i\\'}),\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        @functools.cache\\n        def ways(prev, n):\\n            if n == 0: return 1\\n            res = 0\\n            for cur in self.adj[prev]:\\n                res = (res + ways(cur,n-1)) % (10**9+7)\\n            return res\\n    \\n        return ways(\\'0\\', n)\\n    \\n    # LOG N is possible WOW https://leetcode.com/problems/count-vowels-permutation/discuss/398173/C%2B%2B-Bottom-up-Recursive-DPs-O(n)-and-Matrix-Exponentiation-O(logn)  \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\'a\\': [\\'e\\'],\\n\\'e\\': [\\'a\\', \\'i\\'],\\n\\'i\\':  [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'],\\n\\'o\\': [\\'i\\', \\'u\\'],\\n\\'u\\': [\\'a\\']\\n```\n```\\nDP(prev, N) = ? = ans\\nans = 0\\nfor vowel in adj[prev]:\\n  ans += DP(vowel, N - 1)\\n```\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        self.adj = {\\n            \\'0\\': list(vowels),\\n            \\'a\\': [\\'e\\'],\\n            \\'e\\': [\\'a\\', \\'i\\'],\\n            \\'i\\': list(vowels - {\\'i\\'}),\\n            \\'o\\': [\\'i\\', \\'u\\'],\\n            \\'u\\': [\\'a\\']\\n        }\\n        @functools.cache\\n        def ways(prev, n):\\n            if n == 0: return 1\\n            res = 0\\n            for cur in self.adj[prev]:\\n                res = (res + ways(cur,n-1)) % (10**9+7)\\n            return res\\n    \\n        return ways(\\'0\\', n)\\n    \\n    # LOG N is possible WOW https://leetcode.com/problems/count-vowels-permutation/discuss/398173/C%2B%2B-Bottom-up-Recursive-DPs-O(n)-and-Matrix-Exponentiation-O(logn)  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316138,
                "title": "python-simple-and-short-solution-with-o-n-time-and-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod=1000000007\\n        a=e=i=o=u=1\\n        for _ in range(n-1):\\n            a, e, i, o, u=(e+i+u)%mod, (a+i)%mod, (e+o)%mod, i%mod, (i+o)%mod\\n        return (a+e+i+o+u)%mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod=1000000007\\n        a=e=i=o=u=1\\n        for _ in range(n-1):\\n            a, e, i, o, u=(e+i+u)%mod, (a+i)%mod, (e+o)%mod, i%mod, (i+o)%mod\\n        return (a+e+i+o+u)%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315743,
                "title": "rust-solution",
                "content": "```rust\\nconst MOD: u32 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn count_vowel_permutation(n: i32) -> i32 {\\n        ((1..n)\\n            .fold([1; 5], |v, _| {\\n                [\\n                    (v[1] + v[2] + v[4]) % MOD,\\n                    (v[0] + v[2]) % MOD,\\n                    (v[1] + v[3]) % MOD,\\n                    (v[2]) % MOD,\\n                    (v[2] + v[3]) % MOD,\\n                ]\\n            })\\n            .iter()\\n            .sum::<u32>()\\n            % MOD) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nconst MOD: u32 = 1_000_000_007;\\n\\nimpl Solution {\\n    pub fn count_vowel_permutation(n: i32) -> i32 {\\n        ((1..n)\\n            .fold([1; 5], |v, _| {\\n                [\\n                    (v[1] + v[2] + v[4]) % MOD,\\n                    (v[0] + v[2]) % MOD,\\n                    (v[1] + v[3]) % MOD,\\n                    (v[2]) % MOD,\\n                    (v[2] + v[3]) % MOD,\\n                ]\\n            })\\n            .iter()\\n            .sum::<u32>()\\n            % MOD) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315444,
                "title": "c-matrix-exponentation-log-n-running-time",
                "content": "The following implementation would require the some prior knowledge in Matrix Exponentiation\\n\\nLet us map the vowels ```{a,e,i,o,u}  to numbers  {0,1,2,3,4}```. \\nThe dp transition looks like\\n```\\ndp[i][0]=dp[i-1][1]+dp[i-1][2]+dp[i-1][4]\\ndp[i][1]=dp[i-1][0]+dp[i-1][2]\\ndp[i][2]=dp[i-1][1]+dp[i-1][3]\\ndp[i][3]=dp[i-1][2]\\ndp[i][4]=dp[i-1][2]+dp[i-1][3]\\n```\\nRepresenting this above transition using matrix and using ``` dp[0]=dp[1]=dp[2]=dp[3]=dp[4]=1 initially ``` we can calculate ```path[i][j] for all i=[0,4] and all j=[0,4] after n iterations (where path[i][j] represents total strings which have character i after n iterations and we started with character j in the begining)``` in ``` log(n)``` time by using binary exponentiation\\n\\n\\nHere is the simple implementation of above approach \\n```\\n#define rep(i,n) for(int i=0;i<n;i++)\\n// Initialize a matrix construct\\nlong long m=1e9+7;\\nstruct Matrix{\\n    vector< vector<long long> >a=vector<vector<long long>>(5,vector<long long>(5,0));\\n    Matrix operator *(const Matrix& other){\\n        Matrix product;\\n        rep(i,5)rep(j,5)rep(k,5){\\n            product.a[i][k]=((product.a[i][k])+(a[i][j]) * (other.a[j][k]))%m;\\n                   }\\n        return product;\\n    }\\n};\\n// Function for binary exponentiation of matrices\\nMatrix binpow(Matrix a, long long b) {\\n    Matrix res;\\n    rep(i,5)res.a[i][i]=1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a ;\\n        a = a * a ;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        \\n        Matrix Transition;\\n        Transition.a[0][1]=1;\\n        Transition.a[0][2]=1;\\n        Transition.a[0][4]=1;\\n        \\n        Transition.a[1][0]=1;\\n        Transition.a[1][2]=1;\\n        \\n        Transition.a[2][1]=1;\\n        Transition.a[2][3]=1;\\n        \\n        Transition.a[3][2]=1;\\n        \\n        Transition.a[4][2]=1;\\n        Transition.a[4][3]=1;\\n        \\n        Matrix ans=binpow(Transition,n-1);\\n        long long sum=0;\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<5;j++){\\n                sum=(sum+ans.a[i][j])%m;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```{a,e,i,o,u}  to numbers  {0,1,2,3,4}```\n```\\ndp[i][0]=dp[i-1][1]+dp[i-1][2]+dp[i-1][4]\\ndp[i][1]=dp[i-1][0]+dp[i-1][2]\\ndp[i][2]=dp[i-1][1]+dp[i-1][3]\\ndp[i][3]=dp[i-1][2]\\ndp[i][4]=dp[i-1][2]+dp[i-1][3]\\n```\n``` dp[0]=dp[1]=dp[2]=dp[3]=dp[4]=1 initially ```\n```path[i][j] for all i=[0,4] and all j=[0,4] after n iterations (where path[i][j] represents total strings which have character i after n iterations and we started with character j in the begining)```\n``` log(n)```\n```\\n#define rep(i,n) for(int i=0;i<n;i++)\\n// Initialize a matrix construct\\nlong long m=1e9+7;\\nstruct Matrix{\\n    vector< vector<long long> >a=vector<vector<long long>>(5,vector<long long>(5,0));\\n    Matrix operator *(const Matrix& other){\\n        Matrix product;\\n        rep(i,5)rep(j,5)rep(k,5){\\n            product.a[i][k]=((product.a[i][k])+(a[i][j]) * (other.a[j][k]))%m;\\n                   }\\n        return product;\\n    }\\n};\\n// Function for binary exponentiation of matrices\\nMatrix binpow(Matrix a, long long b) {\\n    Matrix res;\\n    rep(i,5)res.a[i][i]=1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = res * a ;\\n        a = a * a ;\\n        b >>= 1;\\n    }\\n    return res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        \\n        Matrix Transition;\\n        Transition.a[0][1]=1;\\n        Transition.a[0][2]=1;\\n        Transition.a[0][4]=1;\\n        \\n        Transition.a[1][0]=1;\\n        Transition.a[1][2]=1;\\n        \\n        Transition.a[2][1]=1;\\n        Transition.a[2][3]=1;\\n        \\n        Transition.a[3][2]=1;\\n        \\n        Transition.a[4][2]=1;\\n        Transition.a[4][3]=1;\\n        \\n        Matrix ans=binpow(Transition,n-1);\\n        long long sum=0;\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<5;j++){\\n                sum=(sum+ans.a[i][j])%m;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314945,
                "title": "go-dynamic-programming-o-n-time-0ms",
                "content": "```\\nfunc countVowelPermutation(n int) int {\\n    var mod int64 = 1000000007\\n    var a , e, i, o, u int64 = 1, 1, 1, 1, 1\\n    for p:=1;p<n; p++ {\\n        aNew := (e+i+u) % mod\\n        eNew := (a+i) % mod\\n        iNew := (e+o) % mod\\n        oNew := i % mod\\n        uNew := (i+o) % mod\\n        a, e,i,o,u = aNew, eNew, iNew, oNew, uNew\\n    }\\n    return int((a+e+i+o+u)%mod)\\n}",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc countVowelPermutation(n int) int {\\n    var mod int64 = 1000000007\\n    var a , e, i, o, u int64 = 1, 1, 1, 1, 1\\n    for p:=1;p<n; p++ {\\n        aNew := (e+i+u) % mod\\n        eNew := (a+i) % mod\\n        iNew := (e+o) % mod\\n        oNew := i % mod\\n        uNew := (i+o) % mod\\n        a, e,i,o,u = aNew, eNew, iNew, oNew, uNew\\n    }\\n    return int((a+e+i+o+u)%mod)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 450421,
                "title": "simple-dp-solution-java-with-comments",
                "content": "```\\n long[][] dp;\\n    int mod = ((int)Math.pow(10,9))+7;\\n    public int countVowelPermutation(int n) {\\n        dp = new long[n+1][5]; // 0-> a, 1->e, 2->i, 3->o,4->u\\n        for(int i=0;i<5;i++) { // if n==1 we can only have 1 type of each character.\\n            dp[1][i]=1;\\n        }\\n        int sum=0;\\n        for (int i=0;i<5;i++) {\\n            sum=(sum+util(n,i))%mod;\\n        }\\n        return sum;\\n    }\\n\\n    private int util(int n,int index) {\\n        if(dp[n][index]!=0) { // Number of ways when we have n count left and we are at the vowel with index i.\\n            return (int) dp[n][index];\\n        }\\n        long sum=0;\\n        switch(index) {\\n            case 0:// If \\'a\\' is the current char we can only have an \\'e\\' as the next char\\n                sum = (sum+util(n-1,1))%mod;\\n                break;\\n            case 1:// If \\'e\\' is the current char we can only have \\'a\\' & \\'i\\' as the next char\\n                sum = (sum+util(n-1,0)+util(n-1,2))%mod;//\\n                break;\\n            case 2:// If \\'i\\' is the current char we can have any character follow it except \\'i\\'\\n                sum = (sum+util(n-1,0)+util(n-1,1)+util(n-1,3)+util(n-1,4))%mod;\\n                break;\\n            case 3:// If \\'o\\' is the current char we can only have \\'i\\' & \\'u\\' as the next char\\n                sum = (sum+util(n-1,2)+util(n-1,4))%mod;\\n                break;\\n            case 4:// If \\'u\\' is the current char we can only have an \\'a\\' as the next char\\n                sum = (sum+util(n-1,0))%mod;\\n                break;\\n        }\\n\\n        dp[n][index]=sum;\\n        return (int) sum;\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n long[][] dp;\\n    int mod = ((int)Math.pow(10,9))+7;\\n    public int countVowelPermutation(int n) {\\n        dp = new long[n+1][5]; // 0-> a, 1->e, 2->i, 3->o,4->u\\n        for(int i=0;i<5;i++) { // if n==1 we can only have 1 type of each character.\\n            dp[1][i]=1;\\n        }\\n        int sum=0;\\n        for (int i=0;i<5;i++) {\\n            sum=(sum+util(n,i))%mod;\\n        }\\n        return sum;\\n    }\\n\\n    private int util(int n,int index) {\\n        if(dp[n][index]!=0) { // Number of ways when we have n count left and we are at the vowel with index i.\\n            return (int) dp[n][index];\\n        }\\n        long sum=0;\\n        switch(index) {\\n            case 0:// If \\'a\\' is the current char we can only have an \\'e\\' as the next char\\n                sum = (sum+util(n-1,1))%mod;\\n                break;\\n            case 1:// If \\'e\\' is the current char we can only have \\'a\\' & \\'i\\' as the next char\\n                sum = (sum+util(n-1,0)+util(n-1,2))%mod;//\\n                break;\\n            case 2:// If \\'i\\' is the current char we can have any character follow it except \\'i\\'\\n                sum = (sum+util(n-1,0)+util(n-1,1)+util(n-1,3)+util(n-1,4))%mod;\\n                break;\\n            case 3:// If \\'o\\' is the current char we can only have \\'i\\' & \\'u\\' as the next char\\n                sum = (sum+util(n-1,2)+util(n-1,4))%mod;\\n                break;\\n            case 4:// If \\'u\\' is the current char we can only have an \\'a\\' as the next char\\n                sum = (sum+util(n-1,0))%mod;\\n                break;\\n        }\\n\\n        dp[n][index]=sum;\\n        return (int) sum;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399077,
                "title": "python-dfs-memoization",
                "content": "Memo[c, i] saved total number of vowel permutation which starts with character c and has a length of i+1.\\n\"$\" serves as the root of the vowels graph.\\n```\\ndef countVowelPermutation(n):\\n\\tgraph = {\\n\\t\\t\"$\":\"aeiou\",\\n\\t\\t\"a\":\"e\",\\n\\t\\t\"e\":\"ai\",\\n\\t\\t\"i\":\"aeou\",\\n\\t\\t\"o\":\"iu\",\\n\\t\\t\"u\":\"a\",\\n\\t}\\n\\tmemo = {(c,0):1 for c in \"aeiou\"}\\n\\tM = 10**9+7\\n\\tdef dfs(x, n):\\n\\t\\tif (x,n) not in memo\\n\\t\\t\\tmemo[x,n] = sum(dfs(y, n-1) for y in graph[x]) % M\\n\\t\\treturn memo[x,n]\\n\\treturn dfs(\"$\", n)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countVowelPermutation(n):\\n\\tgraph = {\\n\\t\\t\"$\":\"aeiou\",\\n\\t\\t\"a\":\"e\",\\n\\t\\t\"e\":\"ai\",\\n\\t\\t\"i\":\"aeou\",\\n\\t\\t\"o\":\"iu\",\\n\\t\\t\"u\":\"a\",\\n\\t}\\n\\tmemo = {(c,0):1 for c in \"aeiou\"}\\n\\tM = 10**9+7\\n\\tdef dfs(x, n):\\n\\t\\tif (x,n) not in memo\\n\\t\\t\\tmemo[x,n] = sum(dfs(y, n-1) for y in graph[x]) % M\\n\\t\\treturn memo[x,n]\\n\\treturn dfs(\"$\", n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 398198,
                "title": "python3-straightforward",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        dp = [1] * 5\\n        for _ in range(n - 1):\\n            add = [0] * 5\\n            # from a\\n            add[1] = (add[1] + dp[0]) % mod\\n            # from e\\n            add[0] = (add[0] + dp[1]) % mod\\n            add[2] = (add[2] + dp[1]) % mod\\n            # from i\\n            add[0] = (add[0] + dp[2]) % mod\\n            add[1] = (add[1] + dp[2]) % mod\\n            add[3] = (add[3] + dp[2]) % mod\\n            add[4] = (add[4] + dp[2]) % mod\\n            # from o\\n            add[2] = (add[2] + dp[3]) % mod\\n            add[4] = (add[4] + dp[3]) % mod\\n            # from u\\n            add[0] = (add[0] + dp[4]) % mod\\n            for i in range(5):\\n                dp[i] = add[i] % mod\\n        return sum(dp) % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mod = 10 ** 9 + 7\\n        dp = [1] * 5\\n        for _ in range(n - 1):\\n            add = [0] * 5\\n            # from a\\n            add[1] = (add[1] + dp[0]) % mod\\n            # from e\\n            add[0] = (add[0] + dp[1]) % mod\\n            add[2] = (add[2] + dp[1]) % mod\\n            # from i\\n            add[0] = (add[0] + dp[2]) % mod\\n            add[1] = (add[1] + dp[2]) % mod\\n            add[3] = (add[3] + dp[2]) % mod\\n            add[4] = (add[4] + dp[2]) % mod\\n            # from o\\n            add[2] = (add[2] + dp[3]) % mod\\n            add[4] = (add[4] + dp[3]) % mod\\n            # from u\\n            add[0] = (add[0] + dp[4]) % mod\\n            for i in range(5):\\n                dp[i] = add[i] % mod\\n        return sum(dp) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393120,
                "title": "java-o-n-extremely-easy-and-short-dp-solution-with-two-dimension-array",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n      int mod = 1000000007;\\n      long[][]combinations = new long[5][n];\\n        for (int i=0;i<=4;i++)combinations[i][0]=1;\\n        for (int i=1;i<n;i++){\\n              combinations[0][i]=combinations[1][i-1];\\n              combinations[1][i]=(combinations[0][i-1]+combinations[2][i-1])%mod;\\n              combinations[2][i]=(combinations[0][i-1]+combinations[1][i-1]+combinations[3][i-1]+combinations[4][i-1])%mod;\\n              combinations[3][i]=(combinations[2][i-1]+combinations[4][i-1])%mod;\\n              combinations[4][i]=combinations[0][i-1];\\n        }\\n        return (int)((combinations[0][n-1]+combinations[1][n-1]+combinations[2][n-1]+combinations[3][n-1]+combinations[4][n-1])%mod);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n      int mod = 1000000007;\\n      long[][]combinations = new long[5][n];\\n        for (int i=0;i<=4;i++)combinations[i][0]=1;\\n        for (int i=1;i<n;i++){\\n              combinations[0][i]=combinations[1][i-1];\\n              combinations[1][i]=(combinations[0][i-1]+combinations[2][i-1])%mod;\\n              combinations[2][i]=(combinations[0][i-1]+combinations[1][i-1]+combinations[3][i-1]+combinations[4][i-1])%mod;\\n              combinations[3][i]=(combinations[2][i-1]+combinations[4][i-1])%mod;\\n              combinations[4][i]=combinations[0][i-1];\\n        }\\n        return (int)((combinations[0][n-1]+combinations[1][n-1]+combinations[2][n-1]+combinations[3][n-1]+combinations[4][n-1])%mod);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392178,
                "title": "easy-c-solution-4-approaches-recursion-top-down-bottom-up-space-optimized",
                "content": "#  -> Approach 1: Recursion (TLE)\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        if(n==1)\\n            return 5;\\n        \\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        int c=0;\\n        for(int i=0; i<5; i++)\\n            c += count(i, 1, n, vowels);\\n            \\n        return c;\\n    }\\n    \\n    int count(int prev, int len, int n, vector<int> vowels){\\n        if(len==n)\\n            return 1;\\n        \\n        if(prev == 0)\\n            return count(1, len+1, n, vowels);\\n        if(prev == 1)\\n            return count(0, len+1, n, vowels)+count(2, len+1, n, vowels);\\n        if(prev == 2)\\n            return count(0, len+1, n, vowels)+count(1, len+1, n, vowels)+\\n                   count(3, len+1, n, vowels)+count(4, len+1, n, vowels);\\n        if(prev == 3)\\n            return count(2, len+1, n, vowels)+count(4, len+1, n, vowels);\\n        if(prev == 4)\\n            return count(0, len+1, n, vowels);\\n        \\n        return 0;\\n    }\\n};\\n```\\n\\n#  -> Approach 2: Top-Down (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        if(n==1)\\n            return 5;\\n        \\n        vector<vector<int>> dp(5, vector<int> (n+1, -1));\\n        for(int i=0; i<5; i++)\\n            dp[i][n]=1;\\n        \\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        int c=0;\\n        for(int i=0; i<5; i++)\\n            c = (c+count(i, 1, n, vowels, dp))%mod;\\n            \\n        return c;\\n    }\\n    \\n    long long int count(int prev, int len, int n, vector<int> vowels, vector<vector<int>> &dp){\\n        if(dp[prev][len] != -1)\\n            return dp[prev][len]%mod;\\n        \\n        long long int c=0;\\n        if(prev == 0)\\n            c = count(1, len+1, n, vowels, dp)%mod;\\n        else if(prev == 1)\\n            c = (count(0, len+1, n, vowels, dp)+count(2, len+1, n, vowels, dp))%mod;\\n        else if(prev == 2)\\n            c = (count(0, len+1, n, vowels, dp)+count(1, len+1, n, vowels, dp)+\\n                    count(3, len+1, n, vowels, dp)+count(4, len+1, n, vowels, dp))%mod;\\n        else if(prev == 3)\\n            c = (count(2, len+1, n, vowels, dp)+count(4, len+1, n, vowels, dp))%mod;\\n        else if(prev == 4)\\n            c = (count(0, len+1, n, vowels, dp))%mod;\\n        \\n        return dp[prev][len] = c;\\n    }\\n};\\n```\\n\\n#  -> Approach 3: Bottom-Up (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        vector<vector<long>> dp(5, vector<long> (n+1, 0));\\n        for(int i=0; i<5; i++)\\n            dp[i][n]=1;\\n        \\n      \\n        for(int len=n-1; len>0; len--){\\n            dp[0][len]=  (dp[1][len+1])%mod;\\n            dp[1][len] = (dp[0][len+1]+dp[2][len+1])%mod;\\n            dp[2][len] = (dp[0][len+1]+dp[1][len+1]+dp[3][len+1]+dp[4][len+1])%mod;\\n            dp[3][len] = (dp[2][len+1]+dp[4][len+1])%mod;\\n            dp[4][len] = (dp[0][len+1])%mod;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<5; i++)\\n            ans = (ans+dp[i][1])%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n#  -> Approach 4: Space Optimisation (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        vector<long> prev(5, 1);\\n      \\n        vector<long> curr(5, 0);\\n        for(int len=n-1; len>0; len--){\\n            curr[0] = prev[1]%mod;\\n            curr[1] = (prev[0]+prev[2])%mod;\\n            curr[2] = (prev[0]+prev[1]+prev[3]+prev[4])%mod;\\n            curr[3] = (prev[2]+prev[4])%mod;\\n            curr[4] = (prev[0])%mod;\\n            \\n            prev = curr;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<5; i++)\\n            ans = (ans+prev[i])%mod;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        if(n==1)\\n            return 5;\\n        \\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        int c=0;\\n        for(int i=0; i<5; i++)\\n            c += count(i, 1, n, vowels);\\n            \\n        return c;\\n    }\\n    \\n    int count(int prev, int len, int n, vector<int> vowels){\\n        if(len==n)\\n            return 1;\\n        \\n        if(prev == 0)\\n            return count(1, len+1, n, vowels);\\n        if(prev == 1)\\n            return count(0, len+1, n, vowels)+count(2, len+1, n, vowels);\\n        if(prev == 2)\\n            return count(0, len+1, n, vowels)+count(1, len+1, n, vowels)+\\n                   count(3, len+1, n, vowels)+count(4, len+1, n, vowels);\\n        if(prev == 3)\\n            return count(2, len+1, n, vowels)+count(4, len+1, n, vowels);\\n        if(prev == 4)\\n            return count(0, len+1, n, vowels);\\n        \\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        if(n==1)\\n            return 5;\\n        \\n        vector<vector<int>> dp(5, vector<int> (n+1, -1));\\n        for(int i=0; i<5; i++)\\n            dp[i][n]=1;\\n        \\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        int c=0;\\n        for(int i=0; i<5; i++)\\n            c = (c+count(i, 1, n, vowels, dp))%mod;\\n            \\n        return c;\\n    }\\n    \\n    long long int count(int prev, int len, int n, vector<int> vowels, vector<vector<int>> &dp){\\n        if(dp[prev][len] != -1)\\n            return dp[prev][len]%mod;\\n        \\n        long long int c=0;\\n        if(prev == 0)\\n            c = count(1, len+1, n, vowels, dp)%mod;\\n        else if(prev == 1)\\n            c = (count(0, len+1, n, vowels, dp)+count(2, len+1, n, vowels, dp))%mod;\\n        else if(prev == 2)\\n            c = (count(0, len+1, n, vowels, dp)+count(1, len+1, n, vowels, dp)+\\n                    count(3, len+1, n, vowels, dp)+count(4, len+1, n, vowels, dp))%mod;\\n        else if(prev == 3)\\n            c = (count(2, len+1, n, vowels, dp)+count(4, len+1, n, vowels, dp))%mod;\\n        else if(prev == 4)\\n            c = (count(0, len+1, n, vowels, dp))%mod;\\n        \\n        return dp[prev][len] = c;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        vector<vector<long>> dp(5, vector<long> (n+1, 0));\\n        for(int i=0; i<5; i++)\\n            dp[i][n]=1;\\n        \\n      \\n        for(int len=n-1; len>0; len--){\\n            dp[0][len]=  (dp[1][len+1])%mod;\\n            dp[1][len] = (dp[0][len+1]+dp[2][len+1])%mod;\\n            dp[2][len] = (dp[0][len+1]+dp[1][len+1]+dp[3][len+1]+dp[4][len+1])%mod;\\n            dp[3][len] = (dp[2][len+1]+dp[4][len+1])%mod;\\n            dp[4][len] = (dp[0][len+1])%mod;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<5; i++)\\n            ans = (ans+dp[i][1])%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int countVowelPermutation(int n) {\\n        vector<int> vowels({\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'});\\n        vector<long> prev(5, 1);\\n      \\n        vector<long> curr(5, 0);\\n        for(int len=n-1; len>0; len--){\\n            curr[0] = prev[1]%mod;\\n            curr[1] = (prev[0]+prev[2])%mod;\\n            curr[2] = (prev[0]+prev[1]+prev[3]+prev[4])%mod;\\n            curr[3] = (prev[2]+prev[4])%mod;\\n            curr[4] = (prev[0])%mod;\\n            \\n            prev = curr;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<5; i++)\\n            ans = (ans+prev[i])%mod;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391368,
                "title": "recursive-to-dynamic-programming-explained",
                "content": "Recursive(TLE) :If you want how this is working then uncommnet and see the out at each stage surely you will get the idea.\\n```\\nclass Solution {\\n    static List<String> list;\\n    //static Map<String,List<String>> mp;\\n    public int countVowelPermutation(int n){\\n          list=new ArrayList();\\n          list.add(\"a\");\\n          list.add(\"e\");\\n          list.add(\"i\");\\n          list.add(\"o\");\\n          list.add(\"u\");\\n        \\n        Map<String,List<String>> mp=new HashMap<>();\\n        mp.put(\"a\",new ArrayList<String>());\\n        mp.get(\"a\").add(\"e\");\\n        \\n        //System.out.println(mp.get(\"a\"));\\n        \\n        mp.put(\"e\",new ArrayList<String>());\\n        mp.get(\"e\").add(\"a\");\\n        mp.get(\"e\").add(\"i\");\\n        \\n        mp.put(\"i\",new ArrayList());\\n        mp.get(\"i\").add(\"a\");\\n        mp.get(\"i\").add(\"e\");\\n        mp.get(\"i\").add(\"o\");\\n        mp.get(\"i\").add(\"u\");\\n        \\n        mp.put(\"o\",new ArrayList());\\n        mp.get(\"o\").add(\"i\");\\n        mp.get(\"o\").add(\"u\");\\n        \\n        mp.put(\"u\",new ArrayList());\\n        mp.get(\"u\").add(\"a\");\\n        \\n        List<String> ans=new ArrayList();\\n        \\n        \\n        return solve(0,n,ans,mp,new StringBuilder(\"\"),new HashMap<String,Integer>());\\n    }\\n    \\n    \\n    public static int solve(int idx,int end,List<String> ans,Map<String,List<String>> mp,StringBuilder asf,HashMap<String,Integer> dict){\\n        if(idx==end){\\n            //System.out.println(asf);\\n            ans.add(asf.toString());\\n            return 1;\\n        }\\n        \\n        String key=idx+\"#\"+asf+\"#\";\\n        \\n        if(dict.containsKey(key)==true){\\n            System.out.println(key);\\n             return dict.get(key);\\n        }\\n        \\n        int count=0;\\n        \\n        if(idx==0){\\n              for(int i=0;i<list.size();i++){\\n                 asf.append(list.get(i)+\"\");\\n                 count+=solve(idx+1,end,ans,mp,asf,dict);\\n                 asf.deleteCharAt(idx);\\n              }\\n        }else{\\n             for(int i=0;i<list.size();i++){\\n                 List<String> find=mp.get(list.get(i));\\n                // System.out.println(list.get(i)+\" \"+asf.charAt(idx-1)+\" \"+idx);\\n                 if(find==null) continue;\\n                 if(find.contains(asf.charAt(idx-1)+\"\")==false) continue; \\n                 asf.append(list.get(i)+\"\");\\n                 count+=solve(idx+1,end,ans,mp,asf,dict);\\n                 asf.deleteCharAt(idx);\\n             }\\n        }\\n        \\n        dict.put(key,count);\\n        \\n        // for(Map.Entry<String,List<String>> ent: mp.entrySet()){\\n        //     System.out.println(ent.getKey() +\" \"+ ent.getValue());\\n        // }\\n        \\n        return count;\\n```\\n\\nDynamic Programming(Accepted)\\ndp[i][j] : stores the count of strings of length i which ends at char j.\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[][] dp=new long[n+1][5];\\n        \\n        for(int i=0;i<5;i++){\\n            dp[1][i]=1;\\n        }\\n        \\n        int mod=(int)1e9 +7;\\n        \\n        for(int i=2;i<=n;i++){ \\n             dp[i][0]=(dp[i-1][1] )% mod;  \\n             dp[i][1]=(dp[i-1][0] + dp[i-1][2])% mod;\\n             dp[i][2]=(dp[i-1][0] + dp[i-1][1] +dp[i-1][3] + dp[i-1][4] )% mod;\\n             dp[i][3]=(dp[i-1][2] + dp[i-1][4])% mod;\\n             dp[i][4]=(dp[i-1][0])% mod;\\n        }\\n        \\n        long count=0;\\n        for(int j=0;j<5;j++){\\n            count=( count + dp[n][j])%mod;\\n        }\\n        \\n        return (int)count;\\n        \\n    }\\n}\\n```\\n\\n```\\nplz upvote if you like\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static List<String> list;\\n    //static Map<String,List<String>> mp;\\n    public int countVowelPermutation(int n){\\n          list=new ArrayList();\\n          list.add(\"a\");\\n          list.add(\"e\");\\n          list.add(\"i\");\\n          list.add(\"o\");\\n          list.add(\"u\");\\n        \\n        Map<String,List<String>> mp=new HashMap<>();\\n        mp.put(\"a\",new ArrayList<String>());\\n        mp.get(\"a\").add(\"e\");\\n        \\n        //System.out.println(mp.get(\"a\"));\\n        \\n        mp.put(\"e\",new ArrayList<String>());\\n        mp.get(\"e\").add(\"a\");\\n        mp.get(\"e\").add(\"i\");\\n        \\n        mp.put(\"i\",new ArrayList());\\n        mp.get(\"i\").add(\"a\");\\n        mp.get(\"i\").add(\"e\");\\n        mp.get(\"i\").add(\"o\");\\n        mp.get(\"i\").add(\"u\");\\n        \\n        mp.put(\"o\",new ArrayList());\\n        mp.get(\"o\").add(\"i\");\\n        mp.get(\"o\").add(\"u\");\\n        \\n        mp.put(\"u\",new ArrayList());\\n        mp.get(\"u\").add(\"a\");\\n        \\n        List<String> ans=new ArrayList();\\n        \\n        \\n        return solve(0,n,ans,mp,new StringBuilder(\"\"),new HashMap<String,Integer>());\\n    }\\n    \\n    \\n    public static int solve(int idx,int end,List<String> ans,Map<String,List<String>> mp,StringBuilder asf,HashMap<String,Integer> dict){\\n        if(idx==end){\\n            //System.out.println(asf);\\n            ans.add(asf.toString());\\n            return 1;\\n        }\\n        \\n        String key=idx+\"#\"+asf+\"#\";\\n        \\n        if(dict.containsKey(key)==true){\\n            System.out.println(key);\\n             return dict.get(key);\\n        }\\n        \\n        int count=0;\\n        \\n        if(idx==0){\\n              for(int i=0;i<list.size();i++){\\n                 asf.append(list.get(i)+\"\");\\n                 count+=solve(idx+1,end,ans,mp,asf,dict);\\n                 asf.deleteCharAt(idx);\\n              }\\n        }else{\\n             for(int i=0;i<list.size();i++){\\n                 List<String> find=mp.get(list.get(i));\\n                // System.out.println(list.get(i)+\" \"+asf.charAt(idx-1)+\" \"+idx);\\n                 if(find==null) continue;\\n                 if(find.contains(asf.charAt(idx-1)+\"\")==false) continue; \\n                 asf.append(list.get(i)+\"\");\\n                 count+=solve(idx+1,end,ans,mp,asf,dict);\\n                 asf.deleteCharAt(idx);\\n             }\\n        }\\n        \\n        dict.put(key,count);\\n        \\n        // for(Map.Entry<String,List<String>> ent: mp.entrySet()){\\n        //     System.out.println(ent.getKey() +\" \"+ ent.getValue());\\n        // }\\n        \\n        return count;\\n```\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[][] dp=new long[n+1][5];\\n        \\n        for(int i=0;i<5;i++){\\n            dp[1][i]=1;\\n        }\\n        \\n        int mod=(int)1e9 +7;\\n        \\n        for(int i=2;i<=n;i++){ \\n             dp[i][0]=(dp[i-1][1] )% mod;  \\n             dp[i][1]=(dp[i-1][0] + dp[i-1][2])% mod;\\n             dp[i][2]=(dp[i-1][0] + dp[i-1][1] +dp[i-1][3] + dp[i-1][4] )% mod;\\n             dp[i][3]=(dp[i-1][2] + dp[i-1][4])% mod;\\n             dp[i][4]=(dp[i-1][0])% mod;\\n        }\\n        \\n        long count=0;\\n        for(int j=0;j<5;j++){\\n            count=( count + dp[n][j])%mod;\\n        }\\n        \\n        return (int)count;\\n        \\n    }\\n}\\n```\n```\\nplz upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391285,
                "title": "dynamic-programming",
                "content": "```\\n  => Here, our idea to solve this problem is, we first need to understand for n=1 and n==2 ehat is valid permutation\\n  \\n  for n=1,\\n  \\n  a,e,i,o,u\\n  \\n  for n=2,\\n  \\n  if you observe question then you can be come up with below conclusion,\\n  \\n     before a  either e,u,i \\n\\t before e  either i,a\\n\\t before i  either e,o\\n\\t before o either i\\n\\t before u either o,i\\n\\t \\n\\tso for n=2 ans is \\n\\t\\n\\tua,ea,ia,ie,ae,ei,oi,io,ou,iu.\\n\\t\\n\\tso lets denote a=0, b=1, c=2, d=3, e=4;\\n\\t\\n\\tNow, out ith state of dp is dependent on i-1 state of dp\\n\\t\\n\\t    -> for 0(a charactor) of ith state we must choose 1(e),4(u),2(i) of i-1th dp state as we disscuss before a means before 0th charactor there must be e,u,i  which is denoted by 1,4,2.\\n\\t\\n\\t and so on for 1, 2, 3, 4th charator of ith state.\\n\\t   \\n```\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5,0));\\n        if(n==1) return 5;\\n        else if(n==2) return 10;\\n        \\n        dp[1][0]=dp[1][1]=dp[1][2]=dp[1][3]=dp[1][4]=1;\\n        \\n        for(int i=2;i<=n;i++)\\n        {  \\n            dp[i][0]=((dp[i-1][1]+dp[i-1][2])%mod+dp[i-1][4])%mod;\\n            dp[i][1]=(dp[i-1][0]+dp[i-1][2])%mod;\\n            dp[i][2]=(dp[i-1][1]+dp[i-1][3])%mod;\\n            dp[i][3]=(dp[i-1][2])%mod;\\n            dp[i][4]=(dp[i-1][2]+dp[i-1][3])%mod;\\n             \\n        }\\n        \\n        return (((dp[n][0]+dp[n][1])%mod+(dp[n][2]+dp[n][3])%mod)%mod+dp[n][4])%mod;\\n    }  \\n};\\n\\n\\n\\nIf you like please upvote.\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n  => Here, our idea to solve this problem is, we first need to understand for n=1 and n==2 ehat is valid permutation\\n  \\n  for n=1,\\n  \\n  a,e,i,o,u\\n  \\n  for n=2,\\n  \\n  if you observe question then you can be come up with below conclusion,\\n  \\n     before a  either e,u,i \\n\\t before e  either i,a\\n\\t before i  either e,o\\n\\t before o either i\\n\\t before u either o,i\\n\\t \\n\\tso for n=2 ans is \\n\\t\\n\\tua,ea,ia,ie,ae,ei,oi,io,ou,iu.\\n\\t\\n\\tso lets denote a=0, b=1, c=2, d=3, e=4;\\n\\t\\n\\tNow, out ith state of dp is dependent on i-1 state of dp\\n\\t\\n\\t    -> for 0(a charactor) of ith state we must choose 1(e),4(u),2(i) of i-1th dp state as we disscuss before a means before 0th charactor there must be e,u,i  which is denoted by 1,4,2.\\n\\t\\n\\t and so on for 1, 2, 3, 4th charator of ith state.\\n\\t   \\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(5,0));\\n        if(n==1) return 5;\\n        else if(n==2) return 10;\\n        \\n        dp[1][0]=dp[1][1]=dp[1][2]=dp[1][3]=dp[1][4]=1;\\n        \\n        for(int i=2;i<=n;i++)\\n        {  \\n            dp[i][0]=((dp[i-1][1]+dp[i-1][2])%mod+dp[i-1][4])%mod;\\n            dp[i][1]=(dp[i-1][0]+dp[i-1][2])%mod;\\n            dp[i][2]=(dp[i-1][1]+dp[i-1][3])%mod;\\n            dp[i][3]=(dp[i-1][2])%mod;\\n            dp[i][4]=(dp[i-1][2]+dp[i-1][3])%mod;\\n             \\n        }\\n        \\n        return (((dp[n][0]+dp[n][1])%mod+(dp[n][2]+dp[n][3])%mod)%mod+dp[n][4])%mod;\\n    }  \\n};\\n\\n\\n\\nIf you like please upvote.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390907,
                "title": "beats-100-other-s-solutions-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        \\n        long long int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1e9 + 7;\\n        for (int k = 2; k <= n; k++) {\\n            long long int ta = a, ti = i, te = e, to = o, tu = u;\\n            a = te;\\n            e = ta + ti;\\n            i = ta + te + to + tu;\\n            o = ti + tu;\\n            u = ta;\\n            \\n            a %= mod;\\n            e %= mod;\\n            i %= mod;\\n            o %= mod;\\n            u %= mod;\\n        }\\n        return (a + e + i + o + u) % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        \\n        long long int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1e9 + 7;\\n        for (int k = 2; k <= n; k++) {\\n            long long int ta = a, ti = i, te = e, to = o, tu = u;\\n            a = te;\\n            e = ta + ti;\\n            i = ta + te + to + tu;\\n            o = ti + tu;\\n            u = ta;\\n            \\n            a %= mod;\\n            e %= mod;\\n            i %= mod;\\n            o %= mod;\\n            u %= mod;\\n        }\\n        return (a + e + i + o + u) % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308850,
                "title": "o-logn-solution-beats-100",
                "content": "```\\npublic class Solution {\\n    public int CountVowelPermutation(int n) {\\n        // converted adjacency list to matrix\\n        //a->e\\n        //e->a,i\\n        //i->a,e,o,u\\n        //o->i,u\\n        //u->a\\n        long[,] matrix = {\\n            {0,1,0,0,0},\\n            {1,0,1,0,0},\\n            {1,1,0,1,1},\\n            {0,0,1,0,1},\\n            {1,0,0,0,0}\\n        };\\n        long[,] res = {\\n            {1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){\\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n/=2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n-=1;\\n            }\\n        }\\n        long count=0;\\n        for(int i=0;i<5;i++){\\n            count=(count+res[0,i])%1000000007;\\n        }\\n        return (int)count;\\n     }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[5,5];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<5;j++){\\n                for(int k=0;k<5;k++){\\n                    product[i,j] = (product[i,j]+matrix1[i,k]*matrix2[k,j])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountVowelPermutation(int n) {\\n        // converted adjacency list to matrix\\n        //a->e\\n        //e->a,i\\n        //i->a,e,o,u\\n        //o->i,u\\n        //u->a\\n        long[,] matrix = {\\n            {0,1,0,0,0},\\n            {1,0,1,0,0},\\n            {1,1,0,1,1},\\n            {0,0,1,0,1},\\n            {1,0,0,0,0}\\n        };\\n        long[,] res = {\\n            {1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){\\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n/=2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n-=1;\\n            }\\n        }\\n        long count=0;\\n        for(int i=0;i<5;i++){\\n            count=(count+res[0,i])%1000000007;\\n        }\\n        return (int)count;\\n     }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[5,5];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<5;j++){\\n                for(int k=0;k<5;k++){\\n                    product[i,j] = (product[i,j]+matrix1[i,k]*matrix2[k,j])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001213,
                "title": "c-o-n-time-dynamic-programming-tribute-to-my-ex",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int countVowelPermutation(int n) {\\n        vector<long long> kar(n,1);\\n        vector<vector<long long>> opkar;\\n         const int mod=1e9+7;\\n        for(int i=0;i<5;++i){\\n            opkar.push_back(kar);\\n        }\\n        \\n        if(n==1){\\n            return 5;\\n        }\\n        else{\\n            for(int i=1;i<n;++i){                \\n                        opkar[0][i] = (opkar[2][i-1] + opkar[1][i-1] + opkar[4][i-1])%mod;                \\n                        opkar[1][i] = (opkar[0][i-1] + opkar[2][i-1])%mod;                    \\n                        opkar[2][i] = (opkar[1][i-1] + opkar[3][i-1])%mod;                    \\n                        opkar[3][i] = (opkar[2][i-1])%mod;\\n                        opkar[4][i] = (opkar[2][i-1] + opkar[3][i-1])%mod;\\n                                            \\n                }\\n            \\n            long long count = 0;\\n            for(int i =0;i<5;++i){\\n                count += opkar[i][n-1];\\n            }\\n            return count % mod;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int countVowelPermutation(int n) {\\n        vector<long long> kar(n,1);\\n        vector<vector<long long>> opkar;\\n         const int mod=1e9+7;\\n        for(int i=0;i<5;++i){\\n            opkar.push_back(kar);\\n        }\\n        \\n        if(n==1){\\n            return 5;\\n        }\\n        else{\\n            for(int i=1;i<n;++i){                \\n                        opkar[0][i] = (opkar[2][i-1] + opkar[1][i-1] + opkar[4][i-1])%mod;                \\n                        opkar[1][i] = (opkar[0][i-1] + opkar[2][i-1])%mod;                    \\n                        opkar[2][i] = (opkar[1][i-1] + opkar[3][i-1])%mod;                    \\n                        opkar[3][i] = (opkar[2][i-1])%mod;\\n                        opkar[4][i] = (opkar[2][i-1] + opkar[3][i-1])%mod;\\n                                            \\n                }\\n            \\n            long long count = 0;\\n            for(int i =0;i<5;++i){\\n                count += opkar[i][n-1];\\n            }\\n            return count % mod;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923424,
                "title": "c-100-fast-short-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    long long ans = 0;\\n    int countVowelPermutation(int n) {\\n        long long dp[5][n+1];\\n        \\n        memset(dp, 0, sizeof(dp));\\n        dp[0][1] = 1, dp[1][1] = 1, dp[2][1] = 1, dp[3][1] = 1, dp[4][1] = 1;\\n        \\n        for(int i = 2; i<=n; i++){\\n\\n                dp[0][i] = (dp[1][i-1]) % mod;\\n                dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % mod;\\n                dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % mod;\\n                dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % mod;\\n                dp[4][i] = (dp[0][i-1]) % mod;\\n            \\n        }\\n        \\n        for(int i =0; i<5; i++){\\n            ans = (ans + dp[i][n]) % mod;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    long long ans = 0;\\n    int countVowelPermutation(int n) {\\n        long long dp[5][n+1];\\n        \\n        memset(dp, 0, sizeof(dp));\\n        dp[0][1] = 1, dp[1][1] = 1, dp[2][1] = 1, dp[3][1] = 1, dp[4][1] = 1;\\n        \\n        for(int i = 2; i<=n; i++){\\n\\n                dp[0][i] = (dp[1][i-1]) % mod;\\n                dp[1][i] = (dp[0][i-1] + dp[2][i-1]) % mod;\\n                dp[2][i] = (dp[0][i-1] + dp[1][i-1] + dp[3][i-1] + dp[4][i-1]) % mod;\\n                dp[3][i] = (dp[2][i-1] + dp[4][i-1]) % mod;\\n                dp[4][i] = (dp[0][i-1]) % mod;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1322330,
                "title": "python3-4x4-matrix-exponentiation-beat-100-of-python3-submissions",
                "content": "What makes this a different solution to other matrix solutions is that the chosen matrix is only **4x4** compared to those 5x5 ones, which theoretically means more performant by 64/125. (matrix exponentiation has O(M^3 log(N)) where M is the matrix dimension size and N is iterations.)\\n\\n```python\\nMOD = 10**9 + 7\\n\\n\\ndef multiply(mtx1, mtx2):\\n    ret = []\\n    rows = len(mtx1)\\n    cols = len(mtx2)\\n    for i in range(rows):\\n        ret.append([])\\n        for j in range(rows):\\n            ret[i].append(0)\\n            for k in range(cols):\\n                ret[i][j] = ret[i][j] + mtx1[i][k] * mtx2[k][j] % MOD\\n    return ret\\n\\n\\ndef fast_power(mtx, n):\\n    if n == 0:\\n        dim = len(mtx)\\n        return [\\n            [\\n                1 if i == j else 0\\n                for j in range(dim)\\n            ]\\n            for i in range(dim)\\n        ]\\n\\n    if n == 1:\\n        return mtx\\n\\n    res = fast_power(mtx, n // 2)\\n    res = multiply(res, res)\\n\\n    if n % 2 == 1:\\n        res = multiply(mtx, res)\\n\\n    return res\\n\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        factor = fast_power([\\n            [1, 1, 0, 0],\\n            [1, 0, 1, 0],\\n            [0, 0, 1, 1],\\n            [2, 0, 0, -1]\\n        ], n - 1)\\n\\n        # multiply([[1, 0, 0, 0]], factor) == factor[0]\\n        return sum(multiply([factor[0]], [[5], [5], [4], [2]])[0]) % MOD\\n```\\n\\n### Short explaination\\n\\nNk denotes that all possible vowels at the nth iteration.\\n\\nPk denotes the pattern found at the nth iteration.\\n\\nF(Pk) denotes the transition of a pattern.\\n\\nSteps to find patterns at k-th iteration:\\n- Find all possible vowels at this iteration\\n- Reorder vowels to match the pattern found at last iteration\\n- Give it a name denoted as Pk\\n- Replace vowels with existing pattern names\\n\\n```\\nN1 = a e  i    o  u = P1                                      (new pattern found, P1 = aeiou)\\nN2 = e ai aeou iu a = aeiou aaeiu = P1 + P2                   (new pattern found, P2 = aaeiu)\\nN3 = ai e aeou e ai iu a aeou a e = aeiou aeiou aaeiu aaee    (new pattern found, P3 = aaee)\\n   = P1 + P1 + P2 + P3\\n   = 2*P1 + P2 + P3\\nN4 = e aeou ai e ai iu a ai e aeou aeou a e e ai iu a e ai\\n   = aeiou aeiou aeiou aaeiu aaeiu aaee aaee ii               (new pattern found, P4 = ii)\\n   = P1 + P1 + P1 + P2 + P2 + P3 + P3 + P4\\n   = 3*P1 + 2*P2 + 2*P3 + P4\\nN5 = ... (DIY) ...                                            (no new pattern found, the system converges)\\n   = 7*P1 + 3*P2 + 4*P3 + P4                                  (Is that why the example give n=5 :D)\\n \\nP1 = 5 (length of aeiou)\\nP2 = 5 (lengh of aaeiu)\\nP3 = 4 (length of aaee)\\nP4 = 2 (length of ii)\\n\\nVerify:\\nN1 = 5\\nN2 = 10\\nN3 = 19\\nN4 = 35\\nN5 = 68\\n(Pass)\\n\\nWhat we learn from the 4 patterns:\\nF(P1) = P1 + P2\\nF(P2) = P1 + P3\\nF(P3) = P3 + P4\\nF(P4) = 2*P1 - P4\\n\\n(do not worry the subtraction, there is always a P3 at last iteration generating a P4 to compensate this.\\nThink of this P4 borrowed from F(P3))\\n\\nMake it a transition matrix:\\np1\\' = 1*p1 + 1*p2 + 0*p3 + 2*p4\\np2\\' = 1*p1 + 0*p2 + 0*p3 + 0*p4\\np3\\' = 0*p1 + 1*p2 + 1*p3 + 0*p4\\np4\\' = 0*p1 + 0*p2 + 1*p3 + (-1)*p4\\n\\nDone:\\n| p1\\' |   | 1 1 0 2  |   | p1 |\\n| p2\\' |   | 1 0 0 0  |   | p2 |\\n| p3\\' | = | 0 1 1 0  | * | p3 | \\n| p4\\' |   | 0 0 1 -1 |   | p4 |\\n\\n(Though I use a transposed version in the code lol :D)\\n```\\n\\n### Long explaination (in Chinese)\\nhttps://medium.com/cow-say/1220-count-vowels-permutation-921d259e9439",
                "solutionTags": [],
                "code": "```python\\nMOD = 10**9 + 7\\n\\n\\ndef multiply(mtx1, mtx2):\\n    ret = []\\n    rows = len(mtx1)\\n    cols = len(mtx2)\\n    for i in range(rows):\\n        ret.append([])\\n        for j in range(rows):\\n            ret[i].append(0)\\n            for k in range(cols):\\n                ret[i][j] = ret[i][j] + mtx1[i][k] * mtx2[k][j] % MOD\\n    return ret\\n\\n\\ndef fast_power(mtx, n):\\n    if n == 0:\\n        dim = len(mtx)\\n        return [\\n            [\\n                1 if i == j else 0\\n                for j in range(dim)\\n            ]\\n            for i in range(dim)\\n        ]\\n\\n    if n == 1:\\n        return mtx\\n\\n    res = fast_power(mtx, n // 2)\\n    res = multiply(res, res)\\n\\n    if n % 2 == 1:\\n        res = multiply(mtx, res)\\n\\n    return res\\n\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        factor = fast_power([\\n            [1, 1, 0, 0],\\n            [1, 0, 1, 0],\\n            [0, 0, 1, 1],\\n            [2, 0, 0, -1]\\n        ], n - 1)\\n\\n        # multiply([[1, 0, 0, 0]], factor) == factor[0]\\n        return sum(multiply([factor[0]], [[5], [5], [4], [2]])[0]) % MOD\\n```\n```\\nN1 = a e  i    o  u = P1                                      (new pattern found, P1 = aeiou)\\nN2 = e ai aeou iu a = aeiou aaeiu = P1 + P2                   (new pattern found, P2 = aaeiu)\\nN3 = ai e aeou e ai iu a aeou a e = aeiou aeiou aaeiu aaee    (new pattern found, P3 = aaee)\\n   = P1 + P1 + P2 + P3\\n   = 2*P1 + P2 + P3\\nN4 = e aeou ai e ai iu a ai e aeou aeou a e e ai iu a e ai\\n   = aeiou aeiou aeiou aaeiu aaeiu aaee aaee ii               (new pattern found, P4 = ii)\\n   = P1 + P1 + P1 + P2 + P2 + P3 + P3 + P4\\n   = 3*P1 + 2*P2 + 2*P3 + P4\\nN5 = ... (DIY) ...                                            (no new pattern found, the system converges)\\n   = 7*P1 + 3*P2 + 4*P3 + P4                                  (Is that why the example give n=5 :D)\\n \\nP1 = 5 (length of aeiou)\\nP2 = 5 (lengh of aaeiu)\\nP3 = 4 (length of aaee)\\nP4 = 2 (length of ii)\\n\\nVerify:\\nN1 = 5\\nN2 = 10\\nN3 = 19\\nN4 = 35\\nN5 = 68\\n(Pass)\\n\\nWhat we learn from the 4 patterns:\\nF(P1) = P1 + P2\\nF(P2) = P1 + P3\\nF(P3) = P3 + P4\\nF(P4) = 2*P1 - P4\\n\\n(do not worry the subtraction, there is always a P3 at last iteration generating a P4 to compensate this.\\nThink of this P4 borrowed from F(P3))\\n\\nMake it a transition matrix:\\np1\\' = 1*p1 + 1*p2 + 0*p3 + 2*p4\\np2\\' = 1*p1 + 0*p2 + 0*p3 + 0*p4\\np3\\' = 0*p1 + 1*p2 + 1*p3 + 0*p4\\np4\\' = 0*p1 + 0*p2 + 1*p3 + (-1)*p4\\n\\nDone:\\n| p1\\' |   | 1 1 0 2  |   | p1 |\\n| p2\\' |   | 1 0 0 0  |   | p2 |\\n| p3\\' | = | 0 1 1 0  | * | p3 | \\n| p4\\' |   | 0 0 1 -1 |   | p4 |\\n\\n(Though I use a transposed version in the code lol :D)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317101,
                "title": "c-dynamic-programming-simple-solution",
                "content": "**Please up vote( if useful )**\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n  ll mod = 1000000000 + 7;\\n  ll rec(vector<vector<ll>> &dp, ll i, ll j, ll n)\\n  {\\n    if (i == n)\\n      return 1;\\n    if (dp[i][j] != -1)\\n      return dp[i][j];\\n    if (j == \\'a\\' - \\'a\\')\\n      dp[i][j] = rec(dp, i + 1, \\'e\\' - \\'a\\', n);\\n    else if (j == \\'e\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'a\\' - \\'a\\', n) + rec(dp, i + 1, \\'i\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'i\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'a\\' - \\'a\\', n) + rec(dp, i + 1, \\'e\\' - \\'a\\', n) + rec(dp, i + 1, \\'o\\' - \\'a\\', n) + rec(dp, i + 1, \\'u\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'o\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'i\\' - \\'a\\', n) + rec(dp, i + 1, \\'u\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'u\\' - \\'a\\')\\n      dp[i][j] = rec(dp, i + 1, \\'a\\' - \\'a\\', n);\\n    return dp[i][j]%mod;\\n  }\\n  int countVowelPermutation(int n) {\\n    std::vector<std::vector<ll>> dp(n + 1, std::vector<ll> (27, -1));\\n    // dp[i][j] = number of permutations possible of i length, having the j vowel at ith position.\\n    return (rec(dp, 1, \\'a\\' - \\'a\\', n) + rec(dp, 1, \\'e\\' - \\'a\\', n) + rec(dp, 1, \\'i\\' - \\'a\\', n) + rec(dp, 1, \\'o\\' - \\'a\\', n) + rec(dp, 1, \\'u\\' - \\'a\\', n)) % mod;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n  ll mod = 1000000000 + 7;\\n  ll rec(vector<vector<ll>> &dp, ll i, ll j, ll n)\\n  {\\n    if (i == n)\\n      return 1;\\n    if (dp[i][j] != -1)\\n      return dp[i][j];\\n    if (j == \\'a\\' - \\'a\\')\\n      dp[i][j] = rec(dp, i + 1, \\'e\\' - \\'a\\', n);\\n    else if (j == \\'e\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'a\\' - \\'a\\', n) + rec(dp, i + 1, \\'i\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'i\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'a\\' - \\'a\\', n) + rec(dp, i + 1, \\'e\\' - \\'a\\', n) + rec(dp, i + 1, \\'o\\' - \\'a\\', n) + rec(dp, i + 1, \\'u\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'o\\' - \\'a\\')\\n      dp[i][j] = (rec(dp, i + 1, \\'i\\' - \\'a\\', n) + rec(dp, i + 1, \\'u\\' - \\'a\\', n)) % mod;\\n    else if (j == \\'u\\' - \\'a\\')\\n      dp[i][j] = rec(dp, i + 1, \\'a\\' - \\'a\\', n);\\n    return dp[i][j]%mod;\\n  }\\n  int countVowelPermutation(int n) {\\n    std::vector<std::vector<ll>> dp(n + 1, std::vector<ll> (27, -1));\\n    // dp[i][j] = number of permutations possible of i length, having the j vowel at ith position.\\n    return (rec(dp, 1, \\'a\\' - \\'a\\', n) + rec(dp, 1, \\'e\\' - \\'a\\', n) + rec(dp, 1, \\'i\\' - \\'a\\', n) + rec(dp, 1, \\'o\\' - \\'a\\', n) + rec(dp, 1, \\'u\\' - \\'a\\', n)) % mod;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315905,
                "title": "count-vowels-permutation-dp-from-recursion",
                "content": "```\\nRecursion(TLE )\\n\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1000000007;\\n    unordered_map<int,vector<int>> umap;\\n    \\n\\t//this recursive function takes current size and last letter of string form so.\\n\\t    int rec(int n, int l,int last){\\n\\t\\t//base cases\\n        if(n == l) return 1;\\n        if(last == -1){\\n            return (rec(n,1,0)%mod + rec(n,1,1)%mod + rec(n,1,2)%mod + rec(n,1,3)%mod + rec(n,1,4)%mod ) % mod ;\\n        }\\n        \\n       // calculate for all the possible letter that can be placed after this\\n        vector<int> v = umap[last];\\n        int ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            ans = (ans%mod + rec(n,l+1,v[i])%mod) % mod;\\n        }\\n        return  (ans % mod);\\n    }\\n        \\n    int countVowelPermutation(int n) {\\n         umap[0] = {1};\\n        umap[1] = {0,2};\\n        umap[2] = {0,1,3,4};\\n        umap[3] = {4,2};\\n        umap[4] = {0};\\n        \\n         return rec(n,0,-1);\\n        \\n    }\\n};\\n```\\n\\n**Accepted**(DP bottom-up approach)\\n```\\n\\nDP [i][j] -: total no of strings having length i and end with  j (it integer map of given char)\\nDP[1][j] ,(0<j<5) = 1  //base case string \\nDP[i][j] = DP[i-1][umap[j][0]] + DP....   // all possible j\\n\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1000000007;\\n    unordered_map<int,vector<int>> umap;\\n    vector<vector<int>> dp;\\n        \\n        \\n    int countVowelPermutation(int n) {\\n        umap[0] = {1,2,4};\\n        umap[1] = {0,2};\\n        umap[2] = {1,3};\\n        umap[3] = {2};\\n        umap[4] = {3,2};\\n        dp.resize(n+1,vector<int>(5,-1));\\n        \\n        // return rec(n,0,-1);\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<5;j++){\\n                if(i == 1){\\n                    dp[i][j] = 1;\\n                }\\n                else{\\n                    vector<int> v = umap[j];\\n                    int ans = 0;\\n                    for(int l=0;l<v.size();l++){\\n                        ans = (ans%mod + dp[i-1][v[l]]%mod) % mod;\\n                    }\\n                    dp[i][j] = ans % mod;\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i=0;i<5;i++){\\n            res = (res%mod + dp[n][i]%mod) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nRecursion(TLE )\\n\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1000000007;\\n    unordered_map<int,vector<int>> umap;\\n    \\n\\t//this recursive function takes current size and last letter of string form so.\\n\\t    int rec(int n, int l,int last){\\n\\t\\t//base cases\\n        if(n == l) return 1;\\n        if(last == -1){\\n            return (rec(n,1,0)%mod + rec(n,1,1)%mod + rec(n,1,2)%mod + rec(n,1,3)%mod + rec(n,1,4)%mod ) % mod ;\\n        }\\n        \\n       // calculate for all the possible letter that can be placed after this\\n        vector<int> v = umap[last];\\n        int ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            ans = (ans%mod + rec(n,l+1,v[i])%mod) % mod;\\n        }\\n        return  (ans % mod);\\n    }\\n        \\n    int countVowelPermutation(int n) {\\n         umap[0] = {1};\\n        umap[1] = {0,2};\\n        umap[2] = {0,1,3,4};\\n        umap[3] = {4,2};\\n        umap[4] = {0};\\n        \\n         return rec(n,0,-1);\\n        \\n    }\\n};\\n```\n```\\n\\nDP [i][j] -: total no of strings having length i and end with  j (it integer map of given char)\\nDP[1][j] ,(0<j<5) = 1  //base case string \\nDP[i][j] = DP[i-1][umap[j][0]] + DP....   // all possible j\\n\\nclass Solution {\\npublic:\\n    \\n    const int mod = 1000000007;\\n    unordered_map<int,vector<int>> umap;\\n    vector<vector<int>> dp;\\n        \\n        \\n    int countVowelPermutation(int n) {\\n        umap[0] = {1,2,4};\\n        umap[1] = {0,2};\\n        umap[2] = {1,3};\\n        umap[3] = {2};\\n        umap[4] = {3,2};\\n        dp.resize(n+1,vector<int>(5,-1));\\n        \\n        // return rec(n,0,-1);\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=0;j<5;j++){\\n                if(i == 1){\\n                    dp[i][j] = 1;\\n                }\\n                else{\\n                    vector<int> v = umap[j];\\n                    int ans = 0;\\n                    for(int l=0;l<v.size();l++){\\n                        ans = (ans%mod + dp[i-1][v[l]]%mod) % mod;\\n                    }\\n                    dp[i][j] = ans % mod;\\n                }\\n            }\\n        }\\n        \\n        int res = 0;\\n        for(int i=0;i<5;i++){\\n            res = (res%mod + dp[n][i]%mod) % mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315892,
                "title": "count-vowels-best-solution-python-o-1-memory-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        \\n        na = 1\\n        ne = 1\\n        ni = 1\\n        no = 1\\n        nu = 1\\n        \\n        if(n==1):\\n            return 5\\n        \\n        else:\\n            \\n            for _ in range(n-1):\\n                \\n                na,ne,ni,no,nu = ne , na + ni , na+ne+no+nu , ni + nu , na\\n                \\n            return (na+ne+ni+no+nu)%(10**9+7)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        \\n        na = 1\\n        ne = 1\\n        ni = 1\\n        no = 1\\n        nu = 1\\n        \\n        if(n==1):\\n            return 5\\n        \\n        else:\\n            \\n            for _ in range(n-1):\\n                \\n                na,ne,ni,no,nu = ne , na + ni , na+ne+no+nu , ni + nu , na\\n                \\n            return (na+ne+ni+no+nu)%(10**9+7)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1315880,
                "title": "c-3-approaches-recur-memo-bottom-up-dp-organised-and-simple-with-comments",
                "content": "```\\n/*\\n\\tFor more interview Qn : https://github.com/MAZHARMIK/Interview_DS_Algo\\n    Similar Qn            : https://leetcode.com/problems/count-sorted-vowel-strings/\\n*/\\n\\n//Approach-1 (Top Down - Recursion + Memo) Time : O(n)\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    vector<vector<long long>> t;\\n    \\n    /*\\n        Accoring to question : \\n        a -> e\\n        e -> a, i\\n        i -> a, e, o, u\\n        o -> i, u\\n        u -> a\\n        So, count of strings of length n ending at \\'a\\' ?\\n            We can have vowels \\'e\\', \\'i\\' & \\'u\\' in which we can have ending vowel as \\'a\\'\\n        So,         count of strings of length n ending at \\'a\\'  = count of strings of length (n-1) ending at \\'e\\', \\'i\\', \\'u\\'.\\n        \\n        similarly,  We can have vowels \\'a\\' & \\'i\\' in which we can have ending vowel as \\'e\\'\\n                    We can have vowels \\'e\\' & \\'o\\' in which we can have ending vowel as \\'i\\'\\n                    We can have vowels i\\' in which we can have ending vowel as \\'o\\'\\n                    We can have vowels \\'i\\' & \\'o\\' in which we can have ending vowel as \\'u\\'\\n        And in this fashion, we find the count recursively\\n    */\\n    int count(int n, int vowel) {\\n        if(t[n][vowel] != -1)\\n            return t[n][vowel];\\n        \\n        /*\\n            When n is 0, why dowe return 1 ?\\n            Let\\'s look at the caller function countVowelPermutation()\\n            If n = 1, we would call \\n            count(n-1, a) + count(n-1, e) + count(n-1, i) + count(n-1, o) + count(n-1, u)\\n            and for n = 1, we know that count is 5\\n            So, only if we return 1 from here, we will be able to get 5.\\n            This is how I found \\n        */\\n        if(n == 0)\\n            return 1;\\n        \\n        if(vowel == a) {\\n            return t[n][vowel] = ((count(n-1, e) + count(n-1, i))%M + count(n-1, u))%M;\\n        } else if(vowel == e) {\\n            return t[n][vowel] = ((count(n-1, a) + count(n-1, i)))%M;\\n        } else if(vowel == i) {\\n            return t[n][vowel] = ((count(n-1, e) + count(n-1, o)))%M;\\n        } else if(vowel == o) {\\n            return t[n][vowel] = count(n-1, i);\\n        } else if(vowel == u) {\\n            return t[n][vowel] = ((count(n-1, i) + count(n-1, o)))%M;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        t.resize(n, vector<long long>(5, -1));\\n        long long result = 0;\\n        \\n        result = (result + count(n-1, a)) %M; //count(x, v) = # of strings of length x which ends at vowel v\\n        result = (result + count(n-1, e)) %M;\\n        result = (result + count(n-1, i)) %M;\\n        result = (result + count(n-1, o)) %M;\\n        result = (result + count(n-1, u)) %M;\\n        \\n        return result;\\n        \\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Top Down DP : Just iterative version of Approach-1) Time : O(n)\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    \\n    int countVowelPermutation(int n) {\\n        long long t[n+1][5];\\n        //t[i][j] = # strings of length i ending with vowel j\\n        \\n        for(int vowel = a; vowel<=u; vowel++) {\\n            t[1][vowel] = 1;\\n        }\\n        \\n        for(int len = 2; len<=n; len++) {\\n            t[len][a] = ((t[len-1][e] + t[len-1][i])%M + t[len-1][u])%M;\\n            \\n            t[len][e] = (t[len-1][a] + t[len-1][i])%M;\\n            \\n            t[len][i] = (t[len-1][e] + t[len-1][o])%M;\\n            \\n            t[len][o] = t[len-1][i];\\n            \\n            t[len][u] = (t[len-1][i] + t[len-1][o])%M;\\n        }\\n        \\n\\n        long long count = 0;\\n        for(int vowel = a; vowel <= u; vowel++) {\\n            count = (count+t[n][vowel])%M;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (We can apply approach-1 in same way asked in question)\\n/*\\nInstead of considering the string \\'ending with vowel v\\', we consider strings \\'starting with vowel v\\'\\njust as mentioned in the question. It\\'s more intuitive\\n*/\\n\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    vector<vector<long long>> t;\\n    \\n    /*\\n        Accoring to question : \\n        a -> e\\n        e -> a, i\\n        i -> a, e, o, u\\n        o -> i, u\\n        u -> a\\n        So, count of strings of length n starting at \\'a\\' ?\\n            We can have vowel \\'e\\' after \\'a\\'\\n        So, count of strings of length n starting at \\'a\\'  = count of strings of length (n-1) starting at \\'e\\' and so on.    \\n        And in this fashion, we find the count recursively\\n    */\\n    \\n    long long count(int n, int vowel) {\\n        if(t[n][vowel] != -1)\\n            return t[n][vowel];\\n        if(n == 0)\\n            return 1;\\n        \\n        if(vowel == a) {\\n            return t[n][vowel] = (count(n-1, e))%M;\\n        } else if(vowel == e) {\\n            return t[n][vowel] = ((count(n-1, a) + count(n-1, i)))%M;\\n        } else if(vowel == i) {\\n            return t[n][vowel] = (count(n-1, a) + count(n-1, e) + count(n-1, o) + count(n-1, u))%M;\\n        } else if(vowel == o) {\\n            return t[n][vowel] = (count(n-1, i) + count(n-1, u))%M;\\n        } else if(vowel == u) {\\n            return t[n][vowel] = (count(n-1, a))%M;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        t.resize(n, vector<long long>(5, -1));\\n        long long result = 0;\\n        \\n        result = (result + count(n-1, a)) %M; //count(x, v) = # of strings of length x which ends at vowel v\\n        result = (result + count(n-1, e)) %M;\\n        result = (result + count(n-1, i)) %M;\\n        result = (result + count(n-1, o)) %M;\\n        result = (result + count(n-1, u)) %M;\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tFor more interview Qn : https://github.com/MAZHARMIK/Interview_DS_Algo\\n    Similar Qn            : https://leetcode.com/problems/count-sorted-vowel-strings/\\n*/\\n\\n//Approach-1 (Top Down - Recursion + Memo) Time : O(n)\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    vector<vector<long long>> t;\\n    \\n    /*\\n        Accoring to question : \\n        a -> e\\n        e -> a, i\\n        i -> a, e, o, u\\n        o -> i, u\\n        u -> a\\n        So, count of strings of length n ending at \\'a\\' ?\\n            We can have vowels \\'e\\', \\'i\\' & \\'u\\' in which we can have ending vowel as \\'a\\'\\n        So,         count of strings of length n ending at \\'a\\'  = count of strings of length (n-1) ending at \\'e\\', \\'i\\', \\'u\\'.\\n        \\n        similarly,  We can have vowels \\'a\\' & \\'i\\' in which we can have ending vowel as \\'e\\'\\n                    We can have vowels \\'e\\' & \\'o\\' in which we can have ending vowel as \\'i\\'\\n                    We can have vowels i\\' in which we can have ending vowel as \\'o\\'\\n                    We can have vowels \\'i\\' & \\'o\\' in which we can have ending vowel as \\'u\\'\\n        And in this fashion, we find the count recursively\\n    */\\n    int count(int n, int vowel) {\\n        if(t[n][vowel] != -1)\\n            return t[n][vowel];\\n        \\n        /*\\n            When n is 0, why dowe return 1 ?\\n            Let\\'s look at the caller function countVowelPermutation()\\n            If n = 1, we would call \\n            count(n-1, a) + count(n-1, e) + count(n-1, i) + count(n-1, o) + count(n-1, u)\\n            and for n = 1, we know that count is 5\\n            So, only if we return 1 from here, we will be able to get 5.\\n            This is how I found \\n        */\\n        if(n == 0)\\n            return 1;\\n        \\n        if(vowel == a) {\\n            return t[n][vowel] = ((count(n-1, e) + count(n-1, i))%M + count(n-1, u))%M;\\n        } else if(vowel == e) {\\n            return t[n][vowel] = ((count(n-1, a) + count(n-1, i)))%M;\\n        } else if(vowel == i) {\\n            return t[n][vowel] = ((count(n-1, e) + count(n-1, o)))%M;\\n        } else if(vowel == o) {\\n            return t[n][vowel] = count(n-1, i);\\n        } else if(vowel == u) {\\n            return t[n][vowel] = ((count(n-1, i) + count(n-1, o)))%M;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        t.resize(n, vector<long long>(5, -1));\\n        long long result = 0;\\n        \\n        result = (result + count(n-1, a)) %M; //count(x, v) = # of strings of length x which ends at vowel v\\n        result = (result + count(n-1, e)) %M;\\n        result = (result + count(n-1, i)) %M;\\n        result = (result + count(n-1, o)) %M;\\n        result = (result + count(n-1, u)) %M;\\n        \\n        return result;\\n        \\n    }\\n};\\n```\n```\\n//Approach-2 (Top Down DP : Just iterative version of Approach-1) Time : O(n)\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    \\n    int countVowelPermutation(int n) {\\n        long long t[n+1][5];\\n        //t[i][j] = # strings of length i ending with vowel j\\n        \\n        for(int vowel = a; vowel<=u; vowel++) {\\n            t[1][vowel] = 1;\\n        }\\n        \\n        for(int len = 2; len<=n; len++) {\\n            t[len][a] = ((t[len-1][e] + t[len-1][i])%M + t[len-1][u])%M;\\n            \\n            t[len][e] = (t[len-1][a] + t[len-1][i])%M;\\n            \\n            t[len][i] = (t[len-1][e] + t[len-1][o])%M;\\n            \\n            t[len][o] = t[len-1][i];\\n            \\n            t[len][u] = (t[len-1][i] + t[len-1][o])%M;\\n        }\\n        \\n\\n        long long count = 0;\\n        for(int vowel = a; vowel <= u; vowel++) {\\n            count = (count+t[n][vowel])%M;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-3 (We can apply approach-1 in same way asked in question)\\n/*\\nInstead of considering the string \\'ending with vowel v\\', we consider strings \\'starting with vowel v\\'\\njust as mentioned in the question. It\\'s more intuitive\\n*/\\n\\nclass Solution {\\npublic:\\n    int M = 1e9+7;\\n    int a = 0, e = 1, i = 2, o = 3, u = 4;\\n    vector<vector<long long>> t;\\n    \\n    /*\\n        Accoring to question : \\n        a -> e\\n        e -> a, i\\n        i -> a, e, o, u\\n        o -> i, u\\n        u -> a\\n        So, count of strings of length n starting at \\'a\\' ?\\n            We can have vowel \\'e\\' after \\'a\\'\\n        So, count of strings of length n starting at \\'a\\'  = count of strings of length (n-1) starting at \\'e\\' and so on.    \\n        And in this fashion, we find the count recursively\\n    */\\n    \\n    long long count(int n, int vowel) {\\n        if(t[n][vowel] != -1)\\n            return t[n][vowel];\\n        if(n == 0)\\n            return 1;\\n        \\n        if(vowel == a) {\\n            return t[n][vowel] = (count(n-1, e))%M;\\n        } else if(vowel == e) {\\n            return t[n][vowel] = ((count(n-1, a) + count(n-1, i)))%M;\\n        } else if(vowel == i) {\\n            return t[n][vowel] = (count(n-1, a) + count(n-1, e) + count(n-1, o) + count(n-1, u))%M;\\n        } else if(vowel == o) {\\n            return t[n][vowel] = (count(n-1, i) + count(n-1, u))%M;\\n        } else if(vowel == u) {\\n            return t[n][vowel] = (count(n-1, a))%M;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        t.resize(n, vector<long long>(5, -1));\\n        long long result = 0;\\n        \\n        result = (result + count(n-1, a)) %M; //count(x, v) = # of strings of length x which ends at vowel v\\n        result = (result + count(n-1, e)) %M;\\n        result = (result + count(n-1, i)) %M;\\n        result = (result + count(n-1, o)) %M;\\n        result = (result + count(n-1, u)) %M;\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315546,
                "title": "c-recursion-memoization-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = (int)1e9 + 7;\\n    int helper(int n, char i, unordered_map<char,vector<char>>& vc,vector<vector<long long>>& dp){\\n        if(n==0) return 1;\\n        if (dp[n][i-\\'a\\']!=0) return dp[n][i-\\'a\\']%mod;\\n        for(int j=0;j<vc[i].size();j++){\\n            dp[n][i-\\'a\\']+=(helper(n-1,vc[i][j],vc,dp))%mod;\\n        }\\n        return dp[n][i-\\'a\\']%mod;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        unordered_map<char,vector<char>> vc;\\n        vc[\\'a\\'].push_back(\\'e\\');\\n        vc[\\'e\\'].push_back(\\'a\\');vc[\\'e\\'].push_back(\\'i\\');\\n        vc[\\'i\\'].push_back(\\'a\\');vc[\\'i\\'].push_back(\\'e\\');vc[\\'i\\'].push_back(\\'o\\');vc[\\'i\\'].push_back(\\'u\\');\\n        vc[\\'o\\'].push_back(\\'i\\');vc[\\'o\\'].push_back(\\'u\\');\\n        vc[\\'u\\'].push_back(\\'a\\');        \\n        vector<vector<long long>> dp(n+1,vector<long long>(26,0));\\n        long long c=0;\\n        for(auto it = vc.begin();it!=vc.end();it++){\\n            dp[n][it->first-\\'a\\']+=(helper(n-1,it->first,vc,dp))%mod;\\n            c += (dp[n][it->first-\\'a\\'])%mod;\\n        }\\n        return c%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = (int)1e9 + 7;\\n    int helper(int n, char i, unordered_map<char,vector<char>>& vc,vector<vector<long long>>& dp){\\n        if(n==0) return 1;\\n        if (dp[n][i-\\'a\\']!=0) return dp[n][i-\\'a\\']%mod;\\n        for(int j=0;j<vc[i].size();j++){\\n            dp[n][i-\\'a\\']+=(helper(n-1,vc[i][j],vc,dp))%mod;\\n        }\\n        return dp[n][i-\\'a\\']%mod;\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        unordered_map<char,vector<char>> vc;\\n        vc[\\'a\\'].push_back(\\'e\\');\\n        vc[\\'e\\'].push_back(\\'a\\');vc[\\'e\\'].push_back(\\'i\\');\\n        vc[\\'i\\'].push_back(\\'a\\');vc[\\'i\\'].push_back(\\'e\\');vc[\\'i\\'].push_back(\\'o\\');vc[\\'i\\'].push_back(\\'u\\');\\n        vc[\\'o\\'].push_back(\\'i\\');vc[\\'o\\'].push_back(\\'u\\');\\n        vc[\\'u\\'].push_back(\\'a\\');        \\n        vector<vector<long long>> dp(n+1,vector<long long>(26,0));\\n        long long c=0;\\n        for(auto it = vc.begin();it!=vc.end();it++){\\n            dp[n][it->first-\\'a\\']+=(helper(n-1,it->first,vc,dp))%mod;\\n            c += (dp[n][it->first-\\'a\\'])%mod;\\n        }\\n        return c%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315527,
                "title": "c-easy-dp-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int countVowelPermutation(int n) {\\n        \\n        //Let dp[i][j] be the number of strings of length i that ends with the j-th vowel.\\n        long long int mod = 1000000007;\\n        long long int dp[n + 1][5];\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i][0] = 1;\\n            dp[i][1] = 1;\\n            dp[i][2] = 1;\\n            dp[i][3] = 1;\\n            dp[i][4] = 1;\\n        }\\n        \\n        //Creating combinations of each vowel using following conditions:\\n        //For a: ea, ia, ua\\n        //For e: ae, ie\\n        //For i: ei, oi\\n        //For o: io\\n        //For u: iu, ou\\n        \\n        for(int i = 2; i <= n; i++)\\n        {\\n            dp[i][0] += (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % mod;\\n            dp[i][1] += (dp[i - 1][0] + dp[i - 1][2]) % mod;\\n            dp[i][2] += (dp[i - 1][1] + dp[i - 1][3]) % mod;\\n            dp[i][3] += (dp[i - 1][2]) % mod;\\n            dp[i][4] += (dp[i - 1][2]+ dp[i - 1][3]) % mod;\\n        }\\n        \\n        //Finding N-th and (N-1)-th solutions\\n        long long int x = (dp[n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4]) % mod;\\n        long long int y = (dp[n - 1][0] + dp[n - 1][1] + dp[n - 1][2] + dp[n - 1][3] + dp[n - 1][4]) % mod;\\n        \\n        if(n == 1)\\n            return x;\\n        \\n        //Using basics of Modular Arithmetic to overcome overflow\\n        return (x % mod - y % mod + mod) % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int countVowelPermutation(int n) {\\n        \\n        //Let dp[i][j] be the number of strings of length i that ends with the j-th vowel.\\n        long long int mod = 1000000007;\\n        long long int dp[n + 1][5];\\n        for(int i = 1; i <= n; i++)\\n        {\\n            dp[i][0] = 1;\\n            dp[i][1] = 1;\\n            dp[i][2] = 1;\\n            dp[i][3] = 1;\\n            dp[i][4] = 1;\\n        }\\n        \\n        //Creating combinations of each vowel using following conditions:\\n        //For a: ea, ia, ua\\n        //For e: ae, ie\\n        //For i: ei, oi\\n        //For o: io\\n        //For u: iu, ou\\n        \\n        for(int i = 2; i <= n; i++)\\n        {\\n            dp[i][0] += (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % mod;\\n            dp[i][1] += (dp[i - 1][0] + dp[i - 1][2]) % mod;\\n            dp[i][2] += (dp[i - 1][1] + dp[i - 1][3]) % mod;\\n            dp[i][3] += (dp[i - 1][2]) % mod;\\n            dp[i][4] += (dp[i - 1][2]+ dp[i - 1][3]) % mod;\\n        }\\n        \\n        //Finding N-th and (N-1)-th solutions\\n        long long int x = (dp[n][0] + dp[n][1] + dp[n][2] + dp[n][3] + dp[n][4]) % mod;\\n        long long int y = (dp[n - 1][0] + dp[n - 1][1] + dp[n - 1][2] + dp[n - 1][3] + dp[n - 1][4]) % mod;\\n        \\n        if(n == 1)\\n            return x;\\n        \\n        //Using basics of Modular Arithmetic to overcome overflow\\n        return (x % mod - y % mod + mod) % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315343,
                "title": "i-would-expect-dp-space-o-1-if-i-were-the-interviewer",
                "content": "I would expect,\\n- DP with two int[5] arrays to compress the space to O(1).\\n- I DO NOT like the idea which mods (10^9+7), as it is not the focus of the question itself.\\n- Comparing top-to-bottom and bottom-to-top would be an extra bonus point, such as why for this question bottom-to-top is more convenient.\\n\\nAlthough it is a HARD question, probably it is very good for practicing DP.\\n \\n```java\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[] countPrev = new long[5];\\n        long[] countCur = new long[5];\\n        Arrays.fill(countPrev, 1);\\n        \\n        long mod = 1000000007;\\n        \\n        for(int i=1; i <n ;i++){\\n            \\n            \\n            /*\\n            Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n            Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n            Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n            Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n            Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n            */\\n            countCur[0] = countPrev[1] % mod;\\n            countCur[1] = (countPrev[0]+countPrev[2]) % mod;\\n            countCur[2] = (countPrev[0]+countPrev[1]+countPrev[3]+countPrev[4]) % mod;\\n            countCur[3] = (countPrev[2]+countPrev[4]) % mod;\\n            countCur[4] = countPrev[0] % mod;\\n            \\n            long[] tmp = countPrev;\\n            countPrev = countCur;\\n            countCur = tmp;\\n        }\\n        \\n        return (int)((countPrev[0] + countPrev[1] + countPrev[2] + countPrev[3] + countPrev[4]) % mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[] countPrev = new long[5];\\n        long[] countCur = new long[5];\\n        Arrays.fill(countPrev, 1);\\n        \\n        long mod = 1000000007;\\n        \\n        for(int i=1; i <n ;i++){\\n            \\n            \\n            /*\\n            Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n            Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n            Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n            Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n            Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n            */\\n            countCur[0] = countPrev[1] % mod;\\n            countCur[1] = (countPrev[0]+countPrev[2]) % mod;\\n            countCur[2] = (countPrev[0]+countPrev[1]+countPrev[3]+countPrev[4]) % mod;\\n            countCur[3] = (countPrev[2]+countPrev[4]) % mod;\\n            countCur[4] = countPrev[0] % mod;\\n            \\n            long[] tmp = countPrev;\\n            countPrev = countCur;\\n            countCur = tmp;\\n        }\\n        \\n        return (int)((countPrev[0] + countPrev[1] + countPrev[2] + countPrev[3] + countPrev[4]) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315184,
                "title": "easy-dp-solution",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        int mod=1000_000_007;\\n        long dp[][]=new long[n][5];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<5;j++){\\n                if(j==0){                              // for \\'a\\'\\n                    dp[i][j]=dp[i-1][1];\\n                }\\n                else if(j==1){                              // for \\'e\\'\\n                    dp[i][j]=dp[i-1][0]+dp[i-1][2];\\n                }\\n                else if(j==2){                              // for \\'i\\'\\n                    dp[i][j]=dp[i-1][0]+dp[i-1][1]+dp[i-1][3]+dp[i-1][4];\\n                }\\n                else if(j==3){                              // for \\'o\\'\\n                    dp[i][j]=dp[i-1][2]+dp[i-1][4];\\n                }\\n                else{                              // for \\'u\\'\\n                    dp[i][j]=dp[i-1][0];\\n                }\\n                dp[i][j]=dp[i][j]%mod;\\n            }\\n        }\\n\\t\\t//just add all answers possible from vowels\\n        long ans=0;\\n        for(int j=0;j<5;j++)\\n            ans+=dp[n-1][j];\\n        \\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        int mod=1000_000_007;\\n        long dp[][]=new long[n][5];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<5;j++){\\n                if(j==0){                              // for \\'a\\'\\n                    dp[i][j]=dp[i-1][1];\\n                }\\n                else if(j==1){                              // for \\'e\\'\\n                    dp[i][j]=dp[i-1][0]+dp[i-1][2];\\n                }\\n                else if(j==2){                              // for \\'i\\'\\n                    dp[i][j]=dp[i-1][0]+dp[i-1][1]+dp[i-1][3]+dp[i-1][4];\\n                }\\n                else if(j==3){                              // for \\'o\\'\\n                    dp[i][j]=dp[i-1][2]+dp[i-1][4];\\n                }\\n                else{                              // for \\'u\\'\\n                    dp[i][j]=dp[i-1][0];\\n                }\\n                dp[i][j]=dp[i][j]%mod;\\n            }\\n        }\\n\\t\\t//just add all answers possible from vowels\\n        long ans=0;\\n        for(int j=0;j<5;j++)\\n            ans+=dp[n-1][j];\\n        \\n        return (int)(ans%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173310,
                "title": "my-java-solution-with-my-understanding-as-comments",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        if (n == 1)\\n            return 5;\\n        if (n == 2)\\n            return 10;\\n        int mod = (int)1e9 + 7;\\n        // 0th index - a\\n        // 1st index - e\\n        // 2nd index - i\\n        // 3rd index - o\\n        // 4th index - u\\n        long [][] dp = new long [n + 1][5]; \\n        \\n        // if n = 1, then with every letter we can create a string\\n        for (int i=0; i<5; i++) {\\n            dp[1][i] = 1;\\n        }\\n        for (int i=1; i<n; i++) {\\n                // a is followed in e, i, u\\n                dp[i + 1][0] = (dp[i][1] + dp[i][2] + dp[i][4]) % mod;\\n                // e is followed in a, i\\n                dp[i + 1][1] = (dp[i][0] + dp[i][2]) % mod;\\n                // i is followed in e, o\\n                dp[i + 1][2] = (dp[i][1] + dp[i][3]) % mod;\\n                // o is followed in i\\n                dp[i + 1][3] = (dp[i][2]) % mod;\\n                // u is followed in i, o\\n                dp[i + 1][4] = (dp[i][2] + dp[i][3]) % mod;\\n        }\\n        long answer = 0;\\n        for (int i=0; i<5; i++) {\\n            answer = (answer + dp[n][i]) % mod;\\n        }\\n        return (int) answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        if (n == 1)\\n            return 5;\\n        if (n == 2)\\n            return 10;\\n        int mod = (int)1e9 + 7;\\n        // 0th index - a\\n        // 1st index - e\\n        // 2nd index - i\\n        // 3rd index - o\\n        // 4th index - u\\n        long [][] dp = new long [n + 1][5]; \\n        \\n        // if n = 1, then with every letter we can create a string\\n        for (int i=0; i<5; i++) {\\n            dp[1][i] = 1;\\n        }\\n        for (int i=1; i<n; i++) {\\n                // a is followed in e, i, u\\n                dp[i + 1][0] = (dp[i][1] + dp[i][2] + dp[i][4]) % mod;\\n                // e is followed in a, i\\n                dp[i + 1][1] = (dp[i][0] + dp[i][2]) % mod;\\n                // i is followed in e, o\\n                dp[i + 1][2] = (dp[i][1] + dp[i][3]) % mod;\\n                // o is followed in i\\n                dp[i + 1][3] = (dp[i][2]) % mod;\\n                // u is followed in i, o\\n                dp[i + 1][4] = (dp[i][2] + dp[i][3]) % mod;\\n        }\\n        long answer = 0;\\n        for (int i=0; i<5; i++) {\\n            answer = (answer + dp[n][i]) % mod;\\n        }\\n        return (int) answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127526,
                "title": "java-dp-o-n-constant-memory",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long mod = (long) 1e9 + 7;\\n        \\n        long[] dp = {1, 1, 1, 1, 1};        \\n        for(int i = 2; i <= n; i += 1) {\\n            long[] temp = new long[5];\\n            \\n            temp[0] = (dp[1] + dp[2] + dp[4]) % mod;\\n            temp[1] = (dp[0] + dp[2]) % mod;\\n            temp[2] = (dp[1] + dp[3]) % mod;\\n            temp[3] = dp[2];\\n            temp[4] = (dp[2] + dp[3]) % mod;\\n            \\n            dp = temp;\\n        }        \\n                \\n        return (int) ((dp[0] + dp[1] + dp[2] + dp[3] + dp[4]) % mod);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long mod = (long) 1e9 + 7;\\n        \\n        long[] dp = {1, 1, 1, 1, 1};        \\n        for(int i = 2; i <= n; i += 1) {\\n            long[] temp = new long[5];\\n            \\n            temp[0] = (dp[1] + dp[2] + dp[4]) % mod;\\n            temp[1] = (dp[0] + dp[2]) % mod;\\n            temp[2] = (dp[1] + dp[3]) % mod;\\n            temp[3] = dp[2];\\n            temp[4] = (dp[2] + dp[3]) % mod;\\n            \\n            dp = temp;\\n        }        \\n                \\n        return (int) ((dp[0] + dp[1] + dp[2] + dp[3] + dp[4]) % mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103573,
                "title": "javascript-faster-than-100-no-matrix",
                "content": "see other solutions for example why.\\nI tried doing other solutions with array destructuring, using the .map function, etc... \\njust keep it simple i guess!\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countVowelPermutation = function (n) {\\n   const modVal = (1e9 + 7);\\n   let a = 1;\\n   let e = 1;\\n   let i = 1;\\n   let o = 1;\\n   let u = 1;\\n\\n   for (let x = 1; x < n; x++) {\\n      let tempA = e % modVal;\\n      let tempE = (a + i) % modVal;\\n      let tempI = (a + e + o + u) % modVal;\\n      let tempO = (i + u) % modVal;\\n      let tempU = a % modVal;\\n      a = tempA;\\n      e = tempE;\\n      i = tempI;\\n      o = tempO;\\n      u = tempU;\\n   }\\n\\n   return (a + e + i + o + u) % modVal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar countVowelPermutation = function (n) {\\n   const modVal = (1e9 + 7);\\n   let a = 1;\\n   let e = 1;\\n   let i = 1;\\n   let o = 1;\\n   let u = 1;\\n\\n   for (let x = 1; x < n; x++) {\\n      let tempA = e % modVal;\\n      let tempE = (a + i) % modVal;\\n      let tempI = (a + e + o + u) % modVal;\\n      let tempO = (i + u) % modVal;\\n      let tempU = a % modVal;\\n      a = tempA;\\n      e = tempE;\\n      i = tempI;\\n      o = tempO;\\n      u = tempU;\\n   }\\n\\n   return (a + e + i + o + u) % modVal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081078,
                "title": "c-0ms-100-easy-iteratively-obvious",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count Vowels Permutation.\\nMemory Usage: 5.8 MB, less than 99.59% of C++ online submissions for Count Vowels Permutation.\\n```\\nclass Solution {\\npublic:\\n  int countVowelPermutation(int n) {\\n    unsigned int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1000000007;\\n    while(--n){\\n      unsigned int new_a = (e + i + u)%mod;\\n      unsigned int new_e = (a + i)%mod;\\n      unsigned int new_i = (e + o)%mod;\\n      unsigned int new_u = (i + o)%mod;\\n      a = new_a, e = new_e, o = i%mod, i = new_i, u = new_u;\\n    }\\n    \\n    return (a + e + i + o + u)%mod;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countVowelPermutation(int n) {\\n    unsigned int a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1000000007;\\n    while(--n){\\n      unsigned int new_a = (e + i + u)%mod;\\n      unsigned int new_e = (a + i)%mod;\\n      unsigned int new_i = (e + o)%mod;\\n      unsigned int new_u = (i + o)%mod;\\n      a = new_a, e = new_e, o = i%mod, i = new_i, u = new_u;\\n    }\\n    \\n    return (a + e + i + o + u)%mod;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058365,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "The problem can be solved by matrix power. Similar problems are\\n[70. Climbing Stairs ](https://leetcode.com/problems/climbing-stairs/discuss/929659/Evolve-from-brute-force-to-optimal)\\n[509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/discuss/989672/Evolve-from-intuition)\\n[552. Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/discuss/650804/Evolve-from-brute-force-to-optimal).\\n[935. Knight Dialer](https://leetcode.com/problems/knight-dialer/discuss/893523/Evolve-from-brute-force-to-dp)\\n1. Brute force O(4^n)\\n```\\n\\tMap<Character, List<Character>> map;\\n    public int countVowelPermutation(int n) {\\n        map = new HashMap<>();\\n        map.put(\\'a\\', Arrays.asList(\\'e\\'));\\n        map.put(\\'e\\', Arrays.asList(\\'a\\',\\'i\\'));\\n        map.put(\\'i\\', Arrays.asList(\\'a\\',\\'e\\',\\'o\\',\\'u\\'));\\n        map.put(\\'o\\', Arrays.asList(\\'i\\',\\'u\\'));\\n        map.put(\\'u\\', Arrays.asList(\\'a\\'));\\n        map.put(\\' \\', Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n        return permutations(\\' \\',n);\\n\\n    }\\n    private int permutations(char pre, int n) {\\n        if(n==0) {\\n            return 1;\\n        }\\n        int count=0;\\n        for(char c:map.get(pre)) {\\n            count+=permutations(c,n-1); \\n        }\\n        return count;\\n    }\\n```\\n2. Memoization O(n)\\n```\\n\\tint[][] mem;\\n    int MOD = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        mem = new int[n+1][118];\\n        map = new HashMap<>();\\n        map.put(\\'a\\', Arrays.asList(\\'e\\'));\\n        map.put(\\'e\\', Arrays.asList(\\'a\\',\\'i\\'));\\n        map.put(\\'i\\', Arrays.asList(\\'a\\',\\'e\\',\\'o\\',\\'u\\'));\\n        map.put(\\'o\\', Arrays.asList(\\'i\\',\\'u\\'));\\n        map.put(\\'u\\', Arrays.asList(\\'a\\'));\\n        map.put(\\' \\', Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n        return permutations(\\' \\',n);\\n\\n    }\\n    private int permutations(char pre, int n) {\\n        if(n==0) {\\n            return 1;\\n        }\\n        if(mem[n][pre]>0) {\\n            return mem[n][pre];\\n        }\\n        int count=0;\\n        for(char c:map.get(pre)) {\\n            count+=permutations(c,n-1); \\n            count%=MOD;\\n        }\\n        return mem[n][pre]=count;\\n    }\\n```\\n3. dp O(n)\\n```\\n\\tint MOD = (int)1e9+7;\\n    public int countVowelPermutation(int n) {\\n        int[][] dp = new int[n][5];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<n;i++) {\\n            dp[i][0] = ((dp[i-1][1] + dp[i-1][2])%MOD + dp[i-1][4])%MOD;\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2])%MOD;\\n            dp[i][2] = (dp[i-1][1] +dp[i-1][3])%MOD;\\n            dp[i][3] = dp[i-1][2];\\n            dp[i][4] = (dp[i-1][2] + dp[i-1][3])%MOD;\\n        }\\n        int perm = 0;\\n        for(int num:dp[n-1]) {\\n            perm = (perm+num)%MOD;\\n        }\\n        return perm;\\n    }\\n```\\n4. Matrix power O(logn). M is the adjcency matrix. Each column denotes the chars that can precede the column. The code is same as [935. Knight Dialer](https://leetcode.com/problems/knight-dialer/discuss/893523/Evolve-from-brute-force-to-dp) except the matrix.\\n```\\n\\tint MOD = (int)1e9+7, N = 5;\\n    public int countVowelPermutation(int n) {\\n        int[][] M = {{0, 1, 0, 0, 0},\\n                    {1, 0, 1, 0, 0},\\n                    {1, 1, 0, 1, 1},\\n                    {0, 0, 1, 0, 1},\\n                    {1, 0, 0, 0, 0}};\\n        M = pow(M, n-1);\\n        int sum=0;\\n        for(int[] row:M)  \\n            for(int s:row)\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tMap<Character, List<Character>> map;\\n    public int countVowelPermutation(int n) {\\n        map = new HashMap<>();\\n        map.put(\\'a\\', Arrays.asList(\\'e\\'));\\n        map.put(\\'e\\', Arrays.asList(\\'a\\',\\'i\\'));\\n        map.put(\\'i\\', Arrays.asList(\\'a\\',\\'e\\',\\'o\\',\\'u\\'));\\n        map.put(\\'o\\', Arrays.asList(\\'i\\',\\'u\\'));\\n        map.put(\\'u\\', Arrays.asList(\\'a\\'));\\n        map.put(\\' \\', Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n        return permutations(\\' \\',n);\\n\\n    }\\n    private int permutations(char pre, int n) {\\n        if(n==0) {\\n            return 1;\\n        }\\n        int count=0;\\n        for(char c:map.get(pre)) {\\n            count+=permutations(c,n-1); \\n        }\\n        return count;\\n    }\\n```\n```\\n\\tint[][] mem;\\n    int MOD = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        mem = new int[n+1][118];\\n        map = new HashMap<>();\\n        map.put(\\'a\\', Arrays.asList(\\'e\\'));\\n        map.put(\\'e\\', Arrays.asList(\\'a\\',\\'i\\'));\\n        map.put(\\'i\\', Arrays.asList(\\'a\\',\\'e\\',\\'o\\',\\'u\\'));\\n        map.put(\\'o\\', Arrays.asList(\\'i\\',\\'u\\'));\\n        map.put(\\'u\\', Arrays.asList(\\'a\\'));\\n        map.put(\\' \\', Arrays.asList(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'));\\n        return permutations(\\' \\',n);\\n\\n    }\\n    private int permutations(char pre, int n) {\\n        if(n==0) {\\n            return 1;\\n        }\\n        if(mem[n][pre]>0) {\\n            return mem[n][pre];\\n        }\\n        int count=0;\\n        for(char c:map.get(pre)) {\\n            count+=permutations(c,n-1); \\n            count%=MOD;\\n        }\\n        return mem[n][pre]=count;\\n    }\\n```\n```\\n\\tint MOD = (int)1e9+7;\\n    public int countVowelPermutation(int n) {\\n        int[][] dp = new int[n][5];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<n;i++) {\\n            dp[i][0] = ((dp[i-1][1] + dp[i-1][2])%MOD + dp[i-1][4])%MOD;\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2])%MOD;\\n            dp[i][2] = (dp[i-1][1] +dp[i-1][3])%MOD;\\n            dp[i][3] = dp[i-1][2];\\n            dp[i][4] = (dp[i-1][2] + dp[i-1][3])%MOD;\\n        }\\n        int perm = 0;\\n        for(int num:dp[n-1]) {\\n            perm = (perm+num)%MOD;\\n        }\\n        return perm;\\n    }\\n```\n```\\n\\tint MOD = (int)1e9+7, N = 5;\\n    public int countVowelPermutation(int n) {\\n        int[][] M = {{0, 1, 0, 0, 0},\\n                    {1, 0, 1, 0, 0},\\n                    {1, 1, 0, 1, 1},\\n                    {0, 0, 1, 0, 1},\\n                    {1, 0, 0, 0, 0}};\\n        M = pow(M, n-1);\\n        int sum=0;\\n        for(int[] row:M)  \\n            for(int s:row)\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049494,
                "title": "java-recursive-solution-using-dp",
                "content": "JAVA CODE IS:\\n```\\nclass Solution {\\n    int mod=1000000000+7;\\n    Integer dp[][];\\n    int arr[][]=new int[][]{{1},{0,2},{0,1,3,4},{2,4},{0}};\\n    int find(int size,int n,int curr){\\n        if(size==n-1)\\n            return 1;\\n        if(dp[size][curr]!=null)\\n            return dp[size][curr];\\n        int count=0;\\n        for(int d : arr[curr]){\\n            dp[size+1][d]=find(size+1,n,d);\\n            count=(count+dp[size+1][d])%mod;\\n        }\\n        return dp[size][curr]=count;\\n    }\\n    public int countVowelPermutation(int n) {\\n        dp=new Integer[n+1][5];\\n        int count=0;\\n        for(int i=0;i<5;i++)\\n        count=(count+find(0,n,i))%mod;\\n        return count;\\n    }\\n}\\n```\\n\\n***PLEASE,UPVOTE IF THIS IS REALLY HELPFUL FOR YOU***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000000+7;\\n    Integer dp[][];\\n    int arr[][]=new int[][]{{1},{0,2},{0,1,3,4},{2,4},{0}};\\n    int find(int size,int n,int curr){\\n        if(size==n-1)\\n            return 1;\\n        if(dp[size][curr]!=null)\\n            return dp[size][curr];\\n        int count=0;\\n        for(int d : arr[curr]){\\n            dp[size+1][d]=find(size+1,n,d);\\n            count=(count+dp[size+1][d])%mod;\\n        }\\n        return dp[size][curr]=count;\\n    }\\n    public int countVowelPermutation(int n) {\\n        dp=new Integer[n+1][5];\\n        int count=0;\\n        for(int i=0;i<5;i++)\\n        count=(count+find(0,n,i))%mod;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917004,
                "title": "c-dynamic-programming-with-explanation",
                "content": "The list dp[i][j] means that how many kinds of length i end with j (a:0, e:1, i:2, o:3, u:4) exists. So we just only need to write the transition by the principle given. Pretty easy.\\n```\\nclass Solution \\n{\\npublic:\\n    int countVowelPermutation(int n) \\n    {\\n        // a: e-a\\n        // e: a-e or i-e\\n        // i: a-i, e-i, o-i, u-i\\n        // o: i-o, u-i\\n        // u: a-u\\n        vector<vector<int>> dp(n + 1, vector<int>(5, 0));\\n        int mod = 1000000007;\\n        int ret = 0;\\n        dp[1][0] = 1, dp[1][1] = 1, dp[1][2] = 1, dp[1][3] = 1, dp[1][4] = 1;\\n        for(int i = 1; i <= n - 1; i++)\\n        {\\n            dp[i+1][0] = dp[i][1];//a\\n            dp[i+1][1] = (dp[i][0] + dp[i][2]) % mod;//e\\n            dp[i+1][2] = ((dp[i][0] + dp[i][1]) % mod + \\n                          (dp[i][3] + dp[i][4]) % mod) % mod;//i\\n            dp[i+1][3] = (dp[i][2] + dp[i][4]) % mod;\\n            dp[i+1][4] = (dp[i][0]);\\n        }\\n        for(int i = 0; i < 5; i++)\\n            ret = (ret + dp[n][i]) % mod;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countVowelPermutation(int n) \\n    {\\n        // a: e-a\\n        // e: a-e or i-e\\n        // i: a-i, e-i, o-i, u-i\\n        // o: i-o, u-i\\n        // u: a-u\\n        vector<vector<int>> dp(n + 1, vector<int>(5, 0));\\n        int mod = 1000000007;\\n        int ret = 0;\\n        dp[1][0] = 1, dp[1][1] = 1, dp[1][2] = 1, dp[1][3] = 1, dp[1][4] = 1;\\n        for(int i = 1; i <= n - 1; i++)\\n        {\\n            dp[i+1][0] = dp[i][1];//a\\n            dp[i+1][1] = (dp[i][0] + dp[i][2]) % mod;//e\\n            dp[i+1][2] = ((dp[i][0] + dp[i][1]) % mod + \\n                          (dp[i][3] + dp[i][4]) % mod) % mod;//i\\n            dp[i+1][3] = (dp[i][2] + dp[i][4]) % mod;\\n            dp[i+1][4] = (dp[i][0]);\\n        }\\n        for(int i = 0; i < 5; i++)\\n            ret = (ret + dp[n][i]) % mod;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454367,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int last, int n, vector<vector<int>> &dp, int mod) {\\n        if(i == n) return 1;\\n        if(dp[i][last] != -1) return dp[i][last];\\n\\n        long long ans = 0;\\n        if(last == 0) {\\n            for(int j=1; j<=5; j++) ans += dfs(i + 1, j, n, dp, mod);\\n        }\\n        else if(last == 1) ans += dfs(i + 1, 2, n, dp, mod);\\n        else if(last == 2) ans += dfs(i + 1, 1, n, dp, mod) + dfs(i + 1, 3, n, dp, mod);\\n        else if(last == 3) {\\n            for(int j=1; j<=5; j++) {\\n                if(last != j) ans += dfs(i + 1, j, n, dp, mod);\\n            }\\n        }\\n        else if(last == 4) ans += dfs(i + 1, 3, n, dp, mod) + dfs(i + 1, 5, n, dp, mod);\\n        else ans += dfs(i + 1, 1, n, dp, mod);\\n\\n        return dp[i][last] = ans % mod;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n, vector<int> (6, -1));\\n        return dfs(0, 0, n, dp, 1e9 + 7);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int last, int n, vector<vector<int>> &dp, int mod) {\\n        if(i == n) return 1;\\n        if(dp[i][last] != -1) return dp[i][last];\\n\\n        long long ans = 0;\\n        if(last == 0) {\\n            for(int j=1; j<=5; j++) ans += dfs(i + 1, j, n, dp, mod);\\n        }\\n        else if(last == 1) ans += dfs(i + 1, 2, n, dp, mod);\\n        else if(last == 2) ans += dfs(i + 1, 1, n, dp, mod) + dfs(i + 1, 3, n, dp, mod);\\n        else if(last == 3) {\\n            for(int j=1; j<=5; j++) {\\n                if(last != j) ans += dfs(i + 1, j, n, dp, mod);\\n            }\\n        }\\n        else if(last == 4) ans += dfs(i + 1, 3, n, dp, mod) + dfs(i + 1, 5, n, dp, mod);\\n        else ans += dfs(i + 1, 1, n, dp, mod);\\n\\n        return dp[i][last] = ans % mod;\\n    }\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n, vector<int> (6, -1));\\n        return dfs(0, 0, n, dp, 1e9 + 7);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451839,
                "title": "c-simple-dp-solution",
                "content": "```\\n    int countVowelPermutation(int n) {\\n        int  mod = 1e9+7;\\n        vector<vector<long long>> dp(n+1,vector<long long>(5,1));\\n        for(int i = 2;i<=n;i++)\\n        {\\n            dp[i][0] = (dp[i-1][1] + dp[i-1][4] + dp[i-1][2])%mod;   // words ending with \\'a\\'\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2])%mod;   // words ending with \\'e\\'\\n            dp[i][2] = (dp[i-1][1] + dp[i-1][3])%mod;   // words ending with \\'i\\'\\n            dp[i][3] = (dp[i-1][2])%mod ;               // words ending with \\'o\\'\\n            dp[i][4] = (dp[i-1][3] + dp[i-1][2])%mod;   // words ending with \\'u\\'\\n        }\\n        long long ans = 0;\\n        for(int i = 0;i<5;i++) ans = (ans + dp[n][i])%mod;\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int countVowelPermutation(int n) {\\n        int  mod = 1e9+7;\\n        vector<vector<long long>> dp(n+1,vector<long long>(5,1));\\n        for(int i = 2;i<=n;i++)\\n        {\\n            dp[i][0] = (dp[i-1][1] + dp[i-1][4] + dp[i-1][2])%mod;   // words ending with \\'a\\'\\n            dp[i][1] = (dp[i-1][0] + dp[i-1][2])%mod;   // words ending with \\'e\\'\\n            dp[i][2] = (dp[i-1][1] + dp[i-1][3])%mod;   // words ending with \\'i\\'\\n            dp[i][3] = (dp[i-1][2])%mod ;               // words ending with \\'o\\'\\n            dp[i][4] = (dp[i-1][3] + dp[i-1][2])%mod;   // words ending with \\'u\\'\\n        }\\n        long long ans = 0;\\n        for(int i = 0;i<5;i++) ans = (ans + dp[n][i])%mod;\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2396245,
                "title": "python-solution-1d-dynamic-programming-100-faster",
                "content": "the total number of permutations is found by adding all the strings ending with every character in {a,e,i,o,u} \\nbased on given rules - we create formula to find number of strings ending with that character.\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        store = [1,1,1,1,1]\\n        MOD = 10**9 + 7\\n        A, E, I, O, U = 0, 1, 2, 3, 4\\n        for _ in range(1,n):\\n            a, e, i, o, u = store\\n            \\n            store[A] = (e + i + u) % MOD\\n            store[E] = (a + i) % MOD\\n            store[I] = (e + o) % MOD\\n            store[O] = (i)\\n            store[U] = (i + o) % MOD\\n            \\n        return sum(store) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        store = [1,1,1,1,1]\\n        MOD = 10**9 + 7\\n        A, E, I, O, U = 0, 1, 2, 3, 4\\n        for _ in range(1,n):\\n            a, e, i, o, u = store\\n            \\n            store[A] = (e + i + u) % MOD\\n            store[E] = (a + i) % MOD\\n            store[I] = (e + o) % MOD\\n            store[O] = (i)\\n            store[U] = (i + o) % MOD\\n            \\n        return sum(store) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395293,
                "title": "simple-striver-solution-recursion-memoization-tabulation",
                "content": "**Striver method to solve DP questions.**\\n\\nSimilar to Ninja Training question.\\n*To understand the complete method, watch :*  https://www.youtube.com/watch?v=AE39gJYuRog&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY&index=8\\n\\n\\n# **Recursion with Memoization!!!**\\n\\n```\\nclass Solution {\\n    \\n    private static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        long dp[][]=new long[n+1][6];\\n        \\n        for(long[] e:dp)\\n            Arrays.fill(e,-1);\\n        \\n        long ans = recursion(n,5,dp);\\n        \\n        return (int)ans%mod;\\n    }\\n    \\n    long recursion(int n,int last,long[][] dp)\\n    {\\n        if(n==0)\\n            return 1L;\\n        \\n        if(dp[n][last]!=-1)\\n            return dp[n][last];\\n        \\n        long ans=0L;\\n        \\n        if(last==0)\\n            ans=recursion(n-1,1,dp);\\n        if(last==1)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,2,dp);\\n        if(last==2)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,1,dp)+recursion(n-1,3,dp)+recursion(n-1,4,dp);\\n        if(last==3)\\n            ans=recursion(n-1,2,dp)+recursion(n-1,4,dp);\\n        if(last==4)\\n            ans=recursion(n-1,0,dp);\\n        if(last==5)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,1,dp)+recursion(n-1,2,dp)+recursion(n-1,3,dp)+recursion(n-1,4,dp);\\n        \\n        return dp[n][last] = ans%mod;\\n    }\\n}\\n```\\n\\n\\n\\n\\n# **Tabulation**\\n\\n```\\nclass Solution {\\n    \\n    private static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        long dp[][]=new long[n+1][6];\\n        \\n        for(int last=0;last<6;last++)\\n            dp[0][last]=1L;\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int last=0;last<6;last++)\\n            {\\n                long ans=0L;\\n        \\n                if(last==0)\\n                    ans = dp[i-1][1];\\n                if(last==1)\\n                    ans = dp[i-1][0]+dp[i-1][2];\\n                if(last==2)\\n                    ans = dp[i-1][0]+dp[i-1][1]+dp[i-1][3]+dp[i-1][4];\\n                if(last==3)\\n                    ans = dp[i-1][2]+dp[i-1][4];\\n                if(last==4)\\n                    ans = dp[i-1][0];\\n                if(last==5)\\n                    ans = dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]+dp[i-1][4];\\n                \\n                dp[i][last] = ans%mod;\\n            }\\n        }\\n                \\n        return (int)dp[n][5]%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        long dp[][]=new long[n+1][6];\\n        \\n        for(long[] e:dp)\\n            Arrays.fill(e,-1);\\n        \\n        long ans = recursion(n,5,dp);\\n        \\n        return (int)ans%mod;\\n    }\\n    \\n    long recursion(int n,int last,long[][] dp)\\n    {\\n        if(n==0)\\n            return 1L;\\n        \\n        if(dp[n][last]!=-1)\\n            return dp[n][last];\\n        \\n        long ans=0L;\\n        \\n        if(last==0)\\n            ans=recursion(n-1,1,dp);\\n        if(last==1)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,2,dp);\\n        if(last==2)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,1,dp)+recursion(n-1,3,dp)+recursion(n-1,4,dp);\\n        if(last==3)\\n            ans=recursion(n-1,2,dp)+recursion(n-1,4,dp);\\n        if(last==4)\\n            ans=recursion(n-1,0,dp);\\n        if(last==5)\\n            ans=recursion(n-1,0,dp)+recursion(n-1,1,dp)+recursion(n-1,2,dp)+recursion(n-1,3,dp)+recursion(n-1,4,dp);\\n        \\n        return dp[n][last] = ans%mod;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    private static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        long dp[][]=new long[n+1][6];\\n        \\n        for(int last=0;last<6;last++)\\n            dp[0][last]=1L;\\n        \\n        for(int i=1;i<n+1;i++)\\n        {\\n            for(int last=0;last<6;last++)\\n            {\\n                long ans=0L;\\n        \\n                if(last==0)\\n                    ans = dp[i-1][1];\\n                if(last==1)\\n                    ans = dp[i-1][0]+dp[i-1][2];\\n                if(last==2)\\n                    ans = dp[i-1][0]+dp[i-1][1]+dp[i-1][3]+dp[i-1][4];\\n                if(last==3)\\n                    ans = dp[i-1][2]+dp[i-1][4];\\n                if(last==4)\\n                    ans = dp[i-1][0];\\n                if(last==5)\\n                    ans = dp[i-1][0]+dp[i-1][1]+dp[i-1][2]+dp[i-1][3]+dp[i-1][4];\\n                \\n                dp[i][last] = ans%mod;\\n            }\\n        }\\n                \\n        return (int)dp[n][5]%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394623,
                "title": "python-o-log-n-time",
                "content": "**>>>Comments**\\n\\nThe solution involves the use of Linear algebra (matrix exponentiation).\\n\\nIntuition:\\nThis is just an improvement over the DP bottom up approach presented in the approach 2 of the \"official\" leetcode solution.\\nInstead of storing the values of the current permutations that end with a vocal in 5 separate variables, we store all those values in a vector, let\\'s call it \"b\".\\nIn that solution to find the number of permutations of length i that finish with a vocal you utilize a linear combination of the values of the previous entries of the vector b:\\n**but each time you use a linear combination of  the values of a vector to compute an other vector this is equivalent to a matrix multiplication**, you have to know this very well otherwise you will not have the intuition to use matrix multiplication.\\n\\nIf someone knows how to somehow anticipate the module operation to prevent the numbers from getting too big would be helpful, because this is what forced me to make dtype = object, slowing down the code.\\n\\n**>>>Code**\\n\\nMore readable version:\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = np.array([[0,1,1,0,1],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,1,0]], dtype = object)\\n        b = np.array([1,1,1,1,1], dtype = object)\\n        a = np.linalg.matrix_power(a,n-1)\\n        b = matmul(a,b)\\n        return floor(np.sum(b))%1000000007\\n```\\n\\nShorter version: takes advantage of the fact that since b is a vector of all ones when is multiplying it by a matrix and then taking the sum of the entries of the result is the same as just summing all the element of the matrix without multiplying it: \\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = np.array([[0,1,1,0,1],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,1,0]], dtype = object)\\n        a = np.linalg.matrix_power(a,n-1)\\n        return floor(np.sum(a))%1000000007\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = np.array([[0,1,1,0,1],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,1,0]], dtype = object)\\n        b = np.array([1,1,1,1,1], dtype = object)\\n        a = np.linalg.matrix_power(a,n-1)\\n        b = matmul(a,b)\\n        return floor(np.sum(b))%1000000007\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a = np.array([[0,1,1,0,1],[1,0,1,0,0],[0,1,0,1,0],[0,0,1,0,0],[0,0,1,1,0]], dtype = object)\\n        a = np.linalg.matrix_power(a,n-1)\\n        return floor(np.sum(a))%1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394184,
                "title": "c-clean-code-well-explained",
                "content": "Each vowel allows some number of subsequent characters. These transitions are like a tree. This problem is asking, \"what\\'s the width of the tree with height n?\"\\n\\n![image](https://assets.leetcode.com/users/images/91b5c38a-ebc8-43e9-af13-03e9b3cc5b71_1659890728.907886.png)\\n\\nMy solution keeps track of the number of each vowel at a level in this tree. To calculate say \\'A\\', we calculate how many nodes in the previous level produce \\'A\\'. This is the number of \\'E\\', \\'I\\', and \\'U\\' nodes.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long mod = 1e9+7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        long a2, e2, i2, o2, u2;\\n        \\n        for(int j = 2; j <= n; j++){\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = (i) % mod;\\n            u2 = (i + o) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long mod = 1e9+7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        long a2, e2, i2, o2, u2;\\n        \\n        for(int j = 2; j <= n; j++){\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = (i) % mod;\\n            u2 = (i + o) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        \\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393912,
                "title": "c-dp-recursion-memoization-easy-to-understand-straight-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    #define mod  1000000007\\n    int solve(char ch,int n){\\n        if(n==0) return 1;\\n        \\n        if(ch==\\'a\\'){\\n            return solve(\\'e\\',n-1);\\n        }else if(ch==\\'e\\'){\\n            return (solve(\\'a\\',n-1)+solve(\\'i\\',n-1))%mod;\\n        }else if(ch==\\'i\\'){\\n            return (((solve(\\'a\\',n-1)+solve(\\'e\\',n-1))%mod+solve(\\'o\\',n-1))%mod+solve(\\'u\\',n-1))%mod;\\n        }else if(ch==\\'o\\'){\\n            return solve(\\'i\\',n-1)+solve(\\'u\\',n-1)%mod;\\n        }else{\\n            return solve(\\'a\\',n-1);\\n        }\\n    }\\n       int solveMemo(char ch,int n,vector<vector<int>>&dp){\\n        if(n==0) return 1;\\n        if(dp[n][ch-\\'a\\']!=-1) return dp[n][ch-\\'a\\'];\\n        if(ch==\\'a\\'){\\n            return dp[n][ch-\\'a\\']=solveMemo(\\'e\\',n-1,dp);\\n        }else if(ch==\\'e\\'){\\n            return dp[n][ch-\\'a\\']=(solveMemo(\\'a\\',n-1,dp)+solveMemo(\\'i\\',n-1,dp))%mod;\\n        }else if(ch==\\'i\\'){            \\n            return dp[n][ch-\\'a\\']=(((solveMemo(\\'a\\',n-1,dp)+solveMemo(\\'e\\',n-1,dp))%mod+solveMemo(\\'o\\',n-1,dp))%mod+solveMemo(\\'u\\',n-1,dp))%mod;\\n        }else if(ch==\\'o\\'){\\n            return dp[n][ch-\\'a\\']=(solveMemo(\\'i\\',n-1,dp)+solveMemo(\\'u\\',n-1,dp))%mod;\\n        }else{\\n            return dp[n][ch-\\'a\\']=solveMemo(\\'a\\',n-1,dp);\\n        }\\n    }\\n    int countVowelPermutation(int n) {\\n        \\n        int ans=0;\\n        vector<char>vec={\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        // for(int i=0;i<5;i++){\\n        //     ans=(ans+solve(vec[i],n-1))%mod;\\n        // }\\n        vector<vector<int>>dp(n+1,vector<int>(26,-1));\\n          for(int i=0;i<5;i++){\\n            ans=(ans+solveMemo(vec[i],n-1,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define mod  1000000007\\n    int solve(char ch,int n){\\n        if(n==0) return 1;\\n        \\n        if(ch==\\'a\\'){\\n            return solve(\\'e\\',n-1);\\n        }else if(ch==\\'e\\'){\\n            return (solve(\\'a\\',n-1)+solve(\\'i\\',n-1))%mod;\\n        }else if(ch==\\'i\\'){\\n            return (((solve(\\'a\\',n-1)+solve(\\'e\\',n-1))%mod+solve(\\'o\\',n-1))%mod+solve(\\'u\\',n-1))%mod;\\n        }else if(ch==\\'o\\'){\\n            return solve(\\'i\\',n-1)+solve(\\'u\\',n-1)%mod;\\n        }else{\\n            return solve(\\'a\\',n-1);\\n        }\\n    }\\n       int solveMemo(char ch,int n,vector<vector<int>>&dp){\\n        if(n==0) return 1;\\n        if(dp[n][ch-\\'a\\']!=-1) return dp[n][ch-\\'a\\'];\\n        if(ch==\\'a\\'){\\n            return dp[n][ch-\\'a\\']=solveMemo(\\'e\\',n-1,dp);\\n        }else if(ch==\\'e\\'){\\n            return dp[n][ch-\\'a\\']=(solveMemo(\\'a\\',n-1,dp)+solveMemo(\\'i\\',n-1,dp))%mod;\\n        }else if(ch==\\'i\\'){            \\n            return dp[n][ch-\\'a\\']=(((solveMemo(\\'a\\',n-1,dp)+solveMemo(\\'e\\',n-1,dp))%mod+solveMemo(\\'o\\',n-1,dp))%mod+solveMemo(\\'u\\',n-1,dp))%mod;\\n        }else if(ch==\\'o\\'){\\n            return dp[n][ch-\\'a\\']=(solveMemo(\\'i\\',n-1,dp)+solveMemo(\\'u\\',n-1,dp))%mod;\\n        }else{\\n            return dp[n][ch-\\'a\\']=solveMemo(\\'a\\',n-1,dp);\\n        }\\n    }\\n    int countVowelPermutation(int n) {\\n        \\n        int ans=0;\\n        vector<char>vec={\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        // for(int i=0;i<5;i++){\\n        //     ans=(ans+solve(vec[i],n-1))%mod;\\n        // }\\n        vector<vector<int>>dp(n+1,vector<int>(26,-1));\\n          for(int i=0;i<5;i++){\\n            ans=(ans+solveMemo(vec[i],n-1,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392733,
                "title": "c-easy-and-dp-solution",
                "content": "DP solution\\n```\\nclass Solution {\\npublic:   \\n    int countVowelPermutation(int n) {\\n        const int mod=1000000007;\\n\\t\\tlong long int arr[n][5];\\n\\t\\tfor(int i=0;i<5;i++)\\n\\t\\t{\\n\\t\\t\\tarr[0][i]=1;\\n\\t\\t}\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tarr[i][0]=arr[i-1][1]+arr[i-1][2]+arr[i-1][4];\\n\\t\\t\\tarr[i][0]%=mod;\\n\\t\\t\\tarr[i][1]=arr[i-1][0]+arr[i-1][2];  \\n\\t\\t\\tarr[i][1]%=mod;\\n\\t\\t\\tarr[i][2]=arr[i-1][1]+arr[i-1][3];\\n\\t\\t\\tarr[i][2]%=mod;\\n\\t\\t\\tarr[i][3]=arr[i-1][2];\\n\\t\\t\\tarr[i][3]%=mod;\\n\\t\\t\\tarr[i][4]=arr[i-1][2]+arr[i-1][3];\\n\\t\\t\\tarr[i][4]%=mod;\\n\\t\\t}\\n\\t\\tlong long int ans=0;\\n\\t\\tfor(int i=0;i<5;i++)\\n\\t\\t{\\n\\t\\t\\tans+=arr[n-1][i];\\n\\t\\t\\tans%=mod;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```\\nEasy solution\\n```\\nclass Solution {\\npublic:\\n    \\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    int countVowelPermutation(int n) {\\n        const int mod=1000000007;\\n\\t\\tlong long int arr[n][5];\\n\\t\\tfor(int i=0;i<5;i++)\\n\\t\\t{\\n\\t\\t\\tarr[0][i]=1;\\n\\t\\t}\\n\\t\\tfor(int i=1;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tarr[i][0]=arr[i-1][1]+arr[i-1][2]+arr[i-1][4];\\n\\t\\t\\tarr[i][0]%=mod;\\n\\t\\t\\tarr[i][1]=arr[i-1][0]+arr[i-1][2];  \\n\\t\\t\\tarr[i][1]%=mod;\\n\\t\\t\\tarr[i][2]=arr[i-1][1]+arr[i-1][3];\\n\\t\\t\\tarr[i][2]%=mod;\\n\\t\\t\\tarr[i][3]=arr[i-1][2];\\n\\t\\t\\tarr[i][3]%=mod;\\n\\t\\t\\tarr[i][4]=arr[i-1][2]+arr[i-1][3];\\n\\t\\t\\tarr[i][4]%=mod;\\n\\t\\t}\\n\\t\\tlong long int ans=0;\\n\\t\\tfor(int i=0;i<5;i++)\\n\\t\\t{\\n\\t\\t\\tans+=arr[n-1][i];\\n\\t\\t\\tans%=mod;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, mod = pow(10, 9)+7;\\n        long a2, e2, i2, o2, u2; \\n        \\n        for (int j = 2; j <= n; j++) {\\n            a2 = (e + i + u) % mod;\\n            e2 = (a + i) % mod;\\n            i2 = (e + o) % mod;\\n            o2 = i;\\n            u2 = (o + i) % mod;\\n            \\n            a = a2, e = e2, i = i2, o = o2, u = u2;\\n        }\\n        return (a + e + i + o + u) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392650,
                "title": "c-recursion-memoization-easy-explanation-dp",
                "content": "First of all Let\\'s Understand why this problem can be solved by Dynamic-Programming , for approaching this as a dp problem this should have repeating sub problems , so let us understand why this have repeating subproblems....\\nIf we fix the first character as any of the one vowel , so if we start the recursion tree by fixing the first character as \\'a\\' then then second character can be only \\'e\\' , if the length is 10 then again we can think \\'e\\' as the fixed character recursively and for \\'e\\' now we can have the third character as \\'a\\' or \\'i\\'  ...........so we can go on till we reach to the index n , like this we can count permutations .\\nBut let us try to think of the memoizing state , only last fixed character can not define the state completely , we need some index sort of thing , for that let\\'s analayze the state : if the last character was \\'e\\' and current index is 4 from the total length of 10 , so the remaining indices which are left to be explored are 6 , and that defines the dp state , because again we can come to this same state for some different recursion state we can have same character \\'e\\' as the last character and remaining `(n-i)`  indices , so we can memoize this in a DP table ,\\nthe Parameters are the last character and the remaining indices.\\n\\nso just go for the recursion tree and memoize the state as `dp[n-i][lastCharacter]`  and add the answers for the different fixed first index characters .\\nHappy coding \\uD83E\\uDD1E\\n\\nCode:\\n```\\ntypedef long long int l;\\nclass Solution {\\npublic:\\n    map<char,int> m;\\n    int MOD=1e9+7;\\n    l recursion(int i,int n,char last,vector<vector<l>> &dp){\\n        if(i==n){\\n            return 1;\\n        }\\n        \\n        if(dp[n-i][m[last]]!=-1){\\n                return dp[n-i][m[last]];\\n        }\\n        if(last==\\'a\\')\\n                return dp[n-i][m[last]]=recursion(i+1,n,\\'e\\',dp)%MOD;\\n            \\n        if(last==\\'e\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'a\\',dp)+recursion(i+1,n,\\'i\\',dp))%MOD;\\n                \\n        if(last==\\'i\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'a\\',dp)+recursion(i+1,n,\\'e\\',dp)+recursion(i+1,n,\\'o\\',dp)+recursion(i+1,n,\\'u\\',dp))%MOD;\\n                   \\n        if(last==\\'o\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'i\\',dp)+recursion(i+1,n,\\'u\\',dp))%MOD;\\n                       \\n        return dp[n-i][m[last]]=recursion(i+1,n,\\'a\\',dp)%MOD;\\n                       \\n    }\\n    int countVowelPermutation(int n) {\\n        vector<vector<l>> dp(n+1,vector<l>(6,-1));\\n        l ans=0;\\n        m[\\'a\\']=1;  // this mapping for getting integer out of our vowels , for memoizing in array \\n        m[\\'e\\']=2;\\n        m[\\'i\\']=3;\\n        m[\\'o\\']=4;\\n        m[\\'u\\']=5;\\n        // as we have done for the 0th index we are going for the next index which is 1 and the starting character as different vowels\\n        ans=(ans+recursion(1,n,\\'a\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'e\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'i\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'o\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'u\\',dp))%MOD;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ntypedef long long int l;\\nclass Solution {\\npublic:\\n    map<char,int> m;\\n    int MOD=1e9+7;\\n    l recursion(int i,int n,char last,vector<vector<l>> &dp){\\n        if(i==n){\\n            return 1;\\n        }\\n        \\n        if(dp[n-i][m[last]]!=-1){\\n                return dp[n-i][m[last]];\\n        }\\n        if(last==\\'a\\')\\n                return dp[n-i][m[last]]=recursion(i+1,n,\\'e\\',dp)%MOD;\\n            \\n        if(last==\\'e\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'a\\',dp)+recursion(i+1,n,\\'i\\',dp))%MOD;\\n                \\n        if(last==\\'i\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'a\\',dp)+recursion(i+1,n,\\'e\\',dp)+recursion(i+1,n,\\'o\\',dp)+recursion(i+1,n,\\'u\\',dp))%MOD;\\n                   \\n        if(last==\\'o\\')\\n                return dp[n-i][m[last]]=(recursion(i+1,n,\\'i\\',dp)+recursion(i+1,n,\\'u\\',dp))%MOD;\\n                       \\n        return dp[n-i][m[last]]=recursion(i+1,n,\\'a\\',dp)%MOD;\\n                       \\n    }\\n    int countVowelPermutation(int n) {\\n        vector<vector<l>> dp(n+1,vector<l>(6,-1));\\n        l ans=0;\\n        m[\\'a\\']=1;  // this mapping for getting integer out of our vowels , for memoizing in array \\n        m[\\'e\\']=2;\\n        m[\\'i\\']=3;\\n        m[\\'o\\']=4;\\n        m[\\'u\\']=5;\\n        // as we have done for the 0th index we are going for the next index which is 1 and the starting character as different vowels\\n        ans=(ans+recursion(1,n,\\'a\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'e\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'i\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'o\\',dp))%MOD;\\n        ans=(ans+recursion(1,n,\\'u\\',dp))%MOD;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392259,
                "title": "0-ms-faster-than-100-o-n-c-dp-well-explaned",
                "content": "Given length of string ```n``` with vowels. Also given some ```rules or mappings```, each vowel allows some number of subsequent characters. You need to find the total number of different strings we can form of length of ```n```.\\n```\\n\\'a\\'    =>    \\'e\\'\\n\\'e\\'    =>    \\'a\\' / \\'i\\'\\n\\'i\\'    =>    \\'a\\' / \\'e\\' / \\'o\\' / \\'u\\'\\n\\'o\\'    =>    \\'i\\' / \\'u\\'\\n\\'u\\'    =>    \\'a\\'\\n```\\nBut when you observe from oposite side then you can see next vowel depends on some specific current vowels. In simple words, next vowel character count sum of some current vowels count.\\n```\\nNext            Current\\n\\'a\\'    <=    \\'e\\' + \\'i\\' + \\'u\\'\\n\\'e\\'    <=    \\'a\\' + \\'i\\'\\n\\'i\\'    <=    \\'e\\' + \\'o\\'\\n\\'o\\'    <=    \\'i\\'\\n\\'u\\'    <=    \\'i\\' + \\'o\\'\\n```\\nLet\\'s see the simple c++ code:\\n```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int countVowelPermutation(int n) {\\n        int dp[n][5];\\n        for (int i = 0; i < 5 ; i++) {\\n            dp[0][i] = 1;\\n        }\\n        for (int i = 0; i < n-1; i++) {\\n            dp[i + 1][0] = ((dp[i][1] + dp[i][2]) % mod + dp[i][4]) % mod;\\n            dp[i + 1][1] = (dp[i][0] + dp[i][2]) % mod;\\n            dp[i + 1][2] = (dp[i][1] + dp[i][3]) % mod;\\n            dp[i + 1][3] = dp[i][2];\\n            dp[i + 1][4] = (dp[i][2] + dp[i][3]) % mod;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < 5; i++) {\\n            ans = (ans + dp[n - 1][i]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Time Complexity:*** ```O(N)```. The total time complexity becomes ```O(5*N) = O(N)```.\\n***Space Complexity:*** ```O(N)```. The total space complexity becomes ```O(5*N) = O(N)```.\\n\\n```IF YOU REALLY FOUND MY SOLUTION HELPFUL THEN JUST PLEASE UPVOTE IT.```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```n```\n```rules or mappings```\n```n```\n```\\n\\'a\\'    =>    \\'e\\'\\n\\'e\\'    =>    \\'a\\' / \\'i\\'\\n\\'i\\'    =>    \\'a\\' / \\'e\\' / \\'o\\' / \\'u\\'\\n\\'o\\'    =>    \\'i\\' / \\'u\\'\\n\\'u\\'    =>    \\'a\\'\\n```\n```\\nNext            Current\\n\\'a\\'    <=    \\'e\\' + \\'i\\' + \\'u\\'\\n\\'e\\'    <=    \\'a\\' + \\'i\\'\\n\\'i\\'    <=    \\'e\\' + \\'o\\'\\n\\'o\\'    <=    \\'i\\'\\n\\'u\\'    <=    \\'i\\' + \\'o\\'\\n```\n```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int countVowelPermutation(int n) {\\n        int dp[n][5];\\n        for (int i = 0; i < 5 ; i++) {\\n            dp[0][i] = 1;\\n        }\\n        for (int i = 0; i < n-1; i++) {\\n            dp[i + 1][0] = ((dp[i][1] + dp[i][2]) % mod + dp[i][4]) % mod;\\n            dp[i + 1][1] = (dp[i][0] + dp[i][2]) % mod;\\n            dp[i + 1][2] = (dp[i][1] + dp[i][3]) % mod;\\n            dp[i + 1][3] = dp[i][2];\\n            dp[i + 1][4] = (dp[i][2] + dp[i][3]) % mod;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < 5; i++) {\\n            ans = (ans + dp[n - 1][i]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```O(N)```\n```O(5*N) = O(N)```\n```O(N)```\n```O(5*N) = O(N)```\n```IF YOU REALLY FOUND MY SOLUTION HELPFUL THEN JUST PLEASE UPVOTE IT.```",
                "codeTag": "Java"
            },
            {
                "id": 2392131,
                "title": "java-solution-clean-and-well-commented-code-dynamic-programming-easy-to-understand-approach",
                "content": "Well, First think of the **smallest case possible**, `(n == 1)` *In this case the answer is clearly 5*  *(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')*. Then, think of the number of ways you can make ans for `( n == 2 ) `, *By adding characters at the end of all the answer strings in (n == 1) by following the rules. Right?*\\n\\nTo consider all the possibilities I have made an array `\"data\"` which stores all the eligible characters we can append to each of the current string.\\n\\nSo, we have to figure out the ans for \\'n\\' and have only five type of strings possible at each level (**ending with all the five characters**) hence the **dp** array is of dimensions `( n + 1 ) * 5`.\\n\\n*Now, you can go through the code to understand the problem and its approach completely.*\\n\\n\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[][] dp = new long[n+1][5];\\n\\t\\t// Filling the dp array for base case (i.e, n == 1)\\n        for(int i=0; i<5; i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n\\t\\t// Considering  a = 0, e = 1, i = 2, o = 3 and u  = 4 ( for the representation of their indices )\\n\\t\\t// Filling the data array with the characters we can append after the respective character\\n        int[][] data = {{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        int M = (int)1e9+7;\\n        \\n        for(int i=2; i<=n; i++){\\n\\t\\t// we started forming the ans from n = 2 case\\n\\t\\t\\n            for(int j=0; j<5; j++){\\n\\t\\t\\t// traversing all the columns of previous row and adding in the current one\\n\\t\\t\\t\\n                for(int k=0; k<data[j].length; k++){\\n\\t\\t\\t\\t// We have to add to all those characters which can be appended by the previous end characters. \\n\\t\\t\\t\\t//So, the number of strings ending with \\'e\\'s can be formed by appending after all the previously ending with \\'a\\' strings\\n\\t\\t\\t\\t// Here, the mod has also been taken to prevent overflow\\n\\t\\t\\t\\t// data[j][k] let\\'say for j=0 will represent the index of \\'e\\' (1). And we add the number of \\'a\\'s ( dp[ i - 1 ][ j ] ) to it.\\n\\t\\t\\t\\t\\n                    dp[i][data[j][k]] = (dp[i][data[j][k]] + dp[i-1][j])%M;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// At the end the sum of all the strings (ending with the respective character) is our answer for all the strings of length \\'n\\'\\n        long sum = 0;\\n        for(int i=0; i<5; i++){\\n            sum =(sum + dp[n][i])%M;\\n        }\\n        return (int)sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long[][] dp = new long[n+1][5];\\n\\t\\t// Filling the dp array for base case (i.e, n == 1)\\n        for(int i=0; i<5; i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n\\t\\t// Considering  a = 0, e = 1, i = 2, o = 3 and u  = 4 ( for the representation of their indices )\\n\\t\\t// Filling the data array with the characters we can append after the respective character\\n        int[][] data = {{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        int M = (int)1e9+7;\\n        \\n        for(int i=2; i<=n; i++){\\n\\t\\t// we started forming the ans from n = 2 case\\n\\t\\t\\n            for(int j=0; j<5; j++){\\n\\t\\t\\t// traversing all the columns of previous row and adding in the current one\\n\\t\\t\\t\\n                for(int k=0; k<data[j].length; k++){\\n\\t\\t\\t\\t// We have to add to all those characters which can be appended by the previous end characters. \\n\\t\\t\\t\\t//So, the number of strings ending with \\'e\\'s can be formed by appending after all the previously ending with \\'a\\' strings\\n\\t\\t\\t\\t// Here, the mod has also been taken to prevent overflow\\n\\t\\t\\t\\t// data[j][k] let\\'say for j=0 will represent the index of \\'e\\' (1). And we add the number of \\'a\\'s ( dp[ i - 1 ][ j ] ) to it.\\n\\t\\t\\t\\t\\n                    dp[i][data[j][k]] = (dp[i][data[j][k]] + dp[i-1][j])%M;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// At the end the sum of all the strings (ending with the respective character) is our answer for all the strings of length \\'n\\'\\n        long sum = 0;\\n        for(int i=0; i<5; i++){\\n            sum =(sum + dp[n][i])%M;\\n        }\\n        return (int)sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392056,
                "title": "c-dynamic-programming-approach",
                "content": "**One can think of using bruteforce approach in this problem by finding out all the possible strings ending with a particular vowel that leads to branches and overlapping subproblems. Thus, evidently dynamic programming comes into picture.**\\n\\nWe know the possibille strings that can be formed from a string ending with certain characters. So generating the dp[][] matrix becomes simple by observing which vowel comes next if the string end with any vowel.\\n\\nExample : \\n* \\'a\\' will be the end of the string if the previous one ended with an \\'e\\' , \\'u\\' or \\'i\\'.\\n* \\'e\\' will be the end of the string if the previous one ended with an \\'a\\'  or \\'i\\'.\\n* \\'i\\' will be the end of the string if the previous one ended with an \\'e\\' or \\'o\\'.\\n* \\'o\\' will be the end of the string only if the previous one ended with an \\'i\\'.\\n* \\'u\\' will be the end of the string if the previous one ended with an \\'i\\' or \\'o\\'.\\n\\n**Code**\\n\\n```\\nint countVowelPermutation(int n)\\n{\\n    int mod = 1000000007;\\n\\t// dimensions of dp is nx5 as we have only 5 characters to compute\\n    long long dp[n][5];\\n\\t// initializing first row with 1 (when n = 1 , only a character is there)\\n    dp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = dp[0][4] = 1;\\n    for (int i = 1; i < n; i++)\\n    {\\n        dp[i][0] = ((dp[i - 1][1]) + (dp[i - 1][2]) + (dp[i - 1][4])) % mod;         // cases for a\\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod;                              // cases for e\\n        dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % mod;                              // cases for i\\n        dp[i][3] = (dp[i - 1][2]) % mod;                                             // cases for o\\n        dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % mod;                              // cases for u\\n    }\\n    long long ans = 0;\\n    for (int i = 0; i < 5; i++)\\n        ans = (ans + dp[n - 1][i]) % mod;\\n\\t\\t// finally return the sum of all possibilities \\n    return ans;\\n}\\n```\\n\\n**Please upvote if this post was useful.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n)\\n{\\n    int mod = 1000000007;\\n\\t// dimensions of dp is nx5 as we have only 5 characters to compute\\n    long long dp[n][5];\\n\\t// initializing first row with 1 (when n = 1 , only a character is there)\\n    dp[0][0] = dp[0][1] = dp[0][2] = dp[0][3] = dp[0][4] = 1;\\n    for (int i = 1; i < n; i++)\\n    {\\n        dp[i][0] = ((dp[i - 1][1]) + (dp[i - 1][2]) + (dp[i - 1][4])) % mod;         // cases for a\\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % mod;                              // cases for e\\n        dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % mod;                              // cases for i\\n        dp[i][3] = (dp[i - 1][2]) % mod;                                             // cases for o\\n        dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % mod;                              // cases for u\\n    }\\n    long long ans = 0;\\n    for (int i = 0; i < 5; i++)\\n        ans = (ans + dp[n - 1][i]) % mod;\\n\\t\\t// finally return the sum of all possibilities \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391656,
                "title": "java-easy-to-understand-explained",
                "content": "**Do consider upvoting if you find this helpful!**\\n**Also feel free to ask any queries or to suggest any improvements :)**\\n\\nThis solution can be easier to understand if one is familiar with the memoization(top-down) technique used to solve the standard fibonacci series problem with dp.\\n\\nI\\'ll try to explain with an analogical visualizaion...\\n\\n```\\nlength             string ending at vowel\\n     n                          a\\n                             /  |  \\\\\\n                            /   |   \\\\\\n                           /    |    \\\\\\n     n-1                  e     i     u\\n                         / \\\\   / \\\\   / \\\\\\n     n-2                a   i e   o i   o\\n     .                       \\n     .\\n     . and so on\\n```\\n\\nI hope this clearly shows the overlapping sub-problems(the 2 **i**\\'s and 2 **o**\\'s at length n-2) that are being encountered and why dp is necessary to avoid repition of calculating same sub-problem again and again!\\n\\n```\\nclass Solution {\\n    \\n    static int[][] dp;\\n    static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        /*  a -> 0\\n            e -> 1\\n            i -> 2\\n            o -> 3\\n            u -> 4   */\\n        \\n        dp = new int[5][n+1]; // dp array stores the no. of strings of length \\'n\\' ending at i-th vowel \\n        \\n        for(int i=0; i<5; i++)\\n                dp[i][1] = 1; // base cases where for n = 1, each character itself is a valid string\\n        \\n        \\n        // prefix array stores 1 at all the j-th indexes where i-th vowel is preceeded by j-th vowel\\n        \\n        int[][] prefix = {{-1, 1, 1, -1, 1},   //a preceeded by e,i,u (1,2,4)...therefore prefix[0][1] = prefix[0][2] = prefix[0][4] = 1\\n                          {1, -1, 1, -1, -1},  //e preceeded by a,i (0,2)\\n                          {-1, 1, -1, 1, -1},  //i preceeded by e,o (1,3)\\n                          {-1, -1, 1, -1, -1}, //o preceeded by i (2)\\n                          {-1, -1, 1, 1, -1}}; //u preceeded by i,0 (2,3)\\n                \\n        \\n        \\n        for(int i=0; i<5; i++){\\n            digDown(i, n, prefix); // the actual solution phase...finding all the strings ending at each vowel with length \\'n\\'\\n        }\\n        \\n        int sum = 0;\\n        for(int i=0; i<5; i++){\\n            sum = (sum + dp[i][n]%mod)%mod; // calculating the answer...adding up the total strings ending at each vowel\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public void digDown(int c, int n, int[][] prefix){\\n        // here c is the index of current vowel and n is the current lenght of string into consideration\\n\\t\\t\\n        if(n == 1) return; // remember the base cases mentioned earlier!\\n        \\n        for(int i=0; i<5; i++){\\n            \\n            if(prefix[c][i] == 1){ // i.e. if the vowel \\'c\\' is preceeded by vowel \\'i\\' we proceed further\\n                \\n                if(dp[i][n-1] == 0) digDown(i, n-1, prefix); // if the value(i.e. the no. of strings) is not yet calculated for string ending at \\n                                                             // vowel i of length \\'n-1\\'...we call the recursive function to find that out\\n                \\n                dp[c][n] = (dp[c][n]%mod + dp[i][n-1]%mod)%mod; // finally adding the values from vaild predecessor vowel\\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlength             string ending at vowel\\n     n                          a\\n                             /  |  \\\\\\n                            /   |   \\\\\\n                           /    |    \\\\\\n     n-1                  e     i     u\\n                         / \\\\   / \\\\   / \\\\\\n     n-2                a   i e   o i   o\\n     .                       \\n     .\\n     . and so on\\n```\n```\\nclass Solution {\\n    \\n    static int[][] dp;\\n    static int mod = 1000000007;\\n    \\n    public int countVowelPermutation(int n) {\\n        \\n        /*  a -> 0\\n            e -> 1\\n            i -> 2\\n            o -> 3\\n            u -> 4   */\\n        \\n        dp = new int[5][n+1]; // dp array stores the no. of strings of length \\'n\\' ending at i-th vowel \\n        \\n        for(int i=0; i<5; i++)\\n                dp[i][1] = 1; // base cases where for n = 1, each character itself is a valid string\\n        \\n        \\n        // prefix array stores 1 at all the j-th indexes where i-th vowel is preceeded by j-th vowel\\n        \\n        int[][] prefix = {{-1, 1, 1, -1, 1},   //a preceeded by e,i,u (1,2,4)...therefore prefix[0][1] = prefix[0][2] = prefix[0][4] = 1\\n                          {1, -1, 1, -1, -1},  //e preceeded by a,i (0,2)\\n                          {-1, 1, -1, 1, -1},  //i preceeded by e,o (1,3)\\n                          {-1, -1, 1, -1, -1}, //o preceeded by i (2)\\n                          {-1, -1, 1, 1, -1}}; //u preceeded by i,0 (2,3)\\n                \\n        \\n        \\n        for(int i=0; i<5; i++){\\n            digDown(i, n, prefix); // the actual solution phase...finding all the strings ending at each vowel with length \\'n\\'\\n        }\\n        \\n        int sum = 0;\\n        for(int i=0; i<5; i++){\\n            sum = (sum + dp[i][n]%mod)%mod; // calculating the answer...adding up the total strings ending at each vowel\\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public void digDown(int c, int n, int[][] prefix){\\n        // here c is the index of current vowel and n is the current lenght of string into consideration\\n\\t\\t\\n        if(n == 1) return; // remember the base cases mentioned earlier!\\n        \\n        for(int i=0; i<5; i++){\\n            \\n            if(prefix[c][i] == 1){ // i.e. if the vowel \\'c\\' is preceeded by vowel \\'i\\' we proceed further\\n                \\n                if(dp[i][n-1] == 0) digDown(i, n-1, prefix); // if the value(i.e. the no. of strings) is not yet calculated for string ending at \\n                                                             // vowel i of length \\'n-1\\'...we call the recursive function to find that out\\n                \\n                dp[c][n] = (dp[c][n]%mod + dp[i][n-1]%mod)%mod; // finally adding the values from vaild predecessor vowel\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391434,
                "title": "c-dp-easy-to-understand-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    // Mapping vowols to allowed Vowels\\n    // a -> e\\n    // e ->a,i\\n    // i !-> i\\n    // o -> i,u\\n    // u -> a\\n    \\n    int mod=1000000007;\\n     int dp[20001][26]={0};\\n    int solve(int idx,char prevchar,int n,map<char,vector<char>> &mp)\\n    {\\n        if(idx==n)return 1;\\n        if(dp[idx][prevchar-\\'a\\'])return dp[idx][prevchar-\\'a\\'];\\n         int t1=0;\\n       \\n       \\n        for(auto ch:mp[prevchar])\\n        {\\n            t1=(t1%mod+(solve(idx+1,ch,n,mp)%mod))%mod;\\n        }\\n    \\n    return dp[idx][prevchar-\\'a\\']=t1;\\n    }\\n    int countVowelPermutation(int n) {\\n        map<char,vector<char>> mp;\\n        mp[\\'a\\']={\\'e\\'};\\n        mp[\\'e\\']={\\'a\\',\\'i\\'};\\n        mp[\\'i\\']={\\'a\\',\\'e\\',\\'o\\',\\'u\\'};\\n        mp[\\'o\\']={\\'i\\',\\'u\\'};\\n        mp[\\'u\\']={\\'a\\'};\\n        mp[\\'s\\']={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n     \\n        return solve(0,\\'s\\',n,mp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Mapping vowols to allowed Vowels\\n    // a -> e\\n    // e ->a,i\\n    // i !-> i\\n    // o -> i,u\\n    // u -> a\\n    \\n    int mod=1000000007;\\n     int dp[20001][26]={0};\\n    int solve(int idx,char prevchar,int n,map<char,vector<char>> &mp)\\n    {\\n        if(idx==n)return 1;\\n        if(dp[idx][prevchar-\\'a\\'])return dp[idx][prevchar-\\'a\\'];\\n         int t1=0;\\n       \\n       \\n        for(auto ch:mp[prevchar])\\n        {\\n            t1=(t1%mod+(solve(idx+1,ch,n,mp)%mod))%mod;\\n        }\\n    \\n    return dp[idx][prevchar-\\'a\\']=t1;\\n    }\\n    int countVowelPermutation(int n) {\\n        map<char,vector<char>> mp;\\n        mp[\\'a\\']={\\'e\\'};\\n        mp[\\'e\\']={\\'a\\',\\'i\\'};\\n        mp[\\'i\\']={\\'a\\',\\'e\\',\\'o\\',\\'u\\'};\\n        mp[\\'o\\']={\\'i\\',\\'u\\'};\\n        mp[\\'u\\']={\\'a\\'};\\n        mp[\\'s\\']={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n     \\n        return solve(0,\\'s\\',n,mp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391212,
                "title": "easy-explanation",
                "content": "We just need to construct a 2-dimensional DP matrix of n x 5. In which size 5 is used for 5 vowels like for \\'a\\' is stored at index 0, for \\'e\\' at index 1 and so on. Now, we just we our previous result to get the answer based on the given conditions in the question and also took modulas of 1e9+7 due to very large values.\\n```\\nint countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n,vector<int>(5,0));\\n        for(int i=0;i<5;i++)\\n                dp[0][i]=1;\\n        int mod=1e9+7;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<5;j++)\\n            {\\n                if(j==0)\\n                    dp[i][j]=(dp[i-1][1])%mod;\\n                else if(j==1)\\n                    dp[i][j]=(dp[i-1][0]%mod+dp[i-1][2]%mod)%mod;\\n                else if(j==2)\\n                    dp[i][j]=((dp[i-1][0]%mod+dp[i-1][1]%mod)%mod+\\n                              (dp[i-1][3]%mod+dp[i-1][4]%mod)%mod)%mod;\\n                else if(j==3)\\n                    dp[i][j]=(dp[i-1][2]%mod+dp[i-1][4]%mod)%mod;\\n                else \\n                    dp[i][j]=dp[i-1][0]%mod;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<5;i++)\\n            ans=(ans+dp[n-1][i])%mod;\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n) {\\n        vector<vector<int>> dp(n,vector<int>(5,0));\\n        for(int i=0;i<5;i++)\\n                dp[0][i]=1;\\n        int mod=1e9+7;\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<5;j++)\\n            {\\n                if(j==0)\\n                    dp[i][j]=(dp[i-1][1])%mod;\\n                else if(j==1)\\n                    dp[i][j]=(dp[i-1][0]%mod+dp[i-1][2]%mod)%mod;\\n                else if(j==2)\\n                    dp[i][j]=((dp[i-1][0]%mod+dp[i-1][1]%mod)%mod+\\n                              (dp[i-1][3]%mod+dp[i-1][4]%mod)%mod)%mod;\\n                else if(j==3)\\n                    dp[i][j]=(dp[i-1][2]%mod+dp[i-1][4]%mod)%mod;\\n                else \\n                    dp[i][j]=dp[i-1][0]%mod;\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<5;i++)\\n            ans=(ans+dp[n-1][i])%mod;\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391118,
                "title": "tabulation-c",
                "content": "```\\nint countVowelPermutation(int n) {\\n        vector<vector<long long>> dp(n+1,vector<long long>(5,0));\\n        //a = 0,e = 1,i =2, o =3, u=4;\\n        int mod = (int)1e9 + 7;\\n        \\n        for(int i=0;i<5;i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n        // for(auto it:dp){\\n        //     for(auto jt:it){\\n        //         cout<<jt<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        for(int j=2;j<=n;j++){\\n            dp[j][0] = (dp[j-1][1] + dp[j-1][2] + dp[j-1][4]) % mod; //a\\n            dp[j][1] = (dp[j-1][0] + dp[j-1][2]) % mod; //e\\n            dp[j][2] = (dp[j-1][1] + dp[j-1][3]) % mod; //i\\n            dp[j][3] = dp[j-1][2] % mod; // o\\n            dp[j][4] = (dp[j-1][2] + dp[j-1][3])%mod; //u\\n        }\\n        \\n        long long sum = 0;\\n        for(int i=0;i<5;i++){\\n            sum += dp[n][i];\\n        }\\n        \\n        return sum%mod;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n) {\\n        vector<vector<long long>> dp(n+1,vector<long long>(5,0));\\n        //a = 0,e = 1,i =2, o =3, u=4;\\n        int mod = (int)1e9 + 7;\\n        \\n        for(int i=0;i<5;i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n        // for(auto it:dp){\\n        //     for(auto jt:it){\\n        //         cout<<jt<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        for(int j=2;j<=n;j++){\\n            dp[j][0] = (dp[j-1][1] + dp[j-1][2] + dp[j-1][4]) % mod; //a\\n            dp[j][1] = (dp[j-1][0] + dp[j-1][2]) % mod; //e\\n            dp[j][2] = (dp[j-1][1] + dp[j-1][3]) % mod; //i\\n            dp[j][3] = dp[j-1][2] % mod; // o\\n            dp[j][4] = (dp[j-1][2] + dp[j-1][3])%mod; //u\\n        }\\n        \\n        long long sum = 0;\\n        for(int i=0;i<5;i++){\\n            sum += dp[n][i];\\n        }\\n        \\n        return sum%mod;\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2391011,
                "title": "c-dp-memorization-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countVowelPermutation(int n) {\\n        vector<vector<long long>> dp(n,vector<long long>(6,-1));\\n        return fun(dp,0,-1);\\n    }\\n    int fun(vector<vector<long long>>& dp,int i,int c)\\n    {\\n        if(i>=dp.size())\\n            return 1;\\n        \\n        if(dp[i][c+1]!=-1)\\n            return dp[i][c+1];\\n        \\n        long long t=0;\\n        if(c==-1)\\n        {\\n            for(int j=0;j<5;j++)\\n                t+=fun(dp,i+1,j)%mod;\\n        }\\n        else\\n        {\\n            vector<long long> v(5,0);\\n            v[0]=fun(dp,i+1,0)%mod;// a\\n            v[1]=fun(dp,i+1,1)%mod;// e\\n            v[2]=fun(dp,i+1,2)%mod;// i\\n            v[3]=fun(dp,i+1,3)%mod;// o\\n            v[4]=fun(dp,i+1,4)%mod;// u\\n            \\n            if(c==0)// a\\n                t=v[1]%mod; // e\\n            if(c==1)// e\\n                t=(v[0]+v[2])%mod;// a,i\\n            if(c==2)// i\\n                t=(v[0]+v[1]+v[3]+v[4])%mod;// a,e,o,u\\n            if(c==3)// 0\\n                t=(v[2]+v[4])%mod;// i,u\\n            if(c==4)// u\\n                t=v[0]%mod;// a\\n        }\\n        return dp[i][c+1]=t%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int countVowelPermutation(int n) {\\n        vector<vector<long long>> dp(n,vector<long long>(6,-1));\\n        return fun(dp,0,-1);\\n    }\\n    int fun(vector<vector<long long>>& dp,int i,int c)\\n    {\\n        if(i>=dp.size())\\n            return 1;\\n        \\n        if(dp[i][c+1]!=-1)\\n            return dp[i][c+1];\\n        \\n        long long t=0;\\n        if(c==-1)\\n        {\\n            for(int j=0;j<5;j++)\\n                t+=fun(dp,i+1,j)%mod;\\n        }\\n        else\\n        {\\n            vector<long long> v(5,0);\\n            v[0]=fun(dp,i+1,0)%mod;// a\\n            v[1]=fun(dp,i+1,1)%mod;// e\\n            v[2]=fun(dp,i+1,2)%mod;// i\\n            v[3]=fun(dp,i+1,3)%mod;// o\\n            v[4]=fun(dp,i+1,4)%mod;// u\\n            \\n            if(c==0)// a\\n                t=v[1]%mod; // e\\n            if(c==1)// e\\n                t=(v[0]+v[2])%mod;// a,i\\n            if(c==2)// i\\n                t=(v[0]+v[1]+v[3]+v[4])%mod;// a,e,o,u\\n            if(c==3)// 0\\n                t=(v[2]+v[4])%mod;// i,u\\n            if(c==4)// u\\n                t=v[0]%mod;// a\\n        }\\n        return dp[i][c+1]=t%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390991,
                "title": "2-approaches-with-optimisation",
                "content": "**Solution 1:** Basic Tabulation with no optimisation -->\\n```\\nclass Solution {  // TC: O(N)  SC: O(N)\\n    private int add(int a,int b){return (int)(((long)a+b)%1000000007);}\\n    public int countVowelPermutation(int n) {\\n        int dp[][] = new int[n][5],i,j,res=0;\\n        for(j=0;j<5;j++) dp[0][j] = 1;\\n        for(i=0;i<(n-1);i++){\\n            dp[i+1][1]=add(dp[i+1][1],dp[i][0]); // for \\'a\\'\\n            \\n            dp[i+1][0]=add(dp[i+1][0],dp[i][1]); // for \\'e\\'\\n            dp[i+1][2]=add(dp[i+1][2],dp[i][1]);\\n            \\n            for(j=0;j<5;j++) if(j!=2) dp[i+1][j]=add(dp[i+1][j],dp[i][2]); // for \\'i\\'\\n            \\n            dp[i+1][2]=add(dp[i+1][2],dp[i][3]); // for \\'o\\'\\n            dp[i+1][4]=add(dp[i+1][4],dp[i][3]);\\n            \\n            dp[i+1][0]=add(dp[i+1][0],dp[i][4]); // for \\'u\\'\\n        }\\n        \\n        for(j=0;j<5;j++) res=add(res,dp[n-1][j]);\\n        \\n        return res;\\n    }\\n}\\n```\\n**Solution 2:** Space Optimised Tabulated approach -->\\n```\\nclass Solution {  // TC: O(N) SC: O(1)\\n    private int add(int a,int b){return (int)(((long)a+b)%1000000007);}\\n    public int countVowelPermutation(int n) {\\n        int dp[] = new int[5],j,res=0,a,e,i,o,u;\\n        for(j=0;j<5;j++) dp[j] = 1;\\n        for(j=0;j<(n-1);a=e=i=o=u=0,j++){             \\n            e=dp[0]; // for \\'a\\'             \\n            a=i=dp[1]; // for \\'e\\'\\n            a=add(a,dp[2]); e=add(e,dp[2]); o=dp[2]; u=dp[2]; // for \\'i\\'            \\n            i=add(i,dp[3]); u=add(u,dp[3]); // for \\'o\\'            \\n            a=add(a,dp[4]); // for \\'u\\'\\n            \\n            dp[0]=a; dp[1]=e; dp[2]=i; dp[3]=o; dp[4]=u;\\n        }\\n        \\n        for(j=0;j<5;j++) res=add(res,dp[j]);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {  // TC: O(N)  SC: O(N)\\n    private int add(int a,int b){return (int)(((long)a+b)%1000000007);}\\n    public int countVowelPermutation(int n) {\\n        int dp[][] = new int[n][5],i,j,res=0;\\n        for(j=0;j<5;j++) dp[0][j] = 1;\\n        for(i=0;i<(n-1);i++){\\n            dp[i+1][1]=add(dp[i+1][1],dp[i][0]); // for \\'a\\'\\n            \\n            dp[i+1][0]=add(dp[i+1][0],dp[i][1]); // for \\'e\\'\\n            dp[i+1][2]=add(dp[i+1][2],dp[i][1]);\\n            \\n            for(j=0;j<5;j++) if(j!=2) dp[i+1][j]=add(dp[i+1][j],dp[i][2]); // for \\'i\\'\\n            \\n            dp[i+1][2]=add(dp[i+1][2],dp[i][3]); // for \\'o\\'\\n            dp[i+1][4]=add(dp[i+1][4],dp[i][3]);\\n            \\n            dp[i+1][0]=add(dp[i+1][0],dp[i][4]); // for \\'u\\'\\n        }\\n        \\n        for(j=0;j<5;j++) res=add(res,dp[n-1][j]);\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {  // TC: O(N) SC: O(1)\\n    private int add(int a,int b){return (int)(((long)a+b)%1000000007);}\\n    public int countVowelPermutation(int n) {\\n        int dp[] = new int[5],j,res=0,a,e,i,o,u;\\n        for(j=0;j<5;j++) dp[j] = 1;\\n        for(j=0;j<(n-1);a=e=i=o=u=0,j++){             \\n            e=dp[0]; // for \\'a\\'             \\n            a=i=dp[1]; // for \\'e\\'\\n            a=add(a,dp[2]); e=add(e,dp[2]); o=dp[2]; u=dp[2]; // for \\'i\\'            \\n            i=add(i,dp[3]); u=add(u,dp[3]); // for \\'o\\'            \\n            a=add(a,dp[4]); // for \\'u\\'\\n            \\n            dp[0]=a; dp[1]=e; dp[2]=i; dp[3]=o; dp[4]=u;\\n        }\\n        \\n        for(j=0;j<5;j++) res=add(res,dp[j]);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390397,
                "title": "100-faster-dp-maths-solution-easy-understanding",
                "content": "# **100 % faster DP Maths Solution || Easy understanding**\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long a=1,b=1,c=1,d=1,e=1;\\n        long long sum=0;\\n        int mod=1000000007;\\n        for(int i=0;i<n;i++){\\n            sum=(a+b+c+d+e)%mod;\\n            \\n            long long arr[5]={a,b,c,d,e};\\n\\t\\t\\t//counting the occurances which will be ending with respective vowels\\n            a=(arr[1]+arr[2]+arr[4])%mod;\\n            b=(arr[0]+arr[2])%mod;\\n            c=(arr[1]+arr[3])%mod;\\n            d=(arr[2])%mod;\\n            e=(arr[2]+arr[3])%mod;\\n            \\n        }\\n        return sum%mod;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/7a9a071e-03d4-4253-82f7-9be15ea58353_1659843423.9459577.png)\\n\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long a=1,b=1,c=1,d=1,e=1;\\n        long long sum=0;\\n        int mod=1000000007;\\n        for(int i=0;i<n;i++){\\n            sum=(a+b+c+d+e)%mod;\\n            \\n            long long arr[5]={a,b,c,d,e};\\n\\t\\t\\t//counting the occurances which will be ending with respective vowels\\n            a=(arr[1]+arr[2]+arr[4])%mod;\\n            b=(arr[0]+arr[2])%mod;\\n            c=(arr[1]+arr[3])%mod;\\n            d=(arr[2])%mod;\\n            e=(arr[2]+arr[3])%mod;\\n            \\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390340,
                "title": "java-simple-solution-using-recursion-and-memoization",
                "content": "```\\nclass Solution {\\n\\t// a=0, e=1, i=2, o=3, u=4\\n\\t// Mapping a->e \\n\\t\\t\\t   e->a,i\\n\\t\\t\\t   i->a,e,o,u\\n\\t\\t\\t   o-> i,u\\n\\t\\t\\t   u->a\\n    int[][] canGo = {{1},{0,2},{0,1,3,4},{2,4},{0}}; \\n    int MOD = 1000000007;\\n    public int helper(int n, int prev, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][prev] != null)\\n            return dp[n][prev];\\n        int sum = 0;\\n\\t\\t// From previous vowel try all possible vowels that can come next\\n        for(int i: canGo[prev]){\\n            sum = (sum%MOD +helper(n-1,i,dp)%MOD)%MOD;\\n        }\\n        return dp[n][prev] = sum;\\n    }\\n    public int countVowelPermutation(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n][5];\\n        for(int i=0;i<5;i++){ // Start with all possibilities i.e. a, e, i, o, u\\n            ans = (ans + helper(n-1,i,dp))%MOD;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\t// a=0, e=1, i=2, o=3, u=4\\n\\t// Mapping a->e \\n\\t\\t\\t   e->a,i\\n\\t\\t\\t   i->a,e,o,u\\n\\t\\t\\t   o-> i,u\\n\\t\\t\\t   u->a\\n    int[][] canGo = {{1},{0,2},{0,1,3,4},{2,4},{0}}; \\n    int MOD = 1000000007;\\n    public int helper(int n, int prev, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][prev] != null)\\n            return dp[n][prev];\\n        int sum = 0;\\n\\t\\t// From previous vowel try all possible vowels that can come next\\n        for(int i: canGo[prev]){\\n            sum = (sum%MOD +helper(n-1,i,dp)%MOD)%MOD;\\n        }\\n        return dp[n][prev] = sum;\\n    }\\n    public int countVowelPermutation(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n][5];\\n        for(int i=0;i<5;i++){ // Start with all possibilities i.e. a, e, i, o, u\\n            ans = (ans + helper(n-1,i,dp))%MOD;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390233,
                "title": "beginner-friendly-java-javascript-python-o-n-solutions",
                "content": "**Time complexity : O(n)**\\n**Java**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        long mod = 1000000007;\\n        while(n-- > 1){\\n            long new_a = a % mod, new_e = e % mod, new_i = i % mod, new_o = o % mod, new_u = u % mod;\\n            a = new_e + new_i + new_u;\\n            e = new_a + new_i;\\n            i = new_e + new_o;\\n            o = new_i;\\n            u = new_i + new_o;\\n        }\\n        return (int)((a+e+i+o+u) % mod);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar countVowelPermutation = function(n) {\\n    let a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1000000007\\n    while(n-- > 1){\\n        let new_a = a % mod, new_e = e % mod, new_i = i % mod, new_o = o % mod, new_u = u % mod\\n        a = new_e + new_i + new_u\\n        e = new_a + new_i\\n        i = new_e + new_o\\n        o = new_i\\n        u = new_i + new_o\\n    }\\n    return (a + e + i + o + u) % mod\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def countVowelPermutation(self, n):\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a, e, i, o, u = e+i+u, a+i, e+o, i, i+o\\n        return (a+e+i+o+u) % (10**9+7)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        long mod = 1000000007;\\n        while(n-- > 1){\\n            long new_a = a % mod, new_e = e % mod, new_i = i % mod, new_o = o % mod, new_u = u % mod;\\n            a = new_e + new_i + new_u;\\n            e = new_a + new_i;\\n            i = new_e + new_o;\\n            o = new_i;\\n            u = new_i + new_o;\\n        }\\n        return (int)((a+e+i+o+u) % mod);\\n    }\\n}\\n```\n```\\nvar countVowelPermutation = function(n) {\\n    let a = 1, e = 1, i = 1, o = 1, u = 1, mod = 1000000007\\n    while(n-- > 1){\\n        let new_a = a % mod, new_e = e % mod, new_i = i % mod, new_o = o % mod, new_u = u % mod\\n        a = new_e + new_i + new_u\\n        e = new_a + new_i\\n        i = new_e + new_o\\n        o = new_i\\n        u = new_i + new_o\\n    }\\n    return (a + e + i + o + u) % mod\\n};\\n```\n```\\nclass Solution(object):\\n    def countVowelPermutation(self, n):\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a, e, i, o, u = e+i+u, a+i, e+o, i, i+o\\n        return (a+e+i+o+u) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751484,
                "title": "beginner-friendly-dfs-with-comments-grandma-can-understand-python",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={} // Dictionary which stores memoized solution \\n        rules={} // Dictionary which stores the rules given\\n        rules[\\'\\']={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'} // if the starting string is empty, it can choose any character in the vowels set\\n        rules[\\'a\\']={\\'e\\'} // a can only be followed by e\\n        rules[\\'e\\']={\\'a\\',\\'i\\'} // e can only be followed by a and i\\n        rules[\\'i\\']={\\'a\\',\\'e\\',\\'o\\',\\'u\\'} // i cannot be followed by another i\\n        rules[\\'o\\']={\\'i\\',\\'u\\'} // o can be only followed by i and u\\n        rules[\\'u\\']={\\'a\\'} // u can only be folllowed by a\\n        def dfs(i,last):   // passes in the current index to be inserted in the string and the last character used\\n            if i==n: // if current index is equal to n, then we have constructed the string of required length n\\n                dp[(i,last)]=1 // cache the value for current index and last character \\n            elif (i,last) not in dp:  // if current index, last character key not in DP\\n                dp[(i,last)]=0 // Initialize the dp[current index, last character] to 0\\n                for c in rules[last]: // For each character in rules we iterate \\n                    dp[(i,last)]+=dfs(i+1,c)  // increment by passing the next position and character as DFS\\n            return dp[(i,last)] // return the cached solution\\n        return dfs(0,\\'\\')%((10**9)+7) // return by calling dfs for starting index 0 and empty string \"\"\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp={} // Dictionary which stores memoized solution \\n        rules={} // Dictionary which stores the rules given\\n        rules[\\'\\']={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'} // if the starting string is empty, it can choose any character in the vowels set\\n        rules[\\'a\\']={\\'e\\'} // a can only be followed by e\\n        rules[\\'e\\']={\\'a\\',\\'i\\'} // e can only be followed by a and i\\n        rules[\\'i\\']={\\'a\\',\\'e\\',\\'o\\',\\'u\\'} // i cannot be followed by another i\\n        rules[\\'o\\']={\\'i\\',\\'u\\'} // o can be only followed by i and u\\n        rules[\\'u\\']={\\'a\\'} // u can only be folllowed by a\\n        def dfs(i,last):   // passes in the current index to be inserted in the string and the last character used\\n            if i==n: // if current index is equal to n, then we have constructed the string of required length n\\n                dp[(i,last)]=1 // cache the value for current index and last character \\n            elif (i,last) not in dp:  // if current index, last character key not in DP\\n                dp[(i,last)]=0 // Initialize the dp[current index, last character] to 0\\n                for c in rules[last]: // For each character in rules we iterate \\n                    dp[(i,last)]+=dfs(i+1,c)  // increment by passing the next position and character as DFS\\n            return dp[(i,last)] // return the cached solution\\n        return dfs(0,\\'\\')%((10**9)+7) // return by calling dfs for starting index 0 and empty string \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320295,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\t\\t# You can solve the problem removing the lists and just use a few variables, but for simplicity I used lists\\n\\t\\t# case where n=1\\n        a = [1]\\n        e = [1]\\n        i = [1]\\n        o = [1]\\n        u = [1]\\n        \\n        for _ in range(n-1):\\n            a.append(e[-1])\\n            e.append(a[-2] + i[-1]) # it is -2 because we appended a new number in the previous line (same thing will be with the rest)\\n            i.append(a[-2] + e[-2] + o[-1] + u[-1])\\n            o.append(i[-2] + u[-1])\\n            u.append(a[-2])\\n\\n        # get last values\\n        return (a[-1] + e[-1] + i[-1] + o[-1] + u[-1]) % (10**9+7)\\n\\t\\t\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n\\t\\t# You can solve the problem removing the lists and just use a few variables, but for simplicity I used lists\\n\\t\\t# case where n=1\\n        a = [1]\\n        e = [1]\\n        i = [1]\\n        o = [1]\\n        u = [1]\\n        \\n        for _ in range(n-1):\\n            a.append(e[-1])\\n            e.append(a[-2] + i[-1]) # it is -2 because we appended a new number in the previous line (same thing will be with the rest)\\n            i.append(a[-2] + e[-2] + o[-1] + u[-1])\\n            o.append(i[-2] + u[-1])\\n            u.append(a[-2])\\n\\n        # get last values\\n        return (a[-1] + e[-1] + i[-1] + o[-1] + u[-1]) % (10**9+7)\\n\\t\\t\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317522,
                "title": "c-nothing-fancy-just-10-lines-of-code",
                "content": "```\\n#define MOD 1000000007;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        for(int it=1;it<n;it++){\\n            long long aw = a, ew = e, iw = i, ow = o, uw = u;\\n            e = (aw + iw)%MOD;\\n            a = (ew + iw + uw)%MOD;\\n            i = (ew + ow)%MOD;\\n            o = iw;\\n            u = (iw + ow)%MOD;\\n        }\\n        return (a+e+i+o+u)%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define MOD 1000000007;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long a = 1, e = 1, i = 1, o = 1, u = 1;\\n        for(int it=1;it<n;it++){\\n            long long aw = a, ew = e, iw = i, ow = o, uw = u;\\n            e = (aw + iw)%MOD;\\n            a = (ew + iw + uw)%MOD;\\n            i = (ew + ow)%MOD;\\n            o = iw;\\n            u = (iw + ow)%MOD;\\n        }\\n        return (a+e+i+o+u)%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316811,
                "title": "unordered-map-instead-of-dp-array-o-n",
                "content": "i have used two unordered maps. one for previous values and another for current values\\ncounting the occurences of a last charecter ,then adding it to corresponding character folows  \\nthat...\\n```\\nclass Solution {\\npublic:\\n     const unsigned int M = 1000000007;\\n    int countVowelPermutation(int n) {\\n        unordered_map<char,long>m;\\n        unordered_map<char,long>um;\\n        m[\\'a\\']=1;\\n        m[\\'e\\']=1;\\n        m[\\'i\\']=1;\\n        m[\\'o\\']=1;\\n        m[\\'u\\']=1;\\n        for(int i=1;i<n;i++){\\n            for(auto c:m) um[c.first]=c.second;\\n            m[\\'a\\']=(um[\\'e\\']+um[\\'u\\']+um[\\'i\\'])%M;\\n            m[\\'e\\']=(um[\\'a\\']+um[\\'i\\'])%M;\\n            m[\\'i\\']=(um[\\'e\\']+um[\\'o\\'])%M;\\n            m[\\'o\\']=(um[\\'i\\'])%M;\\n            m[\\'u\\']=(um[\\'i\\']+um[\\'o\\'])%M;\\n        }\\n        long long sum=0;\\n        for(auto c: m){\\n            sum=(sum+c.second)%M;\\n        }\\n     return sum;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     const unsigned int M = 1000000007;\\n    int countVowelPermutation(int n) {\\n        unordered_map<char,long>m;\\n        unordered_map<char,long>um;\\n        m[\\'a\\']=1;\\n        m[\\'e\\']=1;\\n        m[\\'i\\']=1;\\n        m[\\'o\\']=1;\\n        m[\\'u\\']=1;\\n        for(int i=1;i<n;i++){\\n            for(auto c:m) um[c.first]=c.second;\\n            m[\\'a\\']=(um[\\'e\\']+um[\\'u\\']+um[\\'i\\'])%M;\\n            m[\\'e\\']=(um[\\'a\\']+um[\\'i\\'])%M;\\n            m[\\'i\\']=(um[\\'e\\']+um[\\'o\\'])%M;\\n            m[\\'o\\']=(um[\\'i\\'])%M;\\n            m[\\'u\\']=(um[\\'i\\']+um[\\'o\\'])%M;\\n        }\\n        long long sum=0;\\n        for(auto c: m){\\n            sum=(sum+c.second)%M;\\n        }\\n     return sum;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316739,
                "title": "count-vowel-soltion-in-java-very-easy-to-understand",
                "content": "class Solution {\\n    int mod=1000000007;\\n\\t HashMap<Character,Integer> map=new HashMap<Character,Integer>();\\n\\t ArrayList<ArrayList<Character>> arr=new ArrayList<ArrayList<Character>>();\\n\\tpublic  int Permutation(char ch[],int n,int j,int dp[][])\\n\\t{\\n\\t\\tif(n==0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\tif(dp[n][j]>-1)\\n\\t\\t{\\n\\t\\t\\treturn dp[n][j];\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tint result=0;\\n\\t\\t\\tfor(int i=0;i<arr.get(j).size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult=(result%mod+(Permutation(ch,n-1,map.get(arr.get(j).get(i)),dp)%mod)%mod);\\n\\t\\t\\t}\\n\\t\\t     return dp[n][j]=result;\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t public  int countVowelPermutation(int n)\\n\\t    {\\n\\t         map.put(\\'a\\',0);map.put(\\'e\\',1);map.put(\\'i\\',2);map.put(\\'o\\',3);map.put(\\'u\\',4);\\n\\t         int dp[][]=new int[n+1][7];\\n\\t         for(int i=0;i<n+1;i++)\\n\\t         {\\n\\t        \\t for(int j=0;j<7;j++)\\n\\t        \\t {\\n\\t        \\t\\t dp[i][j]=-1;\\n\\t        \\t }\\n\\t         }\\n\\t         for(int i=0;i<5;i++)\\n\\t         {\\n\\t        \\t arr.add(new ArrayList());\\n\\t         }\\n\\t         arr.get(0).add(\\'e\\');arr.get(1).add(\\'a\\');\\n\\t         arr.get(1).add(\\'i\\');arr.get(2).add(\\'a\\');arr.get(2).add(\\'e\\');arr.get(2).add(\\'o\\');arr.get(2).add(\\'u\\');\\n\\t         arr.get(3).add(\\'i\\');arr.get(3).add(\\'u\\');arr.get(4).add(\\'a\\');\\n\\t         char ch[]= {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n\\t         int result=0;\\n\\t         for(int i=0;i<5;i++)\\n\\t         {\\n\\t        \\t result=(result%mod+Permutation(ch,n-1,i,dp)%mod)%mod;\\n\\t        \\t \\n\\t         }\\n         System.out.println(result);\\n\\t         return result;\\n\\t    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    int mod=1000000007;\\n\\t HashMap<Character,Integer> map=new HashMap<Character,Integer>();\\n\\t ArrayList<ArrayList<Character>> arr=new ArrayList<ArrayList<Character>>();\\n\\tpublic  int Permutation(char ch[],int n,int j,int dp[][])\\n\\t{\\n\\t\\tif(n==0)\\n\\t\\t{\\n\\t\\t\\treturn 1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1316711,
                "title": "java-o-n-and-o-log-n-with-detailed-explanation",
                "content": "**DP: Linear calculation**\\n\\nLet dp[L][a] represent the number of strings of length ```L``` ending with ```a``` (same thing goes for other characters), then as per the rules given in the problem, we have the following recurrence relations:\\n\\ndp[L+1][a] = dp[L][e] + dp[L][i] + dp[L][u]       // because ```a``` can come after ```e```, ```i``` and ```u``` only\\ndp[L+1][e] = dp[L][a] + dp[L][i]\\ndp[L+1][i] = dp[L][e] + dp[L][o]\\ndp[L+1][o] = dp[L][i]\\ndp[L+1][u] = dp[L][i] + dp[L][o]\\n\\nAs values for dp[L+1] depends only on dp[L] values, we can just maintain the last set of values instead of full dp table thereby reducing space.\\n\\n```\\n// 8 ms. 92.46%\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long A = 1, E = 1, I = 1, O = 1, U = 1, MOD = 1_000_000_007;\\n        while(--n > 0) {\\n            long a = A, e = E, i = I, o = O, u = U;\\n            A = (e + i + u) % MOD;\\n            E = (a + i) % MOD;\\n            I = (e + o) % MOD;\\n            O = i;\\n            U = (i + o) % MOD;\\n        }\\n        return (int) ((A + E + I + O + U) % MOD);\\n    }\\n}\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n**DP: Logarithmic calculation using matrix multiplication**\\n************\\nWe can speed up calculation of higher terms of linear recurrence relations using matrix multiplication. Approach goes like this:\\n\\nSay, we have a function f which is recursively defined like this:\\n\\nf(i) = c(i-1) * f(i-1) + c(i-2) * f(i-2) + ... + c(i-k) * f(i-k)\\n\\nwhere c(i-1), c(i-2) ... c(i-k) are some constant values which represent the coefficients of corresponding terms. Since f depends on last k terms, we\\'d be given its first k values (or base case), in other words, f(0), f(1), ... f(k-1) are known.\\n\\nNow, we define two matrices, F(i) and C.\\n\\nF(i) is a 1 x k matrix = [ f(i) f(i-1) ... f(i-k+1) ]\\nSimilarly, F(i-1) = [ f(i-1) f(i-2) ... f(i-k) ]\\n\\nC is a k x k matrix = [ c(i-1) 1 0 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-2) 0 1 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-3) 0 0 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;...\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-k+1) 0 0 ... 1 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-k) 0 0 ... 0 ]\\n\\nFirst column has all the coefficients. Second column has a 1 in first row, all other elements are zero. Third column has a 1 in second row, all other elements are zero. And so on for the remaining columns.\\n\\nDefining F and C this way ensures that:\\n[ f(i) f(i-1) ... f(i-k+1) ] = [ f(i-1) f(i-2) ... f(i-k) ] * [ c(i-1) 1 0 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-2) 0 1 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp; [ c(i-3) 0 0 ... 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;...\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-k+1) 0 0 ... 1 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ c(i-k) 0 0 ... 0 ]\\n\\ni.e. F(i) = F(i-1) * C\\nSo to get F(i+1),\\nF(i+1) = F(i) * C = F(i-1) * C * C = F(i-1) * C<sup>2</sup>\\nSimilarly, to get F(n),\\nF(n) = F(n-1) * C = F(n-2) * C<sup>2</sup> = ... = F(k-1) * C<sup>n-k+1</sup>\\n\\nCalculating C<sup>p</sup> takes O(log p) iterations using [exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring). Since all multiplications are of k x k matrices, it takes O(k<sup>3</sup>) time for each.\\n\\nSo, overall time complexity to calculate f(n) using this approach is O(k<sup>3</sup> log (n - k + 1)). Since k is generally much smaller compared to n, this is much faster than O(n).\\n\\n************\\nComing to this problem, our matrix equation looks like this:\\n\\n[ dp[L+1][a]  dp[L+1][e] dp[L+1][i] dp[L+1][o] dp[L+1] [u] ] = [ dp[L][a]  dp[L][e] dp[L][i] dp[L][o] dp[L] [u] ] * [ 0 1 0 0 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ 1 0 1 0 0 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ 1 1 0 1 1 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ 0 0 1 0 1 ]\\n&nbsp; &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;  &nbsp;[ 1 0 0 0 0 ]\\n\\nOnce we have the correct coefficient matrix, remaining steps are identical.\\n\\n```\\n// 2 ms. 99.44%\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n    private int[][] multiply(int[][] A, int[][] B) {\\n        int m = A.length, kk = B.length, n = B[0].length;\\n        int[][] P = new int[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                for(int k = 0; k < kk; k++) {\\n                    P[i][j] = (int) ((P[i][j] + (long) A[i][k] * B[k][j]) % MOD);\\n                }\\n            }\\n        }\\n        return P;\\n    }\\n    private int[][] power(int[][] A, int n) {\\n        int[][] R = new int[A.length][A.length];\\n        for(int i = 0; i < R.length; i++) {\\n            R[i][i] = 1;\\n        }\\n        while(n > 0) {\\n            if((n & 1) != 0) {\\n                R = multiply(R, A);\\n            }\\n            A = multiply(A, A);\\n            n >>= 1;\\n        }\\n        return R;\\n    }\\n    public int countVowelPermutation(int n) {\\n        int[][] C = {\\n            {0, 1, 0, 0, 0},\\n            {1, 0, 1, 0, 0},\\n            {1, 1, 0, 1, 1},\\n            {0, 0, 1, 0, 1},\\n            {1, 0, 0, 0, 0}\\n        };\\n        int[] F = multiply(new int[][] { {1, 1, 1, 1, 1} }, power(C, n - 1))[0];\\n        int res = 0;\\n        for(int i = 0; i < 5; i++) {\\n            res = (res + F[i]) % MOD;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nTime complexity: O(log n)\\nSpace complexity: O(1)",
                "solutionTags": [],
                "code": "```L```\n```a```\n```a```\n```e```\n```i```\n```u```\n```\\n// 8 ms. 92.46%\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        long A = 1, E = 1, I = 1, O = 1, U = 1, MOD = 1_000_000_007;\\n        while(--n > 0) {\\n            long a = A, e = E, i = I, o = O, u = U;\\n            A = (e + i + u) % MOD;\\n            E = (a + i) % MOD;\\n            I = (e + o) % MOD;\\n            O = i;\\n            U = (i + o) % MOD;\\n        }\\n        return (int) ((A + E + I + O + U) % MOD);\\n    }\\n}\\n```\n```\\n// 2 ms. 99.44%\\nclass Solution {\\n    private final int MOD = 1_000_000_007;\\n    private int[][] multiply(int[][] A, int[][] B) {\\n        int m = A.length, kk = B.length, n = B[0].length;\\n        int[][] P = new int[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                for(int k = 0; k < kk; k++) {\\n                    P[i][j] = (int) ((P[i][j] + (long) A[i][k] * B[k][j]) % MOD);\\n                }\\n            }\\n        }\\n        return P;\\n    }\\n    private int[][] power(int[][] A, int n) {\\n        int[][] R = new int[A.length][A.length];\\n        for(int i = 0; i < R.length; i++) {\\n            R[i][i] = 1;\\n        }\\n        while(n > 0) {\\n            if((n & 1) != 0) {\\n                R = multiply(R, A);\\n            }\\n            A = multiply(A, A);\\n            n >>= 1;\\n        }\\n        return R;\\n    }\\n    public int countVowelPermutation(int n) {\\n        int[][] C = {\\n            {0, 1, 0, 0, 0},\\n            {1, 0, 1, 0, 0},\\n            {1, 1, 0, 1, 1},\\n            {0, 0, 1, 0, 1},\\n            {1, 0, 0, 0, 0}\\n        };\\n        int[] F = multiply(new int[][] { {1, 1, 1, 1, 1} }, power(C, n - 1))[0];\\n        int res = 0;\\n        for(int i = 0; i < 5; i++) {\\n            res = (res + F[i]) % MOD;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316707,
                "title": "c-8ms-6-1mb-dp-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tconst int MOD = 1e9 + 7;\\n\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\tvector<int> arr(5 ,1);\\n\\n\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\tint arr1 = arr[1];\\n\\t\\t\\t\\tint arr2 = arr[2];\\n\\t\\t\\t\\tarr[1] = (arr[0] + arr2)%MOD;\\n\\t\\t\\t\\tarr[2] = (arr1 + arr[3])%MOD;\\n\\t\\t\\t\\tarr[0] = ((arr1 + arr2)%MOD + arr[4])%MOD;\\n\\t\\t\\t\\tarr[4] = (arr2 + arr[3])%MOD;\\n\\t\\t\\t\\tarr[3] = arr2%MOD;\\n\\t\\t\\t}\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int i = 0;i < 5; i++){\\n\\t\\t\\t\\tsum += arr[i];\\n\\t\\t\\t\\tsum %= MOD;\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tconst int MOD = 1e9 + 7;\\n\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\tvector<int> arr(5 ,1);\\n\\n\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\tint arr1 = arr[1];\\n\\t\\t\\t\\tint arr2 = arr[2];\\n\\t\\t\\t\\tarr[1] = (arr[0] + arr2)%MOD;\\n\\t\\t\\t\\tarr[2] = (arr1 + arr[3])%MOD;\\n\\t\\t\\t\\tarr[0] = ((arr1 + arr2)%MOD + arr[4])%MOD;\\n\\t\\t\\t\\tarr[4] = (arr2 + arr[3])%MOD;\\n\\t\\t\\t\\tarr[3] = arr2%MOD;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1316547,
                "title": "python-dp-recursive-o-n-matrix-multiplication-o-log-n-5-solutions-explained",
                "content": "### Approach #1 - Top-down Recursive with cache\\n* We know which characters will be follow after the `last` character, which are stored in `next_chars`\\n* In every iteration, we reduce the value of `n` and recursively compute the number of permutations for each possible `last` character.\\n* We have to cache intermediate solutions to avoid computing the same solution for a pair of `last` and `m`\\n* Complexity: \\n\\t* Time: `O(n)`\\n\\t\\t*  In every iteration, there will be at max 5 recursive calls, rest will be cached.\\n\\t\\t*  There will be `n` iterations, since we decrease it by 1 every time.\\n\\t* Space: `O(n)`\\n\\t\\t* Stack space and some constant space taken by each instance of `countPerms()`\\n\\n### Python Implementation #1A\\n* Using the rules in forward: which characters will come after the current one.\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        next_chars = {\\'a\\': \\'e\\', \\'e\\': \\'ai\\', \\'i\\': \\'aeou\\', \\'o\\': \\'iu\\', \\'u\\': \\'a\\', \\'\\': \\'aeiou\\'}\\n        @cache\\n        def countPerms(last, m):\\n            if m == 0: return 1\\n            return sum([countPerms(c, m-1) for c in next_chars[last]]) % (10**9+7)\\n        return countPerms(\\'\\', n)\\n```\\n\\n### Python Implementation #1B\\n* Using the rules in reverse: which characters came before the current one.\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        prev_chars = {\\'a\\': \\'eiu\\', \\'e\\': \\'ai\\', \\'i\\': \\'eo\\', \\'o\\': \\'i\\', \\'u\\': \\'io\\', \\'\\': \\'aeiou\\'}\\n        \\n        @cache\\n        def countPerms(last, m):\\n            if m == 0: return 1\\n            return sum([countPerms(c, m-1) for c in prev_chars[last]]) % (10**9+7)\\n            \\n        return countPerms(\\'\\', n)\\n```\\n\\n### Approach #2 - Bottom-up Dynamic Programming\\n* Similar approach as above, but this time we go bottom-up.\\n* Time complexity remains the same, `O(n)`\\n\\t*  It runs faster as it doesn\\'t need to visit call stack everytime\\n* Space complexity becomes `O(1)`\\n\\n### Python Implementation #2A\\n* Using the rules in forward: which characters will come after the current one.\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        M = 10**9+7\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a,e,i,o,u = e, a+i, a+e+o+u, i+u, a\\n            a,e,i,o,u = [x % M for x in (a,e,i,o,u)]\\n        return (a+e+i+o+u) % M\\n```\\n\\n### Python Implementation #2B\\n* Using the rules in reverse: which characters came before the current one.\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        M = 10**9+7\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a,e,i,o,u = e+i+u, a+i, e+o, i, i+o\\n            a,e,i,o,u = [x % M for x in (a,e,i,o,u)]\\n        return (a+e+i+o+u) % M\\n```\\n\\n### Approach #3 - Matrix Multiplication in O(log n) time\\n* We can represent the character followed-by relationship using a Transition Matrix `T` \\n* Identity Matrix `I` represents the case `n=1`\\n* Every time we want to add a character, as per the rules, we just need to multiply the Identity Matrix with the Transition Matrix `I X T`\\n* For a string of length `n` the answer is the sum of all the numbers in the matrix: \\n\\t`result = I x T x T x T x ... (n-1) times`\\n* This can be done in maximum `2*log(n)` steps, each involving one matrix multiplication\\n\\t* If `n` is odd: multiply `result` with `T` and reduce `n` by `1`\\n\\t* If `n` is even: multiply `T`  with itself and reduce `n` by a factor of `2`\\n\\t* `n` will eventually become `1` and populate the correct answer into `result`\\n* The matrix multiplication has to be done in `mod 10^9+7` since numbers can become large\\n* Final answer is the sum of all numbers in the `result` matrix (`mod 10^9+7`)\\n* Complexity:\\n\\t* Time: `O(log n)`  \\n\\t\\t* Every two consecutive steps in the loop will halve `n`\\n\\t\\t* Every step multiplies two 5x5 matrices in `O(1)` time\\n\\t* Space: `O(1)`\\n\\t\\t* Need to hold only two 5x5 matrices in memory and a few other variables\\n\\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        # O(log n) solution\\n        M = 10**9+7\\n\\n        def multiply(A, B):\\n            C = [[0]*5 for _ in range(5)]\\n            for i in range(5):\\n                for j in range(5):\\n                    for k in range(5):\\n                        C[i][j] = (C[i][j] + (A[i][k] * B[k][j]) % M) % M\\n            return C\\n        \\n        # Transition matrix derived from the rules\\n        T = [[0, 1, 0, 0, 0],[1, 0, 1, 0, 0],[1, 1, 0, 1, 1], [0, 0, 1, 0, 1],[1, 0, 0, 0, 0]]\\n        \\n        # Identity matrix\\n        result = [[1 if i == j else 0 for i in range(5)] for j in range(5)]\\n        n -= 1\\n        while n:\\n            if n&1: \\n                result = multiply(result, T)\\n                n -= 1\\n            else:\\n                T = multiply(T, T)\\n                n //= 2\\n                \\n        return sum([sum(row) % M for row in result]) % M\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def countVowelPermutation(self, n: int) -> int:\\n        next_chars = {\\'a\\': \\'e\\', \\'e\\': \\'ai\\', \\'i\\': \\'aeou\\', \\'o\\': \\'iu\\', \\'u\\': \\'a\\', \\'\\': \\'aeiou\\'}\\n        @cache\\n        def countPerms(last, m):\\n            if m == 0: return 1\\n            return sum([countPerms(c, m-1) for c in next_chars[last]]) % (10**9+7)\\n        return countPerms(\\'\\', n)\\n```\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        \\n        prev_chars = {\\'a\\': \\'eiu\\', \\'e\\': \\'ai\\', \\'i\\': \\'eo\\', \\'o\\': \\'i\\', \\'u\\': \\'io\\', \\'\\': \\'aeiou\\'}\\n        \\n        @cache\\n        def countPerms(last, m):\\n            if m == 0: return 1\\n            return sum([countPerms(c, m-1) for c in prev_chars[last]]) % (10**9+7)\\n            \\n        return countPerms(\\'\\', n)\\n```\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        M = 10**9+7\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a,e,i,o,u = e, a+i, a+e+o+u, i+u, a\\n            a,e,i,o,u = [x % M for x in (a,e,i,o,u)]\\n        return (a+e+i+o+u) % M\\n```\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        M = 10**9+7\\n        a = e = i = o = u = 1\\n        for _ in range(n-1):\\n            a,e,i,o,u = e+i+u, a+i, e+o, i, i+o\\n            a,e,i,o,u = [x % M for x in (a,e,i,o,u)]\\n        return (a+e+i+o+u) % M\\n```\n```\\n    def countVowelPermutation(self, n: int) -> int:\\n        # O(log n) solution\\n        M = 10**9+7\\n\\n        def multiply(A, B):\\n            C = [[0]*5 for _ in range(5)]\\n            for i in range(5):\\n                for j in range(5):\\n                    for k in range(5):\\n                        C[i][j] = (C[i][j] + (A[i][k] * B[k][j]) % M) % M\\n            return C\\n        \\n        # Transition matrix derived from the rules\\n        T = [[0, 1, 0, 0, 0],[1, 0, 1, 0, 0],[1, 1, 0, 1, 1], [0, 0, 1, 0, 1],[1, 0, 0, 0, 0]]\\n        \\n        # Identity matrix\\n        result = [[1 if i == j else 0 for i in range(5)] for j in range(5)]\\n        n -= 1\\n        while n:\\n            if n&1: \\n                result = multiply(result, T)\\n                n -= 1\\n            else:\\n                T = multiply(T, T)\\n                n //= 2\\n                \\n        return sum([sum(row) % M for row in result]) % M\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1316534,
                "title": "count-vowels-permutation-c-so-much-easy-solution",
                "content": "Look,\\nAll the strings of length n may ends with \\'a\\' / \\'e\\' / \\'i\\' / \\'o\\' / \\'u\\'. So we have to sum up all those string of length n.\\n\\nFor n=1,\\nThere are only 1 string of length 1 ends with each of the 5 vowels. So ans is 5.\\n\\nFor n>1,\\n1. If a string ends with \\'a\\', the vowel before \\'a\\' should be \\'e\\' / \\'i\\' / \\'u\\'.\\n2. If a string ends with \\'e\\', the vowel before \\'e\\' should be \\'a\\' / \\'i\\'.\\n3. If a string ends with \\'i\\', the vowel before \\'i\\' should be \\'e\\' / \\'o\\'.\\n4. If a string ends with \\'o\\', the vowel before \\'o\\' should be \\'i\\'.\\n5. If a string ends with \\'u\\', the vowel before \\'u\\' should be  \\'i\\' / \\'o\\'.\\n\\nSo,\\nThe number of string of length n ends with \\'a\\' is the sum of the number of string of length (n-1) ends with \\'e\\' and  ends with \\'i\\' and ends with \\'u\\'. Same for the other 4 vowels.\\n\\nFrom 2 to n , we have to update the number of string ends with each vowel from its previous record.\\n\\nAt last ans is the total number of string ends with each 5 vowels.\\n\\nN.B: Everytime mod each calculation with 1000000007.\\n\\n**Runtime beats : 100.00%   and Memory usage beats : 95.70%**\\n**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long j,pre_a,pre_e,pre_i,pre_o,pre_u,new_a,new_e,new_i,new_o,new_u,ans=0,m=1000000007;\\n        \\n        //for n=1\\n        new_a=new_e=new_i=new_o=new_u=1;\\n        \\n        //from 2 to n updating the string number from previous record\\n        for(j=2;j<=n;j++){\\n            //recording new to previous for next calculation\\n            pre_a=new_a, pre_e=new_e, pre_i=new_i, pre_o=new_o, pre_u=new_u;\\n            \\n            new_a=((pre_e % m) + (pre_i % m) + (pre_u % m))%m;\\n            new_e=((pre_a % m) + (pre_i % m))%m;\\n            new_i=((pre_e % m) + (pre_o % m))%m;\\n            new_o=pre_i % m;\\n            new_u=((pre_i % m) + (pre_o % m))%m;\\n        }\\n        ans=(new_a + new_e + new_i + new_o + new_u)%m;\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Time Complexity : O(n)\\nSpace Complexity :O(1)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long long j,pre_a,pre_e,pre_i,pre_o,pre_u,new_a,new_e,new_i,new_o,new_u,ans=0,m=1000000007;\\n        \\n        //for n=1\\n        new_a=new_e=new_i=new_o=new_u=1;\\n        \\n        //from 2 to n updating the string number from previous record\\n        for(j=2;j<=n;j++){\\n            //recording new to previous for next calculation\\n            pre_a=new_a, pre_e=new_e, pre_i=new_i, pre_o=new_o, pre_u=new_u;\\n            \\n            new_a=((pre_e % m) + (pre_i % m) + (pre_u % m))%m;\\n            new_e=((pre_a % m) + (pre_i % m))%m;\\n            new_i=((pre_e % m) + (pre_o % m))%m;\\n            new_o=pre_i % m;\\n            new_u=((pre_i % m) + (pre_o % m))%m;\\n        }\\n        ans=(new_a + new_e + new_i + new_o + new_u)%m;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315306,
                "title": "c-really-simple-solution-explaination",
                "content": "The logic is really simple : We just need to follow the constraints. \\nLet 0 denotes \\'a\\', 1 denotes \\'e\\', 2 denotes \\'i\\', 3 denotes \\'o\\' and 4 denotes \\'u\\'. \\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\t\\tlong long int mod = pow(10, 9) + 7;\\n\\t\\t\\t\\tvector <long long int> dp1(5, 1);\\n\\t\\t\\t\\tvector <long long int> dp2(5, 1);\\n\\t\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\t\\tdp2[0] = dp1[1]; // Since a should be followed by e\\n\\t\\t\\t\\t\\tdp2[1] = (dp1[0] + dp1[2]) % mod; // e should be followed by a or i\\n\\t\\t\\t\\t\\tdp2[2] = (dp1[0] + dp1[1] + dp1[3] + dp1[4]) % mod; // i can be followed by anything except i\\n\\t\\t\\t\\t\\tdp2[3] = (dp1[2] + dp1[4]) % mod; // o should be followed by i or u\\n\\t\\t\\t\\t\\tdp2[4] = dp1[0]; // u should be followed by a\\n\\t\\t\\t\\t\\tdp1 = dp2; // copying the values for next iteration\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long int count = 0;\\n\\t\\t\\t\\tfor(int i = 0; i < 5; i++) // Do summation of the resultant array for all the sequences count.\\n\\t\\t\\t\\t\\tcount = (count + dp1[i]) % mod;\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\nDo upvote, if you find it useful.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint countVowelPermutation(int n) {\\n\\t\\t\\t\\tlong long int mod = pow(10, 9) + 7;\\n\\t\\t\\t\\tvector <long long int> dp1(5, 1);\\n\\t\\t\\t\\tvector <long long int> dp2(5, 1);\\n\\t\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\t\\tdp2[0] = dp1[1]; // Since a should be followed by e\\n\\t\\t\\t\\t\\tdp2[1] = (dp1[0] + dp1[2]) % mod; // e should be followed by a or i\\n\\t\\t\\t\\t\\tdp2[2] = (dp1[0] + dp1[1] + dp1[3] + dp1[4]) % mod; // i can be followed by anything except i\\n\\t\\t\\t\\t\\tdp2[3] = (dp1[2] + dp1[4]) % mod; // o should be followed by i or u\\n\\t\\t\\t\\t\\tdp2[4] = dp1[0]; // u should be followed by a\\n\\t\\t\\t\\t\\tdp1 = dp2; // copying the values for next iteration\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1315112,
                "title": "simple-solution-in-java-treating-the-conditions-as-a-directed-graph",
                "content": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        if(n == 1){\\n            return 5;\\n        }\\n        \\n        int mod = (int) (1e9 + 7);\\n    \\n        // denoting the vowels by integers:\\n        // a: 0, e: 1, i: 2, o: 3, u: 4\\n        long dp[][] = new long[n + 1][5];\\n        \\n        for(int i = 0; i < 5; i++){\\n            dp[0][i] = 0;\\n            dp[1][i] = 1;\\n        }\\n        \\n        int graph[][] = new int[][]{\\n            {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}\\n        };\\n        \\n        for(int i = 1; i < n; i++){\\n            for(int node = 0; node < 5; node++){\\n                for(int neighbor: graph[node]){\\n\\t\\t\\t\\t\\t// for length i + 1, all the permutations that satisfy the conditions can be taken, basically having a link from node to neighbor means satisfying the condition for the node \"node\"\\n                    dp[i + 1][node] += dp[i][neighbor] % mod;\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for(int i = 0; i < 5; i++){\\n            ans = (ans + dp[n][i]) % mod;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        if(n == 1){\\n            return 5;\\n        }\\n        \\n        int mod = (int) (1e9 + 7);\\n    \\n        // denoting the vowels by integers:\\n        // a: 0, e: 1, i: 2, o: 3, u: 4\\n        long dp[][] = new long[n + 1][5];\\n        \\n        for(int i = 0; i < 5; i++){\\n            dp[0][i] = 0;\\n            dp[1][i] = 1;\\n        }\\n        \\n        int graph[][] = new int[][]{\\n            {1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}\\n        };\\n        \\n        for(int i = 1; i < n; i++){\\n            for(int node = 0; node < 5; node++){\\n                for(int neighbor: graph[node]){\\n\\t\\t\\t\\t\\t// for length i + 1, all the permutations that satisfy the conditions can be taken, basically having a link from node to neighbor means satisfying the condition for the node \"node\"\\n                    dp[i + 1][node] += dp[i][neighbor] % mod;\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for(int i = 0; i < 5; i++){\\n            ans = (ans + dp[n][i]) % mod;\\n        }\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681748,
                "title": "java-intuitive-nice-and-clean-top-down-dp-solution-recursive-memo",
                "content": "```\\nclass Solution {\\n    private final char[] vowels = new char[]{\\'#\\',\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    private final int MOD = 1_000_000_007;\\n    private int length;\\n    private int[][] memo;\\n    \\n    public int countVowelPermutation(int n) {\\n        length = n;\\n        memo = new int[n][6];\\n        for (int[] ints : memo) Arrays.fill(ints, -1);\\n        return count(0, 0);\\n    }\\n\\n    private int count(int index, int previous) {\\n        if (index == length) return 1;\\n        if (memo[index][previous] != -1) return memo[index][previous];\\n\\n        long result = 0;\\n        for (int i = 1; i < vowels.length; i++) {\\n            char vowel = vowels[i];\\n            switch (vowels[previous]) {\\n                case \\'a\\':\\n                    if (vowel == \\'e\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'e\\':\\n                    if (vowel == \\'a\\' || vowel == \\'i\\')\\n                        result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'i\\':\\n                    if (vowel != \\'i\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'o\\':\\n                    if (vowel == \\'i\\' || vowel == \\'u\\')\\n                        result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'u\\':\\n                    if (vowel == \\'a\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                default:\\n                    result = (result + count(index + 1, i)) % MOD;\\n            }\\n        }\\n\\n        memo[index][previous] = (int) result;\\n        return memo[index][previous];\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private final char[] vowels = new char[]{\\'#\\',\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    private final int MOD = 1_000_000_007;\\n    private int length;\\n    private int[][] memo;\\n    \\n    public int countVowelPermutation(int n) {\\n        length = n;\\n        memo = new int[n][6];\\n        for (int[] ints : memo) Arrays.fill(ints, -1);\\n        return count(0, 0);\\n    }\\n\\n    private int count(int index, int previous) {\\n        if (index == length) return 1;\\n        if (memo[index][previous] != -1) return memo[index][previous];\\n\\n        long result = 0;\\n        for (int i = 1; i < vowels.length; i++) {\\n            char vowel = vowels[i];\\n            switch (vowels[previous]) {\\n                case \\'a\\':\\n                    if (vowel == \\'e\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'e\\':\\n                    if (vowel == \\'a\\' || vowel == \\'i\\')\\n                        result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'i\\':\\n                    if (vowel != \\'i\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'o\\':\\n                    if (vowel == \\'i\\' || vowel == \\'u\\')\\n                        result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                case \\'u\\':\\n                    if (vowel == \\'a\\') result = (result + count(index + 1, i)) % MOD;\\n                    break;\\n                default:\\n                    result = (result + count(index + 1, i)) % MOD;\\n            }\\n        }\\n\\n        memo[index][previous] = (int) result;\\n        return memo[index][previous];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556830,
                "title": "python-easy-peasy-top-down-dp-recursion-memoization",
                "content": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        m = (10**9+7)\\n        from functools import lru_cache\\n        \\n        @lru_cache(None)\\n        def helper(last, n):\\n            if n==1:\\n                if last==None:\\n                    return 5\\n                else:\\n                    if last==\\'a\\':\\n                        return 1\\n                    if last==\\'e\\':\\n                        return 2\\n                    if last==\\'i\\':\\n                        return 4\\n                    if last==\\'o\\':\\n                        return 2\\n                    if last==\\'u\\':\\n                        return 1\\n                \\n            ans  = 0\\n            if last==None:\\n                ans += helper(\\'a\\', n-1)+helper(\\'e\\', n-1)+helper(\\'i\\', n-1)+helper(\\'o\\', n-1)+helper(\\'u\\', n-1)\\n                ans %= m\\n            else:\\n                if last == \\'a\\':\\n                    ans += helper(\\'e\\', n-1)\\n                    ans %= m\\n                if last == \\'e\\':\\n                    ans += helper(\\'a\\', n-1)+helper(\\'i\\', n-1)\\n                    ans %= m\\n                if last == \\'i\\':\\n                    ans += helper(\\'a\\', n-1)+helper(\\'e\\', n-1)+helper(\\'o\\', n-1)+helper(\\'u\\', n-1)\\n                    ans %= m\\n                if last == \\'o\\':\\n                    ans += helper(\\'i\\', n-1)+helper(\\'u\\', n-1)\\n                    ans %= m\\n                if last == \\'u\\':\\n                    ans += helper(\\'a\\', n-1)\\n                    ans %= m\\n                    \\n            return ans    \\n            \\n        return helper(None, n)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        m = (10**9+7)\\n        from functools import lru_cache\\n        \\n        @lru_cache(None)\\n        def helper(last, n):\\n            if n==1:\\n                if last==None:\\n                    return 5\\n                else:\\n                    if last==\\'a\\':\\n                        return 1\\n                    if last==\\'e\\':\\n                        return 2\\n                    if last==\\'i\\':\\n                        return 4\\n                    if last==\\'o\\':\\n                        return 2\\n                    if last==\\'u\\':\\n                        return 1\\n                \\n            ans  = 0\\n            if last==None:\\n                ans += helper(\\'a\\', n-1)+helper(\\'e\\', n-1)+helper(\\'i\\', n-1)+helper(\\'o\\', n-1)+helper(\\'u\\', n-1)\\n                ans %= m\\n            else:\\n                if last == \\'a\\':\\n                    ans += helper(\\'e\\', n-1)\\n                    ans %= m\\n                if last == \\'e\\':\\n                    ans += helper(\\'a\\', n-1)+helper(\\'i\\', n-1)\\n                    ans %= m\\n                if last == \\'i\\':\\n                    ans += helper(\\'a\\', n-1)+helper(\\'e\\', n-1)+helper(\\'o\\', n-1)+helper(\\'u\\', n-1)\\n                    ans %= m\\n                if last == \\'o\\':\\n                    ans += helper(\\'i\\', n-1)+helper(\\'u\\', n-1)\\n                    ans %= m\\n                if last == \\'u\\':\\n                    ans += helper(\\'a\\', n-1)\\n                    ans %= m\\n                    \\n            return ans    \\n            \\n        return helper(None, n)",
                "codeTag": "Python3"
            },
            {
                "id": 438467,
                "title": "c-o-logn-matrix-multiplication-0ms-beat-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<long long> a = {0,1,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0};\\n        a = matpow(a, n-1);\\n        long long sum = 0;\\n        for (auto& x : a) {\\n            sum += x;\\n        }\\n        return sum % mod;\\n    }\\nprivate:\\n    const int mod = (int)(7 + 1e9);\\n    vector<long long> matmul(const vector<long long>& m1, const vector<long long>& m2) {\\n        vector<long long> res(25, 0);\\n        for (int i = 0; i < 5; ++i) {\\n            for (int j = 0; j < 5; ++j) {\\n                for (int k = 0; k < 5; ++k) {\\n                    res[i*5+j] += m1[i*5+k]*m2[k*5+j]; \\n                }\\n                res[i*5+j] %= mod;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<long long> matpow(const vector<long long>& m, int n) {\\n        if (n == 0) {\\n            return {1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\n        }\\n        else if (n == 1) {\\n            return m;\\n        }\\n        else {\\n            int i = n/2;\\n            vector<long long> mt = matpow(m, i);\\n            mt = matmul(mt, mt);\\n            if (n%2 == 1) {\\n                mt = matmul(mt, m);\\n            }\\n            return mt;            \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<long long> a = {0,1,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0};\\n        a = matpow(a, n-1);\\n        long long sum = 0;\\n        for (auto& x : a) {\\n            sum += x;\\n        }\\n        return sum % mod;\\n    }\\nprivate:\\n    const int mod = (int)(7 + 1e9);\\n    vector<long long> matmul(const vector<long long>& m1, const vector<long long>& m2) {\\n        vector<long long> res(25, 0);\\n        for (int i = 0; i < 5; ++i) {\\n            for (int j = 0; j < 5; ++j) {\\n                for (int k = 0; k < 5; ++k) {\\n                    res[i*5+j] += m1[i*5+k]*m2[k*5+j]; \\n                }\\n                res[i*5+j] %= mod;\\n            }\\n        }\\n        return res;\\n    }\\n    vector<long long> matpow(const vector<long long>& m, int n) {\\n        if (n == 0) {\\n            return {1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1};\\n        }\\n        else if (n == 1) {\\n            return m;\\n        }\\n        else {\\n            int i = n/2;\\n            vector<long long> mt = matpow(m, i);\\n            mt = matmul(mt, mt);\\n            if (n%2 == 1) {\\n                mt = matmul(mt, m);\\n            }\\n            return mt;            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399989,
                "title": "js-dp-o-n-very-readable-and-concise-o-1-space-solution-thought-process",
                "content": "**Thought process**\\nFirst lay out the tranformation clearly\\n * a > ae\\n * e > ea, ei\\n * i > ia, ie, io, iu\\n * o > oi, ou\\n * u > ua\\n\\nWe can see that in order to compute `i`th result, we need to look at `i-1`th result, which is a clear sign for DP. But how do we do DP for this question? \\n\\nIt seems like only the last alphabet is really important, we don\\'t care about the anything before it. To help save space, we can just store the results in an array representing count of last alphabet `[# of a, # of e, # of i, # of o, # of u]`. \\n\\nTo verify this works, we manually compute the 3rd and 4th result and yes indeed it is correct:\\n * a : 1 > 3 > 6 > 11\\n * e : 1 > 2 > 5 > 9\\n * i : 1 > 2 > 4 > 7\\n * o : 1 > 1 > 2 > 3\\n * u : 1 > 2 > 2 > 5\\n \\n Totals: 5 > 10 > 19 > 35\\n\\n**Code**\\n```\\nvar countVowelPermutation = function(n) {\\n  if(n == 1) return 5;\\n  if(n == 2) return 10;\\n  \\n  let res = [3,2,2,1,2]; // start with 2nd result array, since it\\'s already given in problem statement\\n  let mod = 1e9 + 7;\\n  for(let i=3;i<=n;i++){ \\n    res = [\\n      (res[1]+res[2]+res[4]) % mod, //a\\n      (res[0]+res[2]) % mod, //e\\n      (res[1]+res[3]) % mod, //i\\n      (res[2]) % mod, //o\\n      (res[2]+res[3]) % mod //u\\n    ];\\n  }\\n  \\n  return (res[0] + res[1] + res[2] + res[3] + res[4]) % mod;\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nvar countVowelPermutation = function(n) {\\n  if(n == 1) return 5;\\n  if(n == 2) return 10;\\n  \\n  let res = [3,2,2,1,2]; // start with 2nd result array, since it\\'s already given in problem statement\\n  let mod = 1e9 + 7;\\n  for(let i=3;i<=n;i++){ \\n    res = [\\n      (res[1]+res[2]+res[4]) % mod, //a\\n      (res[0]+res[2]) % mod, //e\\n      (res[1]+res[3]) % mod, //i\\n      (res[2]) % mod, //o\\n      (res[2]+res[3]) % mod //u\\n    ];\\n  }\\n  \\n  return (res[0] + res[1] + res[2] + res[3] + res[4]) % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399378,
                "title": "ultrafast-solution-explicit-mathematical-expression",
                "content": "Since the DP equation can be expressed as matrix multiplication, we can solve its eigensystem and get straightforward explicit expression of the answer.\\n```class Solution(object):\\n    def fastpow(self,x,n):\\n        if n==1:return x\\n        elif n&1:return (x*self.fastpow(x,n//2)**2)%1000000007\\n        else:return (self.fastpow(x,n//2)**2)%1000000007\\n    def countVowelPermutation(self, n):\\n        return (62759413*self.fastpow(44051588,n) + 784439686*self.fastpow(419376480,n) + 638771916*self.fastpow(653592850,n) + 514029000*self.fastpow(882979097,n))%1000000007\\n\\t\\t",
                "solutionTags": [],
                "code": "Since the DP equation can be expressed as matrix multiplication, we can solve its eigensystem and get straightforward explicit expression of the answer.\\n```class Solution(object):\\n    def fastpow(self,x,n):\\n        if n==1:return x\\n        elif n&1:return (x*self.fastpow(x,n//2)**2)%1000000007\\n        else:return (self.fastpow(x,n//2)**2)%1000000007\\n    def countVowelPermutation(self, n):\\n        return (62759413*self.fastpow(44051588,n) + 784439686*self.fastpow(419376480,n) + 638771916*self.fastpow(653592850,n) + 514029000*self.fastpow(882979097,n))%1000000007\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 398753,
                "title": "c-java-bottom-up-dp-solution-o-n-10ms-clean-vs-explain-easy-understand",
                "content": "**Intuition**\\nWe have the following statements:\\n* Each character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n* Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n* Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n* Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n* Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n* Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n\\nLet  \\n```java\\n0 -> a, 1 -> e, 2 -> i, 3 -> o, 4 -> u\\n```\\nWe have the following graph relationship:\\n```java\\n0 -> {1}\\n1 -> {0,2}\\n2 -> {0,1,3,4}\\n3 -> {2,4}\\n4 -> {0}\\n```\\n\\nLet `dp[n][char]` denotes the number of strings of length n starting at `char`. \\nHence, `dp[n+1][u]` = sum of all `dp[n][v]` such that there is a directed connection from u to v (u -> v).\\n\\n**Java**\\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        int MOD = (int) (1e9 + 7);\\n        long[][] dp = new long[n + 1][5]; // dp[n][i] is the number of strings of length n starting at char i\\n        for (int i = 0; i < 5; i++)\\n            dp[1][i] = 1; // there are only 1 string of length 1 that start with char i\\n\\n        int[][] relation = new int[][]{{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        for (int i = 1; i < n; i++) { // O(N) -> This is complexity of this solution\\n            for (int u = 0; u < 5; u++) { // This block of code cost O(1) in Time\\n                dp[i + 1][u] = 0;\\n                for (int v : relation[u]) {\\n                    dp[i + 1][u] += dp[i][v] % MOD;\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < 5; i++)\\n            ans = (ans + dp[n][i]) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```\\n\\n**C++**\\n```C++\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        int MOD = 1e9 + 7;\\n        vector<vector<ll>> dp = vector(n+1, vector<ll>(5)); // dp[n][i] is the number of strings of length n starting at char i\\n        for (int i = 0; i < 5; i++)\\n            dp[1][i] = 1; // there are only 1 string of length n that start with char i\\n\\n        vector<vector<ll>> relation = {{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        for (int i = 1; i < n; i++) { // O(N) -> This is complexity of this solution\\n            for (int u = 0; u < 5; u++) { // This block of code cost O(1) in Time\\n                dp[i + 1][u] = 0;\\n                for (int v : relation[u]) {\\n                    dp[i + 1][u] += dp[i][v] % MOD;\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < 5; i++)\\n            ans = (ans + dp[n][i]) % MOD;\\n        return (int) ans;\\n    }\\n};\\n```\\n**Complexity**\\n- Time: O(N)\\n- Space: O(N)",
                "solutionTags": [],
                "code": "```java\\n0 -> a, 1 -> e, 2 -> i, 3 -> o, 4 -> u\\n```\n```java\\n0 -> {1}\\n1 -> {0,2}\\n2 -> {0,1,3,4}\\n3 -> {2,4}\\n4 -> {0}\\n```\n```\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n        int MOD = (int) (1e9 + 7);\\n        long[][] dp = new long[n + 1][5]; // dp[n][i] is the number of strings of length n starting at char i\\n        for (int i = 0; i < 5; i++)\\n            dp[1][i] = 1; // there are only 1 string of length 1 that start with char i\\n\\n        int[][] relation = new int[][]{{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        for (int i = 1; i < n; i++) { // O(N) -> This is complexity of this solution\\n            for (int u = 0; u < 5; u++) { // This block of code cost O(1) in Time\\n                dp[i + 1][u] = 0;\\n                for (int v : relation[u]) {\\n                    dp[i + 1][u] += dp[i][v] % MOD;\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < 5; i++)\\n            ans = (ans + dp[n][i]) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```\n```C++\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        int MOD = 1e9 + 7;\\n        vector<vector<ll>> dp = vector(n+1, vector<ll>(5)); // dp[n][i] is the number of strings of length n starting at char i\\n        for (int i = 0; i < 5; i++)\\n            dp[1][i] = 1; // there are only 1 string of length n that start with char i\\n\\n        vector<vector<ll>> relation = {{1}, {0, 2}, {0, 1, 3, 4}, {2, 4}, {0}};\\n        for (int i = 1; i < n; i++) { // O(N) -> This is complexity of this solution\\n            for (int u = 0; u < 5; u++) { // This block of code cost O(1) in Time\\n                dp[i + 1][u] = 0;\\n                for (int v : relation[u]) {\\n                    dp[i + 1][u] += dp[i][v] % MOD;\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < 5; i++)\\n            ans = (ans + dp[n][i]) % MOD;\\n        return (int) ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398241,
                "title": "solution-in-python-3-dp-three-lines-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        C, m = [1]*5, 10**9 + 7\\n        for i in range(n-1): C = [(C[1]+C[2]+C[4]) % m, (C[0]+C[2]) % m, (C[1]+C[3]) % m, C[2] % m, (C[2]+C[3]) % m]\\n        return sum(C) % m\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        C, m = [1]*5, 10**9 + 7\\n        for i in range(n-1): C = [(C[1]+C[2]+C[4]) % m, (C[0]+C[2]) % m, (C[1]+C[3]) % m, C[2] % m, (C[2]+C[3]) % m]\\n        return sum(C) % m\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 398218,
                "title": "java-top-down-dp",
                "content": "```\\nclass Solution {\\n    char[] cc = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int MOD = 1_000_000_007;\\n    public int countVowelPermutation(int n) {\\n        long res = 0;\\n        Map<String, Long> memo = new HashMap<>();\\n        for (int i = 0; i < 5; i++) {\\n            res = (res + helper(1, cc[i], n, memo)) % MOD;\\n        }\\n        return (int) res;\\n    }\\n    long helper(int index, char c, int n, Map<String, Long> memo) {\\n        if (index == n) {\\n            return 1;\\n        }\\n        String str = index + \" \" + c;\\n        if (memo.containsKey(str)) {\\n            return memo.get(str);\\n        }\\n        long res = 0;\\n        if (c == \\'a\\') {\\n            res = helper(index + 1, \\'e\\', n, memo);\\n        }\\n        if (c == \\'e\\') {\\n            res = (res + helper(index + 1, \\'a\\', n, memo)) % MOD;\\n            res = (res + helper(index + 1, \\'i\\', n, memo)) % MOD;\\n        }\\n        if (c == \\'i\\') {\\n            for (int i = 0; i < 5; i++) {\\n                if (cc[i] != \\'i\\') {\\n                    res = (res + helper(index + 1, cc[i], n, memo)) % MOD;\\n                }\\n            }\\n        }\\n        if (c == \\'o\\') {\\n            res = (res + helper(index + 1, \\'u\\', n, memo)) % MOD;\\n            res = (res + helper(index + 1, \\'i\\', n, memo)) % MOD;\\n        }\\n        if (c == \\'u\\') {\\n            res = (res + helper(index + 1, \\'a\\', n, memo)) % MOD;\\n        }\\n        memo.put(str, res);\\n        return memo.get(str);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[] cc = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    int MOD = 1_000_000_007;\\n    public int countVowelPermutation(int n) {\\n        long res = 0;\\n        Map<String, Long> memo = new HashMap<>();\\n        for (int i = 0; i < 5; i++) {\\n            res = (res + helper(1, cc[i], n, memo)) % MOD;\\n        }\\n        return (int) res;\\n    }\\n    long helper(int index, char c, int n, Map<String, Long> memo) {\\n        if (index == n) {\\n            return 1;\\n        }\\n        String str = index + \" \" + c;\\n        if (memo.containsKey(str)) {\\n            return memo.get(str);\\n        }\\n        long res = 0;\\n        if (c == \\'a\\') {\\n            res = helper(index + 1, \\'e\\', n, memo);\\n        }\\n        if (c == \\'e\\') {\\n            res = (res + helper(index + 1, \\'a\\', n, memo)) % MOD;\\n            res = (res + helper(index + 1, \\'i\\', n, memo)) % MOD;\\n        }\\n        if (c == \\'i\\') {\\n            for (int i = 0; i < 5; i++) {\\n                if (cc[i] != \\'i\\') {\\n                    res = (res + helper(index + 1, cc[i], n, memo)) % MOD;\\n                }\\n            }\\n        }\\n        if (c == \\'o\\') {\\n            res = (res + helper(index + 1, \\'u\\', n, memo)) % MOD;\\n            res = (res + helper(index + 1, \\'i\\', n, memo)) % MOD;\\n        }\\n        if (c == \\'u\\') {\\n            res = (res + helper(index + 1, \\'a\\', n, memo)) % MOD;\\n        }\\n        memo.put(str, res);\\n        return memo.get(str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398179,
                "title": "simple-python-o-n-time-and-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp = [1 for _ in range(5)]\\n        for j in range(1,n):\\n            temp = [0 for _ in range(5)]\\n            temp[0] = dp[1]\\n            temp[1] = dp[0] + dp[2]\\n            for i in [0,1,3,4]:\\n                temp[2] += dp[i]\\n            temp[3] = dp[2] + dp[4]\\n            temp[4] = dp[0]\\n            dp = temp\\n        return sum(dp) % (10 ** 9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        dp = [1 for _ in range(5)]\\n        for j in range(1,n):\\n            temp = [0 for _ in range(5)]\\n            temp[0] = dp[1]\\n            temp[1] = dp[0] + dp[2]\\n            for i in [0,1,3,4]:\\n                temp[2] += dp[i]\\n            temp[3] = dp[2] + dp[4]\\n            temp[4] = dp[0]\\n            dp = temp\\n        return sum(dp) % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 3704454,
                "title": "simple-and-easy-to-understand-java-solution-using-recursion",
                "content": "# Intuition\\nThe problem states to count all the permutations possible of a given length of the vowels so we have to find all possible permuatations therefore we go with recursion. \\n\\n# Approach\\nLabel vowels with indices, 0 -> a, 1 -> b & so on.\\nJust keep track of the last used vowel using a last parameter and do what is told in the question. At the starting we know that last used is nothing so we specify \\'5\\' as the last used parameter. When the index reaches the desired length we return 1.  \\nWe know that there are over lapping sub problems therefore we memoize the solution. \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    private long solve(int index, int n, int last, long[][] dp){\\n        if(index==n)\\n            return 1;\\n        if(last == 0){\\n            return dp[index][0] = solve(index+1,n,1,dp)%mod;\\n        }\\n        if(dp[index][last]!=-1){\\n            return dp[index][last];\\n        }\\n        if(last==1){\\n            return dp[index][1] = (solve(index+1,n,0,dp)+solve(index+1,n,2,dp))%mod;\\n        }\\n        if(last == 2){\\n            return dp[index][2] = (solve(index+1,n,0,dp)+solve(index+1,n,1,dp)+solve(index+1,n,3,dp)+solve(index+1,n,4,dp))%mod;\\n        }\\n        if(last == 3){\\n            return dp[index][3] = (solve(index+1,n,2,dp)+solve(index+1,n,4,dp))%mod;\\n        }\\n        if(last == 4){\\n            return dp[index][4] = solve(index+1,n,0,dp)%mod;\\n        }\\n        else{\\n            return solve(index+1,n,0,dp)+solve(index+1,n,1,dp)+solve(index+1,n,2,dp)+solve(index+1,n,3,dp)+solve(index+1,n,4,dp);\\n        }\\n    }\\n    public int countVowelPermutation(int n) {\\n        long[][] dp = new long[n][6];\\n        for(long[] arr: dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        long ans = solve(0,n,5,dp)%mod;\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    private long solve(int index, int n, int last, long[][] dp){\\n        if(index==n)\\n            return 1;\\n        if(last == 0){\\n            return dp[index][0] = solve(index+1,n,1,dp)%mod;\\n        }\\n        if(dp[index][last]!=-1){\\n            return dp[index][last];\\n        }\\n        if(last==1){\\n            return dp[index][1] = (solve(index+1,n,0,dp)+solve(index+1,n,2,dp))%mod;\\n        }\\n        if(last == 2){\\n            return dp[index][2] = (solve(index+1,n,0,dp)+solve(index+1,n,1,dp)+solve(index+1,n,3,dp)+solve(index+1,n,4,dp))%mod;\\n        }\\n        if(last == 3){\\n            return dp[index][3] = (solve(index+1,n,2,dp)+solve(index+1,n,4,dp))%mod;\\n        }\\n        if(last == 4){\\n            return dp[index][4] = solve(index+1,n,0,dp)%mod;\\n        }\\n        else{\\n            return solve(index+1,n,0,dp)+solve(index+1,n,1,dp)+solve(index+1,n,2,dp)+solve(index+1,n,3,dp)+solve(index+1,n,4,dp);\\n        }\\n    }\\n    public int countVowelPermutation(int n) {\\n        long[][] dp = new long[n][6];\\n        for(long[] arr: dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        long ans = solve(0,n,5,dp)%mod;\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878417,
                "title": "c-most-simple-dp-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time com, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<long long> dp(5,1);\\n\\n        long long a,b,c,d,e;\\n        for(int i=1;i<n;i++){\\n            a=dp[0];\\n            b=dp[1];\\n            c=dp[2];\\n            d=dp[3];\\n            e=dp[4];\\n\\n            dp[0]=(b+c+e)%1000000007;\\n            dp[1]=(a+c)%1000000007;\\n            dp[2]=(b+d)%1000000007;\\n            dp[3]=c%1000000007;\\n            dp[4]=(c+d)%1000000007;\\n\\n        }\\n        return (dp[0]+dp[1]+dp[2]+dp[3]+dp[4])%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        vector<long long> dp(5,1);\\n\\n        long long a,b,c,d,e;\\n        for(int i=1;i<n;i++){\\n            a=dp[0];\\n            b=dp[1];\\n            c=dp[2];\\n            d=dp[3];\\n            e=dp[4];\\n\\n            dp[0]=(b+c+e)%1000000007;\\n            dp[1]=(a+c)%1000000007;\\n            dp[2]=(b+d)%1000000007;\\n            dp[3]=c%1000000007;\\n            dp[4]=(c+d)%1000000007;\\n\\n        }\\n        return (dp[0]+dp[1]+dp[2]+dp[3]+dp[4])%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608692,
                "title": "java-solution-with-detailed-explanation",
                "content": "\\n```\\n/*approach:\\n    Each character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n    Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n    Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n    Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n    Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n    Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n    \\n        // vowel & index mapping\\n        // a: 0\\n        // e: 1\\n        // i: 2\\n        // o: 3\\n        // u: 4\\n        \\n        intially for n=1 all values can be used 1 time so dp[i][i] =1 for all vowels\\n\\n     Here we can see:-\\n        // Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n        // Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n        // Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n        // Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n        // Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n        // === In other words: \\n        // \\'a\\' can be followed by {\\'e\\'}\\n        // \\'e\\' can be followed by {\\'a\\', \\'i\\'}\\n        // \\'i\\' can be followed by {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}\\n        // \\'o\\' can be followed by {\\'i\\', \\'u\\'}\\n        // \\'u\\' can be followed by {\\'a\\'}\\n        // === In other words:\\n        // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n        // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n        // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n        // \\'o\\' can follow {\\'i\\'}\\n        // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n*/\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n       int mod=1000_000_007;  \\n       long [][]dp =new long[n+1][5];\\n       for(int i=0;i<5;i++) dp[1][i]=1;\\n    \\n        for(int i=2;i<=n;i++){\\n            dp[i][0]=(dp[i-1][1]+dp[i-1][2]+dp[i-1][4])%mod;\\n             dp[i][1]=(dp[i-1][0]+dp[i-1][2])%mod;\\n             dp[i][2]=(dp[i-1][1]+dp[i-1][3])%mod;\\n             dp[i][3]=(dp[i-1][2])%mod;\\n             dp[i][4]=(dp[i-1][2]+dp[i-1][3])%mod;\\n        }\\n        long sum=0;\\n        for(long d:dp[n]){\\n            sum+=d;\\n            sum%=mod;\\n        }\\n       return (int)sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/*approach:\\n    Each character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n    Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n    Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n    Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n    Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n    Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n    \\n        // vowel & index mapping\\n        // a: 0\\n        // e: 1\\n        // i: 2\\n        // o: 3\\n        // u: 4\\n        \\n        intially for n=1 all values can be used 1 time so dp[i][i] =1 for all vowels\\n\\n     Here we can see:-\\n        // Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n        // Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n        // Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n        // Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n        // Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n        // === In other words: \\n        // \\'a\\' can be followed by {\\'e\\'}\\n        // \\'e\\' can be followed by {\\'a\\', \\'i\\'}\\n        // \\'i\\' can be followed by {\\'a\\', \\'e\\', \\'o\\', \\'u\\'}\\n        // \\'o\\' can be followed by {\\'i\\', \\'u\\'}\\n        // \\'u\\' can be followed by {\\'a\\'}\\n        // === In other words:\\n        // \\'a\\' can follow {\\'e\\', \\'i\\', \\'u\\'}\\n        // \\'e\\' can follow {\\'a\\', \\'i\\'}\\n        // \\'i\\' can follow {\\'e\\', \\'o\\'}\\n        // \\'o\\' can follow {\\'i\\'}\\n        // \\'u\\' can follow {\\'i\\', \\'o\\'}\\n*/\\nclass Solution {\\n    public int countVowelPermutation(int n) {\\n       int mod=1000_000_007;  \\n       long [][]dp =new long[n+1][5];\\n       for(int i=0;i<5;i++) dp[1][i]=1;\\n    \\n        for(int i=2;i<=n;i++){\\n            dp[i][0]=(dp[i-1][1]+dp[i-1][2]+dp[i-1][4])%mod;\\n             dp[i][1]=(dp[i-1][0]+dp[i-1][2])%mod;\\n             dp[i][2]=(dp[i-1][1]+dp[i-1][3])%mod;\\n             dp[i][3]=(dp[i-1][2])%mod;\\n             dp[i][4]=(dp[i-1][2]+dp[i-1][3])%mod;\\n        }\\n        long sum=0;\\n        for(long d:dp[n]){\\n            sum+=d;\\n            sum%=mod;\\n        }\\n       return (int)sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485411,
                "title": "simple-solution-python",
                "content": "Simple Solution:\\n```\\ndef countVowelPermutation(self, n: int) -> int:\\n        a,e,i,o,u = 1,1,1,1,1\\n        for _ in range(1,n):\\n            a,e,i,o,u = (e+i+u), (a+i), (e+o), (i), (i+o)    \\n        return sum([a,e,i,o,u])%(10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n        a,e,i,o,u = 1,1,1,1,1\\n        for _ in range(1,n):\\n            a,e,i,o,u = (e+i+u), (a+i), (e+o), (i), (i+o)    \\n        return sum([a,e,i,o,u])%(10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2444990,
                "title": "no-brainer-dp-inspired-by-leetcode-1641-count-sorted-vowel-strings",
                "content": "Inspired by a solution for count sorted vowel strings https://leetcode.com/problems/count-sorted-vowel-strings/discuss/918507/Java-DP-O(n)-time-Easy-to-understand\\n\\n```\\ndef countVowelPermutation(self, n: int) -> int:\\n\\ta,e,i,o,u = 1,1,1,1,1\\n\\twhile n>1:\\n\\t\\ta, e, i, o, u = e, a + i, a + e + o + u, i + u, a\\n\\t\\tn-=1\\n\\treturn (a+e+i+o+u) % (10**9+7)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndef countVowelPermutation(self, n: int) -> int:\\n\\ta,e,i,o,u = 1,1,1,1,1\\n\\twhile n>1:\\n\\t\\ta, e, i, o, u = e, a + i, a + e + o + u, i + u, a\\n\\t\\tn-=1\\n\\treturn (a+e+i+o+u) % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2417023,
                "title": "simple-c-o-n-time-o-n-space",
                "content": "When size is 1 there is only possiblity for each char, when more that one it depends on given condition.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long t[n][5], mod=1e9+7;\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<5; j++) {\\n                if (i==0)\\n                    t[i][j]=1;\\n                else if (j==0) // a\\n                    t[i][j]=t[i-1][1]; // e\\n                else if (j==1) // e\\n                    t[i][j]=(t[i-1][0]+t[i-1][2])%mod; // a,i\\n                else if (j==2) // i\\n                    t[i][j]=(t[i-1][0]+t[i-1][1]+t[i-1][3]+t[i-1][4])%mod; // a,e,o,u\\n                else if (j==3) // o\\n                    t[i][j]=(t[i-1][2]+t[i-1][4])%mod; // i,u\\n                else // u\\n                    t[i][j]=t[i-1][0]; // a\\n            }\\n        }\\n        return accumulate(t[n-1], t[n-1]+5, 0ll) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        long t[n][5], mod=1e9+7;\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<5; j++) {\\n                if (i==0)\\n                    t[i][j]=1;\\n                else if (j==0) // a\\n                    t[i][j]=t[i-1][1]; // e\\n                else if (j==1) // e\\n                    t[i][j]=(t[i-1][0]+t[i-1][2])%mod; // a,i\\n                else if (j==2) // i\\n                    t[i][j]=(t[i-1][0]+t[i-1][1]+t[i-1][3]+t[i-1][4])%mod; // a,e,o,u\\n                else if (j==3) // o\\n                    t[i][j]=(t[i-1][2]+t[i-1][4])%mod; // i,u\\n                else // u\\n                    t[i][j]=t[i-1][0]; // a\\n            }\\n        }\\n        return accumulate(t[n-1], t[n-1]+5, 0ll) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401006,
                "title": "c-dp-easy-understanding-intuitions-explained",
                "content": "```\\n ll mod=1e9+7;\\n    \\n    // Intuitions -> as the instructions given in the qquestion \\n    \\n    // we will modify it slightly \\n    \\n    // _ a -> then _ will have {e , i , u}\\n    \\n    // _ e -> then _ will have {a , i }\\n    \\n    // _ i -> then _ will have {o , e }\\n    \\n    // _ o -> then _ will have {  i  }\\n    \\n    // _ u -> then _ will have { o , i }\\n    \\n    // so now we will start forming the decision tree \\n    \\n    //  a , e , i , o , u \\n    \\n    // now for next char having as ith index has \\'a\\' as current char -> \\n    \\n    // this value is equal to i-th index having ( e , i , u ) as i-1th character \\n    \\n    //i.e dp[i][\\'a\\']=dp[i-1][\\'e\\'] + dp[i-1][\\'i\\'] + dp[i-1][\\'u\\']\\n    // dp[i][\\'e\\']=dp[i-1][\\'a\\'] + dp[i-1][\\'i\\'] \\n    // dp[i][\\'i\\']=dp[i-1][\\'o\\'] + dp[i-1][\\'e\\'] \\n    // dp[i][\\'o\\']=dp[i-1][\\'i\\']\\n    // dp[i][\\'u\\']=dp[i-1][\\'o\\'] + dp[i-1][\\'i\\'] \\n    \\n    int countVowelPermutation(int n) {\\n        \\n        vector<vector<ll>> dp(n+1 , vector<ll>(5 , 1));\\n        \\n        int a=0;\\n        int e=1;\\n        int i=2;\\n        int o=3;\\n        int u=4;\\n        \\n        // taking the index of the characters \\n        \\n        for(int k=1;k<n;k++)\\n        {\\n            dp[k][a]= (dp[k-1][e] + dp[k-1][i] + dp[k-1][u])%mod;\\n            dp[k][e]=(dp[k-1][a] + dp[k-1][i])%mod;\\n            dp[k][i]= (dp[k-1][o] + dp[k-1][e])%mod;\\n            dp[k][o]=dp[k-1][i]%mod;\\n            dp[k][u]=(dp[k-1][o] + dp[k-1][i])%mod;\\n        }\\n        \\n        ll ans=0;\\n        \\n        ans = (dp[n-1][a] + dp[n-1][e] + dp[n-1][i] + dp[n-1][o] + dp[n-1][u])%mod;\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n ll mod=1e9+7;\\n    \\n    // Intuitions -> as the instructions given in the qquestion \\n    \\n    // we will modify it slightly \\n    \\n    // _ a -> then _ will have {e , i , u}\\n    \\n    // _ e -> then _ will have {a , i }\\n    \\n    // _ i -> then _ will have {o , e }\\n    \\n    // _ o -> then _ will have {  i  }\\n    \\n    // _ u -> then _ will have { o , i }\\n    \\n    // so now we will start forming the decision tree \\n    \\n    //  a , e , i , o , u \\n    \\n    // now for next char having as ith index has \\'a\\' as current char -> \\n    \\n    // this value is equal to i-th index having ( e , i , u ) as i-1th character \\n    \\n    //i.e dp[i][\\'a\\']=dp[i-1][\\'e\\'] + dp[i-1][\\'i\\'] + dp[i-1][\\'u\\']\\n    // dp[i][\\'e\\']=dp[i-1][\\'a\\'] + dp[i-1][\\'i\\'] \\n    // dp[i][\\'i\\']=dp[i-1][\\'o\\'] + dp[i-1][\\'e\\'] \\n    // dp[i][\\'o\\']=dp[i-1][\\'i\\']\\n    // dp[i][\\'u\\']=dp[i-1][\\'o\\'] + dp[i-1][\\'i\\'] \\n    \\n    int countVowelPermutation(int n) {\\n        \\n        vector<vector<ll>> dp(n+1 , vector<ll>(5 , 1));\\n        \\n        int a=0;\\n        int e=1;\\n        int i=2;\\n        int o=3;\\n        int u=4;\\n        \\n        // taking the index of the characters \\n        \\n        for(int k=1;k<n;k++)\\n        {\\n            dp[k][a]= (dp[k-1][e] + dp[k-1][i] + dp[k-1][u])%mod;\\n            dp[k][e]=(dp[k-1][a] + dp[k-1][i])%mod;\\n            dp[k][i]= (dp[k-1][o] + dp[k-1][e])%mod;\\n            dp[k][o]=dp[k-1][i]%mod;\\n            dp[k][u]=(dp[k-1][o] + dp[k-1][i])%mod;\\n        }\\n        \\n        ll ans=0;\\n        \\n        ans = (dp[n-1][a] + dp[n-1][e] + dp[n-1][i] + dp[n-1][o] + dp[n-1][u])%mod;\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2398031,
                "title": "dp-approach-and-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```\\n**Please UPVOTE if you fund this solution helpful.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelPermutation(int n) {\\n        const int MOD = 1e9 + 7;\\n        long a = 1, e = 1, i = 1, o = 1, u = 1, a_new, e_new, i_new, o_new, u_new;\\n        for(int j = 2; j <= n; j++) {\\n            a_new =  e;\\n            e_new = (a + i) % MOD;\\n            i_new = (a + e + o + u) % MOD;\\n            o_new = (i + u) % MOD;\\n            u_new =  a;\\n            a = a_new, e = e_new, i = i_new, o = o_new, u = u_new;\\n        }\\n        return (a + e + i + o + u) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397327,
                "title": "simple-and-clear-solution-with-recursion-and-memorization-c-dp",
                "content": "class Solution {\\nprivate:\\n    int mod = 1000000007;\\n    map<int, int> a;\\n    map<int, int> e;\\n    map<int, int> i;\\n    map<int, int> o;\\n    map<int, int> u;\\n    int aCount(int n)\\n    {\\n        if (n == 2)\\n            return 1;\\n        if (a.find(n) != a.end())\\n            return a[n];\\n\\n        a[n] = ((eCount(n - 1)) % mod);\\n        return a[n];\\n    }\\n    int eCount(int n)\\n    {\\n        if (n == 2)\\n            return 2;\\n        if (e.find(n) != e.end())\\n            return e[n];\\n        e[n] = (aCount(n - 1)) % mod;\\n        e[n] = (e[n] + iCount(n - 1)) % mod;\\n        return e[n];\\n    }\\n    int iCount(int n)\\n    {\\n        if (n == 2)\\n            return 4;\\n        if (i.find(n) != i.end())\\n            return i[n];\\n        i[n] = (aCount(n - 1)) % mod;\\n        i[n] = (i[n] + eCount(n - 1)) % mod;\\n        i[n] = (i[n] + oCount(n - 1)) % mod;\\n        i[n] = (i[n] + uCount(n - 1)) % mod;\\n        return i[n];\\n    }\\n    int oCount(int n)\\n    {\\n        if (n == 2)\\n            return 2;\\n        if (o.find(n) != o.end())\\n            return o[n];\\n        o[n] = iCount(n - 1) % mod;\\n        o[n] = (o[n] + uCount(n - 1)) % mod;\\n        return o[n];\\n    }\\n    int uCount(int n)\\n    {\\n        if (n == 2)\\n            return 1;\\n        if (u.find(n) != u.end())\\n            return u[n];\\n        u[n] = aCount(n - 1) % mod;\\n        return u[n];\\n    }\\n\\npublic:\\n    int countVowelPermutation(int n)\\n    {\\n        if (n == 1)\\n            return 5;\\n        int sum = aCount(n) % mod;\\n        sum = (sum + eCount(n)) % mod;\\n        sum = (sum + iCount(n)) % mod;\\n        sum = (sum + oCount(n)) % mod;\\n        sum = (sum + uCount(n)) % mod;\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    int mod = 1000000007;\\n    map<int, int> a;\\n    map<int, int> e;\\n    map<int, int> i;\\n    map<int, int> o;\\n    map<int, int> u;\\n    int aCount(int n)\\n    {\\n        if (n == 2)\\n            return 1;\\n        if (a.find(n) != a.end())\\n            return a[n];\\n\\n        a[n] = ((eCount(n - 1)) % mod);\\n        return a[n];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2395343,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int MOD = 1000000007;\\n    \\n    \\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> ind(5);\\n        \\n        ind[0] = {1,2,4};\\n        ind[1] = {0, 2};\\n        ind[2] = {1, 3};\\n        ind[3] = {2};\\n        ind[4] = {2, 3};\\n        \\n        vector<vector<int>> dp(5, vector<int>(n, 1));\\n        \\n        int ans=0;\\n        \\n        for(int j=1;j<n;j++){\\n            for(int i=0;i<5;i++){\\n                dp[i][j]=0;\\n                for(int k=0;k<ind[i].size();k++){\\n                    dp[i][j]=(dp[i][j]+dp[ind[i][k]][j-1])%MOD;\\n                }\\n            }\\n        }\\n        for(int i=0;i<5;i++){\\n            ans = (ans+dp[i][n-1])%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int MOD = 1000000007;\\n    \\n    \\n    int countVowelPermutation(int n) {\\n        vector<vector<int>> ind(5);\\n        \\n        ind[0] = {1,2,4};\\n        ind[1] = {0, 2};\\n        ind[2] = {1, 3};\\n        ind[3] = {2};\\n        ind[4] = {2, 3};\\n        \\n        vector<vector<int>> dp(5, vector<int>(n, 1));\\n        \\n        int ans=0;\\n        \\n        for(int j=1;j<n;j++){\\n            for(int i=0;i<5;i++){\\n                dp[i][j]=0;\\n                for(int k=0;k<ind[i].size();k++){\\n                    dp[i][j]=(dp[i][j]+dp[ind[i][k]][j-1])%MOD;\\n                }\\n            }\\n        }\\n        for(int i=0;i<5;i++){\\n            ans = (ans+dp[i][n-1])%MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395255,
                "title": "go-o-n-time-o-1-space-dp-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Count Vowels Permutation.\\nMemory Usage: 1.9 MB, less than 100.00% of Go online submissions for Count Vowels Permutation.\\n```\\nfunc countVowelPermutation(n int) int {\\n    const (\\n        a = iota\\n        e\\n        i\\n        o\\n        u\\n    )\\n    const m = 1e9+7\\n    \\n    curr := [5]int{1,1,1,1,1}\\n    next := [5]int{}\\n    \\n    for ; n > 1; n-- {\\n        // \\'a\\' may only be followed by an \\'e\\'\\n        next[e] += curr[a]\\n        \\n        // \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'\\n        next[a] += curr[e]\\n        next[i] += curr[e]\\n        \\n        // \\'i\\' may not be followed by another \\'i\\'\\n        next[a] += curr[i]\\n        next[e] += curr[i]\\n        next[o] += curr[i]\\n        next[u] += curr[i]\\n        \\n        // \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'\\n        next[i] += curr[o]\\n        next[u] += curr[o]\\n        \\n        // \\'u\\' may only be followed by an \\'a\\'\\n        next[a] += curr[u]\\n        \\n        for char := 0; char < 5; char++ {\\n            next[char] %= m\\n        }\\n        \\n        curr, next = next, [5]int{}\\n    }\\n    return (curr[a] + curr[e] + curr[i] + curr[o] + curr[u]) % m\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc countVowelPermutation(n int) int {\\n    const (\\n        a = iota\\n        e\\n        i\\n        o\\n        u\\n    )\\n    const m = 1e9+7\\n    \\n    curr := [5]int{1,1,1,1,1}\\n    next := [5]int{}\\n    \\n    for ; n > 1; n-- {\\n        // \\'a\\' may only be followed by an \\'e\\'\\n        next[e] += curr[a]\\n        \\n        // \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'\\n        next[a] += curr[e]\\n        next[i] += curr[e]\\n        \\n        // \\'i\\' may not be followed by another \\'i\\'\\n        next[a] += curr[i]\\n        next[e] += curr[i]\\n        next[o] += curr[i]\\n        next[u] += curr[i]\\n        \\n        // \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'\\n        next[i] += curr[o]\\n        next[u] += curr[o]\\n        \\n        // \\'u\\' may only be followed by an \\'a\\'\\n        next[a] += curr[u]\\n        \\n        for char := 0; char < 5; char++ {\\n            next[char] %= m\\n        }\\n        \\n        curr, next = next, [5]int{}\\n    }\\n    return (curr[a] + curr[e] + curr[i] + curr[o] + curr[u]) % m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2395157,
                "title": "easy-to-understand-python-solution",
                "content": "Here we have to calculate Number of ways we can arrange vowels based on the rules. So we can use these rules to form our base conditions and proceed. \\n\\nIntuition\\nHere we start with making a string of length one.\\nThe strings available are \"a\", \"e\", \"i\" , \"o\", \"u\". So we assign this value\\nThen we start building the length of our string.\\nWe run the loop for (n - 1) times.\\nImportant Points to observe :\\n1. At any jth iteration a,e,i,o,u variables contain the value of all possible strings that start with respective variables of length (j - 1).\\n2. We can use this number to build. \\n3. For eg, we are at 10th iteration so our variables contain values for string of 9 length. Thus if we want to know how many strings of length 10 we can make that begin with e, we can use formula from rules i.e, e = a + i.\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a, e, i, o, u = 1, 1, 1, 1, 1 # \\n        for _ in range(n - 1): \\n            a, e, i, o, u = e, a + i, e + o + a + u, i + u, a\\n        return (a + e + i + o + u) % (10**9 + 7)\\n```\\n\\nOne important thing to note is that all the values we are updating(a,i,e,o,u) must happen simultaneously. More formally we cannot change value of \\'a\\' first and then use this changed \\'a\\' for operations we have to perform on other vowels.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        a, e, i, o, u = 1, 1, 1, 1, 1 # \\n        for _ in range(n - 1): \\n            a, e, i, o, u = e, a + i, e + o + a + u, i + u, a\\n        return (a + e + i + o + u) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394907,
                "title": "why-fear-when-dp-is-here-most-optimized-beats-96-6-explained-properly",
                "content": "***Please upvote if you found it helpful.***\\n\\n**Dynamic programming aproach**\\n\\nclass Solution:\\n    \\n\\tdef countVowelPermutation(self, n: int) -> int:\\n        mod = int(1e9) + 7\\n        # a,e,i,o,u=0,1,2,3,4\\n        choices={0: [1], 1: [0, 2], 2: [0, 1, 3, 4], 3: [2, 4], 4: [0]}\\n        \\n\\t\\t#here dp is previous row used for calculation\\n        dp=[0]*(5)\\n\\t\\t#cur is current row which will be updated at every iteration and made dp row after that iteration\\n        cur=[0]*(5)\\n        \\n\\t\\t#this is done because at starting any element can be picked \\n        for vow in range(5):\\n            dp[vow]=1\\n        \\n        for i in range(1,n):\\n\\t\\t#last is the last vowel picked for condition check\\n            for last in range(5):\\n                pick=0\\n                for vow in choices[last]:\\n                    pick+=dp[vow]\\n                #this is done to store all possibities with one vowel having many choices\\n\\t\\t\\t\\t#like \"i\" has 4 choices,\"e \"and \"o\" has two choices and \"a\"  and \"u\" have a single choice only. \\n\\t\\t\\t\\tcur[last]=pick\\n            dp=cur[:]\\n                \\n        return sum(dp)%mod\\n\\n**Recursion of above code**\\n\\nclass Solution:\\n    \\n    def countVowelPermutation(self, n: int) -> int:\\n        def f(i,last,choices):\\n            if i==1:\\n                return 1\\n            pick=0\\n            for vow in choices[last]:\\n                pick+=f(i-1,vow,choices)\\n            return pick\\n        mod=int(1e9) + 7\\n        choices={\"a\":[\"e\"],\\n                \"e\":[\"a\",\"i\"],\\n                \"i\":[\\'a\\',\\'e\\',\\'o\\',\\'u\\'],\\n                \"o\":[\"i\",\"u\"],\\n                \"u\":[\"a\"] }\\n        count=0\\n        for last in choices.keys():\\n            count+=f(n,last,choices)\\n        return count%mod\\n\\t\\n\\t\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution:\\n    \\n\\tdef countVowelPermutation(self, n: int) -> int:\\n        mod = int(1e9) + 7\\n        # a,e,i,o,u=0,1,2,3,4\\n        choices={0: [1], 1: [0, 2], 2: [0, 1, 3, 4], 3: [2, 4], 4: [0]}",
                "codeTag": "Java"
            },
            {
                "id": 2394879,
                "title": "easy-to-understand-memoized-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n  int mod = 1e9 + 7;\\n  int dp[100005][115];\\n\\n  long long int help(int n, int idx, char c) {\\n    if (idx == n)\\n      return 1;\\n\\n    if (dp[idx][c - \\'a\\'] != -1)\\n      return dp[idx][c - \\'a\\'] % mod;\\n\\n    long long int ans = 0;\\n\\n    switch (c) {\\n\\n    case \\'a\\':\\n      ans += help(n, idx + 1, \\'e\\') % mod;\\n      break;\\n\\n    case \\'e\\':\\n      ans += help(n, idx + 1, \\'a\\') + help(n, idx + 1, \\'i\\');\\n      break;\\n\\n    case \\'i\\':\\n      ans += help(n, idx + 1, \\'a\\') + help(n, idx + 1, \\'e\\') +\\n             help(n, idx + 1, \\'o\\') + help(n, idx + 1, \\'u\\');\\n      break;\\n\\n    case \\'o\\':\\n      ans += help(n, idx + 1, \\'i\\') + help(n, idx + 1, \\'u\\');\\n      break;\\n\\n    case \\'u\\':\\n      ans += help(n, idx + 1, \\'a\\');\\n      break;\\n    }\\n\\n    return dp[idx][c - \\'a\\'] = ans % mod;\\n  }\\n\\n  int countVowelPermutation(int n) {\\n    long long int ans = 0;\\n\\n    vector<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    memset(dp, -1, sizeof(dp));\\n\\n    for (char &c : vowels)\\n      ans += help(n, 1, c);\\n\\n    return ans % mod;\\n  }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int mod = 1e9 + 7;\\n  int dp[100005][115];\\n\\n  long long int help(int n, int idx, char c) {\\n    if (idx == n)\\n      return 1;\\n\\n    if (dp[idx][c - \\'a\\'] != -1)\\n      return dp[idx][c - \\'a\\'] % mod;\\n\\n    long long int ans = 0;\\n\\n    switch (c) {\\n\\n    case \\'a\\':\\n      ans += help(n, idx + 1, \\'e\\') % mod;\\n      break;\\n\\n    case \\'e\\':\\n      ans += help(n, idx + 1, \\'a\\') + help(n, idx + 1, \\'i\\');\\n      break;\\n\\n    case \\'i\\':\\n      ans += help(n, idx + 1, \\'a\\') + help(n, idx + 1, \\'e\\') +\\n             help(n, idx + 1, \\'o\\') + help(n, idx + 1, \\'u\\');\\n      break;\\n\\n    case \\'o\\':\\n      ans += help(n, idx + 1, \\'i\\') + help(n, idx + 1, \\'u\\');\\n      break;\\n\\n    case \\'u\\':\\n      ans += help(n, idx + 1, \\'a\\');\\n      break;\\n    }\\n\\n    return dp[idx][c - \\'a\\'] = ans % mod;\\n  }\\n\\n  int countVowelPermutation(int n) {\\n    long long int ans = 0;\\n\\n    vector<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n    memset(dp, -1, sizeof(dp));\\n\\n    for (char &c : vowels)\\n      ans += help(n, 1, c);\\n\\n    return ans % mod;\\n  }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394874,
                "title": "python-easy-dp",
                "content": "From observation you can see that:\\ncountVowelPermutation(n+1) = the sum of (letters that end in each vowel of length n * possible vowels that can come after that vowel)\\n\\n```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        myStore = {\\'a\\': 1, \\'e\\': 1, \\'i\\': 1, \\'o\\': 1, \\'u\\': 1}\\n        \\n        for i in range(n - 1):\\n            myStore[\\'a\\'],myStore[\\'e\\'],myStore[\\'i\\'],myStore[\\'o\\'],myStore[\\'u\\'] = myStore[\\'e\\'] + myStore[\\'i\\'] + myStore[\\'u\\'],myStore[\\'a\\'] + myStore[\\'i\\'],myStore[\\'e\\'] + myStore[\\'o\\'], myStore[\\'i\\'], myStore[\\'i\\'] + myStore[\\'o\\']\\n        \\n        return sum(myStore.values()) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        myStore = {\\'a\\': 1, \\'e\\': 1, \\'i\\': 1, \\'o\\': 1, \\'u\\': 1}\\n        \\n        for i in range(n - 1):\\n            myStore[\\'a\\'],myStore[\\'e\\'],myStore[\\'i\\'],myStore[\\'o\\'],myStore[\\'u\\'] = myStore[\\'e\\'] + myStore[\\'i\\'] + myStore[\\'u\\'],myStore[\\'a\\'] + myStore[\\'i\\'],myStore[\\'e\\'] + myStore[\\'o\\'], myStore[\\'i\\'], myStore[\\'i\\'] + myStore[\\'o\\']\\n        \\n        return sum(myStore.values()) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394862,
                "title": "clean-c-solution-using-dp-2-d-matrix",
                "content": "The simplest way to approach this problem is by using dynamic programming. The Hint 2 given in the description gives away the actual way to go. \\n\"**Let dp[i][j] be the number of strings of length i that ends with the j-th vowel.**\"\\n\\nWe will initialize a 2-D matrix of size  n * 5 where n is the length of strings and 5 , which is the number of vowels. \\n\\ndp[i][j] will denote the number of strings of length \"i\" which end with \"jth vowel\". Ex: dp[0][1] = 1 --> number of strings of length 1 which end with 2nd vowel - e \\n\\n**Note that I am using zero based indexing here.**\\n\\nThe first row will be all 1s as there can exactly 1 possible combination of all vowels. \\n\\nWe will follow the set of rules given and update the rows till we reach the n th row. \\n\\nAs the sum will be large, we will use mod(10 power 9 + 7).\\n\\nAt the end, we will calculate the mod of sum of elements of the nth row and return.\\n\\n```\\nint countVowelPermutation(int n) {\\n        int count = 0;\\n        vector<vector<long long int>> dp(n, vector<long long int> (5, 0));\\n        for(int i=0;i<5;++i)\\n            dp[0][i] = 1;\\n       \\n        for(int i=0;i<n-1;++i){\\n            for(int j=0;j<5;++j){\\n                switch(j){\\n                    case 0:\\n                        {\\n                            dp[i+1][1] = (dp[i][j] + dp[i+1][1])%mod ;\\n                            break;\\n                        }\\n                    case 1:\\n                        {\\n                            dp[i+1][0] = (dp[i][j] + dp[i+1][0])%mod;\\n                            dp[i+1][2] = (dp[i][j] + dp[i+1][2])%mod;\\n                            break;\\n                        }\\n                    case 2:\\n                        {\\n                            dp[i+1][0] = (dp[i][j]+dp[i+1][0])%mod;\\n                            dp[i+1][1] = (dp[i][j]+dp[i+1][1])%mod;\\n                            dp[i+1][3] = (dp[i][j]+dp[i+1][3])%mod;\\n                            dp[i+1][4] = (dp[i][j]+dp[i+1][4])%mod;\\n                            break;\\n                        }\\n                    case 3:\\n                        {\\n                            dp[i+1][2] = (dp[i][j]+dp[i+1][2])%mod;\\n                            dp[i+1][4] = (dp[i][j]+dp[i+1][4])%mod;\\n                            break;\\n                        }\\n                    case 4:\\n                        {\\n                            dp[i+1][0] = (dp[i][j]+dp[i+1][0])%mod;\\n                            break;\\n                        }\\n                }\\n\\n            }\\n        }\\n   \\n    for(int i = 0; i < 5; ++i){\\n        count = (dp[n-1][i] + count)%mod;\\n    }\\n    return count;\\n}\\n```\\n\\nPlease upvote if it helped!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n) {\\n        int count = 0;\\n        vector<vector<long long int>> dp(n, vector<long long int> (5, 0));\\n        for(int i=0;i<5;++i)\\n            dp[0][i] = 1;\\n       \\n        for(int i=0;i<n-1;++i){\\n            for(int j=0;j<5;++j){\\n                switch(j){\\n                    case 0:\\n                        {\\n                            dp[i+1][1] = (dp[i][j] + dp[i+1][1])%mod ;\\n                            break;\\n                        }\\n                    case 1:\\n                        {\\n                            dp[i+1][0] = (dp[i][j] + dp[i+1][0])%mod;\\n                            dp[i+1][2] = (dp[i][j] + dp[i+1][2])%mod;\\n                            break;\\n                        }\\n                    case 2:\\n                        {\\n                            dp[i+1][0] = (dp[i][j]+dp[i+1][0])%mod;\\n                            dp[i+1][1] = (dp[i][j]+dp[i+1][1])%mod;\\n                            dp[i+1][3] = (dp[i][j]+dp[i+1][3])%mod;\\n                            dp[i+1][4] = (dp[i][j]+dp[i+1][4])%mod;\\n                            break;\\n                        }\\n                    case 3:\\n                        {\\n                            dp[i+1][2] = (dp[i][j]+dp[i+1][2])%mod;\\n                            dp[i+1][4] = (dp[i][j]+dp[i+1][4])%mod;\\n                            break;\\n                        }\\n                    case 4:\\n                        {\\n                            dp[i+1][0] = (dp[i][j]+dp[i+1][0])%mod;\\n                            break;\\n                        }\\n                }\\n\\n            }\\n        }\\n   \\n    for(int i = 0; i < 5; ++i){\\n        count = (dp[n-1][i] + count)%mod;\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394838,
                "title": "1220-count-vowels-permutation-c-code",
                "content": "## 1220. Count Vowels Permutation\\n##### Hard | C++ Code Solution Explanation | Dynamic Programming\\n\\n\\n#### Problem\\nGiven an integer n, your task is to count how many strings of length n can be formed under the following rules:\\n\\n* Each character is a lower case vowel (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n* Each vowel \\'a\\' may only be followed by an \\'e\\'.\\n* Each vowel \\'e\\' may only be followed by an \\'a\\' or an \\'i\\'.\\n* Each vowel \\'i\\' may not be followed by another \\'i\\'.\\n* Each vowel \\'o\\' may only be followed by an \\'i\\' or a \\'u\\'.\\n* Each vowel \\'u\\' may only be followed by an \\'a\\'.\\n\\nSince the answer may be too large, return it modulo 10^9 + 7.\\n\\n#### Solution\\n\\nlet the vowels be denoted as numbers\\n* a = 0\\n* e = 1\\n* i = 2\\n* o = 3\\n* u = 4\\n\\n1. We will make two vectors `prev`,` cur`.\\n2. `prev` will store the number of strings that are ending with each vowel and will be used to calculate `cur`.\\n3. Values will be calculated from previous string using the rules mentioned.\\n\\nFor Example:\\n* The string of length ` n-1` can be appended with \\'a\\' (or end with \\'a\\') to make length `n` only if when string of length `n-1` end with \\'e\\' or \\'i\\' or \\'u\\',\\n`cur[a]= prev[e] + prev[i]+ prev[u];`\\n* Similarly we can calculate for other vowels.\\n\\n#### Code \\n```\\nint countVowelPermutation(int n) {\\n        \\n        vector<int>prev(5, 1);\\n        vector<int>cur(5, 1);\\n        \\n        int sum =0, mod=1000000007;\\n        \\n        for(int i=1; i<n; i++){\\n            cur[0]= ((prev[1]%mod + prev[2]%mod)%mod + prev[4]%mod)%mod;\\n            cur[1]=(prev[0]%mod + prev[2]%mod)%mod;\\n            cur[2]= (prev[1]%mod + prev[3]%mod)%mod;\\n            cur[3]= prev[2]%mod;\\n            cur[4] = (prev[2]%mod + prev[3]%mod)%mod;\\n            prev = cur;\\n        }\\n        \\n        for(int i=0; i<5; i++){\\n            \\n            sum=((cur[i]%mod) + sum%mod)%mod;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint countVowelPermutation(int n) {\\n        \\n        vector<int>prev(5, 1);\\n        vector<int>cur(5, 1);\\n        \\n        int sum =0, mod=1000000007;\\n        \\n        for(int i=1; i<n; i++){\\n            cur[0]= ((prev[1]%mod + prev[2]%mod)%mod + prev[4]%mod)%mod;\\n            cur[1]=(prev[0]%mod + prev[2]%mod)%mod;\\n            cur[2]= (prev[1]%mod + prev[3]%mod)%mod;\\n            cur[3]= prev[2]%mod;\\n            cur[4] = (prev[2]%mod + prev[3]%mod)%mod;\\n            prev = cur;\\n        }\\n        \\n        for(int i=0; i<5; i++){\\n            \\n            sum=((cur[i]%mod) + sum%mod)%mod;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394825,
                "title": "java-dynamic-programming-o-n-time-o-1-space",
                "content": "**Intuition:**\\nWe create a 2-dimensional 5xn array, and traverse it filling each position dp[i][0 to 4] according to the five values of the last iteration dp[i-1][0 to 4].\\n\\n**Approach: bottom-up DP with O(n) space**\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        \\n        int[][] dp = new int[n][5];\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        dp[0][2] = 1;\\n        dp[0][3] = 1;\\n        dp[0][4] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][1] += dp[i-1][0]; // a -> ae\\n            \\n            dp[i][0] += dp[i-1][1]; // e -> ea\\n            dp[i][2] += dp[i-1][1]; // e -> ei\\n            \\n            dp[i][0] += dp[i-1][2]; // i -> ia\\n            dp[i][1] += dp[i-1][2]; // i -> ie\\n            dp[i][3] += dp[i-1][2]; // i -> io\\n            dp[i][4] += dp[i-1][2]; // i -> iu\\n            \\n            dp[i][2] += dp[i-1][3]; // o -> oi\\n            dp[i][4] += dp[i-1][3]; // o -> ou\\n            \\n            dp[i][0] %= mod; // As a general rule, max int is bigger than twice (10\\u2079 + 7), but smaller than three times that number. We are safe adding two values, but risk overflow with a third.\\n            dp[i][0] += dp[i-1][4]; // u -> ua\\n            \\n            for(int j = 0; j < 5; j++) {\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 5; i++) {\\n            ans = (ans + dp[n-1][i])%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Second approach: O(1) space**\\n\\nNotice that we are saving values to a row, then using them immediately, then never using them again. We can reuse this slots instead of keeping them all:\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        \\n        int[] last = new int[5];\\n        int[] cur = new int[5];\\n        last[0] = 1;\\n        last[1] = 1;\\n        last[2] = 1;\\n        last[3] = 1;\\n        last[4] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            cur[1] = last[0];  // \"+=\" -> \"=\"!!\\n            \\n            cur[0] = last[1];  // !!\\n            cur[2] = last[1];  // !!\\n            \\n            cur[0] += last[2];\\n            cur[1] += last[2];\\n            cur[3] = last[2];  // !!\\n            cur[4] = last[2];  // !!\\n            \\n            cur[2] += last[3];\\n            cur[4] += last[3];\\n            \\n            cur[0] = cur[0]%mod + last[4];\\n            \\n            for(int j = 0; j < 5; j++) {\\n                last[j] = cur[j]%mod;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 5; i++) {\\n            ans = (ans + last[i])%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        \\n        int[][] dp = new int[n][5];\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        dp[0][2] = 1;\\n        dp[0][3] = 1;\\n        dp[0][4] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][1] += dp[i-1][0]; // a -> ae\\n            \\n            dp[i][0] += dp[i-1][1]; // e -> ea\\n            dp[i][2] += dp[i-1][1]; // e -> ei\\n            \\n            dp[i][0] += dp[i-1][2]; // i -> ia\\n            dp[i][1] += dp[i-1][2]; // i -> ie\\n            dp[i][3] += dp[i-1][2]; // i -> io\\n            dp[i][4] += dp[i-1][2]; // i -> iu\\n            \\n            dp[i][2] += dp[i-1][3]; // o -> oi\\n            dp[i][4] += dp[i-1][3]; // o -> ou\\n            \\n            dp[i][0] %= mod; // As a general rule, max int is bigger than twice (10\\u2079 + 7), but smaller than three times that number. We are safe adding two values, but risk overflow with a third.\\n            dp[i][0] += dp[i-1][4]; // u -> ua\\n            \\n            for(int j = 0; j < 5; j++) {\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 5; i++) {\\n            ans = (ans + dp[n-1][i])%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countVowelPermutation(int n) {\\n        \\n        int[] last = new int[5];\\n        int[] cur = new int[5];\\n        last[0] = 1;\\n        last[1] = 1;\\n        last[2] = 1;\\n        last[3] = 1;\\n        last[4] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            cur[1] = last[0];  // \"+=\" -> \"=\"!!\\n            \\n            cur[0] = last[1];  // !!\\n            cur[2] = last[1];  // !!\\n            \\n            cur[0] += last[2];\\n            cur[1] += last[2];\\n            cur[3] = last[2];  // !!\\n            cur[4] = last[2];  // !!\\n            \\n            cur[2] += last[3];\\n            cur[4] += last[3];\\n            \\n            cur[0] = cur[0]%mod + last[4];\\n            \\n            for(int j = 0; j < 5; j++) {\\n                last[j] = cur[j]%mod;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 5; i++) {\\n            ans = (ans + last[i])%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394765,
                "title": "easy-memoization-dp-graph-using-adjacency-list",
                "content": "To solve using graph, assume all vowels as nodes and to what they are being followed,\\na -> e\\ne -> a, i\\ni  -> a, e, o, u (excluding i)\\no -> i, u\\nu -> a\\n\\n**CODE:-**\\n```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    unordered_map< string, int> dp;\\n\\n    int dfs(unordered_map<char, vector<char>> &adj, char v, int n, int i){\\n        if(i == n) //base condition\\n            return 1;\\n        \\n        // making key i.e {i, v} -> i_v\\n        string key = to_string(i) +\"_\" + v;\\n        \\n        // if already present\\n        if(dp.find(key) != dp.end())\\n            return dp[key];\\n        \\n        long ans = 0;\\n        for(auto c : adj[v]){\\n            ans += dfs(adj, c, n, i+1);\\n            ans %= mod;\\n            dp[key] += ans;\\n        }\\n        \\n        return dp[key] = (ans%mod);\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        // making adjacency matrix\\n        // mapping vowels to what can comes after\\n        unordered_map<char, vector<char>> adjacencyMatrix;\\n        adj[\\'a\\'] = {\\'e\\'};\\n        adj[\\'e\\'] = {\\'a\\', \\'i\\'};\\n        adj[\\'i\\'] = {\\'a\\', \\'e\\', \\'o\\', \\'u\\'};\\n        adj[\\'o\\'] = {\\'i\\', \\'u\\'};\\n        adj[\\'u\\'] = {\\'a\\'};\\n        \\n        \\n        long ans = 0;\\n        for(auto i : adjacencyMatrix){\\n            ans += dfs(adjacencyMatrix, i.first, n, 1);\\n            ans %= mod;\\n        }\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    unordered_map< string, int> dp;\\n\\n    int dfs(unordered_map<char, vector<char>> &adj, char v, int n, int i){\\n        if(i == n) //base condition\\n            return 1;\\n        \\n        // making key i.e {i, v} -> i_v\\n        string key = to_string(i) +\"_\" + v;\\n        \\n        // if already present\\n        if(dp.find(key) != dp.end())\\n            return dp[key];\\n        \\n        long ans = 0;\\n        for(auto c : adj[v]){\\n            ans += dfs(adj, c, n, i+1);\\n            ans %= mod;\\n            dp[key] += ans;\\n        }\\n        \\n        return dp[key] = (ans%mod);\\n    }\\n    \\n    int countVowelPermutation(int n) {\\n        // making adjacency matrix\\n        // mapping vowels to what can comes after\\n        unordered_map<char, vector<char>> adjacencyMatrix;\\n        adj[\\'a\\'] = {\\'e\\'};\\n        adj[\\'e\\'] = {\\'a\\', \\'i\\'};\\n        adj[\\'i\\'] = {\\'a\\', \\'e\\', \\'o\\', \\'u\\'};\\n        adj[\\'o\\'] = {\\'i\\', \\'u\\'};\\n        adj[\\'u\\'] = {\\'a\\'};\\n        \\n        \\n        long ans = 0;\\n        for(auto i : adjacencyMatrix){\\n            ans += dfs(adjacencyMatrix, i.first, n, 1);\\n            ans %= mod;\\n        }\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394763,
                "title": "c-detailed-explanation",
                "content": "/*\\n\\n    dp[i][0] --> stores count of i-length string , ends with character \\'a\\'        \\n    \\n     dp[i][1] --> stores count of i-length string , ends with character \\'e\\'\\n    \\n     dp[i][2] --> stores count of i-length string , ends with character \\'i\\'\\n    \\n     dp[i][3] --> stores count of i-length string , ends with character \\'o\\'\\n    \\n     dp[i][4] --> stores count of i-length string , ends with character \\'u\\'\\n    \\n    \\n     Required Recurrences for solving the problem ......\\n    \\n    \\n    According to the question Each character \\'a\\' may only be followed by \\'e\\' .\\n    \\n    That means if character at i-th index be \\'e\\' , then its one of the previous characters might be \\'a\\'\\n    \\n    \\'a\\' --next--> \\'e\\'\\n    \\'a\\' <--prev-- \\'e\\'\\n    \\n    Now , the recurrence boils down to ---->\\n    \\n    for the character at i-th index , try to figure out all the possible (i-1)-th indexed characters.\\n    \\n    e.g : dp[i][\\'e\\'] = dp[i-1][\\'a\\'] + dp[i-1][\\'i\\']\\n    \\n    \\n    */\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t`class Solution {\\npublic:\\n\\ntypedef long long ll;\\n\\nconst ll M = 1e9 + 7;\\n\\nll mod(ll a){\\n    return ((a%M)+M)%M;\\n}\\n\\nll mul(ll a,ll b){\\n    return mod(mod(a)*mod(b));\\n}\\n\\nll add(ll a,ll b){\\n    return mod(mod(a)+mod(b));\\n}\\n\\nint countVowelPermutation(int n) {\\n    \\n    vector<vector<ll>>dp(n+1,vector<ll>(5,0LL));\\n   \\n    // Base Case :\\n    \\n    dp[1][0]=1LL;\\n    dp[1][1]=1LL;\\n    dp[1][2]=1LL;\\n    dp[1][3]=1LL;\\n    dp[1][4]=1LL;\\n    \\n    // Transitions for recurrence :\\n    \\n    for(ll i=2;i<=n;++i){\\n        \\n        // For character \\'a\\' \\n        \\n        dp[i][0] = add(add(dp[i-1][1],dp[i-1][2]),dp[i-1][4]);\\n        \\n        // For character \\'e\\'\\n        \\n        dp[i][1] = add(dp[i-1][0],dp[i-1][2]);\\n        \\n        // For character \\'i\\'\\n        \\n        dp[i][2] = add(dp[i-1][1],dp[i-1][3]);\\n        \\n        // For character \\'o\\'\\n        \\n        dp[i][3] = dp[i-1][2];\\n        \\n        // For character \\'u\\'\\n        \\n        dp[i][4] = add(dp[i-1][2],dp[i-1][3]);\\n        \\n    }\\n    \\n    ll total = 0LL;\\n    \\n    for(ll i=0;i<5;++i){\\n        \\n        total=add(total,dp[n][i]);\\n        \\n    }\\n    \\n    return total;\\n    \\n}\\n};\\n`\\n\\n/*\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(N*5) --> O(N)\\n\\n*/",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\ntypedef long long ll;\\n\\nconst ll M = 1e9 + 7;\\n\\nll mod(ll a){\\n    return ((a%M)+M)%M;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2394649,
                "title": "is-it-worthy",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int n,map<int,set<int>>&mp,vector<vector<int>>&dp){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int res=0;\\n        for(int k=1;k<=5;k++){\\n            if(j==0){\\n                res = (res % 1000000007 + dfs(i+1,k,n,mp,dp)%1000000007)%1000000007;\\n            }\\n            else if(mp[j].find(k)!=mp[j].end()){\\n                 res = (res % 1000000007 + dfs(i+1,k,n,mp,dp)%1000000007)%1000000007;\\n            }\\n        }\\n        return dp[i][j]=res;\\n    }\\n    int countVowelPermutation(int n) {\\n        map<int,set<int>>mp;\\n        mp[1].insert(2);\\n        mp[2].insert(1);\\n        mp[2].insert(3);\\n        mp[3].insert(1);\\n        mp[3].insert(2);\\n        mp[3].insert(4);\\n        mp[3].insert(5);\\n        mp[4].insert(3);\\n        mp[4].insert(5);\\n        mp[5].insert(1);\\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(6,-1));\\n        return dfs(0,0,n,mp,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int n,map<int,set<int>>&mp,vector<vector<int>>&dp){\\n        if(i==n){\\n            return 1;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int res=0;\\n        for(int k=1;k<=5;k++){\\n            if(j==0){\\n                res = (res % 1000000007 + dfs(i+1,k,n,mp,dp)%1000000007)%1000000007;\\n            }\\n            else if(mp[j].find(k)!=mp[j].end()){\\n                 res = (res % 1000000007 + dfs(i+1,k,n,mp,dp)%1000000007)%1000000007;\\n            }\\n        }\\n        return dp[i][j]=res;\\n    }\\n    int countVowelPermutation(int n) {\\n        map<int,set<int>>mp;\\n        mp[1].insert(2);\\n        mp[2].insert(1);\\n        mp[2].insert(3);\\n        mp[3].insert(1);\\n        mp[3].insert(2);\\n        mp[3].insert(4);\\n        mp[3].insert(5);\\n        mp[4].insert(3);\\n        mp[4].insert(5);\\n        mp[5].insert(1);\\n        int ans=0;\\n        vector<vector<int>>dp(n+1,vector<int>(6,-1));\\n        return dfs(0,0,n,mp,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1785736,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1573109,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1569642,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1754338,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 2028857,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 2008790,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1999436,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1936154,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1890503,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1754341,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1785736,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1573109,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1569642,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1754338,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 2028857,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 2008790,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1999436,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1936154,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1890503,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            },
            {
                "id": 1754341,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "should be rated easy"
                    },
                    {
                        "username": "lotayliu",
                        "content": "![image](https://assets.leetcode.com/users/lotayliu/image_1571147386.png)\\n\\n"
                    },
                    {
                        "username": "nice_dev",
                        "content": "Problem statement said that\\n> Each vowel \\'a\\' may only be followed by an \\'e\\' (and many other conditions like this).\\n\\nIt doesn\\'t make it clear that `aei` is a valid 3 length sequence as `i` came after `a`, of course not immediately in an adjacent way, but `a` could have only `e` followed by it. \\n\\nI wasted an hour on this and just suspected this issue and solved it a minute later the contest finished."
                    },
                    {
                        "username": "Times_",
                        "content": "This problem is truly amazing.\\n\\nI\\'m begining my competitive programming journey and this problem was really cool to complete.\\n\\nI went from a recursive way that was very inneficient to a cool dynamic programming implementation.\\n\\nBut I saw that I was only beating 50% of people in time.\\n\\nThen I got this idea of matrix exponentiation from that worked really well. I am delighted to have had the opportunity to apply my maths lessons to this problem.\\n\\nThank you.\\n\\nYou can see my full thought process here \\n[https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot](https://leetcode.com/problems/count-vowels-permutation/solutions/3040891/python-4-solutions-slowly-getting-better-thought-process-beats-99/?orderBy=hot)"
                    },
                    {
                        "username": "sk4142",
                        "content": "Why use \"only be followed by\" when \"only IMMEDIATELY be followed by\" is more precise? What a waste of time. Should have at least included some of the output for the test case n = 3. "
                    },
                    {
                        "username": "spookyflame",
                        "content": "If you are thinking you are bad because everyone else is saying this is easy, don't worry. I think this was hard. Everyone has different masteries!"
                    },
                    {
                        "username": "Lipox",
                        "content": "Hard \\u274C\\nEasy Easy one in Medium \\u2714"
                    },
                    {
                        "username": "tyler__",
                        "content": "Easiest hard?"
                    },
                    {
                        "username": "laichbr",
                        "content": "A good hint in this case is to look at what the rules are for what must follow and think instead of what that means for how many of which character comes next. If you do, you can notice a solution that is O(1) space and O(n) time. "
                    },
                    {
                        "username": "Times_",
                        "content": "If someone knows why this function gives wrong results for n > 50, I would be glad to hear a detailed explanation !\\n```python\\nimport numpy as np\\nclass Solution:\\n    def countVowelPermutation(self, n: int) -> int:\\n        mat = [[0,1,1,0,1], [1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,0], [0,0,1,1,0]]\\n        matrix = np.array(mat)\\n        big_mat = np.linalg.matrix_power(matrix, n-1)\\n        return np.sum(big_mat) % (10**9+7)\\n```"
                    },
                    {
                        "username": "laichbr",
                        "content": "I think it may be because the big matrix application does not do modulo inside the valuations and numpy is hitting an overflow error, but that\\'s just me. "
                    }
                ]
            }
        ]
    }
]