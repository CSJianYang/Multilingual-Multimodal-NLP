[
    {
        "title": "Design SQL",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1605603,
                "content": [
                    {
                        "username": "sr_vrd",
                        "content": "Note the columns in each table are also 1-indexed."
                    },
                    {
                        "username": "startupveteran",
                        "content": "Why is this question being downvoted so much? Seemed like a fair and legit challenge to me."
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "making the input param possibly invalid and change the function return type to bool would be better. Otherwise, the 'columns' input is unnecessary.  "
                    }
                ]
            },
            {
                "id": 1909533,
                "content": [
                    {
                        "username": "sr_vrd",
                        "content": "Note the columns in each table are also 1-indexed."
                    },
                    {
                        "username": "startupveteran",
                        "content": "Why is this question being downvoted so much? Seemed like a fair and legit challenge to me."
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "making the input param possibly invalid and change the function return type to bool would be better. Otherwise, the 'columns' input is unnecessary.  "
                    }
                ]
            },
            {
                "id": 1957939,
                "content": [
                    {
                        "username": "sr_vrd",
                        "content": "Note the columns in each table are also 1-indexed."
                    },
                    {
                        "username": "startupveteran",
                        "content": "Why is this question being downvoted so much? Seemed like a fair and legit challenge to me."
                    },
                    {
                        "username": "SleepyPounds",
                        "content": "making the input param possibly invalid and change the function return type to bool would be better. Otherwise, the 'columns' input is unnecessary.  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Days Spent Together",
        "question_content": "<p>Alice and Bob are traveling to Rome for separate business meetings.</p>\n\n<p>You are given 4 strings <code>arriveAlice</code>, <code>leaveAlice</code>, <code>arriveBob</code>, and <code>leaveBob</code>. Alice will be in the city from the dates <code>arriveAlice</code> to <code>leaveAlice</code> (<strong>inclusive</strong>), while Bob will be in the city from the dates <code>arriveBob</code> to <code>leaveBob</code> (<strong>inclusive</strong>). Each will be a 5-character string in the format <code>&quot;MM-DD&quot;</code>, corresponding to the month and day of the date.</p>\n\n<p>Return<em> the total number of days that Alice and Bob are in Rome together.</em></p>\n\n<p>You can assume that all dates occur in the <strong>same</strong> calendar year, which is <strong>not</strong> a leap year. Note that the number of days per month can be represented as: <code>[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arriveAlice = &quot;08-15&quot;, leaveAlice = &quot;08-18&quot;, arriveBob = &quot;08-16&quot;, leaveBob = &quot;08-19&quot;\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arriveAlice = &quot;10-01&quot;, leaveAlice = &quot;10-31&quot;, arriveBob = &quot;11-01&quot;, leaveBob = &quot;12-31&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no day when Alice and Bob are in Rome together, so we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>All dates are provided in the format <code>&quot;MM-DD&quot;</code>.</li>\n\t<li>Alice and Bob&#39;s arrival dates are <strong>earlier than or equal to</strong> their leaving dates.</li>\n\t<li>The given dates are valid dates of a <strong>non-leap</strong> year.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2587981,
                "title": "c-convert-date-to-number-in-year-explaination",
                "content": "- We just need to convert the given date to number in year.\\n- For example, \"01-13\" (13th January) represents **13th day in year**, \"02-13\" (13th February) represents **44th day in year**.\\n- This problem came in Biweekly Contest on 17th September, 2022, which is **260th day** in year.\\n```cpp\\nint md[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nclass Solution {\\n\\t// Convert date to respective number in year.\\n    int td(string s) {\\n        int m = s[1] - \\'0\\' + 10*(s[0] - \\'0\\');\\n        int d = s[4] - \\'0\\' + 10*(s[3] - \\'0\\');\\n        --m;\\n        while (m > 0) {\\n            d += md[m];\\n            --m;\\n        }\\n        return d;\\n    }\\npublic:\\n    int countDaysTogether(string sa1, string sa2, string sb1, string sb2) {\\n        int a1 = td(sa1), a2 = td(sa2), b1 = td(sb1), b2 = td(sb2);\\n        int ans = 0;\\n\\t\\t// Check all 365 days in year\\n        for (int i = 0; i < 367; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint md[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nclass Solution {\\n\\t// Convert date to respective number in year.\\n    int td(string s) {\\n        int m = s[1] - \\'0\\' + 10*(s[0] - \\'0\\');\\n        int d = s[4] - \\'0\\' + 10*(s[3] - \\'0\\');\\n        --m;\\n        while (m > 0) {\\n            d += md[m];\\n            --m;\\n        }\\n        return d;\\n    }\\npublic:\\n    int countDaysTogether(string sa1, string sa2, string sb1, string sb2) {\\n        int a1 = td(sa1), a2 = td(sa2), b1 = td(sb1), b2 = td(sb2);\\n        int ans = 0;\\n\\t\\t// Check all 365 days in year\\n        for (int i = 0; i < 367; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587931,
                "title": "why-is-this-problem-marked-easy",
                "content": "Just because this problem did not use complex algorithm does not mean it should be marked as easy (at least in timed contest).\\nIt\\u2019s like trying to perfectly balance stack of books on your head within a time frame and say it\\u2019s easy because there is not much physical work to do in that.",
                "solutionTags": [],
                "code": "Just because this problem did not use complex algorithm does not mean it should be marked as easy (at least in timed contest).\\nIt\\u2019s like trying to perfectly balance stack of books on your head within a time frame and say it\\u2019s easy because there is not much physical work to do in that.",
                "codeTag": "Unknown"
            },
            {
                "id": 2587939,
                "title": "stupid-problem-line-sweep-dry-run",
                "content": "**Approach: Map Line Sweep**\\n\\n**Intiution:** We need overlapping intervals, so need to use line sweep.\\n\\n**TC**: O(logN) ~= O(log4) ~= **O(1)** as we are inserting 4 elements into map + O(12) for traversing months.. Since 4 is very small no. even for the worst case, so we can say that its O(1)\\n\\n**SC**: O(4 + 4) ~= **O(1)**: we are using 4 variables + 4 elements in the map, which will be same for the worst case as well, so we can say that its O(1) \\n\\n**Dry Run:**\\nFor sample test case 1 our map will contains: \\n258 +1   259 +1   262 -1   263 -1:\\n\\nhere 258, 259 is the key and values are +1, -1.\\n\\nwe will take commulative some of the values..\\nour values goes like this +1 +2 +1 0\\n\\nwhenever we get 2: means we are in a nested cluster like `[ (  ) ] `: \\nwe are at firt curly bracket, now we know that together part will `) - (` is the answer.\\n\\nnext(it) : it will point the next pointer from current pointer, so `(next(it)->first) - (it->first)`: means 262 - 259 = 3, which is our answer..\\n\\nIf we never able to reach to 2, means there\\'s no cluster like `[()] or [(])` which gives answer. In this case our cluster will be like [] (), so will return 0 as there\\'s nothing common between them.\\n```\\nclass Solution {\\npublic:\\n    int convertMonthToDays(int month){\\n        int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int days = 0;\\n        \\n        // we will skip the current month as we are counting them explicitly.\\n        for(int i = 0; i < month - 1; i++){\\n            days += months[i];\\n        }\\n        return days;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aliceArriveDayCount = convertMonthToDays(stoi(arriveAlice.substr(0, 2))) + stoi(arriveAlice.substr(3, 2));\\n        int aliceLeaveDayCount = convertMonthToDays(stoi(leaveAlice.substr(0, 2))) + stoi(leaveAlice.substr(3, 2));\\n        \\n        int bobArriveDayCount = convertMonthToDays(stoi(arriveBob.substr(0, 2))) + stoi(arriveBob.substr(3, 2));\\n        int bobLeaveDayCount = convertMonthToDays(stoi(leaveBob.substr(0, 2))) + stoi(leaveBob.substr(3, 2));\\n        \\n        // Line Sweep\\n        map<int, int> map;\\n        \\n\\t\\t// Marking arriving and leaving boundaries.\\n        map[aliceArriveDayCount]++;\\n        map[aliceLeaveDayCount + 1]--;\\n        \\n        map[bobArriveDayCount]++;\\n        map[bobLeaveDayCount + 1]--;\\n\\n        int days = 0, together = 0;\\n        \\n        // At any point we encounter nested intervals [ (  ) ] or [  (  ] ), we can get common days.\\n        // for eg: for sample test case 1 our map will contains\\n        // [258 +1   (259 +1   262 -1]   263 -1), then answer is : 262 - 259 = 3 days : )\\n        \\n        auto it = map.begin();\\n        while(it != map.end()){\\n            together += it->second;\\n            \\n            if(together == 2){\\n                return next(it)->first - it->first;\\n            }\\n            it++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**Doubts, Queries, Better Approaches are most welcome** \\uD83C\\uDF3B",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int convertMonthToDays(int month){\\n        int months[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int days = 0;\\n        \\n        // we will skip the current month as we are counting them explicitly.\\n        for(int i = 0; i < month - 1; i++){\\n            days += months[i];\\n        }\\n        return days;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aliceArriveDayCount = convertMonthToDays(stoi(arriveAlice.substr(0, 2))) + stoi(arriveAlice.substr(3, 2));\\n        int aliceLeaveDayCount = convertMonthToDays(stoi(leaveAlice.substr(0, 2))) + stoi(leaveAlice.substr(3, 2));\\n        \\n        int bobArriveDayCount = convertMonthToDays(stoi(arriveBob.substr(0, 2))) + stoi(arriveBob.substr(3, 2));\\n        int bobLeaveDayCount = convertMonthToDays(stoi(leaveBob.substr(0, 2))) + stoi(leaveBob.substr(3, 2));\\n        \\n        // Line Sweep\\n        map<int, int> map;\\n        \\n\\t\\t// Marking arriving and leaving boundaries.\\n        map[aliceArriveDayCount]++;\\n        map[aliceLeaveDayCount + 1]--;\\n        \\n        map[bobArriveDayCount]++;\\n        map[bobLeaveDayCount + 1]--;\\n\\n        int days = 0, together = 0;\\n        \\n        // At any point we encounter nested intervals [ (  ) ] or [  (  ] ), we can get common days.\\n        // for eg: for sample test case 1 our map will contains\\n        // [258 +1   (259 +1   262 -1]   263 -1), then answer is : 262 - 259 = 3 days : )\\n        \\n        auto it = map.begin();\\n        while(it != map.end()){\\n            together += it->second;\\n            \\n            if(together == 2){\\n                return next(it)->first - it->first;\\n            }\\n            it++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587888,
                "title": "days-range-java",
                "content": "\\n**Code:**\\n\\n    int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String s1, String e1, String s2, String e2) {\\n        int[] a = new int[]{ getVal(s1), getVal(e1) };\\n        int[] b = new int[]{ getVal(s2), getVal(e2) };\\n        if(b[0]>a[1] || a[0]>b[1]) return 0;  // no overlap\\n        \\n        int start = Math.max(a[0], b[0]);\\n        int last = Math.min(a[1], b[1]);\\n        return last-start+1;\\n    }\\n    \\n    // convert date to nth day of year, (1st-365th day)\\n\\tint getVal(String str){\\n        int idx = 0;\\n        int mon = (str.charAt(0)-\\'0\\')*10+(str.charAt(1)-\\'0\\');\\n        int day = (str.charAt(3)-\\'0\\')*10+(str.charAt(4)-\\'0\\');\\n        for(int i=1; i<mon; i++) idx += months[i-1]; // or use prefix sum\\n        return idx+day;\\n    }",
                "solutionTags": [],
                "code": "\\n**Code:**\\n\\n    int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String s1, String e1, String s2, String e2) {\\n        int[] a = new int[]{ getVal(s1), getVal(e1) };\\n        int[] b = new int[]{ getVal(s2), getVal(e2) };\\n        if(b[0]>a[1] || a[0]>b[1]) return 0;  // no overlap\\n        \\n        int start = Math.max(a[0], b[0]);\\n        int last = Math.min(a[1], b[1]);\\n        return last-start+1;\\n    }\\n    \\n    // convert date to nth day of year, (1st-365th day)\\n\\tint getVal(String str){\\n        int idx = 0;\\n        int mon = (str.charAt(0)-\\'0\\')*10+(str.charAt(1)-\\'0\\');\\n        int day = (str.charAt(3)-\\'0\\')*10+(str.charAt(4)-\\'0\\');\\n        for(int i=1; i<mon; i++) idx += months[i-1]; // or use prefix sum\\n        return idx+day;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2587961,
                "title": "line-sweep-c-with-comments",
                "content": "I learnt this algorithm in last weekly contest.\\n    \\n# Intuition:\\n > Return the total number of days that Alice and Bob are in Rome together\\n\\nThis line gives us straight forward intuition of finding count of **Overlapping events**.\\nThe most optimised algorithm for this is called **Line Sweep Technique**. \\n\\n> A better technique exists which takes constant space and time, but this technique is worth it learning.\\n    \\n # Algorithm:\\n 1. Get the interger form of alice\\'s and bob\\'s start and end day and month\\n 2. After getting integer, get the day number with given day and month number. [For that I wrote function days_convert()]\\n 3. Simply apply Line Sweep Technique and count days with overlapping count of 2 using array `cnt`.\\n\\n**Time** - O(`370`)\\n**Space** - O(`370`)    \\n  # I have attached comments line by line with proper variable naming because there is no use of short code if its not understandable.\\n\\n\\n# C++ \\n    //to extract the count of days before month number given\\n    int days_convert(int month){\\n        vector<int> a{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int count=0;\\n        //we won\\'t include the given month number days because its not complete yet.\\n        for(int i=0;i<=(month-1-1);i++) count+= a[i];\\n        return count;\\n    }\\n    \\n    int countDaysTogether(string a, string la, string b, string lb) {\\n        //Step A:  Get the integer count of day according to 365 numbering \\n       \\n        int alice_arrive_day_count= days_convert((a[0]-\\'0\\')*10+(a[1]-\\'0\\')) + (a[3]-\\'0\\')*10+(a[4]-\\'0\\');\\n        int alice_end_day_count   = days_convert((la[0]-\\'0\\')*10+(la[1]-\\'0\\')) + (la[3]-\\'0\\')*10+(la[4]-\\'0\\');\\n        int bob_arrive_day_count  = days_convert((b[0]-\\'0\\')*10+(b[1]-\\'0\\') ) + (b[3]-\\'0\\')*10+(b[4]-\\'0\\');\\n        int bob_end_day_count     = days_convert((lb[0]-\\'0\\')*10+(lb[1]-\\'0\\')) + (lb[3]-\\'0\\')*10+(lb[4]-\\'0\\');\\n        \\n        \\n        //Step B : Line Sweep Technique\\n        int cnt[370]{};\\n\\t\\t\\n        //Mark Boundaries\\n        cnt[alice_arrive_day_count]++;\\n        cnt[alice_end_day_count+1]--;\\n        cnt[bob_arrive_day_count]++;\\n        cnt[bob_end_day_count+1]--;\\n        \\n        //Take prefix and count days with overlapping count of 2\\n        int days=0, sum=0;\\n        for(int i:cnt){\\n            sum+= i;\\n            //found a count of 2 means , a day where both have their days common\\n            if(sum==2) days++;\\n        }\\n        return days;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "I learnt this algorithm in last weekly contest.\\n    \\n# Intuition:\\n > Return the total number of days that Alice and Bob are in Rome together\\n\\nThis line gives us straight forward intuition of finding count of **Overlapping events**.\\nThe most optimised algorithm for this is called **Line Sweep Technique**. \\n\\n> A better technique exists which takes constant space and time, but this technique is worth it learning.\\n    \\n # Algorithm:\\n 1. Get the interger form of alice\\'s and bob\\'s start and end day and month\\n 2. After getting integer, get the day number with given day and month number. [For that I wrote function days_convert()]\\n 3. Simply apply Line Sweep Technique and count days with overlapping count of 2 using array `cnt`.\\n\\n**Time** - O(`370`)\\n**Space** - O(`370`)    \\n  # I have attached comments line by line with proper variable naming because there is no use of short code if its not understandable.\\n\\n\\n# C++ \\n    //to extract the count of days before month number given\\n    int days_convert(int month){\\n        vector<int> a{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int count=0;\\n        //we won\\'t include the given month number days because its not complete yet.\\n        for(int i=0;i<=(month-1-1);i++) count+= a[i];\\n        return count;\\n    }\\n    \\n    int countDaysTogether(string a, string la, string b, string lb) {\\n        //Step A:  Get the integer count of day according to 365 numbering \\n       \\n        int alice_arrive_day_count= days_convert((a[0]-\\'0\\')*10+(a[1]-\\'0\\')) + (a[3]-\\'0\\')*10+(a[4]-\\'0\\');\\n        int alice_end_day_count   = days_convert((la[0]-\\'0\\')*10+(la[1]-\\'0\\')) + (la[3]-\\'0\\')*10+(la[4]-\\'0\\');\\n        int bob_arrive_day_count  = days_convert((b[0]-\\'0\\')*10+(b[1]-\\'0\\') ) + (b[3]-\\'0\\')*10+(b[4]-\\'0\\');\\n        int bob_end_day_count     = days_convert((lb[0]-\\'0\\')*10+(lb[1]-\\'0\\')) + (lb[3]-\\'0\\')*10+(lb[4]-\\'0\\');\\n        \\n        \\n        //Step B : Line Sweep Technique\\n        int cnt[370]{};\\n\\t\\t\\n        //Mark Boundaries\\n        cnt[alice_arrive_day_count]++;\\n        cnt[alice_end_day_count+1]--;\\n        cnt[bob_arrive_day_count]++;\\n        cnt[bob_end_day_count+1]--;\\n        \\n        //Take prefix and count days with overlapping count of 2\\n        int days=0, sum=0;\\n        for(int i:cnt){\\n            sum+= i;\\n            //found a count of 2 means , a day where both have their days common\\n            if(sum==2) days++;\\n        }\\n        return days;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2588031,
                "title": "python-simple-solution-easy-to-understand-explained",
                "content": "#### Understanding\\n* Find the minimum date of leave between Alice & Bob.\\n* Find the maximum date of arrival between Alice & Bob.\\n* The desire date will be between these two limit.\\n\\n#### Example\\n* Let the input be `arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"`\\n* The minimum date of leave between Alice & Bob is `\"08-18\"`.\\n* The max date of arrival between Alice & Bob is `\"08-16\"`.\\n* Total number of days together will be between these days.\\n\\t* Calculate from `\"08-18\"` the total days in a year using `getDate(date)` method and we get **230** days.\\n\\t* Calculate from `\"08-16\"` the total days in a year using `getDate(date)` method and we get **228** days.\\n* Now substract `230 - 228 + 1`. As days are inclusive so we add 1.\\n* Return the max value between substranct value and 0.\\n\\n##### Code\\n<iframe src=\"https://leetcode.com/playground/6BEiBvaS/shared\" frameBorder=\"0\" width=\"800\" height=\"300\"></iframe>\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "#### Understanding\\n* Find the minimum date of leave between Alice & Bob.\\n* Find the maximum date of arrival between Alice & Bob.\\n* The desire date will be between these two limit.\\n\\n#### Example\\n* Let the input be `arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\"`\\n* The minimum date of leave between Alice & Bob is `\"08-18\"`.\\n* The max date of arrival between Alice & Bob is `\"08-16\"`.\\n* Total number of days together will be between these days.\\n\\t* Calculate from `\"08-18\"` the total days in a year using `getDate(date)` method and we get **230** days.\\n\\t* Calculate from `\"08-16\"` the total days in a year using `getDate(date)` method and we get **228** days.\\n* Now substract `230 - 228 + 1`. As days are inclusive so we add 1.\\n* Return the max value between substranct value and 0.\\n\\n##### Code\\n<iframe src=\"https://leetcode.com/playground/6BEiBvaS/shared\" frameBorder=\"0\" width=\"800\" height=\"300\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2588216,
                "title": "python-explanation-with-pictures-4-line-overlapping-intervals",
                "content": "\\nCount the number of days in the overlapped interval `[second arrive, first leave]`:\\n\\n`overlapped_days = days_before_first_leave - days_before_second_arrive + 1` since its an inclusive range.\\n\\n![image](https://assets.leetcode.com/users/images/8e427dbd-040d-4bd0-8b35-1acb27750eb1_1663435585.724624.png)\\n\\n\\nWe can just count the days from **day_0** (the beginning of this year) till the given date:\\n`overlapped_days = days before end - days before start + 1`\\n\\n\\n![image](https://assets.leetcode.com/users/images/ea0a1d9b-6f9e-4c62-895c-5712a086a9cf_1663435662.367996.png)\\n\\n\\n\\nHow to count the days above:\\n`days = days in whole months + rest days`\\n\\n![image](https://assets.leetcode.com/users/images/85f1a628-44df-4053-8677-77cfa156a2ed_1663435593.0807467.png)\\n\\n\\n**python**\\n\\n```\\ndef countDaysTogether(self, aa: str, la: str, ab: str, lb: str) -> int:\\n        D = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        def helper(days):\\n            return int(days[-2:]) + sum(D[:int(days[:2]) - 1])\\n        \\n        return max(0, helper(min(la, lb)) - helper(max(aa, ab)) + 1)\\n```",
                "solutionTags": [],
                "code": "```\\ndef countDaysTogether(self, aa: str, la: str, ab: str, lb: str) -> int:\\n        D = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        def helper(days):\\n            return int(days[-2:]) + sum(D[:int(days[:2]) - 1])\\n        \\n        return max(0, helper(min(la, lb)) - helper(max(aa, ab)) + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2589668,
                "title": "day-of-year",
                "content": "We use a prefix sum array to convert string dates to the day of the year.\\n\\nThen, we subtract the last and first day when Bob and Alice were together.\\n\\n**C++**\\n```cpp\\nint days[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\nint dayOfYear(string &d) {\\n    return days[10 * (d[0] - \\'0\\') + d[1] - \\'0\\' - 1] + 10 * (d[3] - \\'0\\') + d[4] - \\'0\\';\\n}\\nint countDaysTogether(string aa, string la, string ab, string lb) {\\n    return max(0, min(dayOfYear(la), dayOfYear(lb)) - max(dayOfYear(aa), dayOfYear(ab)) + 1);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint days[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\nint dayOfYear(string &d) {\\n    return days[10 * (d[0] - \\'0\\') + d[1] - \\'0\\' - 1] + 10 * (d[3] - \\'0\\') + d[4] - \\'0\\';\\n}\\nint countDaysTogether(string aa, string la, string ab, string lb) {\\n    return max(0, min(dayOfYear(la), dayOfYear(lb)) - max(dayOfYear(aa), dayOfYear(ab)) + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588389,
                "title": "c-easy-to-understand-100",
                "content": "\\n\\tclass Solution {\\n\\tprivate:\\n    int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    vector<int> sumDays;\\n\\t\\n\\tpublic:\\n\\tint totalDays(string str){\\n        int month = stoi(str.substr(0, 2)), day = stoi(str.substr(3));    \\n        return sumDays[month - 1] + day;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        sumDays.push_back(0);\\n        for(int i =0;i<12;i++){\\n            sumDays.push_back(sumDays.back() + days[i]);\\n        }\\n        \\n        int arrival = max(totalDays(arriveAlice), totalDays(arriveBob));\\n        int departure = min(totalDays(leaveAlice), totalDays(leaveBob));\\n        int countDays = departure - arrival +1;\\n        \\n\\t\\treturn max(0, countDays);\\n        \\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tprivate:\\n    int days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2587883,
                "title": "simple-solution",
                "content": "I think this is a tricky implementation question, but if we use library function it becomes very easy.\\n* Convert the date into number of days from the **Epoch** *1970-01-01* and find the intersection of the days. Check the comments for timeline\\n\\n```\\n//toEpochDay counts the number of days from the epoch 1970-01-01\\nimport java.time.LocalDate;\\nclass Solution {\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob){\\n        LocalDate d1 = LocalDate.of(2021,Integer.parseInt(arriveAlice.substring(0,2)),Integer.parseInt(arriveAlice.substring(3,5)));\\n        LocalDate d2 = LocalDate.of(2021,Integer.parseInt(leaveAlice.substring(0,2)),Integer.parseInt(leaveAlice.substring(3,5)));\\n        LocalDate d3 = LocalDate.of(2021,Integer.parseInt(arriveBob.substring(0,2)),Integer.parseInt(arriveBob.substring(3,5)));\\n        LocalDate d4 = LocalDate.of(2021,Integer.parseInt(leaveBob.substring(0,2)),Integer.parseInt(leaveBob.substring(3,5)));\\n        long aa = d1.toEpochDay(); //Alice Arrive\\n        long al = d2.toEpochDay(); //Alice Left\\n        long ba = d3.toEpochDay(); //Bob Arrive\\n        long bl = d4.toEpochDay(); //Bob Left\\n        if(al<ba || bl<aa) return 0; //No intersection of days\\n        return (int) ((Math.min(al,bl)-Math.max(aa,ba))+1); //Intersection of days\\n    }\\n}\\n/*\\n    //Intersection of alice and bob\\n       aa.....ba.......bl.....al\\n       aa.....ba.......al......bl\\n       ba.....aa.......bl......al\\n       ba.....aa.......al......bl\\n\\n\\n   //No intersection\\n\\n           aa......al.....ba......bl\\n           ba.....bl.....aa......al\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//toEpochDay counts the number of days from the epoch 1970-01-01\\nimport java.time.LocalDate;\\nclass Solution {\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob){\\n        LocalDate d1 = LocalDate.of(2021,Integer.parseInt(arriveAlice.substring(0,2)),Integer.parseInt(arriveAlice.substring(3,5)));\\n        LocalDate d2 = LocalDate.of(2021,Integer.parseInt(leaveAlice.substring(0,2)),Integer.parseInt(leaveAlice.substring(3,5)));\\n        LocalDate d3 = LocalDate.of(2021,Integer.parseInt(arriveBob.substring(0,2)),Integer.parseInt(arriveBob.substring(3,5)));\\n        LocalDate d4 = LocalDate.of(2021,Integer.parseInt(leaveBob.substring(0,2)),Integer.parseInt(leaveBob.substring(3,5)));\\n        long aa = d1.toEpochDay(); //Alice Arrive\\n        long al = d2.toEpochDay(); //Alice Left\\n        long ba = d3.toEpochDay(); //Bob Arrive\\n        long bl = d4.toEpochDay(); //Bob Left\\n        if(al<ba || bl<aa) return 0; //No intersection of days\\n        return (int) ((Math.min(al,bl)-Math.max(aa,ba))+1); //Intersection of days\\n    }\\n}\\n/*\\n    //Intersection of alice and bob\\n       aa.....ba.......bl.....al\\n       aa.....ba.......al......bl\\n       ba.....aa.......bl......al\\n       ba.....aa.......al......bl\\n\\n\\n   //No intersection\\n\\n           aa......al.....ba......bl\\n           ba.....bl.....aa......al\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588105,
                "title": "c-solution-easy-and-concise",
                "content": "**C++ Solution :-**\\n```\\nclass Solution{\\npublic:\\n    vector<int> days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int countDaysTogether(string aA, string lA, string aB, string lB)\\n    {\\n        /* calculating no of days each date represents. */\\n        int aliceA = accumulate(days.begin(), days.begin() + stoi(aA.substr(0, 2)) - 1, 0) + stoi(aA.substr(3, aA.size()));\\n        int aliceL = accumulate(days.begin(), days.begin() + stoi(lA.substr(0, 2)) - 1, 0) + stoi(lA.substr(3, aA.size()));\\n        int bobA = accumulate(days.begin(), days.begin() + stoi(aB.substr(0, 2)) - 1, 0) + stoi(aB.substr(3, aA.size()));\\n        int bobL = accumulate(days.begin(), days.begin() + stoi(lB.substr(0, 2)) - 1, 0) + stoi(lB.substr(3, aA.size()));\\n\\n        /* we have to choose minimum of leave days and maximum of arrival days\\n           in order to get no of days together. */\\n        int x = min(aliceL, bobL) - max(aliceA, bobA) + 1;\\n        if (x > 0)\\n            return x;\\n        return 0;\\n    }\\n};\\n```\\n**Please Upvote if you found this helpful .**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    vector<int> days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int countDaysTogether(string aA, string lA, string aB, string lB)\\n    {\\n        /* calculating no of days each date represents. */\\n        int aliceA = accumulate(days.begin(), days.begin() + stoi(aA.substr(0, 2)) - 1, 0) + stoi(aA.substr(3, aA.size()));\\n        int aliceL = accumulate(days.begin(), days.begin() + stoi(lA.substr(0, 2)) - 1, 0) + stoi(lA.substr(3, aA.size()));\\n        int bobA = accumulate(days.begin(), days.begin() + stoi(aB.substr(0, 2)) - 1, 0) + stoi(aB.substr(3, aA.size()));\\n        int bobL = accumulate(days.begin(), days.begin() + stoi(lB.substr(0, 2)) - 1, 0) + stoi(lB.substr(3, aA.size()));\\n\\n        /* we have to choose minimum of leave days and maximum of arrival days\\n           in order to get no of days together. */\\n        int x = min(aliceL, bobL) - max(aliceA, bobA) + 1;\\n        if (x > 0)\\n            return x;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587987,
                "title": "java-python-3-convert-to-the-kth-day-in-a-whole-year",
                "content": "Count the number of days from `01-01` to current day, then check the maximum of the arrival days and the minimum of the leaving days, if the former greater than the latter, no together days. otherwise, compute the days from the former to the latter.\\n\\n```java\\n    private static final int[] months = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aa = converToDays(arriveAlice);\\n        int la = converToDays(leaveAlice);\\n        int ab = converToDays(arriveBob);\\n        int lb = converToDays(leaveBob);\\n        int lo = Math.max(aa, ab);\\n        int hi = Math.min(la, lb);\\n        return Math.max(0, hi - lo + 1);\\n    }\\n    private int converToDays(String s) {\\n        int days = Integer.parseInt(s.substring(3));\\n        for (int i = 0; i < Integer.parseInt(s.substring(0, 2)) - 1; ++i) {\\n            days += months[i];\\n        }\\n        return days;\\n    }\\n```\\n```python\\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        \\n        def convertToDays(s: str) -> int:\\n            month = int(s[: 2].lstrip(\\'0\\')) - 1\\n            days = int(s[-2 :].lstrip(\\'0\\'))\\n            return days + sum(self.months[: month])\\n        \\n        aa, la, ab, lb = map(convertToDays, (arriveAlice, leaveAlice, arriveBob, leaveBob))\\n        return max(0, min(la, lb) - max(aa, ab)  + 1)\\n```",
                "solutionTags": [],
                "code": "```java\\n    private static final int[] months = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aa = converToDays(arriveAlice);\\n        int la = converToDays(leaveAlice);\\n        int ab = converToDays(arriveBob);\\n        int lb = converToDays(leaveBob);\\n        int lo = Math.max(aa, ab);\\n        int hi = Math.min(la, lb);\\n        return Math.max(0, hi - lo + 1);\\n    }\\n    private int converToDays(String s) {\\n        int days = Integer.parseInt(s.substring(3));\\n        for (int i = 0; i < Integer.parseInt(s.substring(0, 2)) - 1; ++i) {\\n            days += months[i];\\n        }\\n        return days;\\n    }\\n```\n```python\\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        \\n        def convertToDays(s: str) -> int:\\n            month = int(s[: 2].lstrip(\\'0\\')) - 1\\n            days = int(s[-2 :].lstrip(\\'0\\'))\\n            return days + sum(self.months[: month])\\n        \\n        aa, la, ab, lb = map(convertToDays, (arriveAlice, leaveAlice, arriveBob, leaveBob))\\n        return max(0, min(la, lb) - max(aa, ab)  + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2587887,
                "title": "parse-dates-and-find-intersection",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        start = max(arriveAlice, arriveBob)\\n        sm, sd = map(int, start.split(\"-\"))\\n        end = min(leaveAlice, leaveBob)\\n        em, ed = map(int, end.split(\"-\"))\\n        res = 0\\n        for m in range(sm + 1, em):\\n            res += days[m - 1]\\n        if em > sm:\\n            res += days[sm - 1] - sd + ed + 1\\n        elif em == sm:\\n            res += max(ed - sd + 1, 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        start = max(arriveAlice, arriveBob)\\n        sm, sd = map(int, start.split(\"-\"))\\n        end = min(leaveAlice, leaveBob)\\n        em, ed = map(int, end.split(\"-\"))\\n        res = 0\\n        for m in range(sm + 1, em):\\n            res += days[m - 1]\\n        if em > sm:\\n            res += days[sm - 1] - sd + ed + 1\\n        elif em == sm:\\n            res += max(ed - sd + 1, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588050,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        for i in range(1,12):                #to store total days after i months\\n            arr[i]+=arr[i-1]\\n        arr.insert(0,0)\\n        #converting months into days\\n        a = arr[int(arriveAlice[0:2])-1] + int(arriveAlice[3:])                \\n        b = arr[int(leaveAlice[0:2])-1] + int(leaveAlice[3:])\\n        c = arr[int(arriveBob[0:2])-1] + int(arriveBob[3:])\\n        d = arr[int(leaveBob[0:2])-1] + int(leaveBob[3:])\\n        # print(a,b,c,d)\\n        if a<c:               #if alice arrives before bob arrives\\n            if b<c:           #if alice leaves before bob arrives\\n                return 0\\n            if b>=d:          #if alice leaves after bob leaves\\n                return d-c+1\\n            if b<d:            #if bob leaves after alice leaves\\n                return b-c+1\\n        else:                      #reverse the conditions\\n            if d<a:\\n                return 0\\n            if d>=b:\\n                return b-a+1\\n            if d<b:\\n                return d-a+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        for i in range(1,12):                #to store total days after i months\\n            arr[i]+=arr[i-1]\\n        arr.insert(0,0)\\n        #converting months into days\\n        a = arr[int(arriveAlice[0:2])-1] + int(arriveAlice[3:])                \\n        b = arr[int(leaveAlice[0:2])-1] + int(leaveAlice[3:])\\n        c = arr[int(arriveBob[0:2])-1] + int(arriveBob[3:])\\n        d = arr[int(leaveBob[0:2])-1] + int(leaveBob[3:])\\n        # print(a,b,c,d)\\n        if a<c:               #if alice arrives before bob arrives\\n            if b<c:           #if alice leaves before bob arrives\\n                return 0\\n            if b>=d:          #if alice leaves after bob leaves\\n                return d-c+1\\n            if b<d:            #if bob leaves after alice leaves\\n                return b-c+1\\n        else:                      #reverse the conditions\\n            if d<a:\\n                return 0\\n            if d>=b:\\n                return b-a+1\\n            if d<b:\\n                return d-a+1",
                "codeTag": "Java"
            },
            {
                "id": 2591264,
                "title": "python-c-java-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2409. Count Days Spent Together***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def countDaysTogether(self, a1: str, l1: str, a2: str, l2: str) -> int:\\n        def dateConvetor(date:str)->int:\\n            month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n            m,d=int(date[:2]),int(date[3:])\\n            return sum(month[i] for i in range(m - 1)) + d\\n        \\n        ar1=dateConvetor(a1)   \\n        le1=dateConvetor(l1)\\n        ar2=dateConvetor(a2)\\n        le2=dateConvetor(l2)\\n        overlap=min(le1,le2)-max(ar1,ar2)+1\\n        return max(0,overlap)\\n```\\n**Runtime:**  74 ms\\t\\n**Memory Usage:**  17.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int a1 = Days(arriveAlice);\\n        int l1 = Days(leaveAlice);\\n        int a2 = Days(arriveBob);\\n        int l2 = Days(leaveBob);\\n        if(l1 < a2 || l2 < a1) return 0;\\n        return Math.abs(Math.max(a1, a2)-Math.min(l1, l2))+1;\\n    }\\n    private int Days(String str){\\n        int[] month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int sum=0,m=Integer.valueOf(str.substring(0,2)),d=Integer.valueOf(str.substring(3,5));\\n        for(int i=0;i<m-1;i++)\\n            sum+=month[i];\\n        return d+sum;\\n    }\\n}\\n```\\n**Runtime:**  1 ms\\t\\t\\n**Memory Usage:**  41 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int dateconvert(string s)\\n    {\\n        vector<int> month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int sum=0,m=stoi(s.substr(0,2)),d=stoi(s.substr(3,2));\\n        for(int i=0;i<m-1;i++)\\n            sum+=month[i];\\n        return (sum+d);\\n    }\\n    \\n    \\n    int countDaysTogether(string aA, string lA, string aB, string lB) {\\n        int a1=dateconvert(aA),a2=dateconvert(aB),l1=dateconvert(lA),l2=dateconvert(lB);\\n        return max(0,min(l1,l2)-max(a1,a2)+1);\\n        \\n    }\\n};\\n```\\n**Runtime:** 0 ms\\t\\n**Memory Usage:**  6 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, a1: str, l1: str, a2: str, l2: str) -> int:\\n        def dateConvetor(date:str)->int:\\n            month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n            m,d=int(date[:2]),int(date[3:])\\n            return sum(month[i] for i in range(m - 1)) + d\\n        \\n        ar1=dateConvetor(a1)   \\n        le1=dateConvetor(l1)\\n        ar2=dateConvetor(a2)\\n        le2=dateConvetor(l2)\\n        overlap=min(le1,le2)-max(ar1,ar2)+1\\n        return max(0,overlap)\\n```\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int a1 = Days(arriveAlice);\\n        int l1 = Days(leaveAlice);\\n        int a2 = Days(arriveBob);\\n        int l2 = Days(leaveBob);\\n        if(l1 < a2 || l2 < a1) return 0;\\n        return Math.abs(Math.max(a1, a2)-Math.min(l1, l2))+1;\\n    }\\n    private int Days(String str){\\n        int[] month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int sum=0,m=Integer.valueOf(str.substring(0,2)),d=Integer.valueOf(str.substring(3,5));\\n        for(int i=0;i<m-1;i++)\\n            sum+=month[i];\\n        return d+sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int dateconvert(string s)\\n    {\\n        vector<int> month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int sum=0,m=stoi(s.substr(0,2)),d=stoi(s.substr(3,2));\\n        for(int i=0;i<m-1;i++)\\n            sum+=month[i];\\n        return (sum+d);\\n    }\\n    \\n    \\n    int countDaysTogether(string aA, string lA, string aB, string lB) {\\n        int a1=dateconvert(aA),a2=dateconvert(aB),l1=dateconvert(lA),l2=dateconvert(lB);\\n        return max(0,min(l1,l2)-max(a1,a2)+1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588517,
                "title": "c-easy-to-understand-o-1-solution",
                "content": "**just convert the given date into the number in year**\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\t\\t//no. of days elapsed after each months\\n        vector<int> hs={0,0,31,59,90,120,151,181,212,243,273,304,334};\\n\\t\\t\\n        int aliceArrive=hs[(arriveAlice[0]-\\'0\\')*10+(arriveAlice[1]-\\'0\\')]+((arriveAlice[3]-\\'0\\')*10+(arriveAlice[4]-\\'0\\'));\\n        int aliceLeave=hs[(leaveAlice[0]-\\'0\\')*10+(leaveAlice[1]-\\'0\\')]+((leaveAlice[3]-\\'0\\')*10+(leaveAlice[4]-\\'0\\'));\\n        int bobArrive=hs[(arriveBob[0]-\\'0\\')*10+(arriveBob[1]-\\'0\\')]+((arriveBob[3]-\\'0\\')*10+(arriveBob[4]-\\'0\\'));\\n        int bobLeave=hs[(leaveBob[0]-\\'0\\')*10+(leaveBob[1]-\\'0\\')]+((leaveBob[3]-\\'0\\')*10+(leaveBob[4]-\\'0\\'));\\n\\t\\t\\n         //if either of them is leaving before the arrival of other return 0\\n        if(bobLeave<aliceArrive || aliceLeave<bobArrive)\\n            return 0;\\n        return min(aliceLeave,bobLeave)-max(aliceArrive,bobArrive)+1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\t\\t//no. of days elapsed after each months\\n        vector<int> hs={0,0,31,59,90,120,151,181,212,243,273,304,334}",
                "codeTag": "Java"
            },
            {
                "id": 2588442,
                "title": "easy-simple-with-dates",
                "content": "```\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    \\n  const arriveAliceDate = new Date(\\'2001-\\'+arriveAlice);\\n  const leaveAliceDate = new Date(\\'2001-\\'+leaveAlice);\\n  const arriveBobDate = new Date(\\'2001-\\'+arriveBob);\\n  const leaveBobDate = new Date(\\'2001-\\'+leaveBob);\\n  \\n  let arriveMax = new Date(Math.max(arriveAliceDate, arriveBobDate));\\n  let leaveMin = new Date(Math.min(leaveAliceDate, leaveBobDate));\\n  \\n  if(arriveMax>leaveMin) return 0;\\n  return Math.floor((leaveMin-arriveMax)/(1000*60*60*24))+1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    \\n  const arriveAliceDate = new Date(\\'2001-\\'+arriveAlice);\\n  const leaveAliceDate = new Date(\\'2001-\\'+leaveAlice);\\n  const arriveBobDate = new Date(\\'2001-\\'+arriveBob);\\n  const leaveBobDate = new Date(\\'2001-\\'+leaveBob);\\n  \\n  let arriveMax = new Date(Math.max(arriveAliceDate, arriveBobDate));\\n  let leaveMin = new Date(Math.min(leaveAliceDate, leaveBobDate));\\n  \\n  if(arriveMax>leaveMin) return 0;\\n  return Math.floor((leaveMin-arriveMax)/(1000*60*60*24))+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588190,
                "title": "simple-python-solution-9-lines-of-code",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        monthdays = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        start, end = max(arriveAlice, arriveBob), min(leaveAlice, leaveBob)\\n        \\n        start_month, start_day = int(start[:2]), int(start[3:])\\n        end_month, end_day = int(end[:2]), int(end[3:])\\n        \\n        if start > end: return 0\\n        elif start_month == end_month: \\n            return end_day - start_day + 1\\n        else: \\n            return (monthdays[start_month] - start_day) + sum([monthdays[i] for i in range(start_month + 1, end_month)]) + end_day + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        monthdays = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        \\n        start, end = max(arriveAlice, arriveBob), min(leaveAlice, leaveBob)\\n        \\n        start_month, start_day = int(start[:2]), int(start[3:])\\n        end_month, end_day = int(end[:2]), int(end[3:])\\n        \\n        if start > end: return 0\\n        elif start_month == end_month: \\n            return end_day - start_day + 1\\n        else: \\n            return (monthdays[start_month] - start_day) + sum([monthdays[i] for i in range(start_month + 1, end_month)]) + end_day + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587958,
                "title": "c-mm-dd-to-single-no-easy-simple",
                "content": "**NOTE :**\\n**1.** Just **Read solution 1 time no need to see other Solutions**\\n**2. Don\\'t afraid with size of code** It\\'s **long for easy understanding purpose** only\\n\\n**Solution :**\\nhere I had tried to **reperesent perticular day on number line or say absolute value**\\nlike,\\n**`Jan-01` => 1**\\n**`Jan-15` => 15**\\n**`Feb-01` => 32** (1 + total days of jan)\\n**`Feb-28` => 59** (28 + total days of jan)\\n**`Mar-05` => 64** (5 + total days of jan + total days of feb)\\n\\nso this way we get **all days in absolute value** manner\\n\\n[...,BobAriveAbsoluteDay, AliceAriveAbsoluteDay, ...,BobLeaveAbsoluteDay, AliceLeaveAbsoluteDay,...]\\n\\nat last we have to find common absolute days so\\n\\nthis common days are **start from `max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay)`** and **end at `min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay)`**\\n\\n**`ans = min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay) - max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay) + 1`**\\n\\nedge case **common days never be negative** so take care of it\\n\\nso final **`ans = max(0, min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay) - max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay) + 1)`**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n                             // Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\n        int AliceAriveMonth = stoi(arriveAlice.substr(0, 2));\\n        int AliceAriveDay = stoi(arriveAlice.substr(3, 2));\\n        int AliceLeaveMonth = stoi(leaveAlice.substr(0, 2));\\n        int AliceLeaveDay = stoi(leaveAlice.substr(3, 2));\\n\\n        int BobAriveMonth = stoi(arriveBob.substr(0, 2));\\n        int BobAriveDay = stoi(arriveBob.substr(3, 2));\\n        int BobLeaveMonth = stoi(leaveBob.substr(0, 2));\\n        int BobLeaveDay = stoi(leaveBob.substr(3, 2));\\n\\n        int AliceAriveAbsoluteDay = 0;\\n        for (int m = 1; m < AliceAriveMonth; m++)\\n            AliceAriveAbsoluteDay += daysInMonth[m];\\n        AliceAriveAbsoluteDay += AliceAriveDay;\\n\\n        int BobAriveAbsoluteDay = 0;\\n        for (int m = 1; m < BobAriveMonth; m++)\\n            BobAriveAbsoluteDay += daysInMonth[m];\\n        BobAriveAbsoluteDay += BobAriveDay;\\n\\n        int AliceLeaveAbsoluteDay = 0;\\n        for (int m = 1; m < AliceLeaveMonth; m++)\\n            AliceLeaveAbsoluteDay += daysInMonth[m];\\n        AliceLeaveAbsoluteDay += AliceLeaveDay;\\n\\n        int BobLeaveAbsoluteDay = 0;\\n        for (int m = 1; m < BobLeaveMonth; m++)\\n            BobLeaveAbsoluteDay += daysInMonth[m];\\n        BobLeaveAbsoluteDay += BobLeaveDay;\\n\\n        return max(0, min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay) - max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay) + 1);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/09637eca-5b75-4812-b99e-47dd91776279_1663434278.329717.png)\\n\\n\\n**If find Helpful Upvote It \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n                             // Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\n        int AliceAriveMonth = stoi(arriveAlice.substr(0, 2));\\n        int AliceAriveDay = stoi(arriveAlice.substr(3, 2));\\n        int AliceLeaveMonth = stoi(leaveAlice.substr(0, 2));\\n        int AliceLeaveDay = stoi(leaveAlice.substr(3, 2));\\n\\n        int BobAriveMonth = stoi(arriveBob.substr(0, 2));\\n        int BobAriveDay = stoi(arriveBob.substr(3, 2));\\n        int BobLeaveMonth = stoi(leaveBob.substr(0, 2));\\n        int BobLeaveDay = stoi(leaveBob.substr(3, 2));\\n\\n        int AliceAriveAbsoluteDay = 0;\\n        for (int m = 1; m < AliceAriveMonth; m++)\\n            AliceAriveAbsoluteDay += daysInMonth[m];\\n        AliceAriveAbsoluteDay += AliceAriveDay;\\n\\n        int BobAriveAbsoluteDay = 0;\\n        for (int m = 1; m < BobAriveMonth; m++)\\n            BobAriveAbsoluteDay += daysInMonth[m];\\n        BobAriveAbsoluteDay += BobAriveDay;\\n\\n        int AliceLeaveAbsoluteDay = 0;\\n        for (int m = 1; m < AliceLeaveMonth; m++)\\n            AliceLeaveAbsoluteDay += daysInMonth[m];\\n        AliceLeaveAbsoluteDay += AliceLeaveDay;\\n\\n        int BobLeaveAbsoluteDay = 0;\\n        for (int m = 1; m < BobLeaveMonth; m++)\\n            BobLeaveAbsoluteDay += daysInMonth[m];\\n        BobLeaveAbsoluteDay += BobLeaveDay;\\n\\n        return max(0, min(AliceLeaveAbsoluteDay, BobLeaveAbsoluteDay) - max(AliceAriveAbsoluteDay, BobAriveAbsoluteDay) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592872,
                "title": "c-count-the-number-of-days-till-that-date-beats-100-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>v={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    // function to return total number of days from the starting of the year till given date\\n    int cnt(string a){\\n        int no=0,x=(a[0]-\\'0\\')*10+a[1]-\\'0\\';\\n        no=accumulate(v.begin(),v.begin()+x-1,0);\\n        x=(a[3]-\\'0\\')*10+a[4]-\\'0\\';\\n        no+=x;\\n        return no;\\n    }\\n    int countDaysTogether(string a, string al, string b, string bl) {\\n        int x = cnt(a), y = cnt(b), x2 = cnt(al), y2= cnt(bl);\\n        //max(x,y)----> the day on which the second person arrive\\n        // min(x2,y2) ---> the day on which the first person leave\\n        int ans=max(0,min(x2,y2)-max(x,y)+1); // we took 0 here so that if the intersection is negative or if they didn\\'t spend a single day together then answer will automatically becomes zero\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int>v={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2587983,
                "title": "most-stupid-and-time-consuming-problem",
                "content": "How can leetcode accept such questions and mark them as easy?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2587978,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int countDaysTogether(String aA, String lA, String aB, String lB) {\\n         String from = \"\";\\n         if(aA.compareTo(aB) <= 0) {\\n             from = aB;\\n         }else{\\n             from = aA;\\n         }\\n        String to = \"\";\\n        if(lA.compareTo(lB) <= 0) {\\n             to = lA;\\n         }else{\\n             to = lB;\\n         }\\n        int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aM = Integer.parseInt(from.substring(0,2));   // aM = arriveMonth\\n        int aD = Integer.parseInt(from.substring(3));    // aD = arriveDate\\n        int lM = Integer.parseInt(to.substring(0,2));    //lM = leaveMonth\\n        int lD = Integer.parseInt(to.substring(3));      //lD = leaveDate\\n        if(lM < aM) return 0;                                  \\n        else if(aM == lM && aD>lD) return 0;        \\n        else if(aM == lM && aD<=lD) {\\n            return lD-aD+1;\\n        }else{\\n           int k = lM-aM-1;\\n            int cntDays = 0;\\n            int temp = aM;\\n            while(k-->0) {\\n                cntDays+=days[temp++];\\n            }\\n            return cntDays+(days[aM-1]-aD)+lD+1;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String aA, String lA, String aB, String lB) {\\n         String from = \"\";\\n         if(aA.compareTo(aB) <= 0) {\\n             from = aB;\\n         }else{\\n             from = aA;\\n         }\\n        String to = \"\";\\n        if(lA.compareTo(lB) <= 0) {\\n             to = lA;\\n         }else{\\n             to = lB;\\n         }\\n        int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aM = Integer.parseInt(from.substring(0,2));   // aM = arriveMonth\\n        int aD = Integer.parseInt(from.substring(3));    // aD = arriveDate\\n        int lM = Integer.parseInt(to.substring(0,2));    //lM = leaveMonth\\n        int lD = Integer.parseInt(to.substring(3));      //lD = leaveDate\\n        if(lM < aM) return 0;                                  \\n        else if(aM == lM && aD>lD) return 0;        \\n        else if(aM == lM && aD<=lD) {\\n            return lD-aD+1;\\n        }else{\\n           int k = lM-aM-1;\\n            int cntDays = 0;\\n            int temp = aM;\\n            while(k-->0) {\\n                cntDays+=days[temp++];\\n            }\\n            return cntDays+(days[aM-1]-aD)+lD+1;\\n        }\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587884,
                "title": "java-explained",
                "content": "```\\nclass Solution\\n{\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob)\\n    {\\n        int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        String ar, dp; // ar is the latest arrival date, dp is the earliest departure date\\n        \\n        ar = arriveAlice.compareTo(arriveBob) <= 0 ? arriveBob : arriveAlice;\\n        \\n        dp = leaveAlice.compareTo(leaveBob) <= 0 ? leaveAlice : leaveBob;\\n        \\n        int ret = 1;\\n        \\n        if(ar.compareTo(dp) > 0) // ar is later than dp\\n            return 0;\\n\\n        int amm = Integer.parseInt(ar.substring(0,2)), dmm = Integer.parseInt(dp.substring(0,2)), add = Integer.parseInt(ar.substring(3)), ddd = Integer.parseInt(dp.substring(3));\\n        // Month and day separated for arr and dp values\\n\\t\\t\\n        for(int i = amm+1; i < dmm; i++)\\n            ret += days[i]; // Days of months between arrival and departure(exclusive)\\n        \\n        if(amm == dmm) // If arrival and departure in the same month, day difference is departure - arrival\\n            ret += (ddd-add);\\n        \\n        else // If arrival and departure in different months, day difference is number of days remaining in the arrival month + departure date\\n        {\\n            ret += days[amm]-add;\\n            ret += ddd;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```\\n\\n**Dry run**\\n\\nConsider the TC : arriveAlice = \"08-15\", leaveAlice = \"08-18\", arriveBob = \"08-16\", leaveBob = \"08-19\" .\\n`ar` would be `08-16` and `dp` = `08-18`\\n`\"08-16\".compareTo(\"08-18\")` is < 0 so we do not return yet. \\nHere, amm, dmm, are equal so the loop doesn\\'t add to the `ret` value.\\nAnd hence the day difference is simply 18-16 (3 days, hence ret initialized with 1).\\n\\nOther case is when the months are different and the difference in dates would be calculated as `(31/30/28) - add + ddd`\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob)\\n    {\\n        int[] days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        String ar, dp; // ar is the latest arrival date, dp is the earliest departure date\\n        \\n        ar = arriveAlice.compareTo(arriveBob) <= 0 ? arriveBob : arriveAlice;\\n        \\n        dp = leaveAlice.compareTo(leaveBob) <= 0 ? leaveAlice : leaveBob;\\n        \\n        int ret = 1;\\n        \\n        if(ar.compareTo(dp) > 0) // ar is later than dp\\n            return 0;\\n\\n        int amm = Integer.parseInt(ar.substring(0,2)), dmm = Integer.parseInt(dp.substring(0,2)), add = Integer.parseInt(ar.substring(3)), ddd = Integer.parseInt(dp.substring(3));\\n        // Month and day separated for arr and dp values\\n\\t\\t\\n        for(int i = amm+1; i < dmm; i++)\\n            ret += days[i]; // Days of months between arrival and departure(exclusive)\\n        \\n        if(amm == dmm) // If arrival and departure in the same month, day difference is departure - arrival\\n            ret += (ddd-add);\\n        \\n        else // If arrival and departure in different months, day difference is number of days remaining in the arrival month + departure date\\n        {\\n            ret += days[amm]-add;\\n            ret += ddd;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601983,
                "title": "very-easy-question-visual-explanation-100",
                "content": "This problem is very easy to understand. Just think it deeply and you will surely understand the working. Below I have discussed it in very easy steps.\\n\\n![image](https://assets.leetcode.com/users/images/3d5fd148-7390-47d6-a542-068201b541d6_1663689554.302706.jpeg)\\n\\n**Steps:**\\n* As you can see in the above image, I have marked **circles on 16 Aug (arrive) and 18 Aug(Leave)**.\\n* This is because Bob arrived late, so Alice and Bob will meet late on 16 Aug, or we can say that **take the max from the arrival** of Alice and Bob and store it on the ***start*** variable.\\n* And, Alice has left the place earlier, so their last meet up will be on 18 Aug or we can say that **take the min from their leave** and store it on ***end*** variable.\\n* Now, by using some common sense, we have to\\xA0find the answer, since we have ***start*** and ***end***.\\xA0\\n\\n**Code:**\\n```\\nclass Solution:\\n    def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:\\n        months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        start = max(arAl, arBo)\\n        end = min(lAl, lBo)\\n\\n        startDay = int(start[3:])\\n        startMonth = int(start[:2])\\n        endDay = int(end[3:])\\n        endMonth = int(end[:2])\\n        \\n        if start > end:\\n            return 0\\n        if startMonth == endMonth:\\n            return endDay-startDay+1\\n        elif startMonth < endMonth:\\n            return months[startMonth]-startDay + endDay + 1 + sum(months[m] for m in range(startMonth+1, endMonth))\\n```\\n\\nCheck out: [https://github.com/Iamtripathisatyam](https://github.com/Iamtripathisatyam)\\nThanks to @lcshiung",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:\\n        months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        start = max(arAl, arBo)\\n        end = min(lAl, lBo)\\n\\n        startDay = int(start[3:])\\n        startMonth = int(start[:2])\\n        endDay = int(end[3:])\\n        endMonth = int(end[:2])\\n        \\n        if start > end:\\n            return 0\\n        if startMonth == endMonth:\\n            return endDay-startDay+1\\n        elif startMonth < endMonth:\\n            return months[startMonth]-startDay + endDay + 1 + sum(months[m] for m in range(startMonth+1, endMonth))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593566,
                "title": "c-day-of-year-clean-code",
                "content": "### Solution 1: day of year\\n\\nWe convert each event into \"day of the year\" using a prefixsum for the days in the months before. Then we compute the day when the earlier of the two leaves and subtract from that the day when the later of the day arrieves.\\n\\n```\\n    static int dayOfYear(int m, int d) {\\n        constexpr array<int, 12> dm = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        return dm[m - 1] + d;\\n    }\\n    \\n    static int dayOfYear(const string& mmdd) {\\n        return dayOfYear(stoi(mmdd.substr(0, 2)), stoi(mmdd.substr(3, 2)));\\n    }\\n\\n    static int countDaysTogether(const string& arriveAlice, const string& leaveAlice,\\n                                 const string& arriveBob, const string& leaveBob) {\\n        const int aa = dayOfYear(arriveAlice);\\n        const int al = dayOfYear(leaveAlice);\\n        const int ba = dayOfYear(arriveBob);\\n        const int bl = dayOfYear(leaveBob);\\n        return max(0, min(al, bl) - max(aa, ba) + 1);\\n    }\\n```\\t\\n\\n_As always: Feedback, comments, and questions are welcome. Please upvote if you like the solution._",
                "solutionTags": [],
                "code": "```\\n    static int dayOfYear(int m, int d) {\\n        constexpr array<int, 12> dm = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        return dm[m - 1] + d;\\n    }\\n    \\n    static int dayOfYear(const string& mmdd) {\\n        return dayOfYear(stoi(mmdd.substr(0, 2)), stoi(mmdd.substr(3, 2)));\\n    }\\n\\n    static int countDaysTogether(const string& arriveAlice, const string& leaveAlice,\\n                                 const string& arriveBob, const string& leaveBob) {\\n        const int aa = dayOfYear(arriveAlice);\\n        const int al = dayOfYear(leaveAlice);\\n        const int ba = dayOfYear(arriveBob);\\n        const int bl = dayOfYear(leaveBob);\\n        return max(0, min(al, bl) - max(aa, ba) + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588418,
                "title": "java-with-zero-maths-simple-if-else-easy-to-read",
                "content": "```\\nclass Solution {\\n  // we create  the date is nth day of the year then we simply subtract the problem to intersection part of both or independent to each other\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arr [] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int month[] = new int[arr.length+1];\\n        for(int i=1;i<month.length;i++){\\n            month[i] = month[i-1] + arr[i-1];\\n        }\\n        \\n \\n        String [] sarri = arriveAlice.split(\"-\");\\n        String [] sarrib = arriveBob.split(\"-\");\\n        String [] sle = leaveAlice.split(\"-\");\\n        String [] sleb = leaveBob.split(\"-\");\\n        \\n        int arri[] = new int[2];\\n        int arrib[] = new int[2];\\n        int le[] = new int[2];\\n        int leb[] = new int[2];\\n        for (int i = 0; i < arri.length; i++) {\\n            arri[i] = Integer.parseInt(sarri[i]);\\n            arrib[i] = Integer.parseInt(sarrib[i]);\\n            le[i] = Integer.parseInt(sle[i]);\\n            leb[i] = Integer.parseInt(sleb[i]);\\n        }\\n       \\n        \\n        int daa = month[arri[0]-1] + arri[1];\\n        int dab = month[arrib[0]-1] + arrib[1];\\n        int dla = month[le[0]-1] + le[1];\\n        int dlb = month[leb[0]-1] + leb[1];\\n        \\n//         System.out.println(daa + \" \" + dla);\\n//         System.out.println(dab + \" \"  + dlb);\\n        if(daa==dlb&&dab==dla){\\n            return 1;\\n        }\\n        else if(daa>=dlb||dab>=dla){\\n            return 0;\\n        }\\n        else if(dab<daa&&dlb>dla){\\n            return dla - daa +1;\\n        }\\n        else if(daa<dab&&dla>dlb){\\n             return dlb - dab +1;\\n        }\\n        else{\\n            if(dla > dlb){\\n                return dlb - daa + 1;\\n            }\\n            else{\\n                return dla - dab + 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  // we create  the date is nth day of the year then we simply subtract the problem to intersection part of both or independent to each other\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arr [] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int month[] = new int[arr.length+1];\\n        for(int i=1;i<month.length;i++){\\n            month[i] = month[i-1] + arr[i-1];\\n        }\\n        \\n \\n        String [] sarri = arriveAlice.split(\"-\");\\n        String [] sarrib = arriveBob.split(\"-\");\\n        String [] sle = leaveAlice.split(\"-\");\\n        String [] sleb = leaveBob.split(\"-\");\\n        \\n        int arri[] = new int[2];\\n        int arrib[] = new int[2];\\n        int le[] = new int[2];\\n        int leb[] = new int[2];\\n        for (int i = 0; i < arri.length; i++) {\\n            arri[i] = Integer.parseInt(sarri[i]);\\n            arrib[i] = Integer.parseInt(sarrib[i]);\\n            le[i] = Integer.parseInt(sle[i]);\\n            leb[i] = Integer.parseInt(sleb[i]);\\n        }\\n       \\n        \\n        int daa = month[arri[0]-1] + arri[1];\\n        int dab = month[arrib[0]-1] + arrib[1];\\n        int dla = month[le[0]-1] + le[1];\\n        int dlb = month[leb[0]-1] + leb[1];\\n        \\n//         System.out.println(daa + \" \" + dla);\\n//         System.out.println(dab + \" \"  + dlb);\\n        if(daa==dlb&&dab==dla){\\n            return 1;\\n        }\\n        else if(daa>=dlb||dab>=dla){\\n            return 0;\\n        }\\n        else if(dab<daa&&dlb>dla){\\n            return dla - daa +1;\\n        }\\n        else if(daa<dab&&dla>dlb){\\n             return dlb - dab +1;\\n        }\\n        else{\\n            if(dla > dlb){\\n                return dlb - daa + 1;\\n            }\\n            else{\\n                return dla - dab + 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587959,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int month[13]={0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int x=month[(arriveAlice[0]-\\'0\\')*10+(arriveAlice[1]-\\'0\\')-1]+(arriveAlice[3]-\\'0\\')*10+(arriveAlice[4]-\\'0\\');\\n        int y=month[(leaveAlice[0]-\\'0\\')*10+(leaveAlice[1]-\\'0\\')-1]+(leaveAlice[3]-\\'0\\')*10+(leaveAlice[4]-\\'0\\');\\n        int a=month[(arriveBob[0]-\\'0\\')*10+(arriveBob[1]-\\'0\\')-1]+(arriveBob[3]-\\'0\\')*10+(arriveBob[4]-\\'0\\');\\n        int b=month[(leaveBob[0]-\\'0\\')*10+(leaveBob[1]-\\'0\\')-1]+(leaveBob[3]-\\'0\\')*10+(leaveBob[4]-\\'0\\');\\n        int k=min(y,b)-max(x,a)+1;\\n        return k<0?0:k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int month[13]={0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int x=month[(arriveAlice[0]-\\'0\\')*10+(arriveAlice[1]-\\'0\\')-1]+(arriveAlice[3]-\\'0\\')*10+(arriveAlice[4]-\\'0\\');\\n        int y=month[(leaveAlice[0]-\\'0\\')*10+(leaveAlice[1]-\\'0\\')-1]+(leaveAlice[3]-\\'0\\')*10+(leaveAlice[4]-\\'0\\');\\n        int a=month[(arriveBob[0]-\\'0\\')*10+(arriveBob[1]-\\'0\\')-1]+(arriveBob[3]-\\'0\\')*10+(arriveBob[4]-\\'0\\');\\n        int b=month[(leaveBob[0]-\\'0\\')*10+(leaveBob[1]-\\'0\\')-1]+(leaveBob[3]-\\'0\\')*10+(leaveBob[4]-\\'0\\');\\n        int k=min(y,b)-max(x,a)+1;\\n        return k<0?0:k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698314,
                "title": "java-using-standard-time-libraries",
                "content": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        String start = arriveAlice.compareTo(arriveBob) < 0 ? arriveBob : arriveAlice;\\n        String end = leaveAlice.compareTo(leaveBob) < 0 ? leaveAlice : leaveBob;\\n\\n        LocalDate startDate = toLocalDate(start), endDate = toLocalDate(end);\\n\\n        return startDate.isAfter(endDate) ? 0 : (int) ChronoUnit.DAYS.between(startDate, endDate) + 1;\\n    }\\n\\n    private LocalDate toLocalDate(String date) {\\n        return LocalDate.of(2022,Integer.parseInt(date.substring(0, 2)), Integer.parseInt(date.substring(3)));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        String start = arriveAlice.compareTo(arriveBob) < 0 ? arriveBob : arriveAlice;\\n        String end = leaveAlice.compareTo(leaveBob) < 0 ? leaveAlice : leaveBob;\\n\\n        LocalDate startDate = toLocalDate(start), endDate = toLocalDate(end);\\n\\n        return startDate.isAfter(endDate) ? 0 : (int) ChronoUnit.DAYS.between(startDate, endDate) + 1;\\n    }\\n\\n    private LocalDate toLocalDate(String date) {\\n        return LocalDate.of(2022,Integer.parseInt(date.substring(0, 2)), Integer.parseInt(date.substring(3)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608644,
                "title": "c-easy-to-understand",
                "content": "* Converting String of arrival and departure into equivalent Number from 365 day \\n* Then simply calculating difference \\nLike Min (a2 , b2) means who is leaving first \\nand Max (a1 , b1) means who is coming after \\nand difference between both number is ans \\n```\\nclass Solution {\\nvector<int> month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\npublic:\\n\\t int convert(string s) {\\n        int  cnt=0;\\n\\t\\tint mnt=stoi(s.substr(0, 2))-1, d = stoi(s.substr(3, 2));\\n\\t\\tfor (int i = 0; i < mnt; i++)\\n\\t\\t{\\n\\t\\t\\tcnt += month[i];\\n\\t\\t}\\n\\t\\tcnt+=d;\\n\\t\\treturn cnt;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\t\\tint a1=convert(arriveAlice),a2=convert(leaveAlice),b1=convert(arriveBob),b2=convert(leaveBob);\\n\\t\\tint ans= (min(a2, b2)) - (max(a1, b1)) + 1;\\n\\t\\tif (ans < 0)\\n\\t\\t{\\n\\t\\t\\tans = 0;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nvector<int> month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\npublic:\\n\\t int convert(string s) {\\n        int  cnt=0;\\n\\t\\tint mnt=stoi(s.substr(0, 2))-1, d = stoi(s.substr(3, 2));\\n\\t\\tfor (int i = 0; i < mnt; i++)\\n\\t\\t{\\n\\t\\t\\tcnt += month[i];\\n\\t\\t}\\n\\t\\tcnt+=d;\\n\\t\\treturn cnt;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\t\\tint a1=convert(arriveAlice),a2=convert(leaveAlice),b1=convert(arriveBob),b2=convert(leaveBob);\\n\\t\\tint ans= (min(a2, b2)) - (max(a1, b1)) + 1;\\n\\t\\tif (ans < 0)\\n\\t\\t{\\n\\t\\t\\tans = 0;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600563,
                "title": "the-most-easiest-soln-of-this-problem-java",
                "content": "```\\n    public int countDaysTogether(String aa, String la, String ab, String lb) {\\n        int a[]= new int[]{0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i=1;i<a.length;i++) a[i]+=a[i-1];\\n        \\n        int aA = a[Integer.parseInt(aa.substring(0,2))-1] +Integer.parseInt(aa.substring(3,5));\\n        int lA = a[Integer.parseInt(la.substring(0,2))-1] +Integer.parseInt(la.substring(3,5));\\n        int aB = a[Integer.parseInt(ab.substring(0,2))-1] +Integer.parseInt(ab.substring(3,5));\\n        int lB = a[Integer.parseInt(lb.substring(0,2))-1] +Integer.parseInt(lb.substring(3,5));\\n        \\n      return Math.max(Math.min(lA,lB) - Math.max(aA,aB) + 1,0);        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n    public int countDaysTogether(String aa, String la, String ab, String lb) {\\n        int a[]= new int[]{0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i=1;i<a.length;i++) a[i]+=a[i-1];\\n        \\n        int aA = a[Integer.parseInt(aa.substring(0,2))-1] +Integer.parseInt(aa.substring(3,5));\\n        int lA = a[Integer.parseInt(la.substring(0,2))-1] +Integer.parseInt(la.substring(3,5));\\n        int aB = a[Integer.parseInt(ab.substring(0,2))-1] +Integer.parseInt(ab.substring(3,5));\\n        int lB = a[Integer.parseInt(lb.substring(0,2))-1] +Integer.parseInt(lb.substring(3,5));\\n        \\n      return Math.max(Math.min(lA,lB) - Math.max(aA,aB) + 1,0);        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594103,
                "title": "python3-dict-6-lines-w-explan-t-m-32-ms-13-4-mb",
                "content": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #\\n                        # 1) Change each date string to the integer day-of-the-year\\n                        #    1a. split the month and day of the month;\\n                        #    1b. use the dict to determine the days in previous months;\\n                        #    1c. add the integer in 1b. to the days in the month.\\n                        #    \\n                        # 2) Determine the overlap (if any) for their respective leave and arrive dates\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n\\n        d = {1:0,   2:31,  3:59,   4:90,   5:120,  6:151,           # <-- 1b.\\n             7:181, 8:212, 9:243, 10:273, 11:304, 12:334}\\n\\n        def days(date):\\n            mon, day = date.split(\\'-\\')                              # <-- 1a.      \\n            return d[int(mon)]+int(day)                             # <-- 1c.\\n\\n        arrive, leave = (max(days(arriveAlice),days(arriveBob)),    # <-- 2).\\n                         min(days(leaveAlice ),days(leaveBob )))\\n        \\n        return  max(leave-arrive+1,0)",
                "solutionTags": [],
                "code": "class Solution:         # Here\\'s the plan:\\n                        #\\n                        # 1) Change each date string to the integer day-of-the-year\\n                        #    1a. split the month and day of the month;\\n                        #    1b. use the dict to determine the days in previous months;\\n                        #    1c. add the integer in 1b. to the days in the month.\\n                        #    \\n                        # 2) Determine the overlap (if any) for their respective leave and arrive dates\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n\\n        d = {1:0,   2:31,  3:59,   4:90,   5:120,  6:151,           # <-- 1b.\\n             7:181, 8:212, 9:243, 10:273, 11:304, 12:334}",
                "codeTag": "Java"
            },
            {
                "id": 2592385,
                "title": "c-explained-logic-two-approach",
                "content": "**LOGIC:**\\n* days overlap of Alice(a) and Bob(b)\\'s stay is the duration between whoever came late and left first.\\n* If someone already left before other\\'s arrival then there will be no overlap.\\n\\n```\\nwe need to convert date into day\\n\\teg; 01-15 is 15th day of the year.\\n\\teg. 02-12 = days in [month - 1] + 15 \\n\\t\\t\\t  = days [january] + 15 \\n\\t\\t      = 31 + 15 = 46th day of year. \\n```\\n\\n**Approach 1**\\n\\n```\\nclass Solution {\\npublic:\\n    int calendar[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int convertToDay (string s)\\n    {\\n        int month = (s[0] - \\'0\\') * 10 + (s[1] - \\'0\\'); //eg \"12\" == 1 * 10 + 2\\n        int day = (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n        \\n        //count total no. of day\\n        while (--month) //decrementing month first coz we don\\'t want to add current month\\'s days eg: (01-12), it\\'s 12th day of year not 31+12th!\\n        {\\n            day += calendar[month];\\n        }\\n        return day;\\n    }\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        \\n        string lastArrive = max(aa, ab);\\n        string firstLeave = min(la, lb);\\n        \\n        if (lastArrive > firstLeave) return 0; \\n        \\n        int arrival = convertToDay(a); \\n        int departure = convertToDay(l);\\n        \\n        return (departure - arrival) + 1; //+1 coz of inclusive\\n    }\\n};\\n```\\n\\n**Approach 2:** \\nsame logic just using presum and stl\\n\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        int month[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        //presum\\n        for (int i = 1; i < 13; i++)\\n            month[i] += month[i-1];\\n        \\n        string a = max(aa, ab);\\n        string l = min(la, lb);\\n        \\n        if (a > l)\\n            return 0; \\n        \\n        int arrival = month[stoi(a.substr(0,2)) - 1] + stoi(a.substr(3)); //month->days + day\\n        int departure = month[stoi(l.substr(0,2)) - 1] + stoi(l.substr(3)) ; \\n        \\n        return (departure - arrival + 1);\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nwe need to convert date into day\\n\\teg; 01-15 is 15th day of the year.\\n\\teg. 02-12 = days in [month - 1] + 15 \\n\\t\\t\\t  = days [january] + 15 \\n\\t\\t      = 31 + 15 = 46th day of year. \\n```\n```\\nclass Solution {\\npublic:\\n    int calendar[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int convertToDay (string s)\\n    {\\n        int month = (s[0] - \\'0\\') * 10 + (s[1] - \\'0\\'); //eg \"12\" == 1 * 10 + 2\\n        int day = (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n        \\n        //count total no. of day\\n        while (--month) //decrementing month first coz we don\\'t want to add current month\\'s days eg: (01-12), it\\'s 12th day of year not 31+12th!\\n        {\\n            day += calendar[month];\\n        }\\n        return day;\\n    }\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        \\n        string lastArrive = max(aa, ab);\\n        string firstLeave = min(la, lb);\\n        \\n        if (lastArrive > firstLeave) return 0; \\n        \\n        int arrival = convertToDay(a); \\n        int departure = convertToDay(l);\\n        \\n        return (departure - arrival) + 1; //+1 coz of inclusive\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590798,
                "title": "c-easy-to-understand-100",
                "content": "```\\nint countDaysTogether(string aA, string lA, string aB, string lB) {\\n        int aam = 10*(aA[0]-\\'0\\')+(aA[1]-\\'0\\');\\n        int aad = 10*(aA[3]-\\'0\\')+(aA[4]-\\'0\\');\\n        \\n        int alm = 10*(lA[0]-\\'0\\')+(lA[1]-\\'0\\');\\n        int ald = 10*(lA[3]-\\'0\\')+(lA[4]-\\'0\\');\\n        \\n        int bam = 10*(aB[0]-\\'0\\')+(aB[1]-\\'0\\');\\n        int bad = 10*(aB[3]-\\'0\\')+(aB[4]-\\'0\\');\\n        \\n        int blm = 10*(lB[0]-\\'0\\')+(lB[1]-\\'0\\');\\n        int bld = 10*(lB[3]-\\'0\\')+(lB[4]-\\'0\\');\\n        \\n        cout<<aam<<\" \"<<alm<<endl;\\n        cout<<bam<<\" \"<<blm<<endl;\\n\\n        int arr[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 }; \\n         \\n        int AA = arr[aam-1] + aad;\\n        int AL = arr[alm-1] + ald;\\n        \\n        int BA = arr[bam-1] + bad;\\n        int BL = arr[blm-1] + bld;\\n        int count = 0;\\n        if(AA<=BA){\\n            while(BA<=BL && BA<=AL){\\n                count++;\\n                BA++;\\n            }\\n        }else if(BA<=AA){\\n            while(AA<=AL && AA<=BL){\\n                AA++;\\n                count++;\\n            }\\n        }\\n        return count;      \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countDaysTogether(string aA, string lA, string aB, string lB) {\\n        int aam = 10*(aA[0]-\\'0\\')+(aA[1]-\\'0\\');\\n        int aad = 10*(aA[3]-\\'0\\')+(aA[4]-\\'0\\');\\n        \\n        int alm = 10*(lA[0]-\\'0\\')+(lA[1]-\\'0\\');\\n        int ald = 10*(lA[3]-\\'0\\')+(lA[4]-\\'0\\');\\n        \\n        int bam = 10*(aB[0]-\\'0\\')+(aB[1]-\\'0\\');\\n        int bad = 10*(aB[3]-\\'0\\')+(aB[4]-\\'0\\');\\n        \\n        int blm = 10*(lB[0]-\\'0\\')+(lB[1]-\\'0\\');\\n        int bld = 10*(lB[3]-\\'0\\')+(lB[4]-\\'0\\');\\n        \\n        cout<<aam<<\" \"<<alm<<endl;\\n        cout<<bam<<\" \"<<blm<<endl;\\n\\n        int arr[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 }; \\n         \\n        int AA = arr[aam-1] + aad;\\n        int AL = arr[alm-1] + ald;\\n        \\n        int BA = arr[bam-1] + bad;\\n        int BL = arr[blm-1] + bld;\\n        int count = 0;\\n        if(AA<=BA){\\n            while(BA<=BL && BA<=AL){\\n                count++;\\n                BA++;\\n            }\\n        }else if(BA<=AA){\\n            while(AA<=AL && AA<=BL){\\n                AA++;\\n                count++;\\n            }\\n        }\\n        return count;      \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2588315,
                "title": "easy-and-concise-code",
                "content": "**Idea:** Just try to find day ranges in 365 days for both alice and bob and find length of overlapping interval (that is arriving day and leaving day in between 1 and 365)\\n```\\npair<int,int> dm(string x)\\n{\\n    \\n    string s = x.substr(0,2);   // find month\\n    string p = x.substr(3,2);  // find day \\n    \\n    int a = stoi(s);  \\n    int b = stoi(p);\\n    \\n    return {a,b};  \\n     \\n}\\npair<int,int> count(pair<int,int>a,pair<int,int>b)\\n{\\n        int pre[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i=1;i<=12;i++)  // store days till ith month\\n            pre[i]+=pre[i-1];  \\n             // arriving day no. b/w 1 to 365\\n        int start =      pre[a.first-1]+a.second+1;  //  days till (a.first-1)th month and a.seocnd days of a.first                                                                          // month\\n          // leaving day b/w 1 to 365\\n       int end = pre[b.first-1]+b.second+1;     // | | ly days till (b.first-1)th month and a.seocnd days of                                                                            //  b.first month\\n    \\n       return {start,end};  \\n    \\n}    \\n    \\n\\n\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string a, string b, string x, string y) \\n    {\\n       \\n         auto  l1 = dm(a);  // split arriving day and month for alice\\n         auto l2 = dm(b);  //  split leaving day and month for alice\\n         auto  l3 = dm(x);  // split arriving day and month for bob\\n         auto l4 = dm(y);  // split leaving day and month for bob\\n\\t\\t \\n         auto xx = count(l1,l2);  // range of days for alice\\n        \\n         auto yy = count(l3,l4);  // range of days for bob\\n        \\n\\t\\t// find the overlapping interval\\n        int left = max(xx.first,yy.first);\\n        int right = min(xx.second,yy.second);\\n        if(right-left+1>0)\\n        return right-left+1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npair<int,int> dm(string x)\\n{\\n    \\n    string s = x.substr(0,2);   // find month\\n    string p = x.substr(3,2);  // find day \\n    \\n    int a = stoi(s);  \\n    int b = stoi(p);\\n    \\n    return {a,b};  \\n     \\n}\\npair<int,int> count(pair<int,int>a,pair<int,int>b)\\n{\\n        int pre[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        for(int i=1;i<=12;i++)  // store days till ith month\\n            pre[i]+=pre[i-1];  \\n             // arriving day no. b/w 1 to 365\\n        int start =      pre[a.first-1]+a.second+1;  //  days till (a.first-1)th month and a.seocnd days of a.first                                                                          // month\\n          // leaving day b/w 1 to 365\\n       int end = pre[b.first-1]+b.second+1;     // | | ly days till (b.first-1)th month and a.seocnd days of                                                                            //  b.first month\\n    \\n       return {start,end};  \\n    \\n}    \\n    \\n\\n\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string a, string b, string x, string y) \\n    {\\n       \\n         auto  l1 = dm(a);  // split arriving day and month for alice\\n         auto l2 = dm(b);  //  split leaving day and month for alice\\n         auto  l3 = dm(x);  // split arriving day and month for bob\\n         auto l4 = dm(y);  // split leaving day and month for bob\\n\\t\\t \\n         auto xx = count(l1,l2);  // range of days for alice\\n        \\n         auto yy = count(l3,l4);  // range of days for bob\\n        \\n\\t\\t// find the overlapping interval\\n        int left = max(xx.first,yy.first);\\n        int right = min(xx.second,yy.second);\\n        if(right-left+1>0)\\n        return right-left+1;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588235,
                "title": "c-solution",
                "content": "```\\npublic int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        var result = 0;\\n\\n        var arriveAliceDate = DateTime.Parse(arriveAlice);\\n        var leaveAliceDate = DateTime.Parse(leaveAlice);\\n        var arriveBobDate = DateTime.Parse(arriveBob);\\n        var leaveBobDate = DateTime.Parse(leaveBob);\\n\\n        var date = arriveAliceDate;\\n        while (date <= leaveAliceDate)\\n        {\\n            if (date >= arriveBobDate && date <= leaveBobDate)\\n            {\\n                result++;\\n            }\\n\\n            date = date.AddDays(1);\\n        }\\n\\n        return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        var result = 0;\\n\\n        var arriveAliceDate = DateTime.Parse(arriveAlice);\\n        var leaveAliceDate = DateTime.Parse(leaveAlice);\\n        var arriveBobDate = DateTime.Parse(arriveBob);\\n        var leaveBobDate = DateTime.Parse(leaveBob);\\n\\n        var date = arriveAliceDate;\\n        while (date <= leaveAliceDate)\\n        {\\n            if (date >= arriveBobDate && date <= leaveBobDate)\\n            {\\n                result++;\\n            }\\n\\n            date = date.AddDays(1);\\n        }\\n\\n        return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588123,
                "title": "c-easy-to-understand-brute-force",
                "content": "Create a 2D matrix for calender and count the overlapping days\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int days[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int count[13][32];                               //2D matrix to count the overlapping days\\n    \\n    void fillday(int am,int ad,int lm,int ld)\\n    {\\n        if(am==lm)                                   //if arrival and leaving month is same \\n        {\\n            for(int d=ad;d<=ld;d++)\\n                count[am][d]++;\\n            return;\\n        }   \\n        for(int d=ad;d<=days[am-1];d++)              //for arriavl month\\n            count[am][d]++;\\n        for(int m=am+1;m<lm;m++)                     //for months after arrival and before leaving\\n            for(int d=1;d<=days[m-1];d++)            //for all days in that month\\n                count[m][d]++;\\n        for(int d=1;d<=ld;d++)                       //for leaving month\\n            count[lm][d]++;\\n    }\\n    int countDaysTogether(string aa, string la, string ab, string lb) \\n    {\\n        int aam=stoi(aa.substr(0,2)),aad=stoi(aa.substr(3,2)),lam=stoi(la.substr(0,2)),lad=stoi(la.substr(3,2));\\n        int abm=stoi(ab.substr(0,2)),abd=stoi(ab.substr(3,2)),lbm=stoi(lb.substr(0,2)),lbd=stoi(lb.substr(3,2));\\n        int ans=0;\\n        memset(count,0,sizeof(count));\\n        fillday(aam,aad,lam,lad);                    //filling days for Alice\\n        fillday(abm,abd,lbm,lbd);                    //filling days for Bob\\n        \\n        for(int m=1;m<13;m++)\\n            for(int d=1;d<=31;d++)\\n                if(count[m][d]==2)  ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int days[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int count[13][32];                               //2D matrix to count the overlapping days\\n    \\n    void fillday(int am,int ad,int lm,int ld)\\n    {\\n        if(am==lm)                                   //if arrival and leaving month is same \\n        {\\n            for(int d=ad;d<=ld;d++)\\n                count[am][d]++;\\n            return;\\n        }   \\n        for(int d=ad;d<=days[am-1];d++)              //for arriavl month\\n            count[am][d]++;\\n        for(int m=am+1;m<lm;m++)                     //for months after arrival and before leaving\\n            for(int d=1;d<=days[m-1];d++)            //for all days in that month\\n                count[m][d]++;\\n        for(int d=1;d<=ld;d++)                       //for leaving month\\n            count[lm][d]++;\\n    }\\n    int countDaysTogether(string aa, string la, string ab, string lb) \\n    {\\n        int aam=stoi(aa.substr(0,2)),aad=stoi(aa.substr(3,2)),lam=stoi(la.substr(0,2)),lad=stoi(la.substr(3,2));\\n        int abm=stoi(ab.substr(0,2)),abd=stoi(ab.substr(3,2)),lbm=stoi(lb.substr(0,2)),lbd=stoi(lb.substr(3,2));\\n        int ans=0;\\n        memset(count,0,sizeof(count));\\n        fillday(aam,aad,lam,lad);                    //filling days for Alice\\n        fillday(abm,abd,lbm,lbd);                    //filling days for Bob\\n        \\n        for(int m=1;m<13;m++)\\n            for(int d=1;d<=31;d++)\\n                if(count[m][d]==2)  ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588061,
                "title": "simple-c-ans-with-explanation",
                "content": "Okay, I know this question is bit frustating but let me try to help you!\\n\\nSolution-\\nFind who arrived later between bob and alice and who departed first.\\nThis daysPassed function is calculating the number of days from the starting of the year.\\n\\nThe difference between those is our ans, and I\\'m adding 1 because days are inclusive (what if both of them arrived the same day? )\\n```\\nclass Solution {\\npublic:\\n    int daysPassed(string date){\\n        int M = stoi(date.substr(0,2));\\n        int D = stoi(date.substr(3,2));\\n        vector<int>days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i = 1; i<M; i++){\\n            D += days[i];\\n        }\\n        return D;\\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int ans = 0;\\n        int day1 = max(daysPassed(arriveAlice),daysPassed(arriveBob) );\\n        int day2 = min(daysPassed(leaveAlice),daysPassed(leaveBob));\\n        ans = (day2 - day1 + 1);\\n        if(ans > 0) return ans;\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int daysPassed(string date){\\n        int M = stoi(date.substr(0,2));\\n        int D = stoi(date.substr(3,2));\\n        vector<int>days = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2614279,
                "title": "c-calculate-the-day-number-from-the-date",
                "content": "```\\nclass Solution {\\npublic:\\n    int calDays(string s,vector<int>& pref){\\n        int a=stoi(s.substr(0,2));\\n        int b=stoi(s.substr(3));\\n        if(a==1) return b;\\n        return pref[a-2]+b;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int>months={31,28,31,30,31,30,31,31,30,31,30,31};\\n        vector<int>pref(12);\\n        pref[0]=months[0];\\n        for(int i=1;i<12;i++){\\n            pref[i]=pref[i-1]+months[i];\\n        }\\n\\t\\t\\n        int a=calDays(arriveAlice,pref);\\n        int b=calDays(leaveAlice,pref);\\n        int c=calDays(arriveBob,pref);\\n        int d=calDays(leaveBob,pref);\\n\\t\\t\\n        int ans=min(b,d)-max(a,c)+1;\\n\\t\\t\\n        return ans<0 ? 0: ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calDays(string s,vector<int>& pref){\\n        int a=stoi(s.substr(0,2));\\n        int b=stoi(s.substr(3));\\n        if(a==1) return b;\\n        return pref[a-2]+b;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int>months={31,28,31,30,31,30,31,31,30,31,30,31};\\n        vector<int>pref(12);\\n        pref[0]=months[0];\\n        for(int i=1;i<12;i++){\\n            pref[i]=pref[i-1]+months[i];\\n        }\\n\\t\\t\\n        int a=calDays(arriveAlice,pref);\\n        int b=calDays(leaveAlice,pref);\\n        int c=calDays(arriveBob,pref);\\n        int d=calDays(leaveBob,pref);\\n\\t\\t\\n        int ans=min(b,d)-max(a,c)+1;\\n\\t\\t\\n        return ans<0 ? 0: ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591611,
                "title": "c-easy-to-understand-converted-date-into-days-100-faster",
                "content": "**Solution -->**\\n```\\nclass Solution {\\npublic:\\n    int month[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int convert(string &s)\\n    {\\n        string m, d;\\n        m+=s[0];\\n        m+=s[1];\\n        \\n        d+=s[3];\\n        d+=s[4];\\n        \\n        int cnt=0, mm, dd;\\n        mm= stoi(m);\\n        dd= stoi(d);\\n        \\n        for(int i=0; i<mm; i++)\\n            cnt+=month[i];            \\n        \\n        cnt+=dd;\\n        return cnt;        \\n    }\\n    int countDaysTogether(string aA, string lA, string aB, string lB)\\n    {\\n        int arr1= convert(aA);\\n        int arr2= convert(aB);\\n        int lev1= convert(lA);\\n        int lev2= convert(lB);\\n        \\n        int arr= max(arr1, arr2);\\n        int lev= min(lev1, lev2);\\n        \\n        if(arr>lev)\\n            return 0;\\n        \\n        return lev-arr+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int month[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int convert(string &s)\\n    {\\n        string m, d;\\n        m+=s[0];\\n        m+=s[1];\\n        \\n        d+=s[3];\\n        d+=s[4];\\n        \\n        int cnt=0, mm, dd;\\n        mm= stoi(m);\\n        dd= stoi(d);\\n        \\n        for(int i=0; i<mm; i++)\\n            cnt+=month[i];            \\n        \\n        cnt+=dd;\\n        return cnt;        \\n    }\\n    int countDaysTogether(string aA, string lA, string aB, string lB)\\n    {\\n        int arr1= convert(aA);\\n        int arr2= convert(aB);\\n        int lev1= convert(lA);\\n        int lev2= convert(lB);\\n        \\n        int arr= max(arr1, arr2);\\n        int lev= min(lev1, lev2);\\n        \\n        if(arr>lev)\\n            return 0;\\n        \\n        return lev-arr+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591247,
                "title": "java-easy-to-understand",
                "content": "We need to get the days of the year upto that given date and then compare\\n\\n* We just need to convert the given date to number in year.\\n* For example, \"01-13\" (13th January) represents 13th day in year, \"02-13\" (13th February) represents 44th day in year.\\n* This problem came in Biweekly Contest on 17th September, which is 260th day in year.\\n\\n```\\nclass Solution {\\n    int[] month = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        \\n        int a1 = toDays(arriveAlice);\\n        int a2 = toDays(arriveBob);\\n        \\n        int l1 = toDays(leaveAlice);\\n        int l2 = toDays(leaveBob);\\n        \\n        int arr = Math.max(a1, a2);\\n        int lev = Math.min(l1, l2);\\n        \\n        if(arr > lev)\\n            return 0;\\n        else\\n            return lev-arr+1;\\n    }\\n    \\n    public int toDays(String s){\\n        \\n        int m = (s.charAt(0)-\\'0\\')*10 + s.charAt(1)-\\'0\\';\\n        int d = (s.charAt(3)-\\'0\\')*10 + s.charAt(4)-\\'0\\';\\n        \\n        m--;\\n        while(m > 0){\\n            d += month[m];\\n            m--;\\n        }\\n        return d;\\n    }\\n}\\n```\\n\\nwas near to the solution but still failed, \\nresolved by blocker from https://leetcode.com/problems/count-days-spent-together/discuss/2587981/C++-or-Convert-Date-to-Number-in-Year-or-Explaination",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] month = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        \\n        int a1 = toDays(arriveAlice);\\n        int a2 = toDays(arriveBob);\\n        \\n        int l1 = toDays(leaveAlice);\\n        int l2 = toDays(leaveBob);\\n        \\n        int arr = Math.max(a1, a2);\\n        int lev = Math.min(l1, l2);\\n        \\n        if(arr > lev)\\n            return 0;\\n        else\\n            return lev-arr+1;\\n    }\\n    \\n    public int toDays(String s){\\n        \\n        int m = (s.charAt(0)-\\'0\\')*10 + s.charAt(1)-\\'0\\';\\n        int d = (s.charAt(3)-\\'0\\')*10 + s.charAt(4)-\\'0\\';\\n        \\n        m--;\\n        while(m > 0){\\n            d += month[m];\\n            m--;\\n        }\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589459,
                "title": "python-elegant-short-built-in-date",
                "content": "\\tfrom datetime import date\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(1)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef countDaysTogether(self, arrive_alice: str, leave_alice: str, arrive_bob: str, leave_bob: str) -> int:\\n\\t\\t\\tstart = max(self.to_date(arrive_alice), self.to_date(arrive_bob))\\n\\t\\t\\tend = min(self.to_date(leave_alice), self.to_date(leave_bob))\\n\\t\\t\\treturn max((end - start).days + 1, 0)\\n\\n\\t\\t@staticmethod\\n\\t\\tdef to_date(month_day: str) -> date:\\n\\t\\t\\treturn date(2001, *map(int, month_day.split(\\'-\\')))\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tfrom datetime import date\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(1)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef countDaysTogether(self, arrive_alice: str, leave_alice: str, arrive_bob: str, leave_bob: str) -> int:\\n\\t\\t\\tstart = max(self.to_date(arrive_alice), self.to_date(arrive_bob))\\n\\t\\t\\tend = min(self.to_date(leave_alice), self.to_date(leave_bob))\\n\\t\\t\\treturn max((end - start).days + 1, 0)\\n\\n\\t\\t@staticmethod\\n\\t\\tdef to_date(month_day: str) -> date:\\n\\t\\t\\treturn date(2001, *map(int, month_day.split(\\'-\\')))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2589333,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    \\n    const DAYS_IN_MONTHS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n    \\n    const arrivalDAlice = [parseInt(arriveAlice.substring(0,3)), parseInt(arriveAlice.substring(3,5))]\\n    const arrivalDBob = [parseInt(arriveBob.substring(0,3)), parseInt(arriveBob.substring(3,5))]\\n    \\n    const leaveDAlice = [parseInt(leaveAlice.substring(0,3)), parseInt(leaveAlice.substring(3,5))]\\n    const leaveDBob = [parseInt(leaveBob.substring(0,3)), parseInt(leaveBob.substring(3,5))]\\n    \\n    let bothArrivedDate = -1, bothArrivedMonth = -1;\\n    let bothLeavingDate = -1, bothLeavingMonth = -1;\\n    \\n    // Coming in same month     \\n    if(arrivalDAlice[0] === arrivalDBob[0]){\\n            [bothArrivedDate, bothArrivedMonth] = arrivalDAlice[1] > arrivalDBob[1] ? \\n            [arrivalDAlice[1], arrivalDAlice[0]] : [arrivalDBob[1],arrivalDBob[0]];\\n    }else{\\n         [bothArrivedDate, bothArrivedMonth] = arrivalDAlice[0] > arrivalDBob[0] ? \\n                [arrivalDAlice[1], arrivalDAlice[0]] : [arrivalDBob[1],arrivalDBob[0]];\\n    }\\n    \\n    // leaving date and month    \\n    if(leaveDAlice[0] === leaveDBob[0]){\\n            [bothLeavingDate, bothLeavingMonth] = leaveDAlice[1] < leaveDBob[1] ? \\n            [leaveDAlice[1], leaveDAlice[0]] : [leaveDBob[1],leaveDBob[0]];\\n    }else{\\n         [bothLeavingDate, bothLeavingMonth] = leaveDAlice[0] < leaveDBob[0] ? \\n                [leaveDAlice[1], leaveDAlice[0]] : [leaveDBob[1],leaveDBob[0]];\\n    }\\n   \\n    if(bothLeavingMonth === bothArrivedMonth) \\n    {       \\n        const totalDaysTogether = (bothLeavingDate - bothArrivedDate) + 1\\n        return  totalDaysTogether > 0 ? totalDaysTogether : 0;\\n    }\\n    \\n    if(bothLeavingMonth < bothArrivedMonth) return 0\\n    \\n    \\n    // last case when they come in n month and leave in m month\\n    \\n    let totalDaysTogether = DAYS_IN_MONTHS[bothArrivedMonth - 1] - bothArrivedDate + 1 + bothLeavingDate\\n\\n    \\n    for(let i = bothArrivedMonth;  i < bothLeavingMonth - 1; i++ ) {\\n        totalDaysTogether += DAYS_IN_MONTHS[i]\\n    }\\n    \\n    \\n    return totalDaysTogether\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    \\n    const DAYS_IN_MONTHS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n    \\n    const arrivalDAlice = [parseInt(arriveAlice.substring(0,3)), parseInt(arriveAlice.substring(3,5))]\\n    const arrivalDBob = [parseInt(arriveBob.substring(0,3)), parseInt(arriveBob.substring(3,5))]\\n    \\n    const leaveDAlice = [parseInt(leaveAlice.substring(0,3)), parseInt(leaveAlice.substring(3,5))]\\n    const leaveDBob = [parseInt(leaveBob.substring(0,3)), parseInt(leaveBob.substring(3,5))]\\n    \\n    let bothArrivedDate = -1, bothArrivedMonth = -1;\\n    let bothLeavingDate = -1, bothLeavingMonth = -1;\\n    \\n    // Coming in same month     \\n    if(arrivalDAlice[0] === arrivalDBob[0]){\\n            [bothArrivedDate, bothArrivedMonth] = arrivalDAlice[1] > arrivalDBob[1] ? \\n            [arrivalDAlice[1], arrivalDAlice[0]] : [arrivalDBob[1],arrivalDBob[0]];\\n    }else{\\n         [bothArrivedDate, bothArrivedMonth] = arrivalDAlice[0] > arrivalDBob[0] ? \\n                [arrivalDAlice[1], arrivalDAlice[0]] : [arrivalDBob[1],arrivalDBob[0]];\\n    }\\n    \\n    // leaving date and month    \\n    if(leaveDAlice[0] === leaveDBob[0]){\\n            [bothLeavingDate, bothLeavingMonth] = leaveDAlice[1] < leaveDBob[1] ? \\n            [leaveDAlice[1], leaveDAlice[0]] : [leaveDBob[1],leaveDBob[0]];\\n    }else{\\n         [bothLeavingDate, bothLeavingMonth] = leaveDAlice[0] < leaveDBob[0] ? \\n                [leaveDAlice[1], leaveDAlice[0]] : [leaveDBob[1],leaveDBob[0]];\\n    }\\n   \\n    if(bothLeavingMonth === bothArrivedMonth) \\n    {       \\n        const totalDaysTogether = (bothLeavingDate - bothArrivedDate) + 1\\n        return  totalDaysTogether > 0 ? totalDaysTogether : 0;\\n    }\\n    \\n    if(bothLeavingMonth < bothArrivedMonth) return 0\\n    \\n    \\n    // last case when they come in n month and leave in m month\\n    \\n    let totalDaysTogether = DAYS_IN_MONTHS[bothArrivedMonth - 1] - bothArrivedDate + 1 + bothLeavingDate\\n\\n    \\n    for(let i = bothArrivedMonth;  i < bothLeavingMonth - 1; i++ ) {\\n        totalDaysTogether += DAYS_IN_MONTHS[i]\\n    }\\n    \\n    \\n    return totalDaysTogether\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589286,
                "title": "rust-solution",
                "content": "```\\nconst MONTHS: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nimpl Solution {\\n    pub fn count_days_together(\\n        arrive_alice: String,\\n        leave_alice: String,\\n        arrive_bob: String,\\n        leave_bob: String,\\n    ) -> i32 {\\n        let parse_num_date = |s: String| -> i32 {\\n            let mut it = s.split(\\'-\\').map(|mds| mds.parse::<i32>().unwrap());\\n            let (month, day) = (it.next().unwrap(), it.next().unwrap());\\n            MONTHS[..(month - 1) as usize].iter().sum::<i32>() + day\\n        };\\n\\n        let arrive_alice_day = parse_num_date(arrive_alice);\\n        let leave_alice_day = parse_num_date(leave_alice);\\n        let arrive_bob_day = parse_num_date(arrive_bob);\\n        let leave_bob_day = parse_num_date(leave_bob);\\n\\n        let min_day = arrive_alice_day.max(arrive_bob_day);\\n        let max_day = leave_alice_day.min(leave_bob_day);\\n        0.max(max_day - min_day + 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nconst MONTHS: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nimpl Solution {\\n    pub fn count_days_together(\\n        arrive_alice: String,\\n        leave_alice: String,\\n        arrive_bob: String,\\n        leave_bob: String,\\n    ) -> i32 {\\n        let parse_num_date = |s: String| -> i32 {\\n            let mut it = s.split(\\'-\\').map(|mds| mds.parse::<i32>().unwrap());\\n            let (month, day) = (it.next().unwrap(), it.next().unwrap());\\n            MONTHS[..(month - 1) as usize].iter().sum::<i32>() + day\\n        };\\n\\n        let arrive_alice_day = parse_num_date(arrive_alice);\\n        let leave_alice_day = parse_num_date(leave_alice);\\n        let arrive_bob_day = parse_num_date(arrive_bob);\\n        let leave_bob_day = parse_num_date(leave_bob);\\n\\n        let min_day = arrive_alice_day.max(arrive_bob_day);\\n        let max_day = leave_alice_day.min(leave_bob_day);\\n        0.max(max_day - min_day + 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589172,
                "title": "rust-0-ms-day-number-counting-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/802333989/) employs a straightforward day number counting. It demonstrated **0 ms runtime (100.00%)** and used **2.1 MB memory (100.00%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    // [1] this function translates \"MM-DD\" into day number\\n    pub fn day_number(day_string: String) -> i32\\n    {\\n        let days_in_month: Vec<i32> = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n        \\n        // [2] parse string to MM and DD\\n        let mm = usize::from_str_radix(&day_string[0..2], 10).unwrap() - 1;\\n        let dd = i32::from_str_radix(&day_string[3..5], 10).unwrap() - 1;\\n        \\n        // [3] get day number (starting from January 1)\\n        days_in_month[0..mm].iter().sum::<i32>() + dd\\n    }\\n    \\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 \\n    {\\n        // [4] get day numbers for all dates\\n        let day_arrive_alice = Solution::day_number(arrive_alice);\\n        let day_leave_alice  = Solution::day_number(leave_alice);\\n        let day_arrive_bob   = Solution::day_number(arrive_bob);\\n        let day_leave_bob    = Solution::day_number(leave_bob);\\n        \\n        // [5] calculate overlap\\n        let start_day = day_arrive_alice.max(day_arrive_bob);\\n        let end_day   = day_leave_alice.min(day_leave_bob);\\n\\n\\t\\t(end_day - start_day + 1).max(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    // [1] this function translates \"MM-DD\" into day number\\n    pub fn day_number(day_string: String) -> i32\\n    {\\n        let days_in_month: Vec<i32> = vec![31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n        \\n        // [2] parse string to MM and DD\\n        let mm = usize::from_str_radix(&day_string[0..2], 10).unwrap() - 1;\\n        let dd = i32::from_str_radix(&day_string[3..5], 10).unwrap() - 1;\\n        \\n        // [3] get day number (starting from January 1)\\n        days_in_month[0..mm].iter().sum::<i32>() + dd\\n    }\\n    \\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 \\n    {\\n        // [4] get day numbers for all dates\\n        let day_arrive_alice = Solution::day_number(arrive_alice);\\n        let day_leave_alice  = Solution::day_number(leave_alice);\\n        let day_arrive_bob   = Solution::day_number(arrive_bob);\\n        let day_leave_bob    = Solution::day_number(leave_bob);\\n        \\n        // [5] calculate overlap\\n        let start_day = day_arrive_alice.max(day_arrive_bob);\\n        let end_day   = day_leave_alice.min(day_leave_bob);\\n\\n\\t\\t(end_day - start_day + 1).max(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589080,
                "title": "c-easy-to-understand-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        // [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        //  1   2   3   4   5   6   7   8   9   10  11  12\\n        \\n        map<int,int> month; //prev completed days\\n        month[01]=0;\\n        month[02]=31;\\n        month[03]=59;\\n        month[04]=90;\\n        month[05]=120;\\n        month[06]=151;\\n        month[07]=181;\\n        month[8]=212;\\n        month[9]=243;\\n        month[10]=273;\\n        month[11]=304;\\n        month[12]=334;\\n\\n        //arrive alice\\n        int aam = stoi(arriveAlice.substr(0,2)); //arrive alice month\\n        int aad = stoi(arriveAlice.substr(3,2)); //arrive alice date\\n        \\n        int lam = stoi(leaveAlice.substr(0,2)); //leave alice month\\n        int lad = stoi(leaveAlice.substr(3,2));  //leave alice date\\n        \\n        int abm = stoi(arriveBob.substr(0,2));  //arrive bob month\\n        int abd = stoi(arriveBob.substr(3,2));  //arrive bob date\\n        \\n        int lbm = stoi(leaveBob.substr(0,2));  //leave bob month\\n        int lbd = stoi(leaveBob.substr(3,2));  //leave bob date\\n        \\n        if(month[lam]+lad < month[abm]+abd || month[lbm]+lbd < month[aam]+aad  ){\\n            return 0;\\n        }\\n       \\n        //Alice arrived first\\n        if(month[aam]+aad <= month[abm]+abd )\\n        {\\n            //Alice leave first\\n            if(month[lam]+lad <= month[lbm]+lbd)\\n            {\\n                return 1 + (month[lam]+lad) - (month[abm]+abd);\\n            }\\n            //Bob leave first\\n            else if(month[lam]+lad > month[lbm]+lbd){\\n                return 1 + (month[lbm]+lbd) - (month[abm]+abd);\\n            }\\n        }\\n        \\n        // Bob arrived first\\n        else if(month[aam]+aad > month[abm]+abd )\\n        {\\n            //Bob leave first\\n            if(month[lbm]+lbd <= month[lam]+lad)\\n            {\\n                return 1 + (month[lbm]+lbd) - (month[aam]+aad);\\n            }\\n            //Alice leave first\\n            else if(month[lbm]+lbd > month[lam]+lad){\\n                return 1 + (month[lam]+lad) - (month[aam]+aad);\\n            }\\n        }\\n        \\n      return 1;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        // [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        //  1   2   3   4   5   6   7   8   9   10  11  12\\n        \\n        map<int,int> month; //prev completed days\\n        month[01]=0;\\n        month[02]=31;\\n        month[03]=59;\\n        month[04]=90;\\n        month[05]=120;\\n        month[06]=151;\\n        month[07]=181;\\n        month[8]=212;\\n        month[9]=243;\\n        month[10]=273;\\n        month[11]=304;\\n        month[12]=334;\\n\\n        //arrive alice\\n        int aam = stoi(arriveAlice.substr(0,2)); //arrive alice month\\n        int aad = stoi(arriveAlice.substr(3,2)); //arrive alice date\\n        \\n        int lam = stoi(leaveAlice.substr(0,2)); //leave alice month\\n        int lad = stoi(leaveAlice.substr(3,2));  //leave alice date\\n        \\n        int abm = stoi(arriveBob.substr(0,2));  //arrive bob month\\n        int abd = stoi(arriveBob.substr(3,2));  //arrive bob date\\n        \\n        int lbm = stoi(leaveBob.substr(0,2));  //leave bob month\\n        int lbd = stoi(leaveBob.substr(3,2));  //leave bob date\\n        \\n        if(month[lam]+lad < month[abm]+abd || month[lbm]+lbd < month[aam]+aad  ){\\n            return 0;\\n        }\\n       \\n        //Alice arrived first\\n        if(month[aam]+aad <= month[abm]+abd )\\n        {\\n            //Alice leave first\\n            if(month[lam]+lad <= month[lbm]+lbd)\\n            {\\n                return 1 + (month[lam]+lad) - (month[abm]+abd);\\n            }\\n            //Bob leave first\\n            else if(month[lam]+lad > month[lbm]+lbd){\\n                return 1 + (month[lbm]+lbd) - (month[abm]+abd);\\n            }\\n        }\\n        \\n        // Bob arrived first\\n        else if(month[aam]+aad > month[abm]+abd )\\n        {\\n            //Bob leave first\\n            if(month[lbm]+lbd <= month[lam]+lad)\\n            {\\n                return 1 + (month[lbm]+lbd) - (month[aam]+aad);\\n            }\\n            //Alice leave first\\n            else if(month[lbm]+lbd > month[lam]+lad){\\n                return 1 + (month[lam]+lad) - (month[aam]+aad);\\n            }\\n        }\\n        \\n      return 1;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588948,
                "title": "c-brute-force-approach-easy-and-understandable-solution",
                "content": "// Don\\'t affraid from the lenght of code you simply follow comment you easily understand \\n\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string aA, string lA, string aB, string lB) {\\n\\t  // maa = month of arrive alice ,daa =  days of arrive alice \\n\\t  //mla = month of leave alice , dla = days of leave alice \\n        int maa , daa ;  \\n        int mla ,dla;\\n\\t // mab = month of arrive bob ,dab=  days of arrive bob \\n\\t //mlb = month of leave bob, dlb = days of leave bob\\n        int mab ,dab ;\\n        int mlb ,dlb;\\n     \\n      int count = 0;\\n     \\n            maa = (aA[0] -\\'0\\')*10 +(aA[1]-\\'0\\');\\n            daa = (aA[3] -\\'0\\')*10 +(aA[4]-\\'0\\');\\n         mla = (lA[0] -\\'0\\')*10 +(lA[1]-\\'0\\');\\n         dla = (lA[3] -\\'0\\')*10 +(lA[4]-\\'0\\');\\n         mab = (aB[0] -\\'0\\')*10 +(aB[1]-\\'0\\');\\n         dab = (aB[3] -\\'0\\')*10 +(aB[4]-\\'0\\');\\n         mlb = (lB[0] -\\'0\\')*10 +(lB[1]-\\'0\\');\\n         dlb= (lB[3] -\\'0\\')*10 +(lB[4]-\\'0\\');\\n        //  if  month of leave of alice is less than month of arrival of bob then number of days that Alice and Bob are in    Rome together is zero \\n        if (mla < mab){\\n            return 0;\\n        }\\n\\t\\t //  if  month of leave of alice is equal the month of arrival of bob then we check on which date alice is leave if allice leave date is less than bob arrnival date then number of days that Alice and Bob are in Rome together is zero \\n        else if ((mla == mab) && (dla < dab)){\\n            return 0 ;\\n        }\\n\\t\\t// respectively same approach on bob\\n      else  if (mlb<maa){\\n            return 0;\\n        }\\n     else if ((mlb == maa) && (dlb < daa)){\\n            return 0 ;\\n        }      \\n  // if above criteria  doesnt match then we count the no of days they spent together  \\n      else {  \\n\\t            // we calculate whoes arrive 1st in rome x is the month and y is date .\\n                  int x ,y;\\n                  x = max(maa,mab);\\n                  if (maa == mab){\\n                     y = max(dab,daa);\\n                  }\\n                  else {\\n                    if (maa >mab){\\n                        y = daa ;\\n                    }  \\n                      else {\\n                          y = dab;\\n                      }\\n                  }\\n\\t\\t\\t\\t  // we calculate whoes leave 1st in rome, p is the month and q is date .\\n          int p ,q;\\n          p = min(mla,mlb);\\n              if (mla == mlb ){\\n                  q = min (dlb,dla);\\n              }\\n          else {\\n              if(mla>mlb){\\n                  q = dlb;\\n              }\\n              else {\\n                  q = dla;\\n              }\\n          }\\n          // here we calculate the total no of days alice and bob spent together in rome \\n\\t\\t  // be aware of the month which contain 31 days or 30 days or 29 days ,we make separate case from them\\n              while (x<p){\\n                  if (x<=7){\\n                    if(x==2){\\n                    count += (28-y);\\n                        y=0;\\n                      }\\n                  else if (x %2 == 1  ){\\n                  count += (31-y);\\n                      y =0;\\n                      }\\n                  else {\\n                      count += (30-y);\\n                      y = 0;\\n                  }\\n                  x++;\\n              }\\n                  else  if (x>7){\\n                  if (x %2 == 0  ){\\n                  count += (31-y);\\n                      y =0;\\n                      }\\n                  else {\\n                      count += (30-y);\\n                      y = 0;\\n                  }\\n                  x++;\\n              }\\n              }\\n             if (x == p){\\n                 count += (q-y);\\n             }\\n          }\\n              return count+1;\\n    }\\n               \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countDaysTogether(string aA, string lA, string aB, string lB) {\\n\\t  // maa = month of arrive alice ,daa =  days of arrive alice \\n\\t  //mla = month of leave alice , dla = days of leave alice \\n        int maa , daa ;  \\n        int mla ,dla;\\n\\t // mab = month of arrive bob ,dab=  days of arrive bob \\n\\t //mlb = month of leave bob, dlb = days of leave bob\\n        int mab ,dab ;\\n        int mlb ,dlb;\\n     \\n      int count = 0;\\n     \\n            maa = (aA[0] -\\'0\\')*10 +(aA[1]-\\'0\\');\\n            daa = (aA[3] -\\'0\\')*10 +(aA[4]-\\'0\\');\\n         mla = (lA[0] -\\'0\\')*10 +(lA[1]-\\'0\\');\\n         dla = (lA[3] -\\'0\\')*10 +(lA[4]-\\'0\\');\\n         mab = (aB[0] -\\'0\\')*10 +(aB[1]-\\'0\\');\\n         dab = (aB[3] -\\'0\\')*10 +(aB[4]-\\'0\\');\\n         mlb = (lB[0] -\\'0\\')*10 +(lB[1]-\\'0\\');\\n         dlb= (lB[3] -\\'0\\')*10 +(lB[4]-\\'0\\');\\n        //  if  month of leave of alice is less than month of arrival of bob then number of days that Alice and Bob are in    Rome together is zero \\n        if (mla < mab){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2588439,
                "title": "silly-problem-easy-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int month[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        string start = max(arriveAlice, arriveBob), end = min(leaveAlice, leaveBob);\\n        if (start <= end) {\\n            int startMonth = stoi(start.substr(0, 2)), startDate = stoi(start.substr(3, 2));\\n            int endMonth = stoi(end.substr(0, 2)), endDate = stoi(end.substr(3, 2));\\n            if (endMonth == startMonth) return endDate - startDate + 1;\\n            int days = month[startMonth] + endDate - startDate + 1;\\n            for (int i = startMonth + 1; i < endMonth; i++) days += month[i];\\n            return days;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int month[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        string start = max(arriveAlice, arriveBob), end = min(leaveAlice, leaveBob);\\n        if (start <= end) {\\n            int startMonth = stoi(start.substr(0, 2)), startDate = stoi(start.substr(3, 2));\\n            int endMonth = stoi(end.substr(0, 2)), endDate = stoi(end.substr(3, 2));\\n            if (endMonth == startMonth) return endDate - startDate + 1;\\n            int days = month[startMonth] + endDate - startDate + 1;\\n            for (int i = startMonth + 1; i < endMonth; i++) days += month[i];\\n            return days;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588351,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        vector<int> mp = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int as = getDate(mp, aa), ae = getDate(mp, la);\\n        int bs = getDate(mp, ab), be = getDate(mp, lb);\\n        int res = 0;\\n        for(int i=as; i<=ae; i++) {\\n            if(bs<=i && i<=be) res++;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int getDate(vector<int>& mp, string& s) {\\n        int res = 0, m = stoi(s.substr(0, 2)), d = stoi(s.substr(3, 2));\\n        for(int i=0; i<m-1; i++) res += mp[i];\\n        return res + d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string aa, string la, string ab, string lb) {\\n        vector<int> mp = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int as = getDate(mp, aa), ae = getDate(mp, la);\\n        int bs = getDate(mp, ab), be = getDate(mp, lb);\\n        int res = 0;\\n        for(int i=as; i<=ae; i++) {\\n            if(bs<=i && i<=be) res++;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int getDate(vector<int>& mp, string& s) {\\n        int res = 0, m = stoi(s.substr(0, 2)), d = stoi(s.substr(3, 2));\\n        for(int i=0; i<m-1; i++) res += mp[i];\\n        return res + d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588277,
                "title": "javascript",
                "content": "```\\nconst countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n  const months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n  const pref = [0]\\n  for (let i = 0; i < months.length; i++) {\\n      pref.push(pref[i]+months[i])\\n  }\\n  \\n  let [ama, ada] = arriveAlice.split(\\'-\\')\\n  let [aml, adl] = leaveAlice.split(\\'-\\')\\n  let [bma, bda] = arriveBob.split(\\'-\\')\\n  let [bml, bdl] = leaveBob.split(\\'-\\')\\n  \\n  let aA = pref[parseInt(ama)-1] + parseInt(ada)\\n  let aL = pref[parseInt(aml)-1] + parseInt(adl)\\n  \\n  let bA = pref[parseInt(bma)-1] + parseInt(bda)\\n  let bL = pref[parseInt(bml)-1] + parseInt(bdl)\\n  \\n  return Math.max(0, Math.min(aL, bL) - Math.max(aA, bA) + 1)\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n  const months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n  const pref = [0]\\n  for (let i = 0; i < months.length; i++) {\\n      pref.push(pref[i]+months[i])\\n  }\\n  \\n  let [ama, ada] = arriveAlice.split(\\'-\\')\\n  let [aml, adl] = leaveAlice.split(\\'-\\')\\n  let [bma, bda] = arriveBob.split(\\'-\\')\\n  let [bml, bdl] = leaveBob.split(\\'-\\')\\n  \\n  let aA = pref[parseInt(ama)-1] + parseInt(ada)\\n  let aL = pref[parseInt(aml)-1] + parseInt(adl)\\n  \\n  let bA = pref[parseInt(bma)-1] + parseInt(bda)\\n  let bL = pref[parseInt(bml)-1] + parseInt(bdl)\\n  \\n  return Math.max(0, Math.min(aL, bL) - Math.max(aA, bA) + 1)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588232,
                "title": "u-wanted-bigger-is-it-just-as-she-said",
                "content": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arr[]=new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int maa=Integer.valueOf(arriveAlice.split(\"-\")[0])-1;\\n        int daa=Integer.valueOf(arriveAlice.split(\"-\")[1])-1;\\n        int mla=Integer.valueOf(leaveAlice.split(\"-\")[0])-1;\\n        int dla=Integer.valueOf(leaveAlice.split(\"-\")[1])-1;\\n        \\n        int mab=Integer.valueOf(arriveBob.split(\"-\")[0])-1;\\n        int dab=Integer.valueOf(arriveBob.split(\"-\")[1])-1;\\n        int mlb=Integer.valueOf(leaveBob.split(\"-\")[0])-1;\\n        int dlb=Integer.valueOf(leaveBob.split(\"-\")[1])-1;\\n        \\n        int year[][]=new int[12][];\\n        for(int i=0;i<12;i++){\\n            year[i]=new int[arr[i]];\\n        }\\n        if(maa==mla){\\n            for(int i=daa;i<=dla;i++){\\n                year[maa][i]++;\\n            }\\n        }else{\\n            for(int i=daa;i<year[maa].length;i++){\\n                year[maa][i]++;\\n            }\\n            for(int i=maa+1;i<mla;i++){\\n                for(int j=0;i<12 && j<arr[i];j++){\\n                    year[i][j]++;\\n                }\\n            }\\n            for(int i=0;i<=dla;i++){\\n                year[mla][i]++;\\n            }\\n        }\\n        \\n        \\n        \\n        if(mab==mlb){\\n            for(int i=dab;i<=dlb;i++){\\n                year[mab][i]++;\\n            }\\n        }else{\\n            for(int i=dab;i<year[mab].length;i++){\\n                year[mab][i]++;\\n            }\\n            for(int i=mab+1;i<mlb;i++){\\n                for(int j=0;i<12 && j<arr[i];j++){\\n                    year[i][j]++;\\n                }\\n            }\\n            for(int i=0;i<=dlb;i++){\\n                year[mlb][i]++;\\n            }\\n        }\\n        int res=0;\\n        for(int[] array: year){\\n            for(int together: array){\\n                if(together==2) res++;\\n                // System.out.print(together+\" \");\\n            }\\n            // System.out.println();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arr[]=new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        int maa=Integer.valueOf(arriveAlice.split(\"-\")[0])-1;\\n        int daa=Integer.valueOf(arriveAlice.split(\"-\")[1])-1;\\n        int mla=Integer.valueOf(leaveAlice.split(\"-\")[0])-1;\\n        int dla=Integer.valueOf(leaveAlice.split(\"-\")[1])-1;\\n        \\n        int mab=Integer.valueOf(arriveBob.split(\"-\")[0])-1;\\n        int dab=Integer.valueOf(arriveBob.split(\"-\")[1])-1;\\n        int mlb=Integer.valueOf(leaveBob.split(\"-\")[0])-1;\\n        int dlb=Integer.valueOf(leaveBob.split(\"-\")[1])-1;\\n        \\n        int year[][]=new int[12][];\\n        for(int i=0;i<12;i++){\\n            year[i]=new int[arr[i]];\\n        }\\n        if(maa==mla){\\n            for(int i=daa;i<=dla;i++){\\n                year[maa][i]++;\\n            }\\n        }else{\\n            for(int i=daa;i<year[maa].length;i++){\\n                year[maa][i]++;\\n            }\\n            for(int i=maa+1;i<mla;i++){\\n                for(int j=0;i<12 && j<arr[i];j++){\\n                    year[i][j]++;\\n                }\\n            }\\n            for(int i=0;i<=dla;i++){\\n                year[mla][i]++;\\n            }\\n        }\\n        \\n        \\n        \\n        if(mab==mlb){\\n            for(int i=dab;i<=dlb;i++){\\n                year[mab][i]++;\\n            }\\n        }else{\\n            for(int i=dab;i<year[mab].length;i++){\\n                year[mab][i]++;\\n            }\\n            for(int i=mab+1;i<mlb;i++){\\n                for(int j=0;i<12 && j<arr[i];j++){\\n                    year[i][j]++;\\n                }\\n            }\\n            for(int i=0;i<=dlb;i++){\\n                year[mlb][i]++;\\n            }\\n        }\\n        int res=0;\\n        for(int[] array: year){\\n            for(int together: array){\\n                if(together==2) res++;\\n                // System.out.print(together+\" \");\\n            }\\n            // System.out.println();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588208,
                "title": "convert-date-to-the-ith-day-of-the-year",
                "content": "Its a common trick whenever you have dates given there are two possibilities to solve the problem:\\n1) simply brute force travel each day\\n2) convert date to the ith day from a particular reference\\n\\nhere since we are given month and day only so we can safely convert our date to  ith day of the year.\\ni.e(between 0 to 365).\\n(now for the answer we can store the maximum start day and minimum leave day for alice and bob)\\n```\\nclass Solution\\n{\\npublic:\\n    int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int convert(string x)\\n    {\\n        int month = stoi(x.substr(0, 2));\\n        int day = stoi(x.substr(3, 2));\\n        int ans = 0;\\n        for (int i = 1; i < month; i++)\\n            ans += days[i];\\n        ans += day;\\n        return ans;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        int aa = convert(arriveAlice);\\n        int al = convert(leaveAlice);\\n        int ba = convert(arriveBob);\\n        int bl = convert(leaveBob);\\n        int start = max(aa, ba);\\n        int leave = min(al, bl);\\n\\n        return max(leave - start + 1, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int convert(string x)\\n    {\\n        int month = stoi(x.substr(0, 2));\\n        int day = stoi(x.substr(3, 2));\\n        int ans = 0;\\n        for (int i = 1; i < month; i++)\\n            ans += days[i];\\n        ans += day;\\n        return ans;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        int aa = convert(arriveAlice);\\n        int al = convert(leaveAlice);\\n        int ba = convert(arriveBob);\\n        int bl = convert(leaveBob);\\n        int start = max(aa, ba);\\n        int leave = min(al, bl);\\n\\n        return max(leave - start + 1, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588191,
                "title": "too-much-confusion",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a_s_m=(arriveAlice[0]-\\'0\\')*10 + (arriveAlice[1]-\\'0\\');\\n        int a_s_d=(arriveAlice[3]-\\'0\\')*10 + (arriveAlice[4]-\\'0\\');\\n        int a_e_m=(leaveAlice[0]-\\'0\\')*10 + (leaveAlice[1]-\\'0\\');\\n        int a_e_d=(leaveAlice[3]-\\'0\\')*10 + (leaveAlice[4]-\\'0\\');\\n        \\n        int b_s_m=(arriveBob[0]-\\'0\\')*10 + (arriveBob[1]-\\'0\\');\\n        int b_s_d=(arriveBob[3]-\\'0\\')*10 + (arriveBob[4]-\\'0\\');\\n        int b_e_m=(leaveBob[0]-\\'0\\')*10 + (leaveBob[1]-\\'0\\');\\n        int b_e_d=(leaveBob[3]-\\'0\\')*10 + (leaveBob[4]-\\'0\\');\\n        vector<int> days= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int common_m_s, common_d_s, common_m_e, common_d_e;\\n        if(a_s_m < b_s_m){\\n            common_m_s=b_s_m;\\n            common_d_s=b_s_d;\\n        }\\n        else if(a_s_m == b_s_m){\\n            common_m_s=b_s_m;\\n            common_d_s=max(a_s_d,b_s_d);\\n        }\\n        else {\\n            common_m_s=a_s_m;\\n            common_d_s=a_s_d;\\n        }\\n        \\n        if(a_e_m < b_e_m){\\n            common_m_e=a_e_m;\\n            common_d_e=a_e_d;\\n        }\\n        else if(a_e_m==b_e_m){\\n            common_m_e=a_e_m;\\n            common_d_e=min(a_e_d,b_e_d);\\n        }\\n        else{\\n            common_m_e=b_e_m;\\n            common_d_e=b_e_d;\\n        }\\n        // cout<<common_m_s<<\" \"<<common_d_s<<\"|\"<<common_m_e<<\" \"<<common_d_e<<endl;\\n        int count=0;\\n        for(int i=common_m_s;i<=common_m_e;i++){\\n            count+=days[i-1];\\n        }\\n        count-=(common_d_s-1);\\n        count-=(days[common_m_e-1]-common_d_e);\\n        if(count>0) \\n            return count;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a_s_m=(arriveAlice[0]-\\'0\\')*10 + (arriveAlice[1]-\\'0\\');\\n        int a_s_d=(arriveAlice[3]-\\'0\\')*10 + (arriveAlice[4]-\\'0\\');\\n        int a_e_m=(leaveAlice[0]-\\'0\\')*10 + (leaveAlice[1]-\\'0\\');\\n        int a_e_d=(leaveAlice[3]-\\'0\\')*10 + (leaveAlice[4]-\\'0\\');\\n        \\n        int b_s_m=(arriveBob[0]-\\'0\\')*10 + (arriveBob[1]-\\'0\\');\\n        int b_s_d=(arriveBob[3]-\\'0\\')*10 + (arriveBob[4]-\\'0\\');\\n        int b_e_m=(leaveBob[0]-\\'0\\')*10 + (leaveBob[1]-\\'0\\');\\n        int b_e_d=(leaveBob[3]-\\'0\\')*10 + (leaveBob[4]-\\'0\\');\\n        vector<int> days= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int common_m_s, common_d_s, common_m_e, common_d_e;\\n        if(a_s_m < b_s_m){\\n            common_m_s=b_s_m;\\n            common_d_s=b_s_d;\\n        }\\n        else if(a_s_m == b_s_m){\\n            common_m_s=b_s_m;\\n            common_d_s=max(a_s_d,b_s_d);\\n        }\\n        else {\\n            common_m_s=a_s_m;\\n            common_d_s=a_s_d;\\n        }\\n        \\n        if(a_e_m < b_e_m){\\n            common_m_e=a_e_m;\\n            common_d_e=a_e_d;\\n        }\\n        else if(a_e_m==b_e_m){\\n            common_m_e=a_e_m;\\n            common_d_e=min(a_e_d,b_e_d);\\n        }\\n        else{\\n            common_m_e=b_e_m;\\n            common_d_e=b_e_d;\\n        }\\n        // cout<<common_m_s<<\" \"<<common_d_s<<\"|\"<<common_m_e<<\" \"<<common_d_e<<endl;\\n        int count=0;\\n        for(int i=common_m_s;i<=common_m_e;i++){\\n            count+=days[i-1];\\n        }\\n        count-=(common_d_s-1);\\n        count-=(days[common_m_e-1]-common_d_e);\\n        if(count>0) \\n            return count;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2588094,
                "title": "c-easy-solution",
                "content": "- We create an array with a size of 365, with for each cell, a day.\\n - For both Alice and Bob we will add 1 for each cell or their active days\\n -  The hardest part is to convert the string dates to our year array\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int> nbDays = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        vector<int> daysSum(13);\\n\\t\\t// We use a prefix sum to have for each month the cumul count of days\\n        for (int i=1; i<13; i++)\\n        {\\n            daysSum[i]=daysSum[i-1]+nbDays[i-1];\\n        }\\n        vector<int> year(366);\\n        int ans = 0;\\n\\t\\t// We use the function substr to get the firsts elements of \"MM-DD\" and the lasts one\\n\\t\\t// the function stoi will convert our string into an integer\\n        int arriveAD=stoi(arriveAlice.substr(3,2)); //arrive Alice Day\\n        int arriveAM=stoi(arriveAlice.substr(0,2)); //arrive Alice Month\\n        int endAD=stoi(leaveAlice.substr(3,2));\\n        int endAM=stoi(leaveAlice.substr(0,2));\\n        int arriveBD=stoi(arriveBob.substr(3,2)); //arrive Bob Day\\n        int arriveBM=stoi(arriveBob.substr(0,2)); //arrive Bob Month\\n        int endBD=stoi(leaveBob.substr(3,2));\\n        int endBM=stoi(leaveBob.substr(0,2));\\n\\t\\t// For i=first day; i<=last day\\n        for (int i=daysSum[arriveAM-1]+arriveAD; i<=daysSum[endAM-1]+endAD; i++)\\n            year[i]++;\\n        for (int i=daysSum[arriveBM-1]+arriveBD; i<=daysSum[endBM-1]+endBD; i++)\\n            year[i]++;\\n\\t\\t\\t// Each day marked with a 2 is a day that both Alice and Bob were together\\n        for (int i=0; i<366; i++)\\n            if (year[i]==2)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int> nbDays = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        vector<int> daysSum(13);\\n\\t\\t// We use a prefix sum to have for each month the cumul count of days\\n        for (int i=1; i<13; i++)\\n        {\\n            daysSum[i]=daysSum[i-1]+nbDays[i-1];\\n        }\\n        vector<int> year(366);\\n        int ans = 0;\\n\\t\\t// We use the function substr to get the firsts elements of \"MM-DD\" and the lasts one\\n\\t\\t// the function stoi will convert our string into an integer\\n        int arriveAD=stoi(arriveAlice.substr(3,2)); //arrive Alice Day\\n        int arriveAM=stoi(arriveAlice.substr(0,2)); //arrive Alice Month\\n        int endAD=stoi(leaveAlice.substr(3,2));\\n        int endAM=stoi(leaveAlice.substr(0,2));\\n        int arriveBD=stoi(arriveBob.substr(3,2)); //arrive Bob Day\\n        int arriveBM=stoi(arriveBob.substr(0,2)); //arrive Bob Month\\n        int endBD=stoi(leaveBob.substr(3,2));\\n        int endBM=stoi(leaveBob.substr(0,2));\\n\\t\\t// For i=first day; i<=last day\\n        for (int i=daysSum[arriveAM-1]+arriveAD; i<=daysSum[endAM-1]+endAD; i++)\\n            year[i]++;\\n        for (int i=daysSum[arriveBM-1]+arriveBD; i<=daysSum[endBM-1]+endBD; i++)\\n            year[i]++;\\n\\t\\t\\t// Each day marked with a 2 is a day that both Alice and Bob were together\\n        for (int i=0; i<366; i++)\\n            if (year[i]==2)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588045,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        DateTime arrive2 = DateTime.Parse(arriveBob + \"-2019\");\\n        DateTime leave2 = DateTime.Parse(leaveBob + \"-2019\");\\n        DateTime arrive1 = DateTime.Parse(arriveAlice + \"-2019\");\\n        DateTime leave1 = DateTime.Parse(leaveAlice + \"-2019\");\\n        var count = 0;\\n        for(DateTime i= arrive1; i <= leave1; i=i.AddDays(1))\\n        {\\n            if(i>=arrive2 && i <= leave2)\\n            {\\n                count++;\\n            }\\n        } \\n        return count;\\n    } \\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        DateTime arrive2 = DateTime.Parse(arriveBob + \"-2019\");\\n        DateTime leave2 = DateTime.Parse(leaveBob + \"-2019\");\\n        DateTime arrive1 = DateTime.Parse(arriveAlice + \"-2019\");\\n        DateTime leave1 = DateTime.Parse(leaveAlice + \"-2019\");\\n        var count = 0;\\n        for(DateTime i= arrive1; i <= leave1; i=i.AddDays(1))\\n        {\\n            if(i>=arrive2 && i <= leave2)\\n            {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2587926,
                "title": "python-simple-counting-no-libraries",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        if arriveAlice > leaveBob or arriveBob > leaveAlice: return 0\\n        \\n        start = max(arriveAlice, arriveBob)\\n        end = min(leaveAlice, leaveBob)\\n        \\n        days = [0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\n        s_month, s_day = map(int,start.split(\\'-\\'))\\n        e_month, e_day = map(int,end.split(\\'-\\'))\\n\\n        if s_month == e_month: return e_day - s_day + 1\\n\\n        count = days[s_month] - s_day + 1\\n\\n        count += sum(days[month] for month in range(s_month + 1, e_month))\\n\\n        count += e_day \\n\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        if arriveAlice > leaveBob or arriveBob > leaveAlice: return 0\\n        \\n        start = max(arriveAlice, arriveBob)\\n        end = min(leaveAlice, leaveBob)\\n        \\n        days = [0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\n        s_month, s_day = map(int,start.split(\\'-\\'))\\n        e_month, e_day = map(int,end.split(\\'-\\'))\\n\\n        if s_month == e_month: return e_day - s_day + 1\\n\\n        count = days[s_month] - s_day + 1\\n\\n        count += sum(days[month] for month in range(s_month + 1, e_month))\\n\\n        count += e_day \\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466221,
                "title": "to-count-days-spent-together-c-c-simple-solution",
                "content": "# Approach\\nJust convert start days and end days to numbers for easy calculation purposes.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumdays[13];\\n    int Days[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int totalDays(string str)\\n    {\\n        int month=stoi(str.substr(0,2)), day=stoi(str.substr(3));\\n        return sumdays[month-1]+day;\\n    }\\n\\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        sumdays[0]=0;\\n       for(int i=1;i<=12;i++)\\n       {\\n           sumdays[i]=sumdays[i-1]+Days[i-1];\\n       }\\n       int arrival=max(totalDays(arriveAlice),totalDays(arriveBob));\\n       int departure=min(totalDays(leaveAlice),totalDays(leaveBob));\\n       int ans=departure-arrival+1;\\n        return max(0,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumdays[13];\\n    int Days[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int totalDays(string str)\\n    {\\n        int month=stoi(str.substr(0,2)), day=stoi(str.substr(3));\\n        return sumdays[month-1]+day;\\n    }\\n\\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        sumdays[0]=0;\\n       for(int i=1;i<=12;i++)\\n       {\\n           sumdays[i]=sumdays[i-1]+Days[i-1];\\n       }\\n       int arrival=max(totalDays(arriveAlice),totalDays(arriveBob));\\n       int departure=min(totalDays(leaveAlice),totalDays(leaveBob));\\n       int ans=departure-arrival+1;\\n        return max(0,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326455,
                "title": "beat-98-79-23ms-python3-import-datetime-solution-one-liner-easy-understanding",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom datetime import datetime\\nclass Solution:\\n    def countDaysTogether(self, AA: str, LA: str, AB: str, LB: str) -> int:\\n        start , end = max(AA, AB), min(LA, LB)\\n        if start > end: return 0\\n        x = datetime.strptime(start, \\'%m-%d\\')\\n        y = datetime.strptime(end, \\'%m-%d\\')\\n        return abs((y - x).days)  + 1\\n\\n        #One-liner \\n\\n\\n        return abs((datetime.strptime(min(LA, LB), \\'%m-%d\\') - datetime.strptime(max(AA, AB), \\'%m-%d\\')).days)  + 1 if max(AA, AB) < min(LA, LB) else 0\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nfrom datetime import datetime\\nclass Solution:\\n    def countDaysTogether(self, AA: str, LA: str, AB: str, LB: str) -> int:\\n        start , end = max(AA, AB), min(LA, LB)\\n        if start > end: return 0\\n        x = datetime.strptime(start, \\'%m-%d\\')\\n        y = datetime.strptime(end, \\'%m-%d\\')\\n        return abs((y - x).days)  + 1\\n\\n        #One-liner \\n\\n\\n        return abs((datetime.strptime(min(LA, LB), \\'%m-%d\\') - datetime.strptime(max(AA, AB), \\'%m-%d\\')).days)  + 1 if max(AA, AB) < min(LA, LB) else 0\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828976,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nint md[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nclass Solution {\\n    int td(string s) {\\n        int m = s[1] - \\'0\\' + 10*(s[0] - \\'0\\');\\n        int d = s[4] - \\'0\\' + 10*(s[3] - \\'0\\');\\n        --m;\\n        while (m > 0) {\\n            d += md[m];\\n            --m;\\n        }\\n        return d;\\n    }\\npublic:\\n    int countDaysTogether(string sa1, string sa2, string sb1, string sb2) {\\n        int a1 = td(sa1), a2 = td(sa2), b1 = td(sb1), b2 = td(sb2);\\n        int ans = 0;\\n        for (int i = 0; i < 367; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint md[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\nclass Solution {\\n    int td(string s) {\\n        int m = s[1] - \\'0\\' + 10*(s[0] - \\'0\\');\\n        int d = s[4] - \\'0\\' + 10*(s[3] - \\'0\\');\\n        --m;\\n        while (m > 0) {\\n            d += md[m];\\n            --m;\\n        }\\n        return d;\\n    }\\npublic:\\n    int countDaysTogether(string sa1, string sa2, string sb1, string sb2) {\\n        int a1 = td(sa1), a2 = td(sa2), b1 = td(sb1), b2 = td(sb2);\\n        int ans = 0;\\n        for (int i = 0; i < 367; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641625,
                "title": "c-straightforward-solution",
                "content": "```\\npublic class Solution {\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        string start = String.Compare(arriveAlice,arriveBob)>0 ? arriveAlice : arriveBob;\\n        string end = String.Compare(leaveAlice,leaveBob)>0 ? leaveBob : leaveAlice;\\n        int res = (Convert.ToDateTime(end) - Convert.ToDateTime(start)).Days + 1;\\n        return res>0 ? res : 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        string start = String.Compare(arriveAlice,arriveBob)>0 ? arriveAlice : arriveBob;\\n        string end = String.Compare(leaveAlice,leaveBob)>0 ? leaveBob : leaveAlice;\\n        int res = (Convert.ToDateTime(end) - Convert.ToDateTime(start)).Days + 1;\\n        return res>0 ? res : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635606,
                "title": "c-with-comments",
                "content": "class Solution {\\npublic:\\n    int days[12]={0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n    //this array adds all the days upto first of each month\\n    int totaldays(string &d)\\n    {\\n        //eg: 08-15\\n        //days[0x10+8-1]+1x10+5=days[8](month aug)+15=243+15=258th day from jan 1st\\n        return days[10*(d[0]-\\'0\\')+d[1]-\\'0\\'-1]+(d[3]-\\'0\\')*10+d[4]-\\'0\\';\\n    }\\n    //this function will add the no of days passed in string date\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        //first we count no of days till the given date in the string\\n       int leaving_days=min(totaldays(leaveAlice),totaldays(leaveBob));\\n        int arriving_days=max(totaldays(arriveAlice),totaldays(arriveBob));\\n        int common_days=leaving_days-arriving_days+1;\\n        return max(0,common_days);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int days[12]={0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}",
                "codeTag": "Java"
            },
            {
                "id": 2635033,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\nprivate:\\nint days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\nvector<int> sumDays;\\n\\npublic:\\nint totalDays(string str){\\n    int month = stoi(str.substr(0, 2)), day = stoi(str.substr(3));    \\n    return sumDays[month - 1] + day;\\n}\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n    sumDays.push_back(0);\\n    for(int i =0;i<12;i++){\\n        sumDays.push_back(sumDays.back() + days[i]);\\n    }\\n    \\n    int arrival = max(totalDays(arriveAlice), totalDays(arriveBob));\\n    int departure = min(totalDays(leaveAlice), totalDays(leaveBob));\\n    int countDays = departure - arrival +1;\\n    \\n\\treturn max(0, countDays);\\n    \\n\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\nint days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2625298,
                "title": "python3-one-liner",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        return max(0, 1 + min(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveAlice[:2]) - 1)]) + (int(leaveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveBob[:2]) - 1)]) + (int(leaveBob[3:]) - 1))) - max(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveAlice[:2]) - 1)]) + (int(arriveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveBob[:2]) - 1)])) + (int(arriveBob[3:]) - 1))) \\n\\n```\\nextremely unreadable one liner. I essentially found the minimum of the leave dates - max of the arrival dates + 1 and that\\'s the overlap. If there is no overlap then it\\'ll be negative so we just return the max of that and 0.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        return max(0, 1 + min(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveAlice[:2]) - 1)]) + (int(leaveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(leaveBob[:2]) - 1)]) + (int(leaveBob[3:]) - 1))) - max(sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveAlice[:2]) - 1)]) + (int(arriveAlice[3:]) - 1), (sum([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][:(int(arriveBob[:2]) - 1)])) + (int(arriveBob[3:]) - 1))) \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609383,
                "title": "c-simple-easy-on-the-eyes-code-w-comments-beats-100",
                "content": "If you count the number of days elapsed since arrival and departure of both Alice and Bob. It\\'s very easy and intuitive to do the rest.\\n\\n```c++\\nclass Solution\\n{\\n\\t// \\t\\t\\t\\t\\t\\t   1   2   3   4   5   6   7   8   9   10  11  12\\n\\tvector<int> daysInMonth{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n\\tint getDaysCount(string monthAndDate) // return number of days since start of year\\n\\t{\\n\\t\\tint month = stoi(monthAndDate.substr(0, 2)), date = stoi(monthAndDate.substr(3));\\n\\t\\tint days = 0;\\n\\n\\t\\twhile (month--)\\n\\t\\t\\tdays += daysInMonth.at(month);\\n\\n\\t\\treturn days + date;\\n\\t}\\n\\npublic:\\n\\tint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n\\t{\\n\\t\\tint aliceIn = getDaysCount(arriveAlice), aliceOut = getDaysCount(leaveAlice);\\n\\t\\tint bobIn = getDaysCount(arriveBob), bobOut = getDaysCount(leaveBob);\\n\\n\\t\\tint common = min(aliceOut, bobOut) - max(aliceIn, bobIn) + 1; // (1)\\n\\n\\t\\treturn common > 0 ? common : 0; // (2)\\n\\t}\\n};\\n```\\n\\n**(1)** : `Min(out)` is used to see who left first & `Max(in)` is used to see who came last. Because common days will be between these 2 values.\\n\\n**(2)** : If there isn\\'t any common day(s) between them, then common will obviously be negative but the answer is `0`.",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution\\n{\\n\\t// \\t\\t\\t\\t\\t\\t   1   2   3   4   5   6   7   8   9   10  11  12\\n\\tvector<int> daysInMonth{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n\\tint getDaysCount(string monthAndDate) // return number of days since start of year\\n\\t{\\n\\t\\tint month = stoi(monthAndDate.substr(0, 2)), date = stoi(monthAndDate.substr(3));\\n\\t\\tint days = 0;\\n\\n\\t\\twhile (month--)\\n\\t\\t\\tdays += daysInMonth.at(month);\\n\\n\\t\\treturn days + date;\\n\\t}\\n\\npublic:\\n\\tint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n\\t{\\n\\t\\tint aliceIn = getDaysCount(arriveAlice), aliceOut = getDaysCount(leaveAlice);\\n\\t\\tint bobIn = getDaysCount(arriveBob), bobOut = getDaysCount(leaveBob);\\n\\n\\t\\tint common = min(aliceOut, bobOut) - max(aliceIn, bobIn) + 1; // (1)\\n\\n\\t\\treturn common > 0 ? common : 0; // (2)\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598458,
                "title": "easy-python3",
                "content": "\\tclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        day={1:31,2:28,3:31,4:30,5:31,6:30,\\n          7:31,8:31,9:30,10:31,11:30,12:31}\\n        \\n        def calc_days(datestring):\\n            m,d=datestring.split(\"-\")\\n            days=0\\n            for i in range(1,int(m)):\\n                days+=day[i]\\n            days+=int(d)\\n            return days\\n        \\n        pt1=max(calc_days(arriveAlice),calc_days(arriveBob))\\n        pt2=min(calc_days(leaveAlice),calc_days(leaveBob))\\n        \\n        if pt1>pt2:\\n            return 0\\n        else:\\n            return pt2-pt1+1",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        day={1:31,2:28,3:31,4:30,5:31,6:30,\\n          7:31,8:31,9:30,10:31,11:30,12:31}",
                "codeTag": "Java"
            },
            {
                "id": 2596515,
                "title": "java-calculate-day-of-year",
                "content": "```\\nclass Solution {\\n    private int[] days = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aa = calculateDayOfYear(arriveAlice);\\n        int la = calculateDayOfYear(leaveAlice);\\n\\n        int ab = calculateDayOfYear(arriveBob);\\n        int lb = calculateDayOfYear(leaveBob);\\n        \\n        int laterArrive = Math.max(aa, ab);\\n        int earlierLeave = Math.min(la, lb);\\n        \\n        return earlierLeave - laterArrive < 0 ? 0 : earlierLeave - laterArrive + 1;\\n    }\\n    \\n    private int calculateDayOfYear(String obj){\\n        int month = parceMonth(obj);\\n        int day = parceDay(obj);\\n       \\n        int count = 0;\\n        while(month > 1){\\n            count += days[month - 2];\\n            month--;\\n        }\\n        return count + day;\\n    }\\n    \\n    private int parceMonth(String obj){\\n        return Integer.parseInt(obj.substring(0, 2));\\n    }\\n    \\n    private int parceDay(String obj){\\n        return Integer.parseInt(obj.substring(3, 5));\\n    }\\n}\\n```\\nPlease Upvote if you found this helpful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[] days = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aa = calculateDayOfYear(arriveAlice);\\n        int la = calculateDayOfYear(leaveAlice);\\n\\n        int ab = calculateDayOfYear(arriveBob);\\n        int lb = calculateDayOfYear(leaveBob);\\n        \\n        int laterArrive = Math.max(aa, ab);\\n        int earlierLeave = Math.min(la, lb);\\n        \\n        return earlierLeave - laterArrive < 0 ? 0 : earlierLeave - laterArrive + 1;\\n    }\\n    \\n    private int calculateDayOfYear(String obj){\\n        int month = parceMonth(obj);\\n        int day = parceDay(obj);\\n       \\n        int count = 0;\\n        while(month > 1){\\n            count += days[month - 2];\\n            month--;\\n        }\\n        return count + day;\\n    }\\n    \\n    private int parceMonth(String obj){\\n        return Integer.parseInt(obj.substring(0, 2));\\n    }\\n    \\n    private int parceDay(String obj){\\n        return Integer.parseInt(obj.substring(3, 5));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592748,
                "title": "python-simple-to-understand-solution",
                "content": "Here\\'s the straightforward solution: \\n```\\nclass Solution:\\n    def calculate(self, time):\\n        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        return sum(days[:int(time.split(\\'-\\')[0]) - 1]) + int(time.split(\\'-\\')[1])\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        alice = [self.calculate(arriveAlice), self.calculate(leaveAlice)]\\n        bob = [self.calculate(arriveBob), self.calculate(leaveBob)]\\n        if bob[0] <= alice[0] <= bob[1]:\\n            if bob[1] <= alice[1]:\\n                return bob[1] - alice[0] + 1\\n            else:\\n                return alice[1] - alice[0] + 1\\n        elif alice[0] <= bob[0] <= alice[1]:\\n            if alice[1] <= bob[1]:\\n                return alice[1] - bob[0] + 1\\n            else:\\n                return bob[1] - bob[0] + 1\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def calculate(self, time):\\n        days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        return sum(days[:int(time.split(\\'-\\')[0]) - 1]) + int(time.split(\\'-\\')[1])\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        alice = [self.calculate(arriveAlice), self.calculate(leaveAlice)]\\n        bob = [self.calculate(arriveBob), self.calculate(leaveBob)]\\n        if bob[0] <= alice[0] <= bob[1]:\\n            if bob[1] <= alice[1]:\\n                return bob[1] - alice[0] + 1\\n            else:\\n                return alice[1] - alice[0] + 1\\n        elif alice[0] <= bob[0] <= alice[1]:\\n            if alice[1] <= bob[1]:\\n                return alice[1] - bob[0] + 1\\n            else:\\n                return bob[1] - bob[0] + 1\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592247,
                "title": "java-simple-and-short-solution",
                "content": "1) Converting days from char to int\\n2) Calculating total no, of days\\n3) finally calculate the intersecting days and you are good to go\\n```\\nclass Solution {\\n  private  int []   months = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int helper(String s)\\n    {\\n        //converting days from char to Int\\n        int m=s.charAt(1)-\\'0\\'+10*(s.charAt(0)-\\'0\\'); //months\\n           int d=s.charAt(4)-\\'0\\'+10*(s.charAt(3)-\\'0\\'); //days  \\n        //calculating number of days\\n        --m;\\n        while(m>0)\\n        {\\n            d+=months[m];\\n            --m;\\n           }\\n        return d;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n     int a1 = helper(arriveAlice), a2 = helper(leaveAlice), b1 = helper(arriveBob), b2 = helper(leaveBob);\\n       //calculate intersecting days\\n       int ans = 0;\\n        for (int i = 0; i < 370; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n          }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  private  int []   months = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int helper(String s)\\n    {\\n        //converting days from char to Int\\n        int m=s.charAt(1)-\\'0\\'+10*(s.charAt(0)-\\'0\\'); //months\\n           int d=s.charAt(4)-\\'0\\'+10*(s.charAt(3)-\\'0\\'); //days  \\n        //calculating number of days\\n        --m;\\n        while(m>0)\\n        {\\n            d+=months[m];\\n            --m;\\n           }\\n        return d;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n     int a1 = helper(arriveAlice), a2 = helper(leaveAlice), b1 = helper(arriveBob), b2 = helper(leaveBob);\\n       //calculate intersecting days\\n       int ans = 0;\\n        for (int i = 0; i < 370; ++i) {\\n            if (a1 <= i && i <= a2 && b1 <= i && i <= b2) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n          }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592212,
                "title": "ok",
                "content": "```\\nint countDaysTogether(string aA, string lA, string aB, string lB) \\n{\\n\\tauto d = [](auto & s)\\n\\t\\t\\t\\t\\t\\t { \\n\\t\\t\\t\\t\\t\\t\\t int m{10*s[0]+s[1]-11*\\'0\\'}, d{10*s[3]+s[4]-11*\\'0\\'};\\n\\t\\t\\t\\t\\t\\t\\t return 30*(m-1) + (m+(m>8))/2 - 2*(m>2) + d;    \\n\\t\\t\\t\\t\\t\\t };\\n\\treturn max(0, min(d(lA), d(lB))-max(d(aA), d(aB))+1);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint countDaysTogether(string aA, string lA, string aB, string lB) \\n{\\n\\tauto d = [](auto & s)\\n\\t\\t\\t\\t\\t\\t { \\n\\t\\t\\t\\t\\t\\t\\t int m{10*s[0]+s[1]-11*\\'0\\'}, d{10*s[3]+s[4]-11*\\'0\\'};\\n\\t\\t\\t\\t\\t\\t\\t return 30*(m-1) + (m+(m>8))/2 - 2*(m>2) + d;    \\n\\t\\t\\t\\t\\t\\t };\\n\\treturn max(0, min(d(lA), d(lB))-max(d(aA), d(aB))+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592060,
                "title": "take-it-easy-0ms-100-c",
                "content": "**Please Upvote If U like the solution :**\\n\\n\\n```\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int ans=0;\\n            vector<int> days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\t\\t\\t\\n\\t\\t\\t//Calculating the sum of days till a particular month\\n            \\n            vector<int> prefixSum ;\\n            int x =0;\\n            prefixSum.push_back(x);\\n            for(int i=0; i< 12;i++){\\n                    x+=days[i];\\n                   prefixSum.push_back(x);\\n            }\\n            int a = stoi(arriveAlice.substr(0,2))  -1;  //Alice Arriving month \\n            int b = stoi(leaveAlice.substr(0,2)) -1;  //Alice Leaving month \\n            int c= stoi(arriveBob.substr(0,2)) -1;  //Bob Arriving month \\n            int d = stoi(leaveBob.substr(0,2)) -1;  //Bob Leaving month \\n            \\n\\t\\t\\t\\n\\t\\t\\t// Now, calculating the particular day corresponding to a date of Alice and Bob \\n\\t\\t\\t\\n            int Aa = prefixSum[a] + stoi(arriveAlice.substr(3,2)) ;\\n            int Al = prefixSum[b ] + stoi(leaveAlice.substr(3,2)) ;\\n            int Ba = prefixSum[c ] + stoi(arriveBob.substr(3,2)) ;\\n            int Bl = prefixSum[d ] + stoi(leaveBob.substr(3,2)) ;\\n            \\n\\t\\t\\t//Comparing \\n            \\n            if((Ba > Al) || (Aa > Bl)){\\n                    ans = 0;\\n            }else if(Ba <= Al && Ba >= Aa){\\n                    if(Al < Bl){\\n                          ans = Al - Ba +1;  \\n                    }else{\\n                          ans = Bl- Ba +1;  \\n                    }\\n            }else if(Aa <= Bl && Aa >= Ba){\\n                    if(Bl < Al){\\n                          ans = Bl - Aa+1;  \\n                    }else{\\n                          ans = Al - Aa+1;  \\n                    }\\n            }\\n           return ans;\\n\\t\\t   }\\n\\n```\\n**THANK YOU**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int ans=0;\\n            vector<int> days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\t\\t\\t\\n\\t\\t\\t//Calculating the sum of days till a particular month\\n            \\n            vector<int> prefixSum ;\\n            int x =0;\\n            prefixSum.push_back(x);\\n            for(int i=0; i< 12;i++){\\n                    x+=days[i];\\n                   prefixSum.push_back(x);\\n            }\\n            int a = stoi(arriveAlice.substr(0,2))  -1;  //Alice Arriving month \\n            int b = stoi(leaveAlice.substr(0,2)) -1;  //Alice Leaving month \\n            int c= stoi(arriveBob.substr(0,2)) -1;  //Bob Arriving month \\n            int d = stoi(leaveBob.substr(0,2)) -1;  //Bob Leaving month \\n            \\n\\t\\t\\t\\n\\t\\t\\t// Now, calculating the particular day corresponding to a date of Alice and Bob \\n\\t\\t\\t\\n            int Aa = prefixSum[a] + stoi(arriveAlice.substr(3,2)) ;\\n            int Al = prefixSum[b ] + stoi(leaveAlice.substr(3,2)) ;\\n            int Ba = prefixSum[c ] + stoi(arriveBob.substr(3,2)) ;\\n            int Bl = prefixSum[d ] + stoi(leaveBob.substr(3,2)) ;\\n            \\n\\t\\t\\t//Comparing \\n            \\n            if((Ba > Al) || (Aa > Bl)){\\n                    ans = 0;\\n            }else if(Ba <= Al && Ba >= Aa){\\n                    if(Al < Bl){\\n                          ans = Al - Ba +1;  \\n                    }else{\\n                          ans = Bl- Ba +1;  \\n                    }\\n            }else if(Aa <= Bl && Aa >= Ba){\\n                    if(Bl < Al){\\n                          ans = Bl - Aa+1;  \\n                    }else{\\n                          ans = Al - Aa+1;  \\n                    }\\n            }\\n           return ans;\\n\\t\\t   }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2591768,
                "title": "c-solution-with-explanation-beats-100-o-1-easy-to-understand",
                "content": "**DO A DRY RUN FOR BETTER CLARITY**\\n\\n***PLEASE UP-VOTE***\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int month[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  // initialising a month array for every month\\n    \\n    int  convert(string &s)   // function to convert dates to number of days \\n    {\\n        string m,d;        // extracting the character from string and storing into a variable for months\\n        m+=s[0];\\n        m+=s[1];\\n                           // we have to do this as there is an higphen (-) in the given string\\n        \\n         d+=s[3];          //extracting the character from string and storing into a variable for months\\n         d+=s[4];\\n        \\n        int count=0,i,mm,dd;   // count will store the total days for everyones arrival and departure \\n        \\n         mm=stoi(m);          // converting string to integer for months as well as for days \\n         dd=stoi(d);\\n        \\n        \\n        for( i = 0 ; i<mm ; i++){        // calculating total number of days for a given month \\n            count=count+month[i];\\n            \\n        }\\n            \\n          count+=dd;            // adding the number of days in count \\n        return count;\\n        }\\n        \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) \\n    {\\n        int arralice=convert(arriveAlice);\\n        int leaalice=convert(leaveAlice);\\n        int arrbob=convert(arriveBob);\\n        int leabob=convert(leaveBob);\\n        \\n        int arrivetime=max(arralice,arrbob);\\n        int leavetime=min(leaalice,leabob);\\n        \\n        if(arrivetime>leavetime)       // if this is the case no presence will be posssible for them together \\n            return 0;                  // therefore returning 0\\n       \\n            return leavetime-arrivetime+1;       // this will give intersection of both alice and bobs time\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int month[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}",
                "codeTag": "Java"
            },
            {
                "id": 2591757,
                "title": "c-convert-all-day-month-to-specific-i-th-day-easy-but-unefficient-approach",
                "content": "Selft Explainatory Code: Converting {i-th month,j-th day } to particuler indexed day \\nfor e.g.- 1st day of january =>{01-01} =>1.\\n...\\n             31st December=>{12-31} =>365 th day.\\n\\t\\t\\t This Brute Force Approach is just for clear understanding.\\n```\\nclass Solution {\\npublic:\\n    map<vector<int>, int>mp;\\n    int i;\\n    void day_30(int m)\\n    {\\n        for(int d=1;d<=30;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    void day_31(int m)\\n    {\\n        for(int d=1;d<=31;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    void day_28(int m)\\n    {\\n        for(int d=1;d<=28;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    int get_day(string s)\\n    {\\n        string str=s.substr(3);\\n        return stoi(str);\\n    }\\n    int get_month(string s)\\n    {\\n        string str=s.substr(0,3);\\n        return stoi(str);\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        i=1;\\n        day_31(1);\\n        day_28(2);\\n        day_31(3);\\n        day_30(4);\\n        day_31(5);\\n        day_30(6);\\n        day_31(7);\\n        day_31(8);\\n        day_30(9);\\n        day_31(10);\\n        day_30(11);\\n        day_31(12);\\n        \\n        int ad1,ad2,am1,am2;\\n        ad1=get_day(arriveAlice);\\n        ad2=get_day(leaveAlice);\\n        am1=get_month(arriveAlice);\\n        am2=get_month(leaveAlice);\\n        \\n        \\n        \\n        int bd1,bd2,bm1,bm2;\\n        bd1=get_day(arriveBob);\\n        bd2=get_day(leaveBob);\\n        bm1=get_month(arriveBob);\\n        bm2=get_month(leaveBob);\\n        \\n        vector<int>visited(366,-1);\\n        int ans=0;        \\n        \\n        for(int i=mp[{ad1,am1}];i<=mp[{ad2,am2}];i++)\\n        {\\n            visited[i]=0;\\n        }\\n\\n        for(int i=mp[{bd1,bm1}];i<=mp[{bd2,bm2}];i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUndoubtly ! Consuming too much extra space.\\nUpvote if you like it.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<vector<int>, int>mp;\\n    int i;\\n    void day_30(int m)\\n    {\\n        for(int d=1;d<=30;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    void day_31(int m)\\n    {\\n        for(int d=1;d<=31;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    void day_28(int m)\\n    {\\n        for(int d=1;d<=28;d++)\\n        {\\n            mp[{d,m}]=i;\\n            i++;\\n        }\\n        return;\\n    }\\n    int get_day(string s)\\n    {\\n        string str=s.substr(3);\\n        return stoi(str);\\n    }\\n    int get_month(string s)\\n    {\\n        string str=s.substr(0,3);\\n        return stoi(str);\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        i=1;\\n        day_31(1);\\n        day_28(2);\\n        day_31(3);\\n        day_30(4);\\n        day_31(5);\\n        day_30(6);\\n        day_31(7);\\n        day_31(8);\\n        day_30(9);\\n        day_31(10);\\n        day_30(11);\\n        day_31(12);\\n        \\n        int ad1,ad2,am1,am2;\\n        ad1=get_day(arriveAlice);\\n        ad2=get_day(leaveAlice);\\n        am1=get_month(arriveAlice);\\n        am2=get_month(leaveAlice);\\n        \\n        \\n        \\n        int bd1,bd2,bm1,bm2;\\n        bd1=get_day(arriveBob);\\n        bd2=get_day(leaveBob);\\n        bm1=get_month(arriveBob);\\n        bm2=get_month(leaveBob);\\n        \\n        vector<int>visited(366,-1);\\n        int ans=0;        \\n        \\n        for(int i=mp[{ad1,am1}];i<=mp[{ad2,am2}];i++)\\n        {\\n            visited[i]=0;\\n        }\\n\\n        for(int i=mp[{bd1,bm1}];i<=mp[{bd2,bm2}];i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591727,
                "title": "java-solution-easy-solution-intersection-of-dates",
                "content": "```java\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n               \\n        int[] month = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        \\n        String[] alice1 = arriveAlice.split(\"-\");  //Alice Arrival\\n        String[] alice2 = leaveAlice.split(\"-\");  //Alice Departure\\n        String[] bob1 = arriveBob.split(\"-\");   //Bob Arrival \\n        String[] bob2 = leaveBob.split(\"-\");   //Bob Departure\\n        \\n        int d1,d2;\\n        int ma1 = Integer.parseInt(alice1[0]);  //Alice Arrival Month\\n        int mb1 = Integer.parseInt(bob1[0]);  //Bob Arrival Month\\n        int ma2 = Integer.parseInt(alice2[0]);  //Alice Departure Month\\n        int mb2 = Integer.parseInt(bob2[0]);   //Bob Departure Month\\n        \\n        if(ma1 > mb1)\\n            d1 = Integer.parseInt(alice1[1]);\\n        else if(ma1 < mb1)\\n            d1 = Integer.parseInt(bob1[1]);\\n        else \\n            d1 = Math.max(Integer.parseInt(alice1[1]),Integer.parseInt(bob1[1]));\\n        \\n        if(ma2 < mb2)\\n            d2 = Integer.parseInt(alice2[1]);\\n        else if(ma2> mb2)\\n            d2 = Integer.parseInt(bob2[1]);\\n        else \\n            d2 = Math.min(Integer.parseInt(alice2[1]),Integer.parseInt(bob2[1]));\\n    \\n        int m1  = Math.max(ma1,mb1);\\n        int m2  = Math.min(ma2,mb2);\\n     \\n        return Math.max(0,(month[m2-1]+d2)-(month[m1-1]+d1)+1);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n               \\n        int[] month = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}",
                "codeTag": "Java"
            },
            {
                "id": 2591406,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int[] daysInMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        String startDate = arriveAlice.compareTo(arriveBob) > 0 ? arriveAlice : arriveBob;\\n        String endDate = leaveAlice.compareTo(leaveBob) < 0 ? leaveAlice : leaveBob;\\n        if(startDate.compareTo(endDate) > 0) {\\n            return 0;\\n        }\\n        int startMonth = Integer.parseInt(startDate.substring(0, 2));\\n        int startDay = Integer.parseInt(startDate.substring(3));\\n        int endMonth = Integer.parseInt(endDate.substring(0, 2));\\n        int endDay = Integer.parseInt(endDate.substring(3));\\n        \\n        if(startMonth == endMonth) {\\n            return endDay - startDay + 1;\\n        } else { \\n            int daysSpentTogether = daysInMonth[startMonth - 1] - startDay;\\n            for(int month = startMonth + 1; month < endMonth; month++) {\\n                daysSpentTogether += daysInMonth[month - 1];\\n            }\\n            daysSpentTogether += endDay + 1;\\n            return daysSpentTogether;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int[] daysInMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        String startDate = arriveAlice.compareTo(arriveBob) > 0 ? arriveAlice : arriveBob;\\n        String endDate = leaveAlice.compareTo(leaveBob) < 0 ? leaveAlice : leaveBob;\\n        if(startDate.compareTo(endDate) > 0) {\\n            return 0;\\n        }\\n        int startMonth = Integer.parseInt(startDate.substring(0, 2));\\n        int startDay = Integer.parseInt(startDate.substring(3));\\n        int endMonth = Integer.parseInt(endDate.substring(0, 2));\\n        int endDay = Integer.parseInt(endDate.substring(3));\\n        \\n        if(startMonth == endMonth) {\\n            return endDay - startDay + 1;\\n        } else { \\n            int daysSpentTogether = daysInMonth[startMonth - 1] - startDay;\\n            for(int month = startMonth + 1; month < endMonth; month++) {\\n                daysSpentTogether += daysInMonth[month - 1];\\n            }\\n            daysSpentTogether += endDay + 1;\\n            return daysSpentTogether;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591360,
                "title": "kinda-hard-to-figure-out-the-logic-for-me",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    int days(string d)\\n    {\\n        int mp[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int m=(d[0]-48)*10+(d[1]-48);\\n        int nd=(d[3]-48)*10+(d[4]-48);\\n        int ans=0;\\n        for(int i=0;i<m-1;i++)\\n            ans+=mp[i];\\n        return ans+nd;\\n        \\n    }\\n        int countDaysTogether(string aa, string la, string ab, string lb) \\n        {\\n            \\n            int cnt=0;\\n            for(int i=1;i<=365;i++)\\n            {\\n                if(days(aa)<=i && i<=days(la) && days(ab)<=i && i<=days(lb))\\n                    cnt+=1;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    int days(string d)\\n    {\\n        int mp[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int m=(d[0]-48)*10+(d[1]-48);\\n        int nd=(d[3]-48)*10+(d[4]-48);\\n        int ans=0;\\n        for(int i=0;i<m-1;i++)\\n            ans+=mp[i];\\n        return ans+nd;\\n        \\n    }\\n        int countDaysTogether(string aa, string la, string ab, string lb) \\n        {\\n            \\n            int cnt=0;\\n            for(int i=1;i<=365;i++)\\n            {\\n                if(days(aa)<=i && i<=days(la) && days(ab)<=i && i<=days(lb))\\n                    cnt+=1;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589704,
                "title": "dew-it-very-concise-java-solution-simple-and-logical",
                "content": "Break this into two problems\\n\\n**SUB-PROBLEM 1**\\n* ***Parse date string as the `n`th day of the year***\\nIllustrative examples: `01-01` is the 1st day and `12-31` is the 365th\\n* To achieve this, all we need to do is add\\n(1) the *day of the month* and\\n(2) the *number of days before the month*\\n\\nWe precompute (2) and store in a `cumu` array\\n\\n**SUB-PROBLEM 2**\\n* ***Devise logic to count overlapping days***\\nAssuming that the dates are in the \"`n`th day of the year\" format\\n* Idea 1: The first day at which the overlap *might* begin is `max(arriveAlice, arriveBob)` (3)\\nIdea 2: The last day at which the overlap *might* end is `min(leaveAlice, leaveBob)` (4)\\n\\nSo, is `(4) - (3) + 1` the answer? No\\n* Observation 1: If there IS overlap, `(4) - (3) + 1` will be positive (and equal to the answer we seek)\\nObservation 2: If there is no overlap, `(4) - (3) + 1` will be zero Or negative (in which case, the answer we seek is `0`)\\n\\nSo we return `max(0, (4) - (3) + 1)`\\n\\n```\\nclass Solution {\\n    int[] cumu = {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n    \\n    public int countDaysTogether(String a, String b, String c, String d) {\\n        return Math.max(0, 1 + Math.min(get(b), get(d)) - Math.max(get(a), get(c)));\\n    }\\n    \\n    private int get(String s) {\\n        String[] split = s.split(\"-\");\\n        return Integer.valueOf(split[1]) + cumu[Integer.valueOf(split[0])];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] cumu = {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n    \\n    public int countDaysTogether(String a, String b, String c, String d) {\\n        return Math.max(0, 1 + Math.min(get(b), get(d)) - Math.max(get(a), get(c)));\\n    }\\n    \\n    private int get(String s) {\\n        String[] split = s.split(\"-\");\\n        return Integer.valueOf(split[1]) + cumu[Integer.valueOf(split[0])];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589515,
                "title": "convert-date-to-number-in-year-o-1-clean-code-0ms",
                "content": "```\\n```\\n    int countDaysTogether(string aA, string lA, string aBob, string lBob) {\\n        int amA=stoi(aA.substr(0,2));\\n        int lmA=stoi(lA.substr(0,2));\\n        int amB=stoi(aBob.substr(0,2));\\n        int lmB=stoi(lBob.substr(0,2));\\n        \\n        int arr[13]={0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i=1;i<13;i++)\\n        {\\n            arr[i]=arr[i]+arr[i-1];\\n        }\\n        int temp1=arr[amA-1];\\n        temp1+=stoi(aA.substr(3,5));\\n                    \\n        int temp2=arr[lmA-1];\\n        temp2+=stoi(lA.substr(3,5));\\n        \\n        int temp3=arr[amB-1];\\n        temp3+=stoi(aBob.substr(3,5));\\n                    \\n        int temp4=arr[lmB-1];\\n        temp4+=stoi(lBob.substr(3,5));\\n        \\n        int mx=max(temp1,temp3);\\n        int mn=min(temp2,temp4);\\n        \\n        return max(0,mn-mx+1);\\n                    \\n    }\\n```\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589152,
                "title": "java-solution-complex-but-simple-commented-readable-code",
                "content": "#### If you understood the solution then **please upvote it** !!!\\n```\\nclass Solution {\\n    // Number of days in each month whichh will help us calculate n-th day in 0-365\\n    int[] monthDays = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  \\n    \\n    // Returns the n-th day in (0-365) days of the year\\n    private int getNthDay(int month, int day) {\\n        int totalDays = 0;\\n        for (int i = 1; i < month; i++) {\\n            totalDays += monthDays[i];\\n        }\\n        \\n        totalDays += day;\\n        return totalDays;\\n    }\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        \\n        // We split the string and make an array as {\"MM\", \"DD\"} for Alice\\n        String[] aliceArr = arriveAlice.split(\"-\");\\n        String[] aliceLea = leaveAlice.split(\"-\");\\n        \\n        // We get the month and day when Alice arrived\\n        int aliceArriveMon = Integer.parseInt(aliceArr[0]);\\n        int aliceArriveDay = Integer.parseInt(aliceArr[1]);\\n        \\n        // We get the month and day when Alice left\\n        int aliceLeaveMon = Integer.parseInt(aliceLea[0]);\\n        int aliceLeaveDay = Integer.parseInt(aliceLea[1]);\\n        \\n        \\n        // We split the string and make an array as {\"MM\", \"DD\"} for Bob\\n        String[] bobArr = arriveBob.split(\"-\");\\n        String[] bobLea = leaveBob.split(\"-\");\\n        \\n        // We get the month and day when Bob arrived\\n        int bobArriveMon = Integer.parseInt(bobArr[0]);\\n        int bobArriveDay = Integer.parseInt(bobArr[1]);\\n        \\n        // We get the month and day when Alice left\\n        int bobLeaveMon = Integer.parseInt(bobLea[0]);\\n        int bobLeaveDay = Integer.parseInt(bobLea[1]);\\n        \\n        \\n        // We get the n-th day in 0-365 when Alice arrived and left\\n        int aliceArriveNthDay = getNthDay(aliceArriveMon, aliceArriveDay);\\n        int aliceLeaveNthDay = getNthDay(aliceLeaveMon, aliceLeaveDay);\\n        \\n        // We get the n-th day in 0-365 when Bob arrived and left\\n        int bobArriveNthDay = getNthDay(bobArriveMon, bobArriveDay);\\n        int bobLeaveNthDay = getNthDay(bobLeaveMon, bobLeaveDay);\\n        \\n        \\n        // We initialise a common day count\\n        int commonDays = 0;\\n        \\n        When i falls in their common staying range we increment ans\\n        for (int i = aliceArriveNthDay; i <= aliceLeaveNthDay; i++) {\\n            if (i >= bobArriveNthDay && i <= bobLeaveNthDay) commonDays++;\\n        }\\n        \\n        return ans;\\n        \\n        // int commonDays = Math.min(aliceLeaveNthDay, bobLeaveNthDay) - Math.max(aliceArriveNthDay, bobArriveNthDay) + 1;\\n        // return Math.max(commonDays, 0);\\n    }    \\n}\\n\\n// TC: 4 * O(12) + O(365) => O(1)\\n// SC: 4 * O(2) => O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Number of days in each month whichh will help us calculate n-th day in 0-365\\n    int[] monthDays = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};  \\n    \\n    // Returns the n-th day in (0-365) days of the year\\n    private int getNthDay(int month, int day) {\\n        int totalDays = 0;\\n        for (int i = 1; i < month; i++) {\\n            totalDays += monthDays[i];\\n        }\\n        \\n        totalDays += day;\\n        return totalDays;\\n    }\\n    \\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        \\n        // We split the string and make an array as {\"MM\", \"DD\"} for Alice\\n        String[] aliceArr = arriveAlice.split(\"-\");\\n        String[] aliceLea = leaveAlice.split(\"-\");\\n        \\n        // We get the month and day when Alice arrived\\n        int aliceArriveMon = Integer.parseInt(aliceArr[0]);\\n        int aliceArriveDay = Integer.parseInt(aliceArr[1]);\\n        \\n        // We get the month and day when Alice left\\n        int aliceLeaveMon = Integer.parseInt(aliceLea[0]);\\n        int aliceLeaveDay = Integer.parseInt(aliceLea[1]);\\n        \\n        \\n        // We split the string and make an array as {\"MM\", \"DD\"} for Bob\\n        String[] bobArr = arriveBob.split(\"-\");\\n        String[] bobLea = leaveBob.split(\"-\");\\n        \\n        // We get the month and day when Bob arrived\\n        int bobArriveMon = Integer.parseInt(bobArr[0]);\\n        int bobArriveDay = Integer.parseInt(bobArr[1]);\\n        \\n        // We get the month and day when Alice left\\n        int bobLeaveMon = Integer.parseInt(bobLea[0]);\\n        int bobLeaveDay = Integer.parseInt(bobLea[1]);\\n        \\n        \\n        // We get the n-th day in 0-365 when Alice arrived and left\\n        int aliceArriveNthDay = getNthDay(aliceArriveMon, aliceArriveDay);\\n        int aliceLeaveNthDay = getNthDay(aliceLeaveMon, aliceLeaveDay);\\n        \\n        // We get the n-th day in 0-365 when Bob arrived and left\\n        int bobArriveNthDay = getNthDay(bobArriveMon, bobArriveDay);\\n        int bobLeaveNthDay = getNthDay(bobLeaveMon, bobLeaveDay);\\n        \\n        \\n        // We initialise a common day count\\n        int commonDays = 0;\\n        \\n        When i falls in their common staying range we increment ans\\n        for (int i = aliceArriveNthDay; i <= aliceLeaveNthDay; i++) {\\n            if (i >= bobArriveNthDay && i <= bobLeaveNthDay) commonDays++;\\n        }\\n        \\n        return ans;\\n        \\n        // int commonDays = Math.min(aliceLeaveNthDay, bobLeaveNthDay) - Math.max(aliceArriveNthDay, bobArriveNthDay) + 1;\\n        // return Math.max(commonDays, 0);\\n    }    \\n}\\n\\n// TC: 4 * O(12) + O(365) => O(1)\\n// SC: 4 * O(2) => O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588941,
                "title": "rust-solution",
                "content": "~~~\\nimpl Solution {\\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 {\\n        let a = arrive_alice.max(arrive_bob).chars().collect::<Vec<char>>();\\n        let d = leave_alice.min(leave_bob).chars().collect::<Vec<char>>();\\n        \\n        let mut ma = (a[0] as u8 - \\'0\\' as u8) * 10 + a[1] as u8 - \\'0\\' as u8;\\n        let md = (d[0] as u8 - \\'0\\' as u8) * 10 + d[1] as u8 - \\'0\\' as u8;\\n        if ma > md { return 0 }\\n        \\n        let mut ret = 0;\\n        while ma < md {\\n            match ma {\\n                1 | 3 | 5 | 7 | 8 | 10 => { ret += 31; }\\n                2 => { ret += 28; }\\n                _ => { ret += 30; }\\n            }\\n            ma += 1;\\n        }\\n        \\n        let da = (a[3] as u8 - \\'0\\' as u8) * 10 + a[4] as u8 - \\'0\\' as u8;\\n        let dd = (d[3] as u8 - \\'0\\' as u8) * 10 + d[4] as u8 - \\'0\\' as u8;\\n        \\n        0.max(ret as i32 + dd as i32 - da as i32 + 1)\\n        \\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 {\\n        let a = arrive_alice.max(arrive_bob).chars().collect::<Vec<char>>();\\n        let d = leave_alice.min(leave_bob).chars().collect::<Vec<char>>();\\n        \\n        let mut ma = (a[0] as u8 - \\'0\\' as u8) * 10 + a[1] as u8 - \\'0\\' as u8;\\n        let md = (d[0] as u8 - \\'0\\' as u8) * 10 + d[1] as u8 - \\'0\\' as u8;\\n        if ma > md { return 0 }\\n        \\n        let mut ret = 0;\\n        while ma < md {\\n            match ma {\\n                1 | 3 | 5 | 7 | 8 | 10 => { ret += 31; }\\n                2 => { ret += 28; }\\n                _ => { ret += 30; }\\n            }\\n            ma += 1;\\n        }\\n        \\n        let da = (a[3] as u8 - \\'0\\' as u8) * 10 + a[4] as u8 - \\'0\\' as u8;\\n        let dd = (d[3] as u8 - \\'0\\' as u8) * 10 + d[4] as u8 - \\'0\\' as u8;\\n        \\n        0.max(ret as i32 + dd as i32 - da as i32 + 1)\\n        \\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2588686,
                "title": "c-easy-to-understanding-solution-small-code",
                "content": "- Just Convert date to which day in year i.e. \"01-15\" is 15th day , like \"02-14\" is 45th day and \"03-27\" is 86th day in year\\n```\\nclass Solution {\\npublic:\\n    int dayInMonths[13] = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n\\t// function for converting string in which day in year\\n    int days(string s){\\n        int month = s[1]-\\'0\\' + 10*(s[0]-\\'0\\');\\n        int day = s[4]-\\'0\\' + 10*(s[3]-\\'0\\');\\n        month--;\\n        while(month){\\n            day += dayInMonths[month];\\n            month--;       \\n        }\\n        return day;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a1 = days(arriveAlice);\\n        int a2 = days(leaveAlice);\\n        int b1 = days(arriveBob);\\n        int b2 = days(leaveBob);\\n\\n        return max(0,min(a2,b2)-max(a1,b1)+1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dayInMonths[13] = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n\\t// function for converting string in which day in year\\n    int days(string s){\\n        int month = s[1]-\\'0\\' + 10*(s[0]-\\'0\\');\\n        int day = s[4]-\\'0\\' + 10*(s[3]-\\'0\\');\\n        month--;\\n        while(month){\\n            day += dayInMonths[month];\\n            month--;       \\n        }\\n        return day;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a1 = days(arriveAlice);\\n        int a2 = days(leaveAlice);\\n        int b1 = days(arriveBob);\\n        int b2 = days(leaveBob);\\n\\n        return max(0,min(a2,b2)-max(a1,b1)+1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588680,
                "title": "c-convert-date-to-days-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDays(string s){\\n        vector<int> m = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int days = 0;\\n        int month = stoi(s.substr(0,2));\\n        int date = stoi(s.substr(3,2));\\n        \\n        for(int i=0; i<month-1; i++){\\n            days += m[i];\\n        }\\n        days += date;\\n        return days;\\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aa = getDays(arriveAlice);\\n        int la = getDays(leaveAlice);\\n        int ab = getDays(arriveBob);\\n        int lb = getDays(leaveBob);\\n        \\n        return max(0,min(la, lb)-max(aa, ab)+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDays(string s){\\n        vector<int> m = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int days = 0;\\n        int month = stoi(s.substr(0,2));\\n        int date = stoi(s.substr(3,2));\\n        \\n        for(int i=0; i<month-1; i++){\\n            days += m[i];\\n        }\\n        days += date;\\n        return days;\\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aa = getDays(arriveAlice);\\n        int la = getDays(leaveAlice);\\n        int ab = getDays(arriveBob);\\n        int lb = getDays(leaveBob);\\n        \\n        return max(0,min(la, lb)-max(aa, ab)+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588642,
                "title": "java-easy-solution",
                "content": "First of all calculate the total number of days from 1st jan for each arrival and departure of Alice and Bob since inputs are in the same year.\\nFor example : Arrival time of Bob is \\'03-05\\' which means 5th of March, so total number of days from 1st jan will be 64 days.\\nNow check who will arrive first like for example if Alice arrive first , now the arrival days of Bob should be less than departure of Alice otherwise they will not meet. \\n\\n```\\nclass Solution \\n{\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) \\n    {\\n        int aamon = Integer.parseInt(arriveAlice.substring(0,2));\\n        int aadate = Integer.parseInt(arriveAlice.substring(3));\\n        int almon = Integer.parseInt(leaveAlice.substring(0,2));\\n        int aldate = Integer.parseInt(leaveAlice.substring(3));\\n        int bamon = Integer.parseInt(arriveBob.substring(0,2));\\n        int badate = Integer.parseInt(arriveBob.substring(3));\\n        int blmon = Integer.parseInt(leaveBob.substring(0,2));\\n        int bldate = Integer.parseInt(leaveBob.substring(3));\\n        \\n        int a[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aarrive=0,aleave=0,barrive=0,bleave=0;\\n        int i;\\n        for(i=0;i<aamon-1;i++)\\n            aarrive+=a[i];\\n        aarrive+=aadate;\\n       \\n        for(i=0;i<almon-1;i++)\\n            aleave+=a[i];\\n        aleave+=aldate;\\n        \\n        for(i=0;i<bamon-1;i++)\\n            barrive+=a[i];\\n        barrive+=badate;\\n      \\n        for(i=0;i<blmon-1;i++)\\n            bleave+=a[i];\\n        bleave+=bldate;\\n      \\n        if(aarrive<=barrive)\\n        {\\n            if(aleave<barrive)\\n                return 0;\\n            else\\n                return Math.min(bleave,aleave)-barrive+1; // this condition is used for checking who will \\n\\t\\t\\t\\t//leave the town first till then only we will count the answer.\\n        }\\n        else\\n        {\\n            if(bleave<aarrive)\\n                return 0;\\n            else\\n            {\\n                return Math.min(bleave,aleave)-aarrive+1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) \\n    {\\n        int aamon = Integer.parseInt(arriveAlice.substring(0,2));\\n        int aadate = Integer.parseInt(arriveAlice.substring(3));\\n        int almon = Integer.parseInt(leaveAlice.substring(0,2));\\n        int aldate = Integer.parseInt(leaveAlice.substring(3));\\n        int bamon = Integer.parseInt(arriveBob.substring(0,2));\\n        int badate = Integer.parseInt(arriveBob.substring(3));\\n        int blmon = Integer.parseInt(leaveBob.substring(0,2));\\n        int bldate = Integer.parseInt(leaveBob.substring(3));\\n        \\n        int a[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aarrive=0,aleave=0,barrive=0,bleave=0;\\n        int i;\\n        for(i=0;i<aamon-1;i++)\\n            aarrive+=a[i];\\n        aarrive+=aadate;\\n       \\n        for(i=0;i<almon-1;i++)\\n            aleave+=a[i];\\n        aleave+=aldate;\\n        \\n        for(i=0;i<bamon-1;i++)\\n            barrive+=a[i];\\n        barrive+=badate;\\n      \\n        for(i=0;i<blmon-1;i++)\\n            bleave+=a[i];\\n        bleave+=bldate;\\n      \\n        if(aarrive<=barrive)\\n        {\\n            if(aleave<barrive)\\n                return 0;\\n            else\\n                return Math.min(bleave,aleave)-barrive+1; // this condition is used for checking who will \\n\\t\\t\\t\\t//leave the town first till then only we will count the answer.\\n        }\\n        else\\n        {\\n            if(bleave<aarrive)\\n                return 0;\\n            else\\n            {\\n                return Math.min(bleave,aleave)-aarrive+1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588618,
                "title": "c-0ms-explained",
                "content": "**Approach:**\\n\\n* convert the date into the number of days of that year\\n* example:\\n\\t* \"01-26\" is the 26th day of the year\\n\\t* \"02-26\" is the 57th day of the year\\n* now let alice arrives between a0 and a1 day \\n* and bob arrives between b0 and b1 day\\n* so just check for every day of the year how many days fall in both of the above category\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> v = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int solve(string s)\\n    {\\n        int m = (s[0] - \\'0\\') * 10 + (s[1] - \\'0\\');\\n        int d = (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n        m--;\\n        while (m > 0)\\n        {\\n            d += v[m];\\n            m--;\\n        }\\n        return d;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        int a0 = solve(arriveAlice);\\n        int a1 = solve(leaveAlice);\\n        int b0 = solve(arriveBob);\\n        int b1 = solve(leaveBob);\\n        int ans = 0;\\n        for (int i = 0; i < 366; i++)\\n            if ((i >= a0 && i <= a1) && (i >= b0 && i <= b1))\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> v = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int solve(string s)\\n    {\\n        int m = (s[0] - \\'0\\') * 10 + (s[1] - \\'0\\');\\n        int d = (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n        m--;\\n        while (m > 0)\\n        {\\n            d += v[m];\\n            m--;\\n        }\\n        return d;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        int a0 = solve(arriveAlice);\\n        int a1 = solve(leaveAlice);\\n        int b0 = solve(arriveBob);\\n        int b1 = solve(leaveBob);\\n        int ans = 0;\\n        for (int i = 0; i < 366; i++)\\n            if ((i >= a0 && i <= a1) && (i >= b0 && i <= b1))\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588594,
                "title": "c-solution-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int> days {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int total_days=0;\\n        int aliceArriveMonth = stoi(arriveAlice.substr(0,2)), aliceLeaveMonth = stoi(leaveAlice.substr(0,2)), aliceArriveDay = stoi(arriveAlice.substr(3,2)), aliceLeaveDay = stoi(leaveAlice.substr(3,2));\\n        int bobArriveMonth = stoi(arriveBob.substr(0,2)), bobLeaveMonth = stoi(leaveBob.substr(0,2)), bobArriveDay = stoi(arriveBob.substr(3,2)), bobLeaveDay = stoi(leaveBob.substr(3,2));\\n        if(aliceLeaveMonth<bobArriveMonth || (aliceLeaveMonth==bobArriveMonth && aliceLeaveDay<bobArriveDay) || bobLeaveMonth<aliceArriveMonth || (bobLeaveMonth==aliceArriveMonth && bobLeaveDay<aliceArriveDay)) return 0;\\n        int start = aliceArriveMonth>bobArriveMonth?aliceArriveDay:aliceArriveMonth==bobArriveMonth?max(aliceArriveDay,bobArriveDay):bobArriveDay;\\n        int end = aliceLeaveMonth>bobLeaveMonth?bobLeaveDay:aliceLeaveMonth==bobLeaveMonth?min(aliceLeaveDay,bobLeaveDay):aliceLeaveDay;\\n        for(int i=max(aliceArriveMonth,bobArriveMonth); i<min(aliceLeaveMonth,bobLeaveMonth); ++i)\\n          total_days+=days[i];\\n        total_days+=(end-start+1);\\n        return total_days;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        vector<int> days {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int total_days=0;\\n        int aliceArriveMonth = stoi(arriveAlice.substr(0,2)), aliceLeaveMonth = stoi(leaveAlice.substr(0,2)), aliceArriveDay = stoi(arriveAlice.substr(3,2)), aliceLeaveDay = stoi(leaveAlice.substr(3,2));\\n        int bobArriveMonth = stoi(arriveBob.substr(0,2)), bobLeaveMonth = stoi(leaveBob.substr(0,2)), bobArriveDay = stoi(arriveBob.substr(3,2)), bobLeaveDay = stoi(leaveBob.substr(3,2));\\n        if(aliceLeaveMonth<bobArriveMonth || (aliceLeaveMonth==bobArriveMonth && aliceLeaveDay<bobArriveDay) || bobLeaveMonth<aliceArriveMonth || (bobLeaveMonth==aliceArriveMonth && bobLeaveDay<aliceArriveDay)) return 0;\\n        int start = aliceArriveMonth>bobArriveMonth?aliceArriveDay:aliceArriveMonth==bobArriveMonth?max(aliceArriveDay,bobArriveDay):bobArriveDay;\\n        int end = aliceLeaveMonth>bobLeaveMonth?bobLeaveDay:aliceLeaveMonth==bobLeaveMonth?min(aliceLeaveDay,bobLeaveDay):aliceLeaveDay;\\n        for(int i=max(aliceArriveMonth,bobArriveMonth); i<min(aliceLeaveMonth,bobLeaveMonth); ++i)\\n          total_days+=days[i];\\n        total_days+=(end-start+1);\\n        return total_days;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588557,
                "title": "c-easy-clean-solution",
                "content": "**C++ Code:**\\n\\n```\\n int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int arr[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        \\n        int ma1 = stoi(arriveAlice.substr(0,2)),ma2 = stoi(arriveBob.substr(0,2));\\n        int mb1 = stoi(leaveAlice.substr(0,2)),mb2 = stoi(leaveBob.substr(0,2));\\n        int da1 = stoi(arriveAlice.substr(3)),da2 = stoi(arriveBob.substr(3));\\n        int db1 = stoi(leaveAlice.substr(3)),db2 = stoi(leaveBob.substr(3));\\n        \\n        int m1 = max(ma1,ma2);\\n        int m2 = min(mb1,mb2);\\n        if(m1>m2) return 0;  // edge case\\n        \\n        int d1,d2;\\n        // date of arrival\\n        if(ma1<ma2) d1 = da2;\\n        else if(ma1>ma2) d1 = da1;\\n        else d1 = max(da1,da2);\\n        \\n        // date of leaving\\n        if(mb1<mb2) d2 = db1;\\n        else if(mb1>mb2) d2 = db2;\\n        else d2 = min(db1,db2);\\n             \\n        if(m1==m2 && d1>d2) return 0; // edge case\\n        if(m1==m2) return d2-d1+1;\\n        else {\\n            int ans = arr[m1-1]-d1+1;\\n            while(m1+1!=m2){\\n             ans += arr[m1];\\n                m1++;\\n            }\\n            ans += d2;\\n            return ans;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int arr[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\\n        \\n        int ma1 = stoi(arriveAlice.substr(0,2)),ma2 = stoi(arriveBob.substr(0,2));\\n        int mb1 = stoi(leaveAlice.substr(0,2)),mb2 = stoi(leaveBob.substr(0,2));\\n        int da1 = stoi(arriveAlice.substr(3)),da2 = stoi(arriveBob.substr(3));\\n        int db1 = stoi(leaveAlice.substr(3)),db2 = stoi(leaveBob.substr(3));\\n        \\n        int m1 = max(ma1,ma2);\\n        int m2 = min(mb1,mb2);\\n        if(m1>m2) return 0;  // edge case\\n        \\n        int d1,d2;\\n        // date of arrival\\n        if(ma1<ma2) d1 = da2;\\n        else if(ma1>ma2) d1 = da1;\\n        else d1 = max(da1,da2);\\n        \\n        // date of leaving\\n        if(mb1<mb2) d2 = db1;\\n        else if(mb1>mb2) d2 = db2;\\n        else d2 = min(db1,db2);\\n             \\n        if(m1==m2 && d1>d2) return 0; // edge case\\n        if(m1==m2) return d2-d1+1;\\n        else {\\n            int ans = arr[m1-1]-d1+1;\\n            while(m1+1!=m2){\\n             ans += arr[m1];\\n                m1++;\\n            }\\n            ans += d2;\\n            return ans;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588498,
                "title": "simple-solution-using-map",
                "content": "```\\n   int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        map<string,int>m;\\n        \\n        m[\"01\"]=0;\\n        m[\"02\"]=31;\\n        m[\"03\"]=59;\\n        m[\"04\"]=90;\\n        m[\"05\"]=120;\\n        m[\"06\"]=151;\\n        m[\"07\"]=181;\\n        m[\"08\"]=212;\\n        m[\"09\"]=243;\\n        m[\"10\"]=273;\\n        m[\"11\"]=304;\\n        m[\"12\"]=334;\\n        \\n        string aam=\"\";\\n        string aad=\"\";\\n        aam+=arriveAlice[0];\\n        aam+=arriveAlice[1];\\n        aad+=arriveAlice[3];\\n        aad+=arriveAlice[4];   \\n        int aliceA= m[(aam)]+stoi(aad);\\n        \\n       \\n     \\n        \\n        string alm=\"\";\\n        string ald=\"\";\\n        \\n         alm+=leaveAlice[0];\\n        alm+=leaveAlice[1];\\n         ald+=leaveAlice[3];\\n        ald+=leaveAlice[4];        \\n        int aliceL= m[(alm)]+stoi(ald);\\n        \\n        \\n        string bam=\"\";\\n        string bad=\"\";\\n        string blm=\"\";\\n        string bld=\"\";\\n        bam+=arriveBob[0];\\n        bam+=arriveBob[1];\\n         bad+=arriveBob[3];\\n        bad+=arriveBob[4];        \\n        int bobA= m[(bam)]+stoi(bad);\\n        \\n         blm+=leaveBob[0];\\n        blm+=leaveBob[1];\\n         bld+=leaveBob[3];\\n        bld+=leaveBob[4];        \\n        int bobL= m[(blm)]+stoi(bld);\\n        \\n        \\n        if(aliceL>=bobA and aliceA<=bobA)return min(bobL, aliceL)-bobA+1;\\n        if(bobL>=aliceA and bobA<=aliceA)return min(aliceL, bobL)-aliceA+1;\\n        \\n        return 0;\\n \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        map<string,int>m;\\n        \\n        m[\"01\"]=0;\\n        m[\"02\"]=31;\\n        m[\"03\"]=59;\\n        m[\"04\"]=90;\\n        m[\"05\"]=120;\\n        m[\"06\"]=151;\\n        m[\"07\"]=181;\\n        m[\"08\"]=212;\\n        m[\"09\"]=243;\\n        m[\"10\"]=273;\\n        m[\"11\"]=304;\\n        m[\"12\"]=334;\\n        \\n        string aam=\"\";\\n        string aad=\"\";\\n        aam+=arriveAlice[0];\\n        aam+=arriveAlice[1];\\n        aad+=arriveAlice[3];\\n        aad+=arriveAlice[4];   \\n        int aliceA= m[(aam)]+stoi(aad);\\n        \\n       \\n     \\n        \\n        string alm=\"\";\\n        string ald=\"\";\\n        \\n         alm+=leaveAlice[0];\\n        alm+=leaveAlice[1];\\n         ald+=leaveAlice[3];\\n        ald+=leaveAlice[4];        \\n        int aliceL= m[(alm)]+stoi(ald);\\n        \\n        \\n        string bam=\"\";\\n        string bad=\"\";\\n        string blm=\"\";\\n        string bld=\"\";\\n        bam+=arriveBob[0];\\n        bam+=arriveBob[1];\\n         bad+=arriveBob[3];\\n        bad+=arriveBob[4];        \\n        int bobA= m[(bam)]+stoi(bad);\\n        \\n         blm+=leaveBob[0];\\n        blm+=leaveBob[1];\\n         bld+=leaveBob[3];\\n        bld+=leaveBob[4];        \\n        int bobL= m[(blm)]+stoi(bld);\\n        \\n        \\n        if(aliceL>=bobA and aliceA<=bobA)return min(bobL, aliceL)-bobA+1;\\n        if(bobL>=aliceA and bobA<=aliceA)return min(aliceL, bobL)-aliceA+1;\\n        \\n        return 0;\\n \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588336,
                "title": "easy-solution-please-upvote",
                "content": "Hello, I used intersection in this solution. I can\\'t solve it during contest time but I could solve it myself)\\nIf you dont understand this solution you can leave comment, I will explain you. PLEASE UPVOTE)\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string a, string b, string c, string d) {\\n      int kalendar[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n      int p[100]; p[0] = 0;\\n      for (int i = 1; i <= 12; ++i) {\\n        p[i] = p[i - 1] + kalendar[i];\\n      }\\n      int a1 = ((a[0] - \\'0\\') * 10 + a[1] - \\'0\\');\\n      int a2 = ((a[3] - \\'0\\') * 10 + a[4] - \\'0\\');\\n      int b1 = ((b[0] - \\'0\\') * 10 + b[1] - \\'0\\');\\n      int b2 = ((b[3] - \\'0\\') * 10 + b[4] - \\'0\\');\\n      int c1 = ((c[0] - \\'0\\') * 10 + c[1] - \\'0\\');\\n      int c2 = ((c[3] - \\'0\\') * 10 + c[4] - \\'0\\');\\n      int d1 = ((d[0] - \\'0\\') * 10 + d[1] - \\'0\\');\\n      int d2 = ((d[3] - \\'0\\') * 10 + d[4] - \\'0\\');\\n      int s1 = p[a1 - 1] + a2;\\n      int s2 = p[b1 - 1] + b2;\\n      int s3 = p[c1 - 1] + c2;\\n      int s4 = p[d1 - 1] + d2;\\n      int x = max(s1, s3);\\n      int y = min(s2, s4);\\n      if (y - x < 0) return 0;\\n      return y - x + 1;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string a, string b, string c, string d) {\\n      int kalendar[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n      int p[100]; p[0] = 0;\\n      for (int i = 1; i <= 12; ++i) {\\n        p[i] = p[i - 1] + kalendar[i];\\n      }\\n      int a1 = ((a[0] - \\'0\\') * 10 + a[1] - \\'0\\');\\n      int a2 = ((a[3] - \\'0\\') * 10 + a[4] - \\'0\\');\\n      int b1 = ((b[0] - \\'0\\') * 10 + b[1] - \\'0\\');\\n      int b2 = ((b[3] - \\'0\\') * 10 + b[4] - \\'0\\');\\n      int c1 = ((c[0] - \\'0\\') * 10 + c[1] - \\'0\\');\\n      int c2 = ((c[3] - \\'0\\') * 10 + c[4] - \\'0\\');\\n      int d1 = ((d[0] - \\'0\\') * 10 + d[1] - \\'0\\');\\n      int d2 = ((d[3] - \\'0\\') * 10 + d[4] - \\'0\\');\\n      int s1 = p[a1 - 1] + a2;\\n      int s2 = p[b1 - 1] + b2;\\n      int s3 = p[c1 - 1] + c2;\\n      int s4 = p[d1 - 1] + d2;\\n      int x = max(s1, s3);\\n      int y = min(s2, s4);\\n      if (y - x < 0) return 0;\\n      return y - x + 1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588255,
                "title": "c-naive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int months[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int f(string a, string b){\\n        \\n        int m1 = stoi(a.substr(0,2));\\n        int d1 = stoi(a.substr(3,2));\\n        \\n        int m2 = stoi(b.substr(0,2));\\n        int d2 = stoi(b.substr(3,2));\\n                \\n        if(m1==m2) return abs(d1-d2)+1;\\n        \\n        int sum = 0;\\n        \\n        if(m1>m2){\\n            \\n            sum+=abs(months[m2-1]-d2)+d1+1;\\n            \\n            if(m1-m2>1){\\n                \\n                for(int i=m2+1;i<=m1-1;i++) sum+=months[i-1];\\n\\n            }\\n            \\n            return sum;\\n            \\n        } \\n        sum=0;\\n        if(m1<m2){\\n            \\n            sum+=abs(months[m1-1]-d1)+d2+1;\\n            \\n            if(m2-m1>1){\\n                \\n                for(int i=m1+1;i<=m2-1;i++) sum+=months[i-1];\\n\\n            }\\n            return sum;\\n\\n        }\\n        \\n        return sum;\\n\\n    }\\n    \\n    \\n    int countDaysTogether(string a1, string a2, string b1, string b2) {\\n        \\n        \\n        if(a1==b1 and a2==b2) return f(a1, a2);\\n        if(a1<b1 and a2<b2 and a2>b1) return f(a2, b1);\\n        if(b1<a1 and b2<a2 and b2>a1) return f(b2, a1);\\n        if(a2<b1 or b2<a1) return 0;\\n        if(b2<a1 or a2<b1) return 0;\\n        if(b1>a1 and b2>a1 and b1<a2 and b2<a2) return f(b1, b2);\\n        if(a1>b1 and a2>b1 and a1<b2 and a2<b2) return f(a1, a2);        \\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int months[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int f(string a, string b){\\n        \\n        int m1 = stoi(a.substr(0,2));\\n        int d1 = stoi(a.substr(3,2));\\n        \\n        int m2 = stoi(b.substr(0,2));\\n        int d2 = stoi(b.substr(3,2));\\n                \\n        if(m1==m2) return abs(d1-d2)+1;\\n        \\n        int sum = 0;\\n        \\n        if(m1>m2){\\n            \\n            sum+=abs(months[m2-1]-d2)+d1+1;\\n            \\n            if(m1-m2>1){\\n                \\n                for(int i=m2+1;i<=m1-1;i++) sum+=months[i-1];\\n\\n            }\\n            \\n            return sum;\\n            \\n        } \\n        sum=0;\\n        if(m1<m2){\\n            \\n            sum+=abs(months[m1-1]-d1)+d2+1;\\n            \\n            if(m2-m1>1){\\n                \\n                for(int i=m1+1;i<=m2-1;i++) sum+=months[i-1];\\n\\n            }\\n            return sum;\\n\\n        }\\n        \\n        return sum;\\n\\n    }\\n    \\n    \\n    int countDaysTogether(string a1, string a2, string b1, string b2) {\\n        \\n        \\n        if(a1==b1 and a2==b2) return f(a1, a2);\\n        if(a1<b1 and a2<b2 and a2>b1) return f(a2, b1);\\n        if(b1<a1 and b2<a2 and b2>a1) return f(b2, a1);\\n        if(a2<b1 or b2<a1) return 0;\\n        if(b2<a1 or a2<b1) return 0;\\n        if(b1>a1 and b2>a1 and b1<a2 and b2<a2) return f(b1, b2);\\n        if(a1>b1 and a2>b1 and a1<b2 and a2<b2) return f(a1, a2);        \\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588224,
                "title": "easiest-c-solution-0ms",
                "content": "```\\n  int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n        {\\n            const int monthDays[12] = { 31,\\n                28,\\n                31,\\n                30,\\n                31,\\n                30,\\n                31,\\n                31,\\n                30,\\n                31,\\n                30,\\n                31\\n            };\\n            int Alice_arr_day = stoi(arriveAlice.substr(3, 5)), Alice_arr_month = stoi(arriveAlice.substr(0, 2)), Bob_arr_day = stoi(arriveBob.substr(3, 5)), Bob_arr_month = stoi(arriveBob.substr(0, 2));\\n            int Alice_leave_day = stoi(leaveAlice.substr(3, 5)), Alice_leave_month = stoi(leaveAlice.substr(0, 2)), Bob_leave_day = stoi(leaveBob.substr(3, 5)), Bob_leave_month = stoi(leaveBob.substr(0, 2));\\n            for (int i = 0; i < Alice_arr_month - 1; i++)\\n                Alice_arr_day += monthDays[i];\\n\\n            for (int i = 0; i < Bob_arr_month - 1; i++)\\n                Bob_arr_day += monthDays[i];\\n            for (int i = 0; i < Alice_leave_month - 1; i++)\\n                Alice_leave_day += monthDays[i];\\n\\n            for (int i = 0; i < Bob_leave_month - 1; i++)\\n                Bob_leave_day += monthDays[i];\\n            int arr = max(Alice_arr_day, Bob_arr_day), dep = min(Alice_leave_day, Bob_leave_day);\\n            if (dep < arr) return 0;\\n            return (dep - arr + 1);\\n        }\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n        {\\n            const int monthDays[12] = { 31,\\n                28,\\n                31,\\n                30,\\n                31,\\n                30,\\n                31,\\n                31,\\n                30,\\n                31,\\n                30,\\n                31\\n            };\\n            int Alice_arr_day = stoi(arriveAlice.substr(3, 5)), Alice_arr_month = stoi(arriveAlice.substr(0, 2)), Bob_arr_day = stoi(arriveBob.substr(3, 5)), Bob_arr_month = stoi(arriveBob.substr(0, 2));\\n            int Alice_leave_day = stoi(leaveAlice.substr(3, 5)), Alice_leave_month = stoi(leaveAlice.substr(0, 2)), Bob_leave_day = stoi(leaveBob.substr(3, 5)), Bob_leave_month = stoi(leaveBob.substr(0, 2));\\n            for (int i = 0; i < Alice_arr_month - 1; i++)\\n                Alice_arr_day += monthDays[i];\\n\\n            for (int i = 0; i < Bob_arr_month - 1; i++)\\n                Bob_arr_day += monthDays[i];\\n            for (int i = 0; i < Alice_leave_month - 1; i++)\\n                Alice_leave_day += monthDays[i];\\n\\n            for (int i = 0; i < Bob_leave_month - 1; i++)\\n                Bob_leave_day += monthDays[i];\\n            int arr = max(Alice_arr_day, Bob_arr_day), dep = min(Alice_leave_day, Bob_leave_day);\\n            if (dep < arr) return 0;\\n            return (dep - arr + 1);\\n        }\\n\\t\\t\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2588158,
                "title": "very-easy-c-convert-date-string-to-absolute-dates-easy-explaination",
                "content": "I feel this problem is quite similar in approach to <a href=\\'https://leetcode.com/problems/merge-intervals/\\'>Merge Intervals Problem </a>.\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        //Firstly calculate the number of days elapsed in the year before current month started\\n        //We\\'ll use this later to get absolute date by adding these values to given date\\n        //You can also create this vector using for loop on [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        vector<int> prefixSumMonths{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        \\n        int arriveA, leaveA, arriveB, leaveB;\\n        \\n        // Now we store values of absolute dates in these 4 variables i.e. date in the range of [0, 365]\\n        \\n        arriveA = prefixSumMonths[stoi(arriveAlice.substr(0, 2)) - 1] + stoi(arriveAlice.substr(3, 2));\\n        leaveA = prefixSumMonths[stoi(leaveAlice.substr(0, 2)) - 1] + stoi(leaveAlice.substr(3, 2));\\n        arriveB = prefixSumMonths[stoi(arriveBob.substr(0, 2)) - 1] + stoi(arriveBob.substr(3, 2));\\n        leaveB = prefixSumMonths[stoi(leaveBob.substr(0, 2)) - 1] + stoi(leaveBob.substr(3, 2));\\n        \\n        // if this condition occurs then both A & B never spent time together        \\n        if(leaveA < arriveB || leaveB < arriveA)\\n        return 0;\\n        \\n        return abs(max(arriveA, arriveB) - min(leaveA, leaveB)) + 1;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        //Firstly calculate the number of days elapsed in the year before current month started\\n        //We\\'ll use this later to get absolute date by adding these values to given date\\n        //You can also create this vector using for loop on [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        vector<int> prefixSumMonths{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n        \\n        int arriveA, leaveA, arriveB, leaveB;\\n        \\n        // Now we store values of absolute dates in these 4 variables i.e. date in the range of [0, 365]\\n        \\n        arriveA = prefixSumMonths[stoi(arriveAlice.substr(0, 2)) - 1] + stoi(arriveAlice.substr(3, 2));\\n        leaveA = prefixSumMonths[stoi(leaveAlice.substr(0, 2)) - 1] + stoi(leaveAlice.substr(3, 2));\\n        arriveB = prefixSumMonths[stoi(arriveBob.substr(0, 2)) - 1] + stoi(arriveBob.substr(3, 2));\\n        leaveB = prefixSumMonths[stoi(leaveBob.substr(0, 2)) - 1] + stoi(leaveBob.substr(3, 2));\\n        \\n        // if this condition occurs then both A & B never spent time together        \\n        if(leaveA < arriveB || leaveB < arriveA)\\n        return 0;\\n        \\n        return abs(max(arriveA, arriveB) - min(leaveA, leaveB)) + 1;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588118,
                "title": "meaning-less-question-40ms-python",
                "content": "\\tclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        a1,b1 = arriveAlice.split(\"-\")\\n        a1,b1 = int(a1),int(b1)\\n        \\n        a2,b2 = leaveAlice.split(\"-\")\\n        a2,b2 = int(a2),int(b2)\\n        \\n        c1,d1 = arriveBob.split(\"-\")\\n        c1,d1 = int(c1),int(d1)\\n        \\n        c2,d2 = leaveBob.split(\"-\")\\n        c2,d2 = int(c2),int(d2)\\n        \\n        \\n        y = {\\n            1 : 31,\\n            2 : 28,\\n            3 : 31,\\n            4 : 30,\\n            5 :  31,\\n            6 :  30,\\n            7 :  31,\\n            8  : 31,\\n            9  : 30,\\n            10 : 31,\\n            11:  30,\\n            12 : 31\\n        }\\n        \\n        s1 = []\\n        s2 = []\\n        \\n        \\n        flag = 0\\n        while a1<=a2:\\n            \\n            start = b1 if flag ==0 else  1\\n            for date in range(start,y[a1]+1):\\n                if a1==a2 and date>b2:\\n                    break\\n                s1.append(str(date)+\"-\"+str(a1))\\n            flag=1\\n            a1+=1\\n\\n            \\n        # print(s1)\\n        \\n        flag = 0\\n        while c1<=c2:\\n            start = d1 if flag ==0 else  1\\n            for date in range(start,y[c1]+1):\\n                if c1==c2 and date>d2:\\n                    break\\n                s2.append(str(date)+\"-\"+str(c1))\\n            c1+=1\\n            flag=1\\n            \\n        # print(s2)\\n        \\n        s1 = set(s1)\\n        s2 = set(s2)\\n        \\n        s3 = s1.intersection(s2)\\n        \\n        return len(s3)            \\n        \\n        \\n",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        a1,b1 = arriveAlice.split(\"-\")\\n        a1,b1 = int(a1),int(b1)\\n        \\n        a2,b2 = leaveAlice.split(\"-\")\\n        a2,b2 = int(a2),int(b2)\\n        \\n        c1,d1 = arriveBob.split(\"-\")\\n        c1,d1 = int(c1),int(d1)\\n        \\n        c2,d2 = leaveBob.split(\"-\")\\n        c2,d2 = int(c2),int(d2)\\n        \\n        \\n        y = {\\n            1 : 31,\\n            2 : 28,\\n            3 : 31,\\n            4 : 30,\\n            5 :  31,\\n            6 :  30,\\n            7 :  31,\\n            8  : 31,\\n            9  : 30,\\n            10 : 31,\\n            11:  30,\\n            12 : 31\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2588083,
                "title": "easy-solution-map-calender",
                "content": "I am using the approach that i am increase the day count of month in map by 1 when are arriving in map and dec  by 1 when they are leaving.\\nif sum ==2 indicates both were there on that day.\\nI think this is better soln rather than taking care of cases when they will not overlap and and if overlap then count days.\\n```\\nclass Solution {\\npublic:\\n    int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n \\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n          int startMonthAlice = stoi(arriveAlice.substr(0,2));\\n          int startDateAlice = stoi(arriveAlice.substr(3,2));\\n        \\n          int leaveMonthAlice = stoi(leaveAlice.substr(0,2));\\n          int leaveDateAlice = stoi(leaveAlice.substr(3,2));\\n       \\n        \\n          int startMonthBob = stoi(arriveBob.substr(0,2));\\n          int startDateBob = stoi(arriveBob.substr(3,2));\\n        \\n          int leaveMonthBob = stoi(leaveBob.substr(0,2));\\n          int leaveDateBob = stoi(leaveBob.substr(3,2));\\n       \\n        \\n          map<int,vector<int>>mp;\\n          /*\\n\\t\\t  * since they have mentioned that start and end days are inclusive.\\n\\t\\t  * we need  to handle case even when they are arriving-leaving on same day. \\n\\t\\t  * so creating map of on larger size than no of days in month.\\n\\t\\t  */\\n          for (int i = 1; i <= 12; i++) {\\n              vector<int>vec(days[i]+2, 0);\\n              mp[i] = vec;\\n          }\\n        \\n\\n         mp[startMonthAlice][startDateAlice]++;\\n         mp[leaveMonthAlice][leaveDateAlice+1]--;\\n\\n         mp[startMonthBob][startDateBob]++;\\n         mp[leaveMonthBob][leaveDateBob+1]--;\\n\\n        \\n         int totalDays = 0;\\n         int sum = 0;\\n        \\n         for (int i = 1; i <= 12; i++) {\\n             int size = days[i]+1;\\n             for (int j = 1; j <= size; j++) {\\n                  sum += mp[i][j];\\n                  if (sum == 2 && j != days[i]+1) { //To take care of inclusive day.\\n                      totalDays++;\\n                  }\\n             } \\n         }\\n        \\n        return totalDays;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n \\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n          int startMonthAlice = stoi(arriveAlice.substr(0,2));\\n          int startDateAlice = stoi(arriveAlice.substr(3,2));\\n        \\n          int leaveMonthAlice = stoi(leaveAlice.substr(0,2));\\n          int leaveDateAlice = stoi(leaveAlice.substr(3,2));\\n       \\n        \\n          int startMonthBob = stoi(arriveBob.substr(0,2));\\n          int startDateBob = stoi(arriveBob.substr(3,2));\\n        \\n          int leaveMonthBob = stoi(leaveBob.substr(0,2));\\n          int leaveDateBob = stoi(leaveBob.substr(3,2));\\n       \\n        \\n          map<int,vector<int>>mp;\\n          /*\\n\\t\\t  * since they have mentioned that start and end days are inclusive.\\n\\t\\t  * we need  to handle case even when they are arriving-leaving on same day. \\n\\t\\t  * so creating map of on larger size than no of days in month.\\n\\t\\t  */\\n          for (int i = 1; i <= 12; i++) {\\n              vector<int>vec(days[i]+2, 0);\\n              mp[i] = vec;\\n          }\\n        \\n\\n         mp[startMonthAlice][startDateAlice]++;\\n         mp[leaveMonthAlice][leaveDateAlice+1]--;\\n\\n         mp[startMonthBob][startDateBob]++;\\n         mp[leaveMonthBob][leaveDateBob+1]--;\\n\\n        \\n         int totalDays = 0;\\n         int sum = 0;\\n        \\n         for (int i = 1; i <= 12; i++) {\\n             int size = days[i]+1;\\n             for (int j = 1; j <= size; j++) {\\n                  sum += mp[i][j];\\n                  if (sum == 2 && j != days[i]+1) { //To take care of inclusive day.\\n                      totalDays++;\\n                  }\\n             } \\n         }\\n        \\n        return totalDays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588069,
                "title": "java-clean-self-explanotary-code-100-faster-time-space",
                "content": "```\\nclass Solution {\\n    int[] daysOfMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int x1 = getDays(arriveAlice);\\n        int y1 = getDays(leaveAlice);\\n        int x2 = getDays(arriveBob);\\n        int y2 = getDays(leaveBob);\\n        if(y1 < x2 || y2 < x1) return 0;\\n        return Math.abs(Math.max(x1, x2)-Math.min(y1, y2))+1;\\n    }\\n    \\n    private int getDays(String str){\\n        int total = 0;\\n        int month = Integer.valueOf(str.substring(0,2));\\n        int days = Integer.valueOf(str.substring(3,5));\\n        for(int i=0;i<month-1;i++){\\n            total += daysOfMonth[i];\\n        }\\n        total += days;\\n        return total;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] daysOfMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int x1 = getDays(arriveAlice);\\n        int y1 = getDays(leaveAlice);\\n        int x2 = getDays(arriveBob);\\n        int y2 = getDays(leaveBob);\\n        if(y1 < x2 || y2 < x1) return 0;\\n        return Math.abs(Math.max(x1, x2)-Math.min(y1, y2))+1;\\n    }\\n    \\n    private int getDays(String str){\\n        int total = 0;\\n        int month = Integer.valueOf(str.substring(0,2));\\n        int days = Integer.valueOf(str.substring(3,5));\\n        for(int i=0;i<month-1;i++){\\n            total += daysOfMonth[i];\\n        }\\n        total += days;\\n        return total;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588051,
                "title": "java-date-library",
                "content": "```\\nimport java.text.DateFormat;\\nimport java.text.ParseException;\\nimport java.text.SimpleDateFormat;\\nimport java.util.*;\\n\\nclass Solution {\\n        public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n            int[] aa = Arrays.stream(arriveAlice.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n            int[] la = Arrays.stream(leaveAlice.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n\\n            int[] ab = Arrays.stream(arriveBob.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n            int[] lb = Arrays.stream(leaveBob.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n\\n            try {\\n                Calendar c = Calendar.getInstance();\\n                DateFormat sourceFormat = new SimpleDateFormat(\"dd/MM/yyyy\");\\n\\n                c.setTime(sourceFormat.parse(aa[1] + \"/\" + aa[0] + \"/2010\"));\\n                int aad = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(la[1] + \"/\" + la[0] + \"/2010\"));\\n                int ald = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(ab[1] + \"/\" + ab[0] + \"/2010\"));\\n                int bad = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(lb[1] + \"/\" + lb[0] + \"/2010\"));\\n                int bld = c.get(Calendar.DAY_OF_YEAR);\\n\\n                int x = Math.max(aad, bad), y = Math.min(ald, bld);\\n                if (x <= y) return 1 + Math.abs(x - y);\\n                return 0;\\n            } catch (Exception ex) {\\n                return 0;\\n            }\\n\\n        }\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.text.DateFormat;\\nimport java.text.ParseException;\\nimport java.text.SimpleDateFormat;\\nimport java.util.*;\\n\\nclass Solution {\\n        public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n            int[] aa = Arrays.stream(arriveAlice.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n            int[] la = Arrays.stream(leaveAlice.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n\\n            int[] ab = Arrays.stream(arriveBob.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n            int[] lb = Arrays.stream(leaveBob.split(\"-\")).mapToInt(Integer::parseInt).toArray();\\n\\n            try {\\n                Calendar c = Calendar.getInstance();\\n                DateFormat sourceFormat = new SimpleDateFormat(\"dd/MM/yyyy\");\\n\\n                c.setTime(sourceFormat.parse(aa[1] + \"/\" + aa[0] + \"/2010\"));\\n                int aad = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(la[1] + \"/\" + la[0] + \"/2010\"));\\n                int ald = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(ab[1] + \"/\" + ab[0] + \"/2010\"));\\n                int bad = c.get(Calendar.DAY_OF_YEAR);\\n\\n                c.setTime(sourceFormat.parse(lb[1] + \"/\" + lb[0] + \"/2010\"));\\n                int bld = c.get(Calendar.DAY_OF_YEAR);\\n\\n                int x = Math.max(aad, bad), y = Math.min(ald, bld);\\n                if (x <= y) return 1 + Math.abs(x - y);\\n                return 0;\\n            } catch (Exception ex) {\\n                return 0;\\n            }\\n\\n        }\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588046,
                "title": "simple-solution-python-brute-force",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        alice_arrive_month = int(arriveAlice[0:2])\\n        alice_arrive_day = int(arriveAlice[3:])\\n        bob_arrive_month = int(arriveBob[0:2] )\\n        bob_arrive_day = int(arriveBob[3:] )\\n        alice_leave_month = int(leaveAlice[0:2] )\\n        alice_leave_day = int(leaveAlice[3:])\\n        bob_leave_month = int(leaveBob[0:2] )\\n        bob_leave_day = int(leaveBob[3:] )\\n        count = 0\\n        \\n        b = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        if(arriveAlice == arriveBob and leaveBob == leaveAlice): \\n            if(alice_arrive_month == bob_leave_month): \\n                return alice_leave_day - alice_arrive_day + 1\\n            else: \\n                count += b[alice_arrive_month - 1] - alice_arrive_day + 1\\n                for i in range(alice_arrive_month + 1, alice_leave_month): \\n                    count += b[i-1]\\n                count += alice_leave_day\\n                return count\\n        \\n        if((arriveAlice < arriveBob and leaveAlice < arriveBob) or (arriveBob < arriveAlice and leaveBob < arriveAlice)): \\n            return 0 \\n        \\n        \\n        # when arrival and leave lie in between of the other\\n        if(arriveBob > arriveAlice and leaveBob < leaveAlice): \\n            if(bob_leave_month == bob_arrive_month): \\n                return bob_leave_day - bob_arrive_day + 1\\n            else:\\n                count += b[bob_arrive_month-1] - bob_arrive_day + 1\\n                for i in range(bob_arrive_month + 1, bob_leave_month):\\n                    count += (b[i -1]) \\n                count += bob_leave_day \\n                return count\\n        elif(arriveAlice > arriveBob and leaveAlice < leaveBob): \\n            if(alice_leave_month == alice_arrive_month): \\n                return alice_leave_day - alice_arrive_day + 1\\n            else:\\n                count += (b[alice_arrive_month -1] - alice_arrive_day)  + 1\\n                for i in range(alice_arrive_month + 1, alice_leave_month):\\n                    count += (b[i -1]) \\n                count += alice_leave_day\\n                return count\\n            \\n        # arriveAlice = \"08-15\", leaveAlice = \"08-18\", \\n        # arriveBob = \"08-16\", leaveBob = \"08-19\"\\n        if(arriveBob < leaveAlice and leaveAlice < leaveBob): \\n            if(bob_arrive_month == alice_leave_month): \\n                return alice_leave_day - bob_arrive_day + 1\\n            else: \\n                count += b[bob_arrive_month-1] - bob_arrive_day + 1\\n                for i in range(bob_arrive_month + 1, alice_leave_month): \\n                    count += (b[i -1]) \\n                count += alice_leave_day\\n                return count \\n        \\n\\t\\t# \"08-06\" --> \\n\\t\\t# \"12-08\"  \\n\\t\\t# \"02-04\"\\n\\t\\t# \"09-01\" --> \\n        if(arriveAlice < leaveBob and leaveBob < leaveAlice): \\n            if(alice_arrive_month == bob_leave_month): \\n                return bob_leave_day - alice_arrive_day + 1\\n            else: \\n                count += b[alice_arrive_month-1] - alice_arrive_day + 1\\n                for i in range(alice_arrive_month + 1, bob_leave_month): \\n                    count += (b[i -1]) \\n                count += bob_leave_day\\n                return count \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        alice_arrive_month = int(arriveAlice[0:2])\\n        alice_arrive_day = int(arriveAlice[3:])\\n        bob_arrive_month = int(arriveBob[0:2] )\\n        bob_arrive_day = int(arriveBob[3:] )\\n        alice_leave_month = int(leaveAlice[0:2] )\\n        alice_leave_day = int(leaveAlice[3:])\\n        bob_leave_month = int(leaveBob[0:2] )\\n        bob_leave_day = int(leaveBob[3:] )\\n        count = 0\\n        \\n        b = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        if(arriveAlice == arriveBob and leaveBob == leaveAlice): \\n            if(alice_arrive_month == bob_leave_month): \\n                return alice_leave_day - alice_arrive_day + 1\\n            else: \\n                count += b[alice_arrive_month - 1] - alice_arrive_day + 1\\n                for i in range(alice_arrive_month + 1, alice_leave_month): \\n                    count += b[i-1]\\n                count += alice_leave_day\\n                return count\\n        \\n        if((arriveAlice < arriveBob and leaveAlice < arriveBob) or (arriveBob < arriveAlice and leaveBob < arriveAlice)): \\n            return 0 \\n        \\n        \\n        # when arrival and leave lie in between of the other\\n        if(arriveBob > arriveAlice and leaveBob < leaveAlice): \\n            if(bob_leave_month == bob_arrive_month): \\n                return bob_leave_day - bob_arrive_day + 1\\n            else:\\n                count += b[bob_arrive_month-1] - bob_arrive_day + 1\\n                for i in range(bob_arrive_month + 1, bob_leave_month):\\n                    count += (b[i -1]) \\n                count += bob_leave_day \\n                return count\\n        elif(arriveAlice > arriveBob and leaveAlice < leaveBob): \\n            if(alice_leave_month == alice_arrive_month): \\n                return alice_leave_day - alice_arrive_day + 1\\n            else:\\n                count += (b[alice_arrive_month -1] - alice_arrive_day)  + 1\\n                for i in range(alice_arrive_month + 1, alice_leave_month):\\n                    count += (b[i -1]) \\n                count += alice_leave_day\\n                return count\\n            \\n        # arriveAlice = \"08-15\", leaveAlice = \"08-18\", \\n        # arriveBob = \"08-16\", leaveBob = \"08-19\"\\n        if(arriveBob < leaveAlice and leaveAlice < leaveBob): \\n            if(bob_arrive_month == alice_leave_month): \\n                return alice_leave_day - bob_arrive_day + 1\\n            else: \\n                count += b[bob_arrive_month-1] - bob_arrive_day + 1\\n                for i in range(bob_arrive_month + 1, alice_leave_month): \\n                    count += (b[i -1]) \\n                count += alice_leave_day\\n                return count \\n        \\n\\t\\t# \"08-06\" --> \\n\\t\\t# \"12-08\"  \\n\\t\\t# \"02-04\"\\n\\t\\t# \"09-01\" --> \\n        if(arriveAlice < leaveBob and leaveBob < leaveAlice): \\n            if(alice_arrive_month == bob_leave_month): \\n                return bob_leave_day - alice_arrive_day + 1\\n            else: \\n                count += b[alice_arrive_month-1] - alice_arrive_day + 1\\n                for i in range(alice_arrive_month + 1, bob_leave_month): \\n                    count += (b[i -1]) \\n                count += bob_leave_day\\n                return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588035,
                "title": "faster-than-100-brute-force",
                "content": "We have to write functions to calculate no. of days between two dates and another function to find which date is smaller than the other date.\\n\\nNow using, if-checks we can easily find the dates we to should choose and return the number of days between them\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> dayInMonth{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    // compare date returns true if d1<=d2\\n    bool compareDate(string date1,string date2){\\n        int m1 = stoi(date1.substr(0,2));\\n        int d1 = stoi(date1.substr(3,2));\\n        int m2 = stoi(date2.substr(0,2));\\n        int d2 = stoi(date2.substr(3,2));\\n        \\n        if(m1<m2)\\n            return true;\\n        else if(m1==m2){\\n            if(d1<=d2)\\n                return true;\\n            else\\n                return false;\\n        }else\\n            return false;\\n    }\\n    \\n    // stay duration find no of days between d1 and d2\\n    int stayDuration(string date1,string date2){\\n        int m1 = stoi(date1.substr(0,2));\\n        int d1 = stoi(date1.substr(3,2));\\n        int m2 = stoi(date2.substr(0,2));\\n        int d2 = stoi(date2.substr(3,2));\\n        \\n        if(m2>m1){\\n            int days=0;\\n            for(int i=m1;i<=m2;i++){\\n                if(i==m1)\\n                    days+=dayInMonth[i-1]-d1+1;\\n                else if(i==m2)\\n                    days+=d2;\\n                else\\n                    days+=dayInMonth[i-1];\\n            }\\n            \\n            return days;\\n        }else{\\n            return d2-d1+1;\\n        }\\n        \\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        string d1=arriveAlice,d2=leaveAlice,d3=arriveBob,d4=leaveBob;\\n        if(compareDate(d3,d2) && compareDate(d1,d3) && compareDate(d2,d4))\\n            return stayDuration(d3,d2);\\n        else if(compareDate(d1,d4) && compareDate(d4,d2) && compareDate(d3,d1))\\n            return stayDuration(d1,d4);\\n        else if(compareDate(d3,d1) && compareDate(d2,d4))\\n            return stayDuration(d1,d2);\\n        else if(compareDate(d1,d3) && compareDate(d4,d2))\\n            return stayDuration(d3,d4);\\n        else \\n            return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dayInMonth{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    // compare date returns true if d1<=d2\\n    bool compareDate(string date1,string date2){\\n        int m1 = stoi(date1.substr(0,2));\\n        int d1 = stoi(date1.substr(3,2));\\n        int m2 = stoi(date2.substr(0,2));\\n        int d2 = stoi(date2.substr(3,2));\\n        \\n        if(m1<m2)\\n            return true;\\n        else if(m1==m2){\\n            if(d1<=d2)\\n                return true;\\n            else\\n                return false;\\n        }else\\n            return false;\\n    }\\n    \\n    // stay duration find no of days between d1 and d2\\n    int stayDuration(string date1,string date2){\\n        int m1 = stoi(date1.substr(0,2));\\n        int d1 = stoi(date1.substr(3,2));\\n        int m2 = stoi(date2.substr(0,2));\\n        int d2 = stoi(date2.substr(3,2));\\n        \\n        if(m2>m1){\\n            int days=0;\\n            for(int i=m1;i<=m2;i++){\\n                if(i==m1)\\n                    days+=dayInMonth[i-1]-d1+1;\\n                else if(i==m2)\\n                    days+=d2;\\n                else\\n                    days+=dayInMonth[i-1];\\n            }\\n            \\n            return days;\\n        }else{\\n            return d2-d1+1;\\n        }\\n        \\n    }\\n    \\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        string d1=arriveAlice,d2=leaveAlice,d3=arriveBob,d4=leaveBob;\\n        if(compareDate(d3,d2) && compareDate(d1,d3) && compareDate(d2,d4))\\n            return stayDuration(d3,d2);\\n        else if(compareDate(d1,d4) && compareDate(d4,d2) && compareDate(d3,d1))\\n            return stayDuration(d1,d4);\\n        else if(compareDate(d3,d1) && compareDate(d2,d4))\\n            return stayDuration(d1,d2);\\n        else if(compareDate(d1,d3) && compareDate(d4,d2))\\n            return stayDuration(d3,d4);\\n        else \\n            return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588026,
                "title": "lengthy-but-easy-to-understand-python3-solution",
                "content": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        month=[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        aam,aad=int(arriveAlice[:2]),int(arriveAlice[3:])\\n        alm,ald=int(leaveAlice[:2]),int(leaveAlice[3:])\\n        bam,bad=int(arriveBob[:2]),int(arriveBob[3:])\\n        blm,bld=int(leaveBob[:2]),int(leaveBob[3:])\\n        \\n        sm,sd,em,ed=0,0,0,0\\n        \\n        \\n        \\n        \\n        def diff(sm,sd,em,ed):\\n            print(sm,sd,em,ed)\\n            if(sm>=em):\\n                if(sm==em and ed-sd+1>0):\\n                    return ed-sd+1\\n                else: \\n                    return 0\\n            \\n            a = (month[sm-1]-sd+1)\\n            b=0\\n            for i in range(sm+1,em):\\n                b+= month[i-1]\\n            c = ed\\n            #print(month[sm-1],aad,c)\\n            diff=a+b+c\\n            return diff\\n        \\n        d = 0\\n        \\n        if aam>=bam and alm>=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=bld\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=aad\\n                \\n            return diff(aam,sd,blm,ed)\\n            \\n        elif aam<=bam and alm<=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=ald\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=bad\\n                \\n            return diff(bam,sd,alm,ed)\\n        \\n        elif aam>=bam and alm<=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=ald\\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=aad\\n                \\n            return diff(aam,sd,alm,ed)\\n            \\n        elif aam<=bam and blm<=alm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=bld\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=bad\\n                \\n            return diff(bam,sd,blm,ed)\\n            \\n        return d\\n\\n        \\n```\\nTime Complexity: O(1) # For looping for the difference of months, will never be greater than 12\\nSpace Complexity:O(1)\\nThere are much better approaches possible",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        month=[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        aam,aad=int(arriveAlice[:2]),int(arriveAlice[3:])\\n        alm,ald=int(leaveAlice[:2]),int(leaveAlice[3:])\\n        bam,bad=int(arriveBob[:2]),int(arriveBob[3:])\\n        blm,bld=int(leaveBob[:2]),int(leaveBob[3:])\\n        \\n        sm,sd,em,ed=0,0,0,0\\n        \\n        \\n        \\n        \\n        def diff(sm,sd,em,ed):\\n            print(sm,sd,em,ed)\\n            if(sm>=em):\\n                if(sm==em and ed-sd+1>0):\\n                    return ed-sd+1\\n                else: \\n                    return 0\\n            \\n            a = (month[sm-1]-sd+1)\\n            b=0\\n            for i in range(sm+1,em):\\n                b+= month[i-1]\\n            c = ed\\n            #print(month[sm-1],aad,c)\\n            diff=a+b+c\\n            return diff\\n        \\n        d = 0\\n        \\n        if aam>=bam and alm>=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=bld\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=aad\\n                \\n            return diff(aam,sd,blm,ed)\\n            \\n        elif aam<=bam and alm<=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=ald\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=bad\\n                \\n            return diff(bam,sd,alm,ed)\\n        \\n        elif aam>=bam and alm<=blm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=ald\\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=aad\\n                \\n            return diff(aam,sd,alm,ed)\\n            \\n        elif aam<=bam and blm<=alm:\\n            if(blm==alm):\\n                ed=min(bld,ald)\\n            else:\\n                ed=bld\\n                \\n            if(aam==bam):\\n                sd=max(aad,bad)\\n            else:\\n                sd=bad\\n                \\n            return diff(bam,sd,blm,ed)\\n            \\n        return d\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588003,
                "title": "javascript-easy-to-understand",
                "content": "```\\n\\n  const maxArrival = arriveAlice > arriveBob ? arriveAlice : arriveBob;\\n  const minLeave = leaveAlice < leaveBob ? leaveAlice : leaveBob;\\n\\n  const days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\n  let days_spent_together = 0;\\n\\n  const dayArrived = Number(maxArrival.slice(3));\\n  const monthArrived = Number(maxArrival.slice(0,2));\\n\\n  const dayLeft = Number(minLeave.slice(3));\\n  const monthLeft = Number(minLeave.slice(0,2));\\n\\n  if (maxArrival > minLeave) return 0;\\n\\n  if (monthArrived === monthLeft) {\\n    days_spent_together = dayLeft - dayArrived + 1;\\n  } else {\\n    days_spent_together = days_in_months[monthArrived - 1] - dayArrived + 1;\\n\\n    for (let i = monthArrived; i < monthLeft - 1; i++) {\\n      days_spent_together += days_in_months[i];\\n    }\\n    days_spent_together += dayLeft;\\n  }\\n\\n  return days_spent_together;\\n  \\n  ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n  const maxArrival = arriveAlice > arriveBob ? arriveAlice : arriveBob;\\n  const minLeave = leaveAlice < leaveBob ? leaveAlice : leaveBob;\\n\\n  const days_in_months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\n  let days_spent_together = 0;\\n\\n  const dayArrived = Number(maxArrival.slice(3));\\n  const monthArrived = Number(maxArrival.slice(0,2));\\n\\n  const dayLeft = Number(minLeave.slice(3));\\n  const monthLeft = Number(minLeave.slice(0,2));\\n\\n  if (maxArrival > minLeave) return 0;\\n\\n  if (monthArrived === monthLeft) {\\n    days_spent_together = dayLeft - dayArrived + 1;\\n  } else {\\n    days_spent_together = days_in_months[monthArrived - 1] - dayArrived + 1;\\n\\n    for (let i = monthArrived; i < monthLeft - 1; i++) {\\n      days_spent_together += days_in_months[i];\\n    }\\n    days_spent_together += dayLeft;\\n  }\\n\\n  return days_spent_together;\\n  \\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587980,
                "title": "easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>pref;\\n    int solve(string aalice){\\n    string first=aalice.substr(0,2);\\n        int k=stoi(first);\\n        k--;\\n        k=pref[k];\\n        string sec=aalice.substr(3,5);\\n        k+=stoi(sec);\\n        k--;\\n        return k;\\n    }\\n    vector<int>temp={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int countDaysTogether(string aalice, string la, string ab, string lb) {\\n        \\n        pref.push_back(0);\\n        for(int i=1;i<12;i++){\\n            int k=temp[i-1]+pref[i-1];\\n            pref.push_back(k);\\n        }\\n        int a=solve(aalice);\\n        int b=solve(la);\\n        int c=solve(ab);\\n        int d=solve(lb);\\n        int x=max(a,c);\\n        int y=min(b,d);\\n        int ans=y-x+1;\\n        if(ans<0){\\n            ans=0;\\n        }\\n        return ans;\\n        //itne ke baad aara \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>pref;\\n    int solve(string aalice){\\n    string first=aalice.substr(0,2);\\n        int k=stoi(first);\\n        k--;\\n        k=pref[k];\\n        string sec=aalice.substr(3,5);\\n        k+=stoi(sec);\\n        k--;\\n        return k;\\n    }\\n    vector<int>temp={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int countDaysTogether(string aalice, string la, string ab, string lb) {\\n        \\n        pref.push_back(0);\\n        for(int i=1;i<12;i++){\\n            int k=temp[i-1]+pref[i-1];\\n            pref.push_back(k);\\n        }\\n        int a=solve(aalice);\\n        int b=solve(la);\\n        int c=solve(ab);\\n        int d=solve(lb);\\n        int x=max(a,c);\\n        int y=min(b,d);\\n        int ans=y-x+1;\\n        if(ans<0){\\n            ans=0;\\n        }\\n        return ans;\\n        //itne ke baad aara \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587940,
                "title": "toughest-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aad = stoi(arriveAlice.substr(3));\\n        int aam = stoi(arriveAlice.substr(0, 2));\\n        int ald = stoi(leaveAlice.substr(3));\\n        int alm = stoi(leaveAlice.substr(0, 2));\\n        \\n        int bad = stoi(arriveBob.substr(3));\\n        int bam = stoi(arriveBob.substr(0, 2));\\n        int bld = stoi(leaveBob.substr(3));\\n        int blm = stoi(leaveBob.substr(0, 2));\\n        \\n        vector<vector<int>> cal1, cal2;\\n        vector<int> md = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i=0; i<12; i++) {\\n            vector<int> m1(md[i]), m2(md[i]);\\n            cal1.push_back(m1);\\n            cal2.push_back(m2);\\n        }\\n        \\n        if(aam == alm) {\\n            for(int i=aad - 1; i<=ald - 1; i++) cal1[aam - 1][i] = 1;\\n        }\\n        else {\\n            for(int i=aad - 1; i<md[aam - 1]; i++) cal1[aam - 1][i] = 1;\\n            for(int i=0; i<=ald - 1; i++) cal1[alm - 1][i] = 1;\\n            \\n            for(int i=aam-1+1; i<=alm-1-1; i++) {\\n                for(int j=0; j<md[i]; j++) cal1[i][j] = 1;\\n            }\\n        }\\n        \\n        if(bam == blm) {\\n            for(int i=bad - 1; i<=bld - 1; i++) cal2[bam - 1][i] = 1;\\n        }\\n        else {\\n            for(int i=bad - 1; i<md[bam - 1]; i++) cal2[bam - 1][i] = 1;\\n            for(int i=0; i<=bld - 1; i++) cal2[blm - 1][i] = 1;\\n            \\n            for(int i=bam-1+1; i<=blm-1-1; i++) {\\n                for(int j=0; j<md[i]; j++) cal2[i][j] = 1;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<12; i++) {\\n            for(int j=0; j<cal1[i].size(); j++) {\\n                if(cal1[i][j] && cal2[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aad = stoi(arriveAlice.substr(3));\\n        int aam = stoi(arriveAlice.substr(0, 2));\\n        int ald = stoi(leaveAlice.substr(3));\\n        int alm = stoi(leaveAlice.substr(0, 2));\\n        \\n        int bad = stoi(arriveBob.substr(3));\\n        int bam = stoi(arriveBob.substr(0, 2));\\n        int bld = stoi(leaveBob.substr(3));\\n        int blm = stoi(leaveBob.substr(0, 2));\\n        \\n        vector<vector<int>> cal1, cal2;\\n        vector<int> md = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        for(int i=0; i<12; i++) {\\n            vector<int> m1(md[i]), m2(md[i]);\\n            cal1.push_back(m1);\\n            cal2.push_back(m2);\\n        }\\n        \\n        if(aam == alm) {\\n            for(int i=aad - 1; i<=ald - 1; i++) cal1[aam - 1][i] = 1;\\n        }\\n        else {\\n            for(int i=aad - 1; i<md[aam - 1]; i++) cal1[aam - 1][i] = 1;\\n            for(int i=0; i<=ald - 1; i++) cal1[alm - 1][i] = 1;\\n            \\n            for(int i=aam-1+1; i<=alm-1-1; i++) {\\n                for(int j=0; j<md[i]; j++) cal1[i][j] = 1;\\n            }\\n        }\\n        \\n        if(bam == blm) {\\n            for(int i=bad - 1; i<=bld - 1; i++) cal2[bam - 1][i] = 1;\\n        }\\n        else {\\n            for(int i=bad - 1; i<md[bam - 1]; i++) cal2[bam - 1][i] = 1;\\n            for(int i=0; i<=bld - 1; i++) cal2[blm - 1][i] = 1;\\n            \\n            for(int i=bam-1+1; i<=blm-1-1; i++) {\\n                for(int j=0; j<md[i]; j++) cal2[i][j] = 1;\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<12; i++) {\\n            for(int j=0; j<cal1[i].size(); j++) {\\n                if(cal1[i][j] && cal2[i][j]) ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587938,
                "title": "easy-implementation-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>days{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    set<string>ans;\\n    void store(string &s,string &s1)\\n    {\\n        int a = 0;\\n        a = a*10+(s[0]-\\'0\\');\\n        a = a*10+(s[1]-\\'0\\');\\n        int b = 0;\\n        b = b*10+(s1[0]-\\'0\\');\\n        b = b*10+(s1[1]-\\'0\\');\\n        \\n        int count = 0;\\n        count = count*10+(s[3]-\\'0\\');\\n        count = count*10+(s[4]-\\'0\\');\\n        \\n        int count1 = 0;\\n        count1 = count1*10+(s1[3]-\\'0\\');\\n        count1 = count1*10+(s1[4]-\\'0\\');\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(count<=count1)\\n                {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    ans.insert(x);\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(a<b)\\n            {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    ans.insert(x);\\n                    count++;\\n                    if(count>days[a-1])\\n                    {\\n                        count = 1;\\n                        a = (a)%12;\\n                        a++;\\n                    }\\n            }\\n        }\\n    }\\n    int countDays(string &s,string &s1)\\n    {\\n        int total = 0;\\n        int a = 0;\\n        a = a*10+(s[0]-\\'0\\');\\n        a = a*10+(s[1]-\\'0\\');\\n        int b = 0;\\n        b = b*10+(s1[0]-\\'0\\');\\n        b = b*10+(s1[1]-\\'0\\');\\n        \\n        int count = 0;\\n        count = count*10+(s[3]-\\'0\\');\\n        count = count*10+(s[4]-\\'0\\');\\n        \\n        int count1 = 0;\\n        count1 = count1*10+(s1[3]-\\'0\\');\\n        count1 = count1*10+(s1[4]-\\'0\\');\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(count<=count1)\\n                {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    if(ans.find(x)!=ans.end())total++;\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(a<b)\\n            {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    if(ans.find(x)!=ans.end())total++;\\n                    count++;\\n                    if(count>days[a-1])\\n                    {\\n                        count = 1;\\n                        a = (a)%12;\\n                        a++;\\n                    }\\n            }\\n        }\\n        return total;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        store(arriveAlice,leaveAlice);\\n        return countDays(arriveBob,leaveBob);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>days{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    set<string>ans;\\n    void store(string &s,string &s1)\\n    {\\n        int a = 0;\\n        a = a*10+(s[0]-\\'0\\');\\n        a = a*10+(s[1]-\\'0\\');\\n        int b = 0;\\n        b = b*10+(s1[0]-\\'0\\');\\n        b = b*10+(s1[1]-\\'0\\');\\n        \\n        int count = 0;\\n        count = count*10+(s[3]-\\'0\\');\\n        count = count*10+(s[4]-\\'0\\');\\n        \\n        int count1 = 0;\\n        count1 = count1*10+(s1[3]-\\'0\\');\\n        count1 = count1*10+(s1[4]-\\'0\\');\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(count<=count1)\\n                {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    ans.insert(x);\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(a<b)\\n            {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    ans.insert(x);\\n                    count++;\\n                    if(count>days[a-1])\\n                    {\\n                        count = 1;\\n                        a = (a)%12;\\n                        a++;\\n                    }\\n            }\\n        }\\n    }\\n    int countDays(string &s,string &s1)\\n    {\\n        int total = 0;\\n        int a = 0;\\n        a = a*10+(s[0]-\\'0\\');\\n        a = a*10+(s[1]-\\'0\\');\\n        int b = 0;\\n        b = b*10+(s1[0]-\\'0\\');\\n        b = b*10+(s1[1]-\\'0\\');\\n        \\n        int count = 0;\\n        count = count*10+(s[3]-\\'0\\');\\n        count = count*10+(s[4]-\\'0\\');\\n        \\n        int count1 = 0;\\n        count1 = count1*10+(s1[3]-\\'0\\');\\n        count1 = count1*10+(s1[4]-\\'0\\');\\n        while(a<=b)\\n        {\\n            if(a==b)\\n            {\\n                if(count<=count1)\\n                {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    if(ans.find(x)!=ans.end())total++;\\n                    count++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            else if(a<b)\\n            {\\n                    string x = to_string(a);\\n                     x+= \"-\";\\n                     x+=to_string(count);\\n                    if(ans.find(x)!=ans.end())total++;\\n                    count++;\\n                    if(count>days[a-1])\\n                    {\\n                        count = 1;\\n                        a = (a)%12;\\n                        a++;\\n                    }\\n            }\\n        }\\n        return total;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        store(arriveAlice,leaveAlice);\\n        return countDays(arriveBob,leaveBob);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587933,
                "title": "c-short-and-concise",
                "content": "```\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        string start = max(arriveAlice,arriveBob) , end=min(leaveAlice,leaveBob);\\n        vector<int> m = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        if(start<=end)\\n        {\\n            int em = stoi(end.substr(0,2))   , ed = stoi(end.substr(3,2)) ;\\n            int sm = stoi(start.substr(0,2)) , sd = stoi(start.substr(3,2)) ;\\n            \\n            if(em != sm)\\n            {\\n                int d = m[sm]-sd;\\n                for(int i=sm+1 ; i<em ; i++)   d += m[i] ; \\n                \\n                return d += ed+1 ;\\n            }            \\n            else  return ed-sd+1 ;\\n        }\\n        return 0 ;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        string start = max(arriveAlice,arriveBob) , end=min(leaveAlice,leaveBob);\\n        vector<int> m = {0,31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        \\n        if(start<=end)\\n        {\\n            int em = stoi(end.substr(0,2))   , ed = stoi(end.substr(3,2)) ;\\n            int sm = stoi(start.substr(0,2)) , sd = stoi(start.substr(3,2)) ;\\n            \\n            if(em != sm)\\n            {\\n                int d = m[sm]-sd;\\n                for(int i=sm+1 ; i<em ; i++)   d += m[i] ; \\n                \\n                return d += ed+1 ;\\n            }            \\n            else  return ed-sd+1 ;\\n        }\\n        return 0 ;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076719,
                "title": "too-easy-to-understand-code-throughly-explained-beats-runtime-100-memory-85",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, find the largest of the two arrival date and lowest of the two leave date, this will give you the inclusive days they spend together. \\nString compareTo() function is used to get a lexicographical difference.\\nRest of the explanation is in the Code itself. \\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/c11c8b2b-5f82-4300-8a98-bb843d7c37bb_1695388049.2025945.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        //the date at which both will be in the town at the start,\\n        //would be the arrival date of the latecomer (largest of the two arrival date)\\n        String start = arriveAlice.compareTo(arriveBob) >= 0 ? arriveAlice : arriveBob;\\n        //the date at the both will in the town for the last time,\\n        //would be the date of the early leaver (smallest of the two leave date)\\n        String end = leaveAlice.compareTo(leaveBob) >= 0 ? leaveBob : leaveAlice;\\n        \\n        //if one leaves early before the arrival of the second one\\n        //total day spend would be 0\\n        if(start.compareTo(end) > 0){\\n            return 0;\\n        }\\n\\n        //extract months and dates from the string\\n        int total = 0;\\n        int startMonth = Integer.parseInt(start.substring(0, 2));\\n        int startDate = Integer.parseInt(start.substring(3));\\n        int endMonth = Integer.parseInt(end.substring(0, 2));\\n        int endDate = Integer.parseInt(end.substring(3));\\n        \\n        //if the startMonth and endMonth is equal, total days spend\\n        //together would be subtration of endDate - startDate + 1 as startDate is inclusive\\n        if(startMonth == endMonth){\\n            return endDate - startDate + 1;\\n        }\\n\\n        //if months are not equal, then this applies\\n        int[] month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        //add the days per month they stays together\\n        //as startMonth is already running cant take full days of it, same goes for endMonth\\n        //any month inbetween these would be added in total\\n        for(int i = startMonth+1; i < endMonth; i++){\\n            //i-1 as month starts from 1 but index from 0\\n            total += month[i-1];\\n        }\\n\\n        //add the days of first month spend together (total days in the month - lowest \\n        //arrival date + 1(as arrival date is inclusive)) and \\n        //the end date to the total\\n        return total + month[startMonth-1] - startDate + 1 + endDate;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        //the date at which both will be in the town at the start,\\n        //would be the arrival date of the latecomer (largest of the two arrival date)\\n        String start = arriveAlice.compareTo(arriveBob) >= 0 ? arriveAlice : arriveBob;\\n        //the date at the both will in the town for the last time,\\n        //would be the date of the early leaver (smallest of the two leave date)\\n        String end = leaveAlice.compareTo(leaveBob) >= 0 ? leaveBob : leaveAlice;\\n        \\n        //if one leaves early before the arrival of the second one\\n        //total day spend would be 0\\n        if(start.compareTo(end) > 0){\\n            return 0;\\n        }\\n\\n        //extract months and dates from the string\\n        int total = 0;\\n        int startMonth = Integer.parseInt(start.substring(0, 2));\\n        int startDate = Integer.parseInt(start.substring(3));\\n        int endMonth = Integer.parseInt(end.substring(0, 2));\\n        int endDate = Integer.parseInt(end.substring(3));\\n        \\n        //if the startMonth and endMonth is equal, total days spend\\n        //together would be subtration of endDate - startDate + 1 as startDate is inclusive\\n        if(startMonth == endMonth){\\n            return endDate - startDate + 1;\\n        }\\n\\n        //if months are not equal, then this applies\\n        int[] month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        //add the days per month they stays together\\n        //as startMonth is already running cant take full days of it, same goes for endMonth\\n        //any month inbetween these would be added in total\\n        for(int i = startMonth+1; i < endMonth; i++){\\n            //i-1 as month starts from 1 but index from 0\\n            total += month[i-1];\\n        }\\n\\n        //add the days of first month spend together (total days in the month - lowest \\n        //arrival date + 1(as arrival date is inclusive)) and \\n        //the end date to the total\\n        return total + month[startMonth-1] - startDate + 1 + endDate;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064066,
                "title": "c-python-date-to-a-number-solution-with-explanation",
                "content": "First, convert date to a number,\\nfor example, 07-01 = (total days from 01-01 to 06 -30) + 1.\\nSo, we can use prefix sum to calculate total day from 01-01 to current month\\'s last day.\\nAnd add days in current month, we get a number.\\n\\n![image](https://assets.leetcode.com/users/images/c25e375c-6efe-4ed7-915c-7706a911d4ab_1695121965.0763216.png)\\nif the condition is true, they can meet each other in the city.\\nif not, return 0.\\n\\n\\n### python\\n```python\\nprefix = [0]\\nfor x in (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31):\\n    prefix.append(prefix[-1] + x)\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        def calc(day: str) -> int:\\n            m = int(day[:2])\\n            d = int(day[3:])\\n            return prefix[m-1] + d\\n        arriveAlice, leaveAlice = calc(arriveAlice), calc(leaveAlice)\\n        arriveBob, leaveBob = calc(arriveBob), calc(leaveBob)\\n        if max(arriveAlice, arriveBob) <= min(leaveAlice, leaveBob):\\n            return min(leaveAlice, leaveBob) - max(arriveAlice, arriveBob) + 1\\n        return 0\\n```\\n\\n### c++\\n```cpp\\nconst int day_[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\nvector<int> prefix {0};\\nint prefix_ = [] () {\\n    for (auto&x: day_)\\n        prefix.emplace_back(x + prefix.back());\\n    return 0;\\n}();\\n\\nint calc (string& day) {\\n    int m = prefix[stoi(day.substr(0, 2)) - 1], d = stoi(day.substr(3, 2));\\n    return m + d;\\n}\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aa = calc(arriveAlice), la = calc(leaveAlice), ab = calc(arriveBob), lb = calc(leaveBob);\\n        if (max(aa, ab) <= min(la, lb))\\n            return min(la, lb) - max(aa, ab) + 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nprefix = [0]\\nfor x in (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31):\\n    prefix.append(prefix[-1] + x)\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        def calc(day: str) -> int:\\n            m = int(day[:2])\\n            d = int(day[3:])\\n            return prefix[m-1] + d\\n        arriveAlice, leaveAlice = calc(arriveAlice), calc(leaveAlice)\\n        arriveBob, leaveBob = calc(arriveBob), calc(leaveBob)\\n        if max(arriveAlice, arriveBob) <= min(leaveAlice, leaveBob):\\n            return min(leaveAlice, leaveBob) - max(arriveAlice, arriveBob) + 1\\n        return 0\\n```\n```cpp\\nconst int day_[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\nvector<int> prefix {0};\\nint prefix_ = [] () {\\n    for (auto&x: day_)\\n        prefix.emplace_back(x + prefix.back());\\n    return 0;\\n}();\\n\\nint calc (string& day) {\\n    int m = prefix[stoi(day.substr(0, 2)) - 1], d = stoi(day.substr(3, 2));\\n    return m + d;\\n}\\n\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aa = calc(arriveAlice), la = calc(leaveAlice), ab = calc(arriveBob), lb = calc(leaveBob);\\n        if (max(aa, ab) <= min(la, lb))\\n            return min(la, lb) - max(aa, ab) + 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062216,
                "title": "brute-force-solution-c-commented-code",
                "content": "# Code\\n```\\n// Upvote If it\\'s Helps\\n\\nclass Solution {\\nprivate:\\n    void FillMonth(vector<vector<int>> &nums,string &s,string &e){\\n        int startMonth = (s[0]-\\'0\\')*10 + s[1]-\\'0\\';\\n        int endMonth = (e[0]-\\'0\\')*10 + e[1]-\\'0\\';\\n        int startDay = (s[3]-\\'0\\')*10 + s[4]-\\'0\\';\\n        int endDay = (e[3]-\\'0\\')*10 + e[4]-\\'0\\';\\n\\n        // Case 1 : if start and end month is same\\n        if(startMonth == endMonth){\\n            for(int i=startDay-1;i<endDay;i++){\\n                nums[startMonth-1][i] += 1;\\n            }\\n        }\\n        // Case 2 : if start month and end month is not same\\n        else{\\n            // Adding starting first month\\n            for(int i=startDay-1;i<nums[startMonth-1].size();i++){\\n                nums[startMonth-1][i] += 1;\\n            }\\n            // Adding months between start and end month\\n            for(int i=startMonth;i<endMonth-1;i++){\\n                for(int j=0;j<nums[i].size();j++){\\n                    nums[i][j] += 1;\\n                }\\n            }\\n            // Adding last month\\n            for(int j=0;j<endDay;j++){\\n                nums[endMonth-1][j] += 1;\\n            }\\n        }\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        // Creating calender\\n        vector<vector<int>> calender;\\n        // Pushing Jan and feb\\n        vector<int> jan(31,0), feb(28,0);\\n        calender.push_back(jan);\\n        calender.push_back(feb);\\n\\n        int k = 2;\\n        while(k--){\\n            int flag = 0;\\n            for(int i=0;i<5;i++){\\n                if(flag == 0){\\n                    vector<int> temp(31,0);\\n                    calender.push_back(temp);\\n                    flag = 1;\\n                }\\n                else{\\n                    vector<int> temp(30,0);\\n                    calender.push_back(temp);\\n                    flag = 0;\\n                }\\n            }\\n        }\\n\\n        // Now calender is created\\n        // filling the month\\n        FillMonth(calender,arriveAlice,leaveAlice);\\n        FillMonth(calender,arriveBob,leaveBob);\\n\\n        int ans = 0;\\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<calender[i].size();j++){\\n                if(calender[i][j] == 2){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n// Upvote If it\\'s Helps\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Upvote If it\\'s Helps\\n\\nclass Solution {\\nprivate:\\n    void FillMonth(vector<vector<int>> &nums,string &s,string &e){\\n        int startMonth = (s[0]-\\'0\\')*10 + s[1]-\\'0\\';\\n        int endMonth = (e[0]-\\'0\\')*10 + e[1]-\\'0\\';\\n        int startDay = (s[3]-\\'0\\')*10 + s[4]-\\'0\\';\\n        int endDay = (e[3]-\\'0\\')*10 + e[4]-\\'0\\';\\n\\n        // Case 1 : if start and end month is same\\n        if(startMonth == endMonth){\\n            for(int i=startDay-1;i<endDay;i++){\\n                nums[startMonth-1][i] += 1;\\n            }\\n        }\\n        // Case 2 : if start month and end month is not same\\n        else{\\n            // Adding starting first month\\n            for(int i=startDay-1;i<nums[startMonth-1].size();i++){\\n                nums[startMonth-1][i] += 1;\\n            }\\n            // Adding months between start and end month\\n            for(int i=startMonth;i<endMonth-1;i++){\\n                for(int j=0;j<nums[i].size();j++){\\n                    nums[i][j] += 1;\\n                }\\n            }\\n            // Adding last month\\n            for(int j=0;j<endDay;j++){\\n                nums[endMonth-1][j] += 1;\\n            }\\n        }\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        // Creating calender\\n        vector<vector<int>> calender;\\n        // Pushing Jan and feb\\n        vector<int> jan(31,0), feb(28,0);\\n        calender.push_back(jan);\\n        calender.push_back(feb);\\n\\n        int k = 2;\\n        while(k--){\\n            int flag = 0;\\n            for(int i=0;i<5;i++){\\n                if(flag == 0){\\n                    vector<int> temp(31,0);\\n                    calender.push_back(temp);\\n                    flag = 1;\\n                }\\n                else{\\n                    vector<int> temp(30,0);\\n                    calender.push_back(temp);\\n                    flag = 0;\\n                }\\n            }\\n        }\\n\\n        // Now calender is created\\n        // filling the month\\n        FillMonth(calender,arriveAlice,leaveAlice);\\n        FillMonth(calender,arriveBob,leaveBob);\\n\\n        int ans = 0;\\n        for(int i=0;i<12;i++){\\n            for(int j=0;j<calender[i].size();j++){\\n                if(calender[i][j] == 2){\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n// Upvote If it\\'s Helps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055306,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:KARUNYA UNIVERISTY:::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) \\n    {\\n\\n     String[] temp1=arriveAlice.split(\"-\");\\n     String[] temp2=leaveAlice.split(\"-\");\\n     String[] temp3=arriveBob.split(\"-\");\\n     String[] temp4=leaveBob.split(\"-\");\\n    \\n     int[] arriveAlicemonthanddate=new int[2];\\n     int[] leaveAlicemonthanddate=new int[2];\\n     int[] arriveBobmonthanddate=new int[2];\\n     int[] leaveBobmonthanddate=new int[2];\\n\\n     for (int i = 0; i < 2; i++) \\n     {\\n        arriveAlicemonthanddate[i]=Integer.parseInt(temp1[i]);\\n        leaveAlicemonthanddate[i]=Integer.parseInt(temp2[i]);\\n        arriveBobmonthanddate[i]=Integer.parseInt(temp3[i]);\\n        leaveBobmonthanddate[i]=Integer.parseInt(temp4[i]);  \\n     }\\n    \\n     //0 condition\\n   if ((leaveAlicemonthanddate[0]*60)+leaveAlicemonthanddate[1]<(arriveBobmonthanddate[0]*60)+arriveBobmonthanddate[1]) \\n   {\\n     //System.out.println(0);\\n    return 0;   \\n   }\\n   else if ((arriveAlicemonthanddate[0]*60)+arriveAlicemonthanddate[1]>((leaveBobmonthanddate[0])*60)+leaveBobmonthanddate[1]) \\n   {\\n     // System.out.println(0);\\n     return 0;\\n   }\\n   \\n   int startmonth=0;\\n   int startdate=0;\\n\\n   int endmonth=0;\\n   int enddate=0;\\n   \\n   //finding the start month\\n   //alice came late\\n   if ((arriveAlicemonthanddate[0]*60)+arriveAlicemonthanddate[1]>=(arriveBobmonthanddate[0]*60)+arriveBobmonthanddate[1]) \\n   {\\n      //System.out.println(\"sdfs\");\\n     startmonth=arriveAlicemonthanddate[0];\\n     startdate= arriveAlicemonthanddate[1];\\n   }\\n   //bob came late\\n   else\\n   {\\n     // System.out.println(\"sadadad\"+arriveBobmonthanddate[0]+\"-\"+arriveBobmonthanddate[1]);\\n     startmonth=arriveBobmonthanddate[0];\\n     startdate= arriveBobmonthanddate[1];\\n   }\\n   \\n   //finding the end date\\n   if ((leaveAlicemonthanddate[0]*60)+leaveAlicemonthanddate[1]<=(leaveBobmonthanddate[0]*60)+leaveBobmonthanddate[1]) \\n   { \\n      //System.out.println(\"sdfsf\");\\n      endmonth=leaveAlicemonthanddate[0];\\n      enddate=leaveAlicemonthanddate[1];\\n   }\\n   else\\n   {   \\n      //System.out.println(\"sdfsfsf\");\\n      endmonth= leaveBobmonthanddate[0];\\n      enddate=leaveBobmonthanddate[1];\\n   }\\n    \\n\\n   //System.out.println(\"startmonth\"+\" \"+startmonth);\\n   //System.out.println(\"startdate\"+\" \"+startdate);\\n   //System.out.println(\"endmonth\"+\" \"+endmonth);\\n   //System.out.println(\"enddate\"+\" \"+enddate);\\n\\n\\n   HashMap<Integer, Integer> monthDaysMap = new HashMap<>();\\n\\n   // Populate the HashMap with months and their respective days\\n   monthDaysMap.put(1, 31);   // January\\n   monthDaysMap.put(2, 28);   // February (non-leap year)\\n   monthDaysMap.put(3, 31);   // March\\n   monthDaysMap.put(4, 30);   // April\\n   monthDaysMap.put(5, 31);   // May\\n   monthDaysMap.put(6, 30);   // June\\n   monthDaysMap.put(7, 31);   // July\\n   monthDaysMap.put(8, 31);   // August\\n   monthDaysMap.put(9, 30);   // September\\n   monthDaysMap.put(10, 31);  // October\\n   monthDaysMap.put(11, 30);  // November\\n   monthDaysMap.put(12, 31);  // December\\n   \\n   int finalanswer=0;\\n     \\n\\n\\n   for (int i = startmonth; i <=endmonth; i++) \\n   {  \\n      if(startmonth==endmonth)\\n      { \\n        // System.out.println(\"sdfsf\");\\n          finalanswer=Math.abs(startdate-enddate)+1;\\n      } \\n      else if (i==startmonth) \\n      {\\n         finalanswer+=(monthDaysMap.get(startmonth)-startdate)+1;\\n         //System.out.println(finalanswer);\\n      }\\n      else if (i==endmonth) \\n      { \\n         finalanswer+=enddate;\\n          //System.out.println(finalanswer);\\n      }\\n      else\\n      {\\n        finalanswer+=monthDaysMap.get(i);\\n      }\\n   }\\n     \\n  /// System.out.println(finalanswer);\\n\\n   return finalanswer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) \\n    {\\n\\n     String[] temp1=arriveAlice.split(\"-\");\\n     String[] temp2=leaveAlice.split(\"-\");\\n     String[] temp3=arriveBob.split(\"-\");\\n     String[] temp4=leaveBob.split(\"-\");\\n    \\n     int[] arriveAlicemonthanddate=new int[2];\\n     int[] leaveAlicemonthanddate=new int[2];\\n     int[] arriveBobmonthanddate=new int[2];\\n     int[] leaveBobmonthanddate=new int[2];\\n\\n     for (int i = 0; i < 2; i++) \\n     {\\n        arriveAlicemonthanddate[i]=Integer.parseInt(temp1[i]);\\n        leaveAlicemonthanddate[i]=Integer.parseInt(temp2[i]);\\n        arriveBobmonthanddate[i]=Integer.parseInt(temp3[i]);\\n        leaveBobmonthanddate[i]=Integer.parseInt(temp4[i]);  \\n     }\\n    \\n     //0 condition\\n   if ((leaveAlicemonthanddate[0]*60)+leaveAlicemonthanddate[1]<(arriveBobmonthanddate[0]*60)+arriveBobmonthanddate[1]) \\n   {\\n     //System.out.println(0);\\n    return 0;   \\n   }\\n   else if ((arriveAlicemonthanddate[0]*60)+arriveAlicemonthanddate[1]>((leaveBobmonthanddate[0])*60)+leaveBobmonthanddate[1]) \\n   {\\n     // System.out.println(0);\\n     return 0;\\n   }\\n   \\n   int startmonth=0;\\n   int startdate=0;\\n\\n   int endmonth=0;\\n   int enddate=0;\\n   \\n   //finding the start month\\n   //alice came late\\n   if ((arriveAlicemonthanddate[0]*60)+arriveAlicemonthanddate[1]>=(arriveBobmonthanddate[0]*60)+arriveBobmonthanddate[1]) \\n   {\\n      //System.out.println(\"sdfs\");\\n     startmonth=arriveAlicemonthanddate[0];\\n     startdate= arriveAlicemonthanddate[1];\\n   }\\n   //bob came late\\n   else\\n   {\\n     // System.out.println(\"sadadad\"+arriveBobmonthanddate[0]+\"-\"+arriveBobmonthanddate[1]);\\n     startmonth=arriveBobmonthanddate[0];\\n     startdate= arriveBobmonthanddate[1];\\n   }\\n   \\n   //finding the end date\\n   if ((leaveAlicemonthanddate[0]*60)+leaveAlicemonthanddate[1]<=(leaveBobmonthanddate[0]*60)+leaveBobmonthanddate[1]) \\n   { \\n      //System.out.println(\"sdfsf\");\\n      endmonth=leaveAlicemonthanddate[0];\\n      enddate=leaveAlicemonthanddate[1];\\n   }\\n   else\\n   {   \\n      //System.out.println(\"sdfsfsf\");\\n      endmonth= leaveBobmonthanddate[0];\\n      enddate=leaveBobmonthanddate[1];\\n   }\\n    \\n\\n   //System.out.println(\"startmonth\"+\" \"+startmonth);\\n   //System.out.println(\"startdate\"+\" \"+startdate);\\n   //System.out.println(\"endmonth\"+\" \"+endmonth);\\n   //System.out.println(\"enddate\"+\" \"+enddate);\\n\\n\\n   HashMap<Integer, Integer> monthDaysMap = new HashMap<>();\\n\\n   // Populate the HashMap with months and their respective days\\n   monthDaysMap.put(1, 31);   // January\\n   monthDaysMap.put(2, 28);   // February (non-leap year)\\n   monthDaysMap.put(3, 31);   // March\\n   monthDaysMap.put(4, 30);   // April\\n   monthDaysMap.put(5, 31);   // May\\n   monthDaysMap.put(6, 30);   // June\\n   monthDaysMap.put(7, 31);   // July\\n   monthDaysMap.put(8, 31);   // August\\n   monthDaysMap.put(9, 30);   // September\\n   monthDaysMap.put(10, 31);  // October\\n   monthDaysMap.put(11, 30);  // November\\n   monthDaysMap.put(12, 31);  // December\\n   \\n   int finalanswer=0;\\n     \\n\\n\\n   for (int i = startmonth; i <=endmonth; i++) \\n   {  \\n      if(startmonth==endmonth)\\n      { \\n        // System.out.println(\"sdfsf\");\\n          finalanswer=Math.abs(startdate-enddate)+1;\\n      } \\n      else if (i==startmonth) \\n      {\\n         finalanswer+=(monthDaysMap.get(startmonth)-startdate)+1;\\n         //System.out.println(finalanswer);\\n      }\\n      else if (i==endmonth) \\n      { \\n         finalanswer+=enddate;\\n          //System.out.println(finalanswer);\\n      }\\n      else\\n      {\\n        finalanswer+=monthDaysMap.get(i);\\n      }\\n   }\\n     \\n  /// System.out.println(finalanswer);\\n\\n   return finalanswer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046008,
                "title": "rust-const-fn-lookup",
                "content": "# Code\\n```\\nuse std::str::FromStr;\\n\\nimpl Solution {\\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 {\\n        let starta = str_to_date(&arrive_alice);\\n        let enda = str_to_date(&leave_alice);\\n        let startb = str_to_date(&arrive_bob);\\n        let endb = str_to_date(&leave_bob);\\n        (enda.min(endb) - starta.max(startb) + 1).max(0)\\n    }\\n}\\n\\nfn str_to_date(date: &str) -> i32 {\\n    let (left, right) = date.split_once(\\'-\\').unwrap();\\n    let month = usize::from_str(left).unwrap() - 1;\\n    let day = i32::from_str(right).unwrap() - 1;\\n    day + MONTH_START[month]\\n}\\n\\nconst MONTH_LEN: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nconst MONTH_START: [i32; 12] = gen_starts();\\n\\nconst fn gen_starts() -> [i32; 12] {\\n    let mut arr = [0; 12];\\n    let mut sum = 0;\\n    let mut i = 0;\\n    while i < 12 {\\n        arr[i] = sum;\\n        sum += MONTH_LEN[i];\\n        i += 1;\\n    }\\n    arr\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::str::FromStr;\\n\\nimpl Solution {\\n    pub fn count_days_together(arrive_alice: String, leave_alice: String, arrive_bob: String, leave_bob: String) -> i32 {\\n        let starta = str_to_date(&arrive_alice);\\n        let enda = str_to_date(&leave_alice);\\n        let startb = str_to_date(&arrive_bob);\\n        let endb = str_to_date(&leave_bob);\\n        (enda.min(endb) - starta.max(startb) + 1).max(0)\\n    }\\n}\\n\\nfn str_to_date(date: &str) -> i32 {\\n    let (left, right) = date.split_once(\\'-\\').unwrap();\\n    let month = usize::from_str(left).unwrap() - 1;\\n    let day = i32::from_str(right).unwrap() - 1;\\n    day + MONTH_START[month]\\n}\\n\\nconst MONTH_LEN: [i32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nconst MONTH_START: [i32; 12] = gen_starts();\\n\\nconst fn gen_starts() -> [i32; 12] {\\n    let mut arr = [0; 12];\\n    let mut sum = 0;\\n    let mut i = 0;\\n    while i < 12 {\\n        arr[i] = sum;\\n        sum += MONTH_LEN[i];\\n        i += 1;\\n    }\\n    arr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037709,
                "title": "python-beats-89-45",
                "content": "# Code\\n![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/e8058428-4f4a-4b63-b3e9-ae1c706437c3_1694566803.1178703.png)\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        Output = 0\\n        d = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}\\n        arriveAlice = arriveAlice[0] + arriveAlice[1] + arriveAlice[3] + arriveAlice[4]\\n        leaveAlice = leaveAlice[0] + leaveAlice[1] + leaveAlice[3] + leaveAlice[4]\\n        arriveBob = arriveBob[0] + arriveBob[1] + arriveBob[3] + arriveBob[4]\\n        leaveBob = leaveBob[0] + leaveBob[1] + leaveBob[3] + leaveBob[4]\\n\\n        def PASS(time1: str,time2: str) -> int:\\n            nonlocal Output\\n            curr = int(time1[0] + time1[1])\\n            end = int(time2[0] + time2[1])\\n\\n            if curr != end:\\n                Output = Output + d[curr] - int(time1[2] + time1[3]) + 1\\n                curr = curr + 1\\n                while curr != end:\\n                    Output = Output + d[curr]\\n                    curr = curr + 1\\n                Output = Output + int(time2[2] + time2[3])\\n            elif curr == end:\\n                Output = Output + int(time2[2] + time2[3]) - int(time1[2] + time1[3]) + 1\\n            \\n            return Output\\n        \\n        if int(arriveBob) > int(leaveAlice) or int(arriveAlice) > int(leaveBob):\\n            return 0\\n        else:\\n            if int(arriveBob) > int(arriveAlice):\\n                if int(leaveBob) > int(leaveAlice):\\n                    return PASS(arriveBob, leaveAlice)\\n                elif int(leaveBob) <= int(leaveAlice):\\n                    return PASS(arriveBob, leaveBob)\\n            elif int(arriveBob) < int(arriveAlice):\\n                if int(leaveBob) >= int(leaveAlice):\\n                    return PASS(arriveAlice, leaveAlice)\\n                elif int(leaveBob) < int(leaveAlice):\\n                    return PASS(arriveAlice, leaveBob)\\n            elif int(arriveBob) == int(arriveAlice):\\n                if int(leaveBob) >= int(leaveAlice):\\n                    return PASS(arriveAlice, leaveAlice)\\n                elif int(leaveBob) < int(leaveAlice):\\n                    return PASS(arriveBob, leaveBob)\\n\\n        # 20230913\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        Output = 0\\n        d = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30, 7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}\\n        arriveAlice = arriveAlice[0] + arriveAlice[1] + arriveAlice[3] + arriveAlice[4]\\n        leaveAlice = leaveAlice[0] + leaveAlice[1] + leaveAlice[3] + leaveAlice[4]\\n        arriveBob = arriveBob[0] + arriveBob[1] + arriveBob[3] + arriveBob[4]\\n        leaveBob = leaveBob[0] + leaveBob[1] + leaveBob[3] + leaveBob[4]\\n\\n        def PASS(time1: str,time2: str) -> int:\\n            nonlocal Output\\n            curr = int(time1[0] + time1[1])\\n            end = int(time2[0] + time2[1])\\n\\n            if curr != end:\\n                Output = Output + d[curr] - int(time1[2] + time1[3]) + 1\\n                curr = curr + 1\\n                while curr != end:\\n                    Output = Output + d[curr]\\n                    curr = curr + 1\\n                Output = Output + int(time2[2] + time2[3])\\n            elif curr == end:\\n                Output = Output + int(time2[2] + time2[3]) - int(time1[2] + time1[3]) + 1\\n            \\n            return Output\\n        \\n        if int(arriveBob) > int(leaveAlice) or int(arriveAlice) > int(leaveBob):\\n            return 0\\n        else:\\n            if int(arriveBob) > int(arriveAlice):\\n                if int(leaveBob) > int(leaveAlice):\\n                    return PASS(arriveBob, leaveAlice)\\n                elif int(leaveBob) <= int(leaveAlice):\\n                    return PASS(arriveBob, leaveBob)\\n            elif int(arriveBob) < int(arriveAlice):\\n                if int(leaveBob) >= int(leaveAlice):\\n                    return PASS(arriveAlice, leaveAlice)\\n                elif int(leaveBob) < int(leaveAlice):\\n                    return PASS(arriveAlice, leaveBob)\\n            elif int(arriveBob) == int(arriveAlice):\\n                if int(leaveBob) >= int(leaveAlice):\\n                    return PASS(arriveAlice, leaveAlice)\\n                elif int(leaveBob) < int(leaveAlice):\\n                    return PASS(arriveBob, leaveBob)\\n\\n        # 20230913\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019880,
                "title": "clear-and-easy-to-understand-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int[] daysOfMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aA = dayOfYear(daysOfMonth, mmdd(arriveAlice));\\n        int lA = dayOfYear(daysOfMonth, mmdd(leaveAlice));\\n        int aB = dayOfYear(daysOfMonth, mmdd(arriveBob));\\n        int lB = dayOfYear(daysOfMonth, mmdd(leaveBob));\\n        if(aA > lB || aB > lA) return 0;\\n        return Math.min(lA, lB) - Math.max(aA, aB) + 1;\\n        \\n    }\\n\\n    private int[] mmdd(String str){\\n        String[] arr = str.split(\"-\");\\n        return new int[]{Integer.parseInt(arr[0]), Integer.parseInt(arr[1])};\\n    }\\n\\n    private int dayOfYear(int[] daysOfMonths, int[] mmdd){\\n        int count = 0;\\n        for(int i = 0; i < mmdd[0] - 1; i++)\\n            count += daysOfMonths[i];\\n        count += mmdd[1];\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int[] daysOfMonth = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int aA = dayOfYear(daysOfMonth, mmdd(arriveAlice));\\n        int lA = dayOfYear(daysOfMonth, mmdd(leaveAlice));\\n        int aB = dayOfYear(daysOfMonth, mmdd(arriveBob));\\n        int lB = dayOfYear(daysOfMonth, mmdd(leaveBob));\\n        if(aA > lB || aB > lA) return 0;\\n        return Math.min(lA, lB) - Math.max(aA, aB) + 1;\\n        \\n    }\\n\\n    private int[] mmdd(String str){\\n        String[] arr = str.split(\"-\");\\n        return new int[]{Integer.parseInt(arr[0]), Integer.parseInt(arr[1])};\\n    }\\n\\n    private int dayOfYear(int[] daysOfMonths, int[] mmdd){\\n        int count = 0;\\n        for(int i = 0; i < mmdd[0] - 1; i++)\\n            count += daysOfMonths[i];\\n        count += mmdd[1];\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965711,
                "title": "python-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nchoosing second to come and first to leave dates.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConverting the string to [month, date] list.\\nAdding dates in a month between these two choosing and the rest of days.\\nMultiplying the month with some high number to compare the dates.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arriveAlice, arriveBob = [int(i) for i in arriveAlice.split(\\'-\\')], [int(j) for j in arriveBob.split(\\'-\\')]\\n        leaveAlice, leaveBob = [int(i) for i in leaveAlice.split(\\'-\\')], [int(j) for j in leaveBob.split(\\'-\\')]\\n        second_come = arriveAlice if arriveAlice[0] * 1000 + arriveAlice[1] > arriveBob[0] * 1000 + arriveBob[1] else arriveBob\\n        first_leave = leaveAlice if leaveAlice[0] * 1000 + leaveAlice[1] < leaveBob[0] * 1000 + leaveBob[1] else leaveBob\\n        if second_come[0] * 1000 + second_come[1] > first_leave[0] * 1000 + first_leave[1]: return 0\\n        return sum(self.months[i - 1] for i in range(second_come[0], first_leave[0])) - second_come[1] + first_leave[1] + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arriveAlice, arriveBob = [int(i) for i in arriveAlice.split(\\'-\\')], [int(j) for j in arriveBob.split(\\'-\\')]\\n        leaveAlice, leaveBob = [int(i) for i in leaveAlice.split(\\'-\\')], [int(j) for j in leaveBob.split(\\'-\\')]\\n        second_come = arriveAlice if arriveAlice[0] * 1000 + arriveAlice[1] > arriveBob[0] * 1000 + arriveBob[1] else arriveBob\\n        first_leave = leaveAlice if leaveAlice[0] * 1000 + leaveAlice[1] < leaveBob[0] * 1000 + leaveBob[1] else leaveBob\\n        if second_come[0] * 1000 + second_come[1] > first_leave[0] * 1000 + first_leave[1]: return 0\\n        return sum(self.months[i - 1] for i in range(second_come[0], first_leave[0])) - second_come[1] + first_leave[1] + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948758,
                "title": "unique-solution-using-the-logic-of-number-of-days-between-two-dates",
                "content": "# Code\\n```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        LocalDate aAlice = LocalDate.of(2019,Integer.valueOf(arriveAlice.substring(0,2)),Integer.valueOf( arriveAlice.substring(3,5) ) );\\n\\n        LocalDate aBob = LocalDate.of(2019,Integer.valueOf(arriveBob.substring(0,2)),Integer.valueOf( arriveBob.substring(3,5) ) );\\n\\n        LocalDate lAlice = LocalDate.of(2019,Integer.valueOf(leaveAlice.substring(0,2)),Integer.valueOf( leaveAlice.substring(3,5) ) );\\n\\n        LocalDate lBob = LocalDate.of(2019,Integer.valueOf(leaveBob.substring(0,2)),Integer.valueOf( leaveBob.substring(3,5) ) );\\n\\n        LocalDate arrival = aAlice.isAfter(aBob)?aAlice:aBob;\\n        LocalDate depart = lAlice.isBefore(lBob)?lAlice:lBob;\\n        long daysBetween =  ChronoUnit.DAYS.between(arrival,depart);\\n        int g = (int) daysBetween+1;\\n        if(g<0){\\n            return 0;\\n        }\\n        return g;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.temporal.ChronoUnit;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        LocalDate aAlice = LocalDate.of(2019,Integer.valueOf(arriveAlice.substring(0,2)),Integer.valueOf( arriveAlice.substring(3,5) ) );\\n\\n        LocalDate aBob = LocalDate.of(2019,Integer.valueOf(arriveBob.substring(0,2)),Integer.valueOf( arriveBob.substring(3,5) ) );\\n\\n        LocalDate lAlice = LocalDate.of(2019,Integer.valueOf(leaveAlice.substring(0,2)),Integer.valueOf( leaveAlice.substring(3,5) ) );\\n\\n        LocalDate lBob = LocalDate.of(2019,Integer.valueOf(leaveBob.substring(0,2)),Integer.valueOf( leaveBob.substring(3,5) ) );\\n\\n        LocalDate arrival = aAlice.isAfter(aBob)?aAlice:aBob;\\n        LocalDate depart = lAlice.isBefore(lBob)?lAlice:lBob;\\n        long daysBetween =  ChronoUnit.DAYS.between(arrival,depart);\\n        int g = (int) daysBetween+1;\\n        if(g<0){\\n            return 0;\\n        }\\n        return g;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945679,
                "title": "easy-to-understand-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    String greatDate(String s1,String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        if(m1>m2) return s1;\\n        else if(m2>m1) return s2;\\n\\n        m1=Integer.parseInt(s1.substring(3));\\n        m2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1>m2) return s1;\\n\\n        return s2;\\n    }\\n\\n     String smallDate(String s1,String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        if(m1<m2) return s1;\\n        else if(m2<m1) return s2;\\n\\n        m1=Integer.parseInt(s1.substring(3));\\n        m2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1<m2) return s1;\\n\\n        return s2;\\n    }\\n\\n    int countDay(String s1, String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        int d1=Integer.parseInt(s1.substring(3));\\n        int d2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1>m2) return 0;\\n        else if(m1==m2 && d1>d2) return 0;\\n        \\n\\n        int c=0;\\n        int [] arr={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n        if(m1!=m2){\\n       for(int i=m1; i<m2-1; i++)\\n         c+=arr[i];\\n        }else if(m1==m2) return d2-d1+1;\\n\\n\\n        return c+d2+arr[m1-1]-d1+1;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n         \\n         String startDateTogether = greatDate(arriveAlice,arriveBob);\\n\\n         String endDateTogether = smallDate(leaveBob,leaveAlice);\\n\\n         return countDay(startDateTogether,endDateTogether);\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String greatDate(String s1,String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        if(m1>m2) return s1;\\n        else if(m2>m1) return s2;\\n\\n        m1=Integer.parseInt(s1.substring(3));\\n        m2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1>m2) return s1;\\n\\n        return s2;\\n    }\\n\\n     String smallDate(String s1,String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        if(m1<m2) return s1;\\n        else if(m2<m1) return s2;\\n\\n        m1=Integer.parseInt(s1.substring(3));\\n        m2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1<m2) return s1;\\n\\n        return s2;\\n    }\\n\\n    int countDay(String s1, String s2){\\n        int m1=Integer.parseInt(s1.substring(0,2));\\n        int m2=Integer.parseInt(s2.substring(0,2));\\n        int d1=Integer.parseInt(s1.substring(3));\\n        int d2=Integer.parseInt(s2.substring(3));\\n\\n        if(m1>m2) return 0;\\n        else if(m1==m2 && d1>d2) return 0;\\n        \\n\\n        int c=0;\\n        int [] arr={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n        if(m1!=m2){\\n       for(int i=m1; i<m2-1; i++)\\n         c+=arr[i];\\n        }else if(m1==m2) return d2-d1+1;\\n\\n\\n        return c+d2+arr[m1-1]-d1+1;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n         \\n         String startDateTogether = greatDate(arriveAlice,arriveBob);\\n\\n         String endDateTogether = smallDate(leaveBob,leaveAlice);\\n\\n         return countDay(startDateTogether,endDateTogether);\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943026,
                "title": "simple-typescript-solution-100-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/772c5f9d-36de-45ee-90e1-35634b35f341_1692661114.9814005.png)\\n\\n# Code (100% speed)\\n```ts\\nconst NOT_LEAP_YEAR = \"2023-\"\\nconst DAY = 1000 * 60 * 60 * 24\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    const getDateVal = (a: string): number => {\\n        return new Date(NOT_LEAP_YEAR + a).valueOf()\\n    }\\n\\n    return Math.max(\\n        0,\\n        (\\n            Math.min(getDateVal(leaveAlice), getDateVal(leaveBob))\\n            - Math.max(getDateVal(arriveAlice), getDateVal(arriveBob))\\n        )/ DAY + 1\\n    )\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nconst NOT_LEAP_YEAR = \"2023-\"\\nconst DAY = 1000 * 60 * 60 * 24\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    const getDateVal = (a: string): number => {\\n        return new Date(NOT_LEAP_YEAR + a).valueOf()\\n    }\\n\\n    return Math.max(\\n        0,\\n        (\\n            Math.min(getDateVal(leaveAlice), getDateVal(leaveBob))\\n            - Math.max(getDateVal(arriveAlice), getDateVal(arriveBob))\\n        )/ DAY + 1\\n    )\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938889,
                "title": "easy-readable-solution-3-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom datetime import datetime\\n\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        def get_date(d):\\n            return datetime.strptime(d, \\'%m-%d\\')\\n        return max(0, (min(get_date(leaveAlice), get_date(leaveBob)) - max(get_date(arriveAlice), get_date(arriveBob))).days + 1)\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom datetime import datetime\\n\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        def get_date(d):\\n            return datetime.strptime(d, \\'%m-%d\\')\\n        return max(0, (min(get_date(leaveAlice), get_date(leaveBob)) - max(get_date(arriveAlice), get_date(arriveBob))).days + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919540,
                "title": "java-easiest-to-understand-clean-code-beats-100",
                "content": "# Intuition\\n* Get a reference for easy dealing with the intervals (start of year)\\n* Get days since start of year for each point in time\\n* Discard in case of no overalp\\n* Calculate difference between latest interval start and earlier interval end (+1 since limits are all inclusive)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nNo libraries or magic tricks, just parse dates and easily calculate.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public final static int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arriveAliveEpoch = getDaysSinceYearStart(arriveAlice);\\n        int leaveAliceEpoch = getDaysSinceYearStart(leaveAlice);\\n        int arriveBobEpoch = getDaysSinceYearStart(arriveBob);\\n        int leaveBobEpoch = getDaysSinceYearStart(leaveBob);\\n\\n        return getOverlappingDays(arriveAliveEpoch, leaveAliceEpoch, arriveBobEpoch, leaveBobEpoch);\\n    }\\n\\n    private int getDaysSinceYearStart(String date) {\\n        int month = Integer.valueOf(date.substring(0, 2));\\n        int day = Integer.valueOf(date.substring(3, 5));\\n\\n        int numDays = 0;\\n\\n        for (int i = 0; i < month - 1; i++) {\\n            numDays += daysInMonth[i];\\n        }\\n\\n        numDays += day;\\n\\n        return numDays;\\n    }\\n\\n    private int getOverlappingDays(int firstIntervalStart, int firstIntervalEnd, int secondIntervalStart, int secondIntervalEnd) {\\n        if ( firstIntervalStart > secondIntervalEnd || secondIntervalStart > firstIntervalEnd) {\\n            return 0;\\n        } else {\\n            int latestStart = Math.max(firstIntervalStart, secondIntervalStart);\\n            int earliestEnd = Math.min(firstIntervalEnd, secondIntervalEnd);\\n\\n            return earliestEnd - latestStart + 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public final static int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int arriveAliveEpoch = getDaysSinceYearStart(arriveAlice);\\n        int leaveAliceEpoch = getDaysSinceYearStart(leaveAlice);\\n        int arriveBobEpoch = getDaysSinceYearStart(arriveBob);\\n        int leaveBobEpoch = getDaysSinceYearStart(leaveBob);\\n\\n        return getOverlappingDays(arriveAliveEpoch, leaveAliceEpoch, arriveBobEpoch, leaveBobEpoch);\\n    }\\n\\n    private int getDaysSinceYearStart(String date) {\\n        int month = Integer.valueOf(date.substring(0, 2));\\n        int day = Integer.valueOf(date.substring(3, 5));\\n\\n        int numDays = 0;\\n\\n        for (int i = 0; i < month - 1; i++) {\\n            numDays += daysInMonth[i];\\n        }\\n\\n        numDays += day;\\n\\n        return numDays;\\n    }\\n\\n    private int getOverlappingDays(int firstIntervalStart, int firstIntervalEnd, int secondIntervalStart, int secondIntervalEnd) {\\n        if ( firstIntervalStart > secondIntervalEnd || secondIntervalStart > firstIntervalEnd) {\\n            return 0;\\n        } else {\\n            int latestStart = Math.max(firstIntervalStart, secondIntervalStart);\\n            int earliestEnd = Math.min(firstIntervalEnd, secondIntervalEnd);\\n\\n            return earliestEnd - latestStart + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879453,
                "title": "java-10ms-beats-5-49",
                "content": "# Intuition & Approach\\n- Use Java\\'s built-in Date functions because they\\'re efficient and error-free\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.time.LocalDate;\\nimport java.time.ZoneId;\\nimport java.time.temporal.ChronoUnit;\\nimport java.util.Date;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        // strategy: find difference between later arrive and earlier leave.\\n        // negative values mean no overlap.\\n\\n        // find difference between later arrive and and earlier leave\\n        int arriveComparison = arriveAlice.compareTo(arriveBob);\\n        Date laterArrive = null;\\n        if (arriveComparison < 0) {\\n            laterArrive = convertMonthDayToDate(arriveBob);\\n        } else {\\n            laterArrive = convertMonthDayToDate(arriveAlice);\\n        }\\n\\n        int leaveComparison = leaveAlice.compareTo(leaveBob);\\n        Date earlierLeave = null;\\n        if (leaveComparison < 0) {\\n            earlierLeave = convertMonthDayToDate(leaveAlice);\\n        } else {\\n            earlierLeave = convertMonthDayToDate(leaveBob);\\n        }\\n\\n        int overlap = daysOverlap(laterArrive, earlierLeave);\\n        return overlap < 0 ? 0 : overlap;\\n    }\\n\\n    private Date convertMonthDayToDate(String s) {\\n        int year = 2023;  // we need a year without a leap day\\n        int month = (s.charAt(0) - \\'0\\') * 10 + s.charAt(1) - \\'0\\';\\n        int day = (s.charAt(3) - \\'0\\') * 10 + s.charAt(4) - \\'0\\';\\n        LocalDate localDate = LocalDate.of(year, month, day);\\n        return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());\\n    }\\n\\n    private int daysOverlap(Date date1, Date date2) {\\n        LocalDate localDate1 = date1.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\\n        LocalDate localDate2 = date2.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\\n        return (int)ChronoUnit.DAYS.between(localDate1, localDate2) + 1;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\nimport java.time.ZoneId;\\nimport java.time.temporal.ChronoUnit;\\nimport java.util.Date;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        // strategy: find difference between later arrive and earlier leave.\\n        // negative values mean no overlap.\\n\\n        // find difference between later arrive and and earlier leave\\n        int arriveComparison = arriveAlice.compareTo(arriveBob);\\n        Date laterArrive = null;\\n        if (arriveComparison < 0) {\\n            laterArrive = convertMonthDayToDate(arriveBob);\\n        } else {\\n            laterArrive = convertMonthDayToDate(arriveAlice);\\n        }\\n\\n        int leaveComparison = leaveAlice.compareTo(leaveBob);\\n        Date earlierLeave = null;\\n        if (leaveComparison < 0) {\\n            earlierLeave = convertMonthDayToDate(leaveAlice);\\n        } else {\\n            earlierLeave = convertMonthDayToDate(leaveBob);\\n        }\\n\\n        int overlap = daysOverlap(laterArrive, earlierLeave);\\n        return overlap < 0 ? 0 : overlap;\\n    }\\n\\n    private Date convertMonthDayToDate(String s) {\\n        int year = 2023;  // we need a year without a leap day\\n        int month = (s.charAt(0) - \\'0\\') * 10 + s.charAt(1) - \\'0\\';\\n        int day = (s.charAt(3) - \\'0\\') * 10 + s.charAt(4) - \\'0\\';\\n        LocalDate localDate = LocalDate.of(year, month, day);\\n        return Date.from(localDate.atStartOfDay(ZoneId.systemDefault()).toInstant());\\n    }\\n\\n    private int daysOverlap(Date date1, Date date2) {\\n        LocalDate localDate1 = date1.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\\n        LocalDate localDate2 = date2.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\\n        return (int)ChronoUnit.DAYS.between(localDate1, localDate2) + 1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867827,
                "title": "js-six-possibilities",
                "content": "# Intuition\\nBuild and array with days in, days out and compare possibilities\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\nlet yrdd = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\nvar days = []\\ndays.push(dds(arriveAlice))\\ndays.push(dds(leaveAlice))\\ndays.push(dds(arriveBob))\\ndays.push(dds(leaveBob))\\n\\n// 1. Alices arrives when Bob has left\\n    if(days[3]<days[0]){\\n        return 0\\n    }\\n\\n// 2. Bob arrives when Alice has left\\n    if(days[1]<days[2]){\\n        return 0\\n    }\\n\\n// 3. Alice arrives after Bob and leaves after Bob\\n    if(days[2]<=days[0] && days[3]<=days[1]){\\n        return days[3]-days[0]+1\\n    }\\n\\n// 4. Alice arrives after Bob and leaves before Bob\\n    if(days[2]<=days[0] && days[1]<=days[3]){\\n        return days[1]-days[0]+1\\n    }\\n\\n// 5. Alice arrives before Bob and leaves after Bob\\n    if(days[0]<=days[2] && days[3]<=days[1]){\\n        return days[3]-days[2]+1\\n    }\\n\\n// 6. Alice arrives before bob and leaves before Bob\\n    if(days[0]<=days[2] && days[1]<=days[3]){\\n        return days[1]-days[2]+1\\n    }\\n\\nfunction dds(str){\\n    var arr = str.split(\\'-\\')\\n    var m = Number(arr[0])\\n    var d = Number(arr[1])\\n    var dd = d\\n    for(var i = 0; i<m-1; i++){\\n        dd += yrdd[i]\\n    }\\n    return dd;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\nlet yrdd = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\nvar days = []\\ndays.push(dds(arriveAlice))\\ndays.push(dds(leaveAlice))\\ndays.push(dds(arriveBob))\\ndays.push(dds(leaveBob))\\n\\n// 1. Alices arrives when Bob has left\\n    if(days[3]<days[0]){\\n        return 0\\n    }\\n\\n// 2. Bob arrives when Alice has left\\n    if(days[1]<days[2]){\\n        return 0\\n    }\\n\\n// 3. Alice arrives after Bob and leaves after Bob\\n    if(days[2]<=days[0] && days[3]<=days[1]){\\n        return days[3]-days[0]+1\\n    }\\n\\n// 4. Alice arrives after Bob and leaves before Bob\\n    if(days[2]<=days[0] && days[1]<=days[3]){\\n        return days[1]-days[0]+1\\n    }\\n\\n// 5. Alice arrives before Bob and leaves after Bob\\n    if(days[0]<=days[2] && days[3]<=days[1]){\\n        return days[3]-days[2]+1\\n    }\\n\\n// 6. Alice arrives before bob and leaves before Bob\\n    if(days[0]<=days[2] && days[1]<=days[3]){\\n        return days[1]-days[2]+1\\n    }\\n\\nfunction dds(str){\\n    var arr = str.split(\\'-\\')\\n    var m = Number(arr[0])\\n    var d = Number(arr[1])\\n    var dd = d\\n    for(var i = 0; i<m-1; i++){\\n        dd += yrdd[i]\\n    }\\n    return dd;\\n}\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3856758,
                "title": "python-simple-solution-string-math",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:\\n    months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    start = max(arAl, arBo)\\n    end = min(lAl, lBo)\\n\\n    startDay = int(start[3:])\\n    startMonth = int(start[:2])\\n    endDay = int(end[3:])\\n    endMonth = int(end[:2])\\n\\n    if start > end:\\n      return 0\\n    if startMonth == endMonth:\\n      return endDay - startDay + 1\\n    elif startMonth < endMonth:\\n      return months[startMonth] - startDay + endDay + 1 + sum(months[m] for m in range(startMonth + 1, endMonth))\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def countDaysTogether(self, arAl: str, lAl: str, arBo: str, lBo: str) -> int:\\n    months = [-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n    start = max(arAl, arBo)\\n    end = min(lAl, lBo)\\n\\n    startDay = int(start[3:])\\n    startMonth = int(start[:2])\\n    endDay = int(end[3:])\\n    endMonth = int(end[:2])\\n\\n    if start > end:\\n      return 0\\n    if startMonth == endMonth:\\n      return endDay - startDay + 1\\n    elif startMonth < endMonth:\\n      return months[startMonth] - startDay + endDay + 1 + sum(months[m] for m in range(startMonth + 1, endMonth))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844736,
                "title": "beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private static final int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    private static final int[] daysBefore = new int[12];\\n\\n\\n    static {\\n        int totalDaysBefore = 0;\\n        int i = 0;\\n        for (int days: daysInMonth) {\\n            daysBefore[i++] = totalDaysBefore; \\n            totalDaysBefore += days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int days = Math.min(toDayNumber(leaveAlice), toDayNumber(leaveBob)) - Math.max(toDayNumber(arriveAlice), toDayNumber(arriveBob));\\n        return days >= 0 ? days + 1 : 0;\\n    }\\n\\n    private int toDayNumber(String mmdd) {\\n        int month = toInt(mmdd.charAt(0)) * 10 + toInt(mmdd.charAt(1));\\n        int day = toInt(mmdd.charAt(3)) * 10 + toInt(mmdd.charAt(4));\\n        return daysBefore[month - 1] + day;\\n    }\\n\\n\\n    private int toInt(char c) {\\n        return c - \\'0\\';\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    private static final int[] daysBefore = new int[12];\\n\\n\\n    static {\\n        int totalDaysBefore = 0;\\n        int i = 0;\\n        for (int days: daysInMonth) {\\n            daysBefore[i++] = totalDaysBefore; \\n            totalDaysBefore += days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int days = Math.min(toDayNumber(leaveAlice), toDayNumber(leaveBob)) - Math.max(toDayNumber(arriveAlice), toDayNumber(arriveBob));\\n        return days >= 0 ? days + 1 : 0;\\n    }\\n\\n    private int toDayNumber(String mmdd) {\\n        int month = toInt(mmdd.charAt(0)) * 10 + toInt(mmdd.charAt(1));\\n        int day = toInt(mmdd.charAt(3)) * 10 + toInt(mmdd.charAt(4));\\n        return daysBefore[month - 1] + day;\\n    }\\n\\n\\n    private int toInt(char c) {\\n        return c - \\'0\\';\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844734,
                "title": "beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private static final int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    private static final int[] daysBefore = new int[12];\\n\\n\\n    static {\\n        int totalDaysBefore = 0;\\n        int i = 0;\\n        for (int days: daysInMonth) {\\n            daysBefore[i++] = totalDaysBefore; \\n            totalDaysBefore += days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int days = Math.min(toDayNumber(leaveAlice), toDayNumber(leaveBob)) - Math.max(toDayNumber(arriveAlice), toDayNumber(arriveBob));\\n        return days >= 0 ? days + 1 : 0;\\n    }\\n\\n    private int toDayNumber(String mmdd) {\\n        int month = toInt(mmdd.charAt(0)) * 10 + toInt(mmdd.charAt(1));\\n        int day = toInt(mmdd.charAt(3)) * 10 + toInt(mmdd.charAt(4));\\n        return daysBefore[month - 1] + day;\\n    }\\n\\n\\n    private int toInt(char c) {\\n        return c - \\'0\\';\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final int[] daysInMonth = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    private static final int[] daysBefore = new int[12];\\n\\n\\n    static {\\n        int totalDaysBefore = 0;\\n        int i = 0;\\n        for (int days: daysInMonth) {\\n            daysBefore[i++] = totalDaysBefore; \\n            totalDaysBefore += days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int days = Math.min(toDayNumber(leaveAlice), toDayNumber(leaveBob)) - Math.max(toDayNumber(arriveAlice), toDayNumber(arriveBob));\\n        return days >= 0 ? days + 1 : 0;\\n    }\\n\\n    private int toDayNumber(String mmdd) {\\n        int month = toInt(mmdd.charAt(0)) * 10 + toInt(mmdd.charAt(1));\\n        int day = toInt(mmdd.charAt(3)) * 10 + toInt(mmdd.charAt(4));\\n        return daysBefore[month - 1] + day;\\n    }\\n\\n\\n    private int toInt(char c) {\\n        return c - \\'0\\';\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825853,
                "title": "average-solution-day-of-year",
                "content": "# Intuition\\n\\nParse date to date of year and then do check interception of two intervals. \\n\\n# Approach\\n\\nDefine an array with day of year at the begining of month. When parse - search by month, add day. \\n\\n\\n# Code\\n```\\nimport java.time.LocalDate;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n  \\n        final var months = new int[]{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n\\n        final var aliceStart = parse(arriveAlice, months);\\n        final var aliceEnd = parse(leaveAlice, months);\\n\\n        final var bobStart = parse(arriveBob, months);\\n        final var bobEnd = parse(leaveBob, months);\\n\\n        if(aliceEnd < bobStart || bobEnd < aliceStart){\\n            return 0;\\n        }\\n\\n        if(aliceStart < bobStart){ // allice arived before bob\\n            if(aliceEnd < bobEnd){ // alice left before bob\\n                return aliceEnd - bobStart + 1;\\n            }else { // bob left before alice\\n                return bobEnd - bobStart  + 1;\\n            }\\n        }else{ // bob arived before alice\\n            if(bobEnd < aliceEnd){ // bob left before left\\n                return bobEnd - aliceStart  + 1; \\n            }else { // alice left before bob\\n                return aliceEnd - aliceStart  + 1;\\n            }\\n        }\\n    }\\n\\n    private int parse(final String date, final int[] monthsDay){\\n        final var s = date.split(\"-\");\\n        final int month = Integer.parseInt(s[0]) - 1;\\n        final int day = Integer.parseInt(s[1]);\\n\\n        return monthsDay[month] + day;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.time.LocalDate;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n  \\n        final var months = new int[]{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n\\n        final var aliceStart = parse(arriveAlice, months);\\n        final var aliceEnd = parse(leaveAlice, months);\\n\\n        final var bobStart = parse(arriveBob, months);\\n        final var bobEnd = parse(leaveBob, months);\\n\\n        if(aliceEnd < bobStart || bobEnd < aliceStart){\\n            return 0;\\n        }\\n\\n        if(aliceStart < bobStart){ // allice arived before bob\\n            if(aliceEnd < bobEnd){ // alice left before bob\\n                return aliceEnd - bobStart + 1;\\n            }else { // bob left before alice\\n                return bobEnd - bobStart  + 1;\\n            }\\n        }else{ // bob arived before alice\\n            if(bobEnd < aliceEnd){ // bob left before left\\n                return bobEnd - aliceStart  + 1; \\n            }else { // alice left before bob\\n                return aliceEnd - aliceStart  + 1;\\n            }\\n        }\\n    }\\n\\n    private int parse(final String date, final int[] monthsDay){\\n        final var s = date.split(\"-\");\\n        final int month = Integer.parseInt(s[0]) - 1;\\n        final int day = Integer.parseInt(s[1]);\\n\\n        return monthsDay[month] + day;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821118,
                "title": "58ms-optimized",
                "content": "\\n# Code\\n```\\ntype DateInput = {\\n    month: number;\\n    day: number;\\n}\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    let aliceData = {\\n        arriveDate: inputDate(arriveAlice), // {month, day}\\n        leaveDate: inputDate(leaveAlice),\\n        arriveAbsoluteDay: 0,\\n        leaveAbsoluteDay: 0,\\n    }\\n\\n    let bobData = {\\n        arriveDate: inputDate(arriveBob),\\n        leaveDate: inputDate(leaveBob),\\n        arriveAbsoluteDay: 0,\\n        leaveAbsoluteDay: 0\\n    }\\n\\n    aliceData.arriveAbsoluteDay = absoluteDay({...aliceData.arriveDate})\\n    aliceData.leaveAbsoluteDay = absoluteDay({...aliceData.leaveDate})\\n\\n    bobData.arriveAbsoluteDay = absoluteDay({...bobData.arriveDate})\\n    bobData.leaveAbsoluteDay = absoluteDay({...bobData.leaveDate})\\n\\n   return Math.max(0, Math.min(aliceData.leaveAbsoluteDay, bobData.leaveAbsoluteDay) - Math.max(aliceData.arriveAbsoluteDay, bobData.arriveAbsoluteDay) + 1);\\n};\\n\\n\\n// helpers\\n\\nconst inputDate = (date: string): DateInput => {\\n        // format: MM-DD\\n        const chunks = date.split(\\'-\\');\\n        let month: number = Number(chunks[0])\\n        let day: number = Number(chunks[1]);\\n        return {month, day}\\n    }\\n\\nconst absoluteDay = ({month, day}): number => {\\n    const daysInEachMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n    let result = 0;\\n    for (let m = 1; m < month; m++) {\\n        result += daysInEachMonth[m - 1];\\n    }\\n    result += day;\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype DateInput = {\\n    month: number;\\n    day: number;\\n}\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    let aliceData = {\\n        arriveDate: inputDate(arriveAlice), // {month, day}\\n        leaveDate: inputDate(leaveAlice),\\n        arriveAbsoluteDay: 0,\\n        leaveAbsoluteDay: 0,\\n    }\\n\\n    let bobData = {\\n        arriveDate: inputDate(arriveBob),\\n        leaveDate: inputDate(leaveBob),\\n        arriveAbsoluteDay: 0,\\n        leaveAbsoluteDay: 0\\n    }\\n\\n    aliceData.arriveAbsoluteDay = absoluteDay({...aliceData.arriveDate})\\n    aliceData.leaveAbsoluteDay = absoluteDay({...aliceData.leaveDate})\\n\\n    bobData.arriveAbsoluteDay = absoluteDay({...bobData.arriveDate})\\n    bobData.leaveAbsoluteDay = absoluteDay({...bobData.leaveDate})\\n\\n   return Math.max(0, Math.min(aliceData.leaveAbsoluteDay, bobData.leaveAbsoluteDay) - Math.max(aliceData.arriveAbsoluteDay, bobData.arriveAbsoluteDay) + 1);\\n};\\n\\n\\n// helpers\\n\\nconst inputDate = (date: string): DateInput => {\\n        // format: MM-DD\\n        const chunks = date.split(\\'-\\');\\n        let month: number = Number(chunks[0])\\n        let day: number = Number(chunks[1]);\\n        return {month, day}\\n    }\\n\\nconst absoluteDay = ({month, day}): number => {\\n    const daysInEachMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n    let result = 0;\\n    for (let m = 1; m < month; m++) {\\n        result += daysInEachMonth[m - 1];\\n    }\\n    result += day;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817916,
                "title": "problem-days-spent-together",
                "content": "# Intuition\\nJust compute the days without using any date functions.\\n\\n# Approach\\nGet the start and end date where they are together then compute the distance.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype DateInput = {\\n    month: number;\\n    date: number;\\n}\\n\\nconst daysMap = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nfunction createDateInput(value: string): DateInput {\\n    const chunks = value.split(\\'-\\');\\n    return {\\n        month: parseInt(chunks[0]),\\n        date: parseInt(chunks[1]),\\n    };\\n}\\n\\nfunction compare(input1: DateInput, input2: DateInput): number {\\n    if (input1.month === input2.month) {\\n        if (input1.date > input2.date) {\\n            return 1;\\n        } else if (input1.date < input2.date) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    } else {\\n        if (input1.month > input2.month) {\\n            return 1;\\n        } else if (input1.month < input2.month) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\\nfunction computeDiff(input1: DateInput, input2: DateInput): number {\\n    if (input1.month === input2.month) {\\n        // Same month, just diff the date and pad 1 day\\n        return input2.date - input1.date;\\n    } else {\\n        // Different month, compute distance\\n        let runningMonth = input1.month;\\n        let daysInMonth = daysMap[runningMonth - 1];\\n        let days = daysInMonth - input1.date;\\n\\n        while (runningMonth < input2.month) {\\n            runningMonth++;\\n            daysInMonth = daysMap[runningMonth - 1];\\n            if (runningMonth === input2.month) {\\n                days += input2.date;\\n            } else {\\n                days += daysInMonth;\\n            }\\n        }\\n        \\n        return days;\\n    }\\n}\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    const arriveAliceInput = createDateInput(arriveAlice);\\n    const leaveAliceInput = createDateInput(leaveAlice);\\n    const arriveBobInput = createDateInput(arriveBob);\\n    const leaveBobInput = createDateInput(leaveBob);\\n\\n    let together = 0;\\n    let start: DateInput;\\n    let end: DateInput;\\n\\n    // Find earliest arrival and earliest leave\\n    const earliestDiff = compare(arriveAliceInput, arriveBobInput);\\n    const earliestLeaveDiff = compare(leaveAliceInput, leaveBobInput);\\n\\n    if (earliestDiff === 0 || earliestDiff === -1) {\\n        // Alice was earlier or they arrived at the same date\\n        // Let\\'s find out if they met by finding out if bob arrived earlier than alice left\\n        const intersect = compare(leaveAliceInput, arriveBobInput);\\n        if (intersect === 1 || intersect === 0) {\\n            // They met somehow, so let\\'s start by the date where bob arrived\\n            start = arriveBobInput;\\n\\n            // When does it ends? Depends on who left earlier\\n            if (earliestLeaveDiff === 0 || earliestLeaveDiff === -1) {\\n                // Alice left early or they left at the same time\\n                // Let\\'s assumethe end date be when alice left\\n                end = leaveAliceInput;\\n            } else {\\n                // Bob left early so the end date must be when bob left\\n                end = leaveBobInput;\\n            }\\n        }\\n    } else {\\n        // Bob was earlier\\n        // Let\\'s find out if they met by finding out if alice arrived earlier than bob left\\n        const intersect = compare(leaveBobInput, arriveAliceInput);\\n        if (intersect === 1 || intersect === 0) {\\n            // The met somehow, so let\\'s start the date where alice arrived\\n            start = arriveAliceInput;\\n\\n            // When does it ends? Depends on who left earlier\\n            if (earliestLeaveDiff === 0 || earliestLeaveDiff === -1) {\\n                // Alice left early or they left at the same time\\n                // Let\\'s assume the end date be when alice left\\n                end = leaveAliceInput;\\n            } else {\\n                // Bob left early so the end date must be when bob left\\n                end = leaveBobInput;\\n            }\\n        }\\n    }\\n    \\n    if (start && end) {\\n        const diff = compare(start, end);\\n        if (diff === -1) {\\n            // Let\\'s compute the days they are together...\\n            together = computeDiff(start, end) + 1;\\n        } else if (diff === 0) {\\n            // They met on that same day\\n            together = 1;\\n        }\\n    }\\n\\n    return together;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype DateInput = {\\n    month: number;\\n    date: number;\\n}\\n\\nconst daysMap = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\\n\\nfunction createDateInput(value: string): DateInput {\\n    const chunks = value.split(\\'-\\');\\n    return {\\n        month: parseInt(chunks[0]),\\n        date: parseInt(chunks[1]),\\n    };\\n}\\n\\nfunction compare(input1: DateInput, input2: DateInput): number {\\n    if (input1.month === input2.month) {\\n        if (input1.date > input2.date) {\\n            return 1;\\n        } else if (input1.date < input2.date) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    } else {\\n        if (input1.month > input2.month) {\\n            return 1;\\n        } else if (input1.month < input2.month) {\\n            return -1;\\n        } else {\\n            return 0;\\n        }\\n    }\\n}\\n\\nfunction computeDiff(input1: DateInput, input2: DateInput): number {\\n    if (input1.month === input2.month) {\\n        // Same month, just diff the date and pad 1 day\\n        return input2.date - input1.date;\\n    } else {\\n        // Different month, compute distance\\n        let runningMonth = input1.month;\\n        let daysInMonth = daysMap[runningMonth - 1];\\n        let days = daysInMonth - input1.date;\\n\\n        while (runningMonth < input2.month) {\\n            runningMonth++;\\n            daysInMonth = daysMap[runningMonth - 1];\\n            if (runningMonth === input2.month) {\\n                days += input2.date;\\n            } else {\\n                days += daysInMonth;\\n            }\\n        }\\n        \\n        return days;\\n    }\\n}\\n\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    const arriveAliceInput = createDateInput(arriveAlice);\\n    const leaveAliceInput = createDateInput(leaveAlice);\\n    const arriveBobInput = createDateInput(arriveBob);\\n    const leaveBobInput = createDateInput(leaveBob);\\n\\n    let together = 0;\\n    let start: DateInput;\\n    let end: DateInput;\\n\\n    // Find earliest arrival and earliest leave\\n    const earliestDiff = compare(arriveAliceInput, arriveBobInput);\\n    const earliestLeaveDiff = compare(leaveAliceInput, leaveBobInput);\\n\\n    if (earliestDiff === 0 || earliestDiff === -1) {\\n        // Alice was earlier or they arrived at the same date\\n        // Let\\'s find out if they met by finding out if bob arrived earlier than alice left\\n        const intersect = compare(leaveAliceInput, arriveBobInput);\\n        if (intersect === 1 || intersect === 0) {\\n            // They met somehow, so let\\'s start by the date where bob arrived\\n            start = arriveBobInput;\\n\\n            // When does it ends? Depends on who left earlier\\n            if (earliestLeaveDiff === 0 || earliestLeaveDiff === -1) {\\n                // Alice left early or they left at the same time\\n                // Let\\'s assumethe end date be when alice left\\n                end = leaveAliceInput;\\n            } else {\\n                // Bob left early so the end date must be when bob left\\n                end = leaveBobInput;\\n            }\\n        }\\n    } else {\\n        // Bob was earlier\\n        // Let\\'s find out if they met by finding out if alice arrived earlier than bob left\\n        const intersect = compare(leaveBobInput, arriveAliceInput);\\n        if (intersect === 1 || intersect === 0) {\\n            // The met somehow, so let\\'s start the date where alice arrived\\n            start = arriveAliceInput;\\n\\n            // When does it ends? Depends on who left earlier\\n            if (earliestLeaveDiff === 0 || earliestLeaveDiff === -1) {\\n                // Alice left early or they left at the same time\\n                // Let\\'s assume the end date be when alice left\\n                end = leaveAliceInput;\\n            } else {\\n                // Bob left early so the end date must be when bob left\\n                end = leaveBobInput;\\n            }\\n        }\\n    }\\n    \\n    if (start && end) {\\n        const diff = compare(start, end);\\n        if (diff === -1) {\\n            // Let\\'s compute the days they are together...\\n            together = computeDiff(start, end) + 1;\\n        } else if (diff === 0) {\\n            // They met on that same day\\n            together = 1;\\n        }\\n    }\\n\\n    return together;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3804342,
                "title": "100-beat-best-code-shortest",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int dn(string s){\\n        vector<int>v{0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int m = stoi(s.substr(0,2)) , d = stoi(s.substr(3,2)) , ans=0;\\n        return ans+v[m-1]+d;\\n    }\\n\\n    int countDaysTogether(string aa , string la , string ab , string lb){\\n        int a = dn(aa) , b = dn(la) , c = dn(ab) , d = dn(lb);\\n        vector<int>v(366,0);\\n        for(int i=a; i<=b; i++){\\n            v[i]++;\\n        }\\n        for(int i=c; i<=d; i++){\\n            v[i]++;\\n        }\\n        int co=0;\\n        for(auto i:v){\\n            if(i==2){\\n                co++;\\n            }\\n        }\\n        return co;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dn(string s){\\n        vector<int>v{0,31,59,90,120,151,181,212,243,273,304,334,365};\\n        int m = stoi(s.substr(0,2)) , d = stoi(s.substr(3,2)) , ans=0;\\n        return ans+v[m-1]+d;\\n    }\\n\\n    int countDaysTogether(string aa , string la , string ab , string lb){\\n        int a = dn(aa) , b = dn(la) , c = dn(ab) , d = dn(lb);\\n        vector<int>v(366,0);\\n        for(int i=a; i<=b; i++){\\n            v[i]++;\\n        }\\n        for(int i=c; i<=d; i++){\\n            v[i]++;\\n        }\\n        int co=0;\\n        for(auto i:v){\\n            if(i==2){\\n                co++;\\n            }\\n        }\\n        return co;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791124,
                "title": "simple-solution-using-java",
                "content": "# Intuition\\nCheck if there is any overlapping between late arrival and early leave.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int months[]=new int[]{0,31,59,90,120,151,181,212,243,273,304,334};\\n    private int getDays(String s){\\n        int month = s.charAt(1)-\\'0\\';\\n        if(s.charAt(0) == \\'1\\'){\\n            month += 10;\\n        }\\n        int days = (s.charAt(3)-\\'0\\') * 10 + s.charAt(4)-\\'0\\';\\n        return months[month-1] + days;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n      int arrive1 = getDays(arriveAlice);\\n      int leave1 = getDays(leaveAlice);\\n      int arrive2 = getDays(arriveBob);\\n      int leave2 = getDays(leaveBob);\\n\\n      int lateArrive = Math.max(arrive1,arrive2);\\n      int earlyLeave = Math.min(leave1,leave2);\\n      if(lateArrive > earlyLeave){\\n          return 0;\\n      }\\n      return earlyLeave - lateArrive + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int months[]=new int[]{0,31,59,90,120,151,181,212,243,273,304,334};\\n    private int getDays(String s){\\n        int month = s.charAt(1)-\\'0\\';\\n        if(s.charAt(0) == \\'1\\'){\\n            month += 10;\\n        }\\n        int days = (s.charAt(3)-\\'0\\') * 10 + s.charAt(4)-\\'0\\';\\n        return months[month-1] + days;\\n    }\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n      int arrive1 = getDays(arriveAlice);\\n      int leave1 = getDays(leaveAlice);\\n      int arrive2 = getDays(arriveBob);\\n      int leave2 = getDays(leaveBob);\\n\\n      int lateArrive = Math.max(arrive1,arrive2);\\n      int earlyLeave = Math.min(leave1,leave2);\\n      if(lateArrive > earlyLeave){\\n          return 0;\\n      }\\n      return earlyLeave - lateArrive + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753544,
                "title": "java-simple-interval-overlap",
                "content": "**Idea:** Find the 4 day indices and find overlap between the 2 pairs\\n>**T/S:** O(1)/O(1)\\n```\\nprivate static final int[] MONTH_DAYS = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\npublic int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\treturn Math.max(0, 1 + Math.min(dayIndex(leaveAlice), dayIndex(leaveBob)) - \\n\\t\\t\\t\\t\\t\\t   Math.max(dayIndex(arriveAlice), dayIndex(arriveBob)));\\n}\\n\\nprivate int dayIndex(String date) {\\n\\tvar index = Integer.parseInt(date.substring(3, 5));\\n\\tfor (var i = Integer.parseInt(date.substring(0, 2)) - 1; i > 0; i--)\\n\\t\\tindex += MONTH_DAYS[i];\\n\\treturn index;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate static final int[] MONTH_DAYS = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n\\npublic int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\treturn Math.max(0, 1 + Math.min(dayIndex(leaveAlice), dayIndex(leaveBob)) - \\n\\t\\t\\t\\t\\t\\t   Math.max(dayIndex(arriveAlice), dayIndex(arriveBob)));\\n}\\n\\nprivate int dayIndex(String date) {\\n\\tvar index = Integer.parseInt(date.substring(3, 5));\\n\\tfor (var i = Integer.parseInt(date.substring(0, 2)) - 1; i > 0; i--)\\n\\t\\tindex += MONTH_DAYS[i];\\n\\treturn index;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748537,
                "title": "beats-100-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int countDays(string s){\\n        int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int m = stoi(s.substr(0,2)), ans = 0, d = stoi(s.substr(3,2));\\n        for(int i = 1; i < m; i++){\\n            ans += month[i-1];\\n        }\\n        return ans + d;\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aA = countDays(arriveAlice), lA = countDays(leaveAlice), aB = countDays(arriveBob), lB = countDays(leaveBob);\\n        int ans = min(lA, lB) - max(aA, aB) + 1;\\n        return ans > 0 ? ans : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countDays(string s){\\n        int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int m = stoi(s.substr(0,2)), ans = 0, d = stoi(s.substr(3,2));\\n        for(int i = 1; i < m; i++){\\n            ans += month[i-1];\\n        }\\n        return ans + d;\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int aA = countDays(arriveAlice), lA = countDays(leaveAlice), aB = countDays(arriveBob), lB = countDays(leaveBob);\\n        int ans = min(lA, lB) - max(aA, aB) + 1;\\n        return ans > 0 ? ans : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719597,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    const arrivalDate = Math.max(Date.parse(arriveAlice), Date.parse(arriveBob));\\n    const leaveDate = Math.min(Date.parse(leaveAlice), Date.parse(leaveBob));\\n    const dayInMS = 1000*60*60*24;\\n    return arrivalDate > leaveDate ? 0 : ((leaveDate - arrivalDate)/dayInMS) + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} arriveAlice\\n * @param {string} leaveAlice\\n * @param {string} arriveBob\\n * @param {string} leaveBob\\n * @return {number}\\n */\\nvar countDaysTogether = function(arriveAlice, leaveAlice, arriveBob, leaveBob) {\\n    const arrivalDate = Math.max(Date.parse(arriveAlice), Date.parse(arriveBob));\\n    const leaveDate = Math.min(Date.parse(leaveAlice), Date.parse(leaveBob));\\n    const dayInMS = 1000*60*60*24;\\n    return arrivalDate > leaveDate ? 0 : ((leaveDate - arrivalDate)/dayInMS) + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694255,
                "title": "easy-solution-with-for-loop",
                "content": "# Intuition\\nYou can find counter of days that belong to each segment: Alice-segment and Bob-segment\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    let alice1 = (new Date(\"2022-\" + arriveAlice)).getTime();\\n    let alice2 = (new Date(\"2022-\" + leaveAlice)).getTime();\\n    let bob1 = (new Date(\"2022-\" + arriveBob)).getTime();\\n    let bob2 = (new Date(\"2022-\" + leaveBob)).getTime();\\n    let min = Math.min(alice1, alice2, bob1, bob2);\\n    let max = Math.max(alice1, alice2, bob1, bob2);\\n    let counter: number = 0;\\n    for(let i = min; i <= max; i = i + 86400000){\\n        if(i >= alice1 && i <= alice2 && i >= bob1 && i <= bob2)    counter++;\\n    };\\n    return counter;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction countDaysTogether(arriveAlice: string, leaveAlice: string, arriveBob: string, leaveBob: string): number {\\n    let alice1 = (new Date(\"2022-\" + arriveAlice)).getTime();\\n    let alice2 = (new Date(\"2022-\" + leaveAlice)).getTime();\\n    let bob1 = (new Date(\"2022-\" + arriveBob)).getTime();\\n    let bob2 = (new Date(\"2022-\" + leaveBob)).getTime();\\n    let min = Math.min(alice1, alice2, bob1, bob2);\\n    let max = Math.max(alice1, alice2, bob1, bob2);\\n    let counter: number = 0;\\n    for(let i = min; i <= max; i = i + 86400000){\\n        if(i >= alice1 && i <= alice2 && i >= bob1 && i <= bob2)    counter++;\\n    };\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694194,
                "title": "simple-c-code-using-string-basics",
                "content": "# Intuition\\nConvert all your dates to days of the year as all dates are of the same year.Use stoi for string to integer conversion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nComapre the arrival time fo both and departure times of both to conclude what all days they spent together or if they didn\\'t then return 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a1=stoi(arriveAlice.substr(0,2));\\n        int a2=stoi(arriveAlice.substr(3,5));\\n        int b1=stoi(arriveBob.substr(0,2));\\n        int b2=stoi(arriveBob.substr(3,5));\\n        int a3=stoi(leaveAlice.substr(0,2));\\n        int a4=stoi(leaveAlice.substr(3,5));\\n        int b3=stoi(leaveBob.substr(0,2));\\n        int b4=stoi(leaveBob.substr(3,5));\\n        int t1=countdays(a1,a2);\\n        int t2=countdays(b1,b2);\\n        int t3=countdays(a3,a4);\\n        int t4=countdays(b3,b4);\\n        if(t2>=t1 && t2<=t3)\\n        {\\n            cout<<t1<<endl<<t2<<endl<<t3<<endl<<t4;\\n            if(t4<t3)\\n            return t4-t2+1;\\n            return t3-t2+1;\\n        }\\n        else if(t1>=t2 && t1<=t4)\\n        {\\n            cout<<t1<<endl<<t2<<endl<<t3<<endl<<t4;\\n            if(t3<t4)\\n            return t3-t1+1;\\n            return t4-t1+1;\\n        }\\n        return 0;\\n    }\\n    int countdays(int x1,int x2)\\n    {\\n        int days[]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int s=0;\\n        for(int i=0;i<x1-1;i++)\\n        {\\n            s=s+days[i];\\n        }\\n        return x2+s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int a1=stoi(arriveAlice.substr(0,2));\\n        int a2=stoi(arriveAlice.substr(3,5));\\n        int b1=stoi(arriveBob.substr(0,2));\\n        int b2=stoi(arriveBob.substr(3,5));\\n        int a3=stoi(leaveAlice.substr(0,2));\\n        int a4=stoi(leaveAlice.substr(3,5));\\n        int b3=stoi(leaveBob.substr(0,2));\\n        int b4=stoi(leaveBob.substr(3,5));\\n        int t1=countdays(a1,a2);\\n        int t2=countdays(b1,b2);\\n        int t3=countdays(a3,a4);\\n        int t4=countdays(b3,b4);\\n        if(t2>=t1 && t2<=t3)\\n        {\\n            cout<<t1<<endl<<t2<<endl<<t3<<endl<<t4;\\n            if(t4<t3)\\n            return t4-t2+1;\\n            return t3-t2+1;\\n        }\\n        else if(t1>=t2 && t1<=t4)\\n        {\\n            cout<<t1<<endl<<t2<<endl<<t3<<endl<<t4;\\n            if(t3<t4)\\n            return t3-t1+1;\\n            return t4-t1+1;\\n        }\\n        return 0;\\n    }\\n    int countdays(int x1,int x2)\\n    {\\n        int days[]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int s=0;\\n        for(int i=0;i<x1-1;i++)\\n        {\\n            s=s+days[i];\\n        }\\n        return x2+s;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3662521,
                "title": "easiet-solution-by-nnn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countDaysTogether(String aA, String lA, String aB, String lB) {\\n        int dayOfMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n        int Ax = dayOfMonth[Integer.parseInt(aA.substring(0, 2)) - 1] + Integer.parseInt(aA.substring(3, 5));\\n        int Ay = dayOfMonth[Integer.parseInt(lA.substring(0, 2)) - 1] + Integer.parseInt(lA.substring(3, 5));\\n        int Bx = dayOfMonth[Integer.parseInt(aB.substring(0, 2)) - 1] + Integer.parseInt(aB.substring(3, 5));\\n        int By = dayOfMonth[Integer.parseInt(lB.substring(0, 2)) - 1] + Integer.parseInt(lB.substring(3, 5));\\n        if (Ax > By || Bx > Ay)\\n            return 0;\\n        if (Ax > Bx && Ay < By)\\n            return Ay - Ax+1;\\n        if (Bx > Ax && By < Ay)\\n            return By - Bx+1;\\n        if (Bx < Ay && By > Ay)\\n            return Ay - Bx+1;\\n        if (Ax < By && Ay > By)\\n            return By - Ax+1;\\n        if(Ax==Bx&&Ay==By)return Ay-Ax+1;\\n        if(Ay==Bx||Ax==By)return 1;\\n        return 0;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countDaysTogether(String aA, String lA, String aB, String lB) {\\n        int dayOfMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};\\n        int Ax = dayOfMonth[Integer.parseInt(aA.substring(0, 2)) - 1] + Integer.parseInt(aA.substring(3, 5));\\n        int Ay = dayOfMonth[Integer.parseInt(lA.substring(0, 2)) - 1] + Integer.parseInt(lA.substring(3, 5));\\n        int Bx = dayOfMonth[Integer.parseInt(aB.substring(0, 2)) - 1] + Integer.parseInt(aB.substring(3, 5));\\n        int By = dayOfMonth[Integer.parseInt(lB.substring(0, 2)) - 1] + Integer.parseInt(lB.substring(3, 5));\\n        if (Ax > By || Bx > Ay)\\n            return 0;\\n        if (Ax > Bx && Ay < By)\\n            return Ay - Ax+1;\\n        if (Bx > Ax && By < Ay)\\n            return By - Bx+1;\\n        if (Bx < Ay && By > Ay)\\n            return Ay - Bx+1;\\n        if (Ax < By && Ay > By)\\n            return By - Ax+1;\\n        if(Ax==Bx&&Ay==By)return Ay-Ax+1;\\n        if(Ay==Bx||Ax==By)return 1;\\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654580,
                "title": "python-find-the-max-of-arrivals-and-min-of-departures",
                "content": "# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n    \\n        def days_count(string):\\n            days = [31,28,31,30,31,30,31,31,30,31,30,31]\\n            month, day = string.split(\"-\")\\n            return sum(days[:int(month)-1]) + int(day)\\n\\n        end_date = days_count(min(leaveAlice, leaveBob))\\n        start_date = days_count(max(arriveAlice, arriveBob))\\n\\n        return int(start_date <= end_date)*( end_date - start_date + 1)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n    \\n        def days_count(string):\\n            days = [31,28,31,30,31,30,31,31,30,31,30,31]\\n            month, day = string.split(\"-\")\\n            return sum(days[:int(month)-1]) + int(day)\\n\\n        end_date = days_count(min(leaveAlice, leaveBob))\\n        start_date = days_count(max(arriveAlice, arriveBob))\\n\\n        return int(start_date <= end_date)*( end_date - start_date + 1)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648050,
                "title": "c-solution-beats-100-59ms-w-explanation-kth-day-of-the-month",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy idea was simply to figure out the difference between the date of whoever arrived second and whoever left first. Of course, I knew there would be a few edge cases, which are commented in the code.\\n\\nPS: Reading into other solutions, mine was needlessly complicated in nature. Instead of using each date as a \"day of the year\", I converted each date into a \"day of the month\". This created a lot of challenges as conversions were now necessary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI decided to first parse the arrival and leave dates into integer arrays. My knowledge doesn\\'t cover whether a tuplet would be faster, but it was pretty negligible.\\n\\nAfterwards, I first came up with a way to check if they even had days in common before proceeding with that assumption.\\n\\nThen, it was implementing my idea: Find the difference between the dates of whoever arrived second (arrS) and whoever left first (leaveF). The only edge case here was whether arrS and leaveF had the shared the same month, as that would behave incorrectly with how I calculated all other cases.\\n\\nThis was my first leetcode problem after a couple months away from programming, so it took me an embarrasingly long time.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(1)$$ -->\\n\\n- Space complexity: I have no clue. I would guess that it\\'s also $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int CountDaysTogether(string arriveAlice, string leaveAli_ce, string arriveBob, string leaveBob) {\\n        int[] arriveAli_ = new int[]{Int32.Parse(arriveAlice.Substring(0,2)), Int32.Parse(arriveAlice.Substring(3,2))};\\n        int[] leaveAli_ = new int[]{Int32.Parse(leaveAli_ce.Substring(0,2)), Int32.Parse(leaveAli_ce.Substring(3,2))};\\n\\n        int[] arriveBob_ = new int[]{Int32.Parse(arriveBob.Substring(0,2)), Int32.Parse(arriveBob.Substring(3,2))};\\n        int[] leaveBob_ = new int[]{Int32.Parse(leaveBob.Substring(0,2)), Int32.Parse(leaveBob.Substring(3,2))};\\n\\n        // Do they even have common days?\\n\\n        //If Ali\\'s trip concludes before Bob\\'s starts\\n        if((leaveAli_[0] < arriveBob_[0]) || (leaveAli_[0] == arriveBob_[0] && leaveAli_[1] < arriveBob_[1])) return 0;\\n        //If Bob\\'s trip concludes before Ali\\'s starts\\n        if((leaveBob_[0] < arriveAli_[0]) || (leaveBob_[0] == arriveAli_[0] && leaveBob_[1] < arriveAli_[1])) return 0;\\n\\n        int days = 1;\\n        int[] arrS;\\n        int[] leaveF;\\n\\n        //Check who arrived first\\n        // Ali arrives first\\n        if(arriveAli_[0] < arriveBob_[0] || (arriveAli_[0] == arriveBob_[0] && arriveAli_[1] < arriveBob_[1])) {\\n            arrS = arriveBob_;\\n        }\\n        // Bob arrives first\\n        else {\\n            arrS = arriveAli_;\\n        }\\n\\n        // Who leaves first\\n\\n        // Ali leaves first\\n        if(leaveAli_[0] < leaveBob_[0] || (leaveAli_[0] == leaveBob_[0] && leaveAli_[1] < leaveBob_[1])) {\\n            leaveF = leaveAli_;\\n        }\\n        // Bob leaves first\\n        else {\\n            leaveF = leaveBob_;\\n        }\\n\\n        // If first leaves the same month second arrives\\n        if(leaveF[0] == arrS[0]) {\\n            return leaveF[1] - arrS[1] + 1;\\n        }\\n\\n        // Add the days of the month of the second arrival and the days of the month of the first leave\\n        days = months[arrS[0]-1] - arrS[1] + 1 + leaveF[1];\\n\\n        // The months in between\\n        for(int i = 0; i < leaveF[0] - arrS[0] - 1; i++) {\\n            days += months[i + arrS[0]];\\n        }\\n\\n        return days;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[] months = new int[]{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int CountDaysTogether(string arriveAlice, string leaveAli_ce, string arriveBob, string leaveBob) {\\n        int[] arriveAli_ = new int[]{Int32.Parse(arriveAlice.Substring(0,2)), Int32.Parse(arriveAlice.Substring(3,2))};\\n        int[] leaveAli_ = new int[]{Int32.Parse(leaveAli_ce.Substring(0,2)), Int32.Parse(leaveAli_ce.Substring(3,2))};\\n\\n        int[] arriveBob_ = new int[]{Int32.Parse(arriveBob.Substring(0,2)), Int32.Parse(arriveBob.Substring(3,2))};\\n        int[] leaveBob_ = new int[]{Int32.Parse(leaveBob.Substring(0,2)), Int32.Parse(leaveBob.Substring(3,2))};\\n\\n        // Do they even have common days?\\n\\n        //If Ali\\'s trip concludes before Bob\\'s starts\\n        if((leaveAli_[0] < arriveBob_[0]) || (leaveAli_[0] == arriveBob_[0] && leaveAli_[1] < arriveBob_[1])) return 0;\\n        //If Bob\\'s trip concludes before Ali\\'s starts\\n        if((leaveBob_[0] < arriveAli_[0]) || (leaveBob_[0] == arriveAli_[0] && leaveBob_[1] < arriveAli_[1])) return 0;\\n\\n        int days = 1;\\n        int[] arrS;\\n        int[] leaveF;\\n\\n        //Check who arrived first\\n        // Ali arrives first\\n        if(arriveAli_[0] < arriveBob_[0] || (arriveAli_[0] == arriveBob_[0] && arriveAli_[1] < arriveBob_[1])) {\\n            arrS = arriveBob_;\\n        }\\n        // Bob arrives first\\n        else {\\n            arrS = arriveAli_;\\n        }\\n\\n        // Who leaves first\\n\\n        // Ali leaves first\\n        if(leaveAli_[0] < leaveBob_[0] || (leaveAli_[0] == leaveBob_[0] && leaveAli_[1] < leaveBob_[1])) {\\n            leaveF = leaveAli_;\\n        }\\n        // Bob leaves first\\n        else {\\n            leaveF = leaveBob_;\\n        }\\n\\n        // If first leaves the same month second arrives\\n        if(leaveF[0] == arrS[0]) {\\n            return leaveF[1] - arrS[1] + 1;\\n        }\\n\\n        // Add the days of the month of the second arrival and the days of the month of the first leave\\n        days = months[arrS[0]-1] - arrS[1] + 1 + leaveF[1];\\n\\n        // The months in between\\n        for(int i = 0; i < leaveF[0] - arrS[0] - 1; i++) {\\n            days += months[i + arrS[0]];\\n        }\\n\\n        return days;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647455,
                "title": "c-solution-beats-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Get exact day of the year from the given data and then it becomes a normal intersecting regions problem.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector <int> daysOfMonths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int getExactDayOfYear(string k){\\n        int m1 = k[0] - \\'0\\', m2 = k[1] - \\'0\\';\\n        int d1 = k[3] - \\'0\\', d2 = k[4] - \\'0\\';\\n        int month = m1*10 + m2;\\n        int day = d1 * 10 + d2;\\n        int totalDays = 0;\\n        for(int i = 1; i < month; i++) totalDays += daysOfMonths[i];\\n        totalDays += day;\\n        return totalDays;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        int aA = getExactDayOfYear(arriveAlice);\\n        int lA = getExactDayOfYear(leaveAlice);\\n        int aB = getExactDayOfYear(arriveBob);\\n        int lB = getExactDayOfYear(leaveBob);\\n\\n        vector<int> v;\\n        v.push_back(aA);\\n        v.push_back(lA);\\n        v.push_back(aB);\\n        v.push_back(lB);\\n        sort(v.begin(), v.end());\\n\\n        int ans = 0;\\n\\n        for(int i = v[0]; i <= v[3]; i++){\\n            if(i >= aA and i <= lA){\\n                if(i >= aB and i <= lB) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> daysOfMonths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    int getExactDayOfYear(string k){\\n        int m1 = k[0] - \\'0\\', m2 = k[1] - \\'0\\';\\n        int d1 = k[3] - \\'0\\', d2 = k[4] - \\'0\\';\\n        int month = m1*10 + m2;\\n        int day = d1 * 10 + d2;\\n        int totalDays = 0;\\n        for(int i = 1; i < month; i++) totalDays += daysOfMonths[i];\\n        totalDays += day;\\n        return totalDays;\\n    }\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        \\n        int aA = getExactDayOfYear(arriveAlice);\\n        int lA = getExactDayOfYear(leaveAlice);\\n        int aB = getExactDayOfYear(arriveBob);\\n        int lB = getExactDayOfYear(leaveBob);\\n\\n        vector<int> v;\\n        v.push_back(aA);\\n        v.push_back(lA);\\n        v.push_back(aB);\\n        v.push_back(lB);\\n        sort(v.begin(), v.end());\\n\\n        int ans = 0;\\n\\n        for(int i = v[0]; i <= v[3]; i++){\\n            if(i >= aA and i <= lA){\\n                if(i >= aB and i <= lB) ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636051,
                "title": "standard-java-solution",
                "content": "### Theory\\nConvert the dates to a day. Loop through all the days in the year and check if alice and bob are present on that day.\\n\\n### Solution\\n```\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aliceStartDay = getDays(arriveAlice), aliceEndDay = getDays(leaveAlice);\\n        int bobStartDay = getDays(arriveBob), bobEndDay = getDays(leaveBob);\\n\\n        int count = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (presentOnDay(i, aliceStartDay, aliceEndDay) && presentOnDay(i, bobStartDay, bobEndDay))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean presentOnDay(int day, int start, int end) {\\n        return day >= start && day <= end;\\n    }\\n    \\n    private int getDays(String date) {\\n        int dayCount = 0;\\n        String[] parts = date.split(\"-\");\\n        Integer month = Integer.parseInt(parts[0]), dayOfMonth = Integer.parseInt(parts[1]);\\n        for (int i = 0; i < month - 1; i++) {\\n            dayCount += days[i];\\n        }\\n        \\n        dayCount += dayOfMonth;\\n        return dayCount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n        int aliceStartDay = getDays(arriveAlice), aliceEndDay = getDays(leaveAlice);\\n        int bobStartDay = getDays(arriveBob), bobEndDay = getDays(leaveBob);\\n\\n        int count = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (presentOnDay(i, aliceStartDay, aliceEndDay) && presentOnDay(i, bobStartDay, bobEndDay))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean presentOnDay(int day, int start, int end) {\\n        return day >= start && day <= end;\\n    }\\n    \\n    private int getDays(String date) {\\n        int dayCount = 0;\\n        String[] parts = date.split(\"-\");\\n        Integer month = Integer.parseInt(parts[0]), dayOfMonth = Integer.parseInt(parts[1]);\\n        for (int i = 0; i < month - 1; i++) {\\n            dayCount += days[i];\\n        }\\n        \\n        dayCount += dayOfMonth;\\n        return dayCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627360,
                "title": "java-solution-using-sets-to-calculate-days-spent-together-by-this-weird-couple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nimport java.util.Date; \\nimport java.time.*;\\nimport java.time.LocalDateTime;\\nimport java.time.format.DateTimeFormatter;\\nimport java.text.SimpleDateFormat;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        String result = arriveAlice + \"-\" +leaveAlice + \"-\" + arriveBob +\"-\" + leaveBob;\\n        String[] arr = result.split(\"-\");\\n        int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int start1 = Integer.parseInt(arr[0]);\\n        int end1 = Integer.parseInt(arr[2]);\\n        int start2 = Integer.parseInt(arr[4]);\\n        int end2 = Integer.parseInt(arr[6]);\\n\\n  \\n        int start1Day = getDayOfYear(start1, Integer.parseInt(arr[1]), days);\\n        int end1Day = getDayOfYear(end1, Integer.parseInt(arr[3]), days);\\n        int start2Day = getDayOfYear(start2, Integer.parseInt(arr[5]), days);\\n        int end2Day =getDayOfYear(end2, Integer.parseInt(arr[7]), days); \\n\\n        int startDateMonth = Math.max(start1, start2);\\n        int startDateDay = Math.max(start1Day, start2Day);\\n        int endDateMonth = Math.min(end1, end2);\\n        int endDateDay = Math.min(end1Day, end2Day);\\n\\n        if (endDateMonth < startDateMonth || (endDateMonth == startDateMonth && endDateDay < startDateDay)) {\\n            return 0;\\n        }\\n\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        while (start1Day <= end1Day ){\\n            set1.add(start1Day);\\n            start1Day++;\\n         }\\n         while (start2Day <= end2Day ){\\n            set2.add(start2Day);\\n            start2Day++;\\n         }\\n  \\n\\n    return countIntersection(set1, set2);\\n    }\\n        public static int countIntersection(Set<Integer> set1, Set<Integer> set2) {\\n        Set<Integer> intersection = new HashSet<>(set1);\\n        intersection.retainAll(set2);\\n\\n        return intersection.size();\\n    }\\n    public int getDayOfYear(int month, int day, int[] days) {\\n        int dayOfYear = day;\\n        for (int i = 0; i < month - 1; i++) {\\n            dayOfYear += days[i];\\n        }\\n        return dayOfYear;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Date; \\nimport java.time.*;\\nimport java.time.LocalDateTime;\\nimport java.time.format.DateTimeFormatter;\\nimport java.text.SimpleDateFormat;\\n\\nclass Solution {\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        String result = arriveAlice + \"-\" +leaveAlice + \"-\" + arriveBob +\"-\" + leaveBob;\\n        String[] arr = result.split(\"-\");\\n        int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n        int start1 = Integer.parseInt(arr[0]);\\n        int end1 = Integer.parseInt(arr[2]);\\n        int start2 = Integer.parseInt(arr[4]);\\n        int end2 = Integer.parseInt(arr[6]);\\n\\n  \\n        int start1Day = getDayOfYear(start1, Integer.parseInt(arr[1]), days);\\n        int end1Day = getDayOfYear(end1, Integer.parseInt(arr[3]), days);\\n        int start2Day = getDayOfYear(start2, Integer.parseInt(arr[5]), days);\\n        int end2Day =getDayOfYear(end2, Integer.parseInt(arr[7]), days); \\n\\n        int startDateMonth = Math.max(start1, start2);\\n        int startDateDay = Math.max(start1Day, start2Day);\\n        int endDateMonth = Math.min(end1, end2);\\n        int endDateDay = Math.min(end1Day, end2Day);\\n\\n        if (endDateMonth < startDateMonth || (endDateMonth == startDateMonth && endDateDay < startDateDay)) {\\n            return 0;\\n        }\\n\\n        Set<Integer> set1 = new HashSet<>();\\n        Set<Integer> set2 = new HashSet<>();\\n        while (start1Day <= end1Day ){\\n            set1.add(start1Day);\\n            start1Day++;\\n         }\\n         while (start2Day <= end2Day ){\\n            set2.add(start2Day);\\n            start2Day++;\\n         }\\n  \\n\\n    return countIntersection(set1, set2);\\n    }\\n        public static int countIntersection(Set<Integer> set1, Set<Integer> set2) {\\n        Set<Integer> intersection = new HashSet<>(set1);\\n        intersection.retainAll(set2);\\n\\n        return intersection.size();\\n    }\\n    public int getDayOfYear(int month, int day, int[] days) {\\n        int dayOfYear = day;\\n        for (int i = 0; i < month - 1; i++) {\\n            dayOfYear += days[i];\\n        }\\n        return dayOfYear;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617616,
                "title": "python3-convert-then-get-the-intersection",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe need to convert then in same unit base on the fixed days in month \\n[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\nExample: \\n02-01 = arr[0] + 01\\n05-19 = arr[0] + arr[1] + arr[2] + arr[3] + 19\\n\\nThen we have 2 line in same axis X.\\n[120, 130], [125,135]\\nWe can think they are 2 line and we need to find the intersection between them. \\n\\nBy using max at x1, x2 -> \\n--------x1----------------------------y1----------------------\\n------------x2-----------------------------y2-----------------\\n-------max(x1,x2)-------------------min(y1,y2)----------------\\nresult = min(y1,y2) - max(x1,x2)\\n\\nIn case: they didn\\'t intersect\\n--------x1-----y1---------------------------------------------\\n-----------------------------------x2---------------y2--------\\n--------------min(y1,y2)--------max(x1,x2)-------------------- \\nmin(y1,y2) - max(x1,x2) < 0\\n\\n\\nThen the final formula is:\\nreturn 0 if result < 0 else result\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def convertToTimespan(self, date: str) -> int:\\n        daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        [months, days] = date.split(\"-\")\\n        result = 0\\n        for i in range(int(months) - 1):\\n            result += daysInMonth[i]\\n        return result + int(days)\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arriveAliceTimeSpan = self.convertToTimespan(arriveAlice)\\n        leaveAliceTimeSpan = self.convertToTimespan(leaveAlice)\\n        arriveBobTimeSpan = self.convertToTimespan(arriveBob)\\n        leaveBobTimeSpan = self.convertToTimespan(leaveBob)\\n        result = min(leaveAliceTimeSpan,leaveBobTimeSpan) - max(arriveAliceTimeSpan,arriveBobTimeSpan) + 1\\n        return 0 if result < 0 else result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def convertToTimespan(self, date: str) -> int:\\n        daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        [months, days] = date.split(\"-\")\\n        result = 0\\n        for i in range(int(months) - 1):\\n            result += daysInMonth[i]\\n        return result + int(days)\\n\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        arriveAliceTimeSpan = self.convertToTimespan(arriveAlice)\\n        leaveAliceTimeSpan = self.convertToTimespan(leaveAlice)\\n        arriveBobTimeSpan = self.convertToTimespan(arriveBob)\\n        leaveBobTimeSpan = self.convertToTimespan(leaveBob)\\n        result = min(leaveAliceTimeSpan,leaveBobTimeSpan) - max(arriveAliceTimeSpan,arriveBobTimeSpan) + 1\\n        return 0 if result < 0 else result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573864,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        auto daysYearToDate = [](const string& date) {\\n            int daysYearToMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n            return daysYearToMonth[10 * (date[0] - \\'0\\') + date[1] - \\'0\\' - 1] + 10 * (date[3] - \\'0\\') + date[4] - \\'0\\';\\n        };\\n        const auto beginAlice = daysYearToDate(arriveAlice), endAlice = daysYearToDate(leaveAlice),\\n                   beginBob = daysYearToDate(arriveBob), endBob = daysYearToDate(leaveBob);\\n        return max(0, min(endAlice, endBob) - max(beginAlice, beginBob) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        auto daysYearToDate = [](const string& date) {\\n            int daysYearToMonth[] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};\\n            return daysYearToMonth[10 * (date[0] - \\'0\\') + date[1] - \\'0\\' - 1] + 10 * (date[3] - \\'0\\') + date[4] - \\'0\\';\\n        };\\n        const auto beginAlice = daysYearToDate(arriveAlice), endAlice = daysYearToDate(leaveAlice),\\n                   beginBob = daysYearToDate(arriveBob), endBob = daysYearToDate(leaveBob);\\n        return max(0, min(endAlice, endBob) - max(beginAlice, beginBob) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562871,
                "title": "simple-solution-by-finding-day-of-the-year",
                "content": "# Approach\\nThe question states that there is no leep year.\\n\\nfind all days in day of the year and find the difference between second came and first left\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    static int [] arr = new int [13] ;\\n\\n    static{\\n        int days = 0;\\n        for(int i = 1;i<=12;i++){\\n            if(i == 2){\\n                days+=28;\\n                arr[i] = days;\\n                continue;\\n            }   \\n            if(i<=7){\\n                days += i%2 == 0 ? 30 : 31;\\n            }else{\\n                days += i%2 == 0 ? 31 : 30;\\n            }\\n            arr[i] = days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String aa, String la, String ab, String lb) {\\n        int alicecame = dayOfTheYear(aa.split(\"-\"));\\n        int aliceleave = dayOfTheYear(la.split(\"-\"));\\n        int bobcame = dayOfTheYear(ab.split(\"-\"));\\n        int bobleave = dayOfTheYear(lb.split(\"-\"));\\n        if(aliceleave < bobcame || bobleave < alicecame)\\n            return 0;\\n        int secondcame = alicecame > bobcame ? alicecame : bobcame;\\n        int firstleave = aliceleave < bobleave ? aliceleave : bobleave;\\n\\n        return firstleave - secondcame+1;\\n    }\\n\\n    public int dayOfTheYear(String [] date){\\n        int res = 0;\\n        int month = Integer.parseInt(date[0])-1;\\n        res+= arr[month];\\n        res += Integer.parseInt(date[1]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int [] arr = new int [13] ;\\n\\n    static{\\n        int days = 0;\\n        for(int i = 1;i<=12;i++){\\n            if(i == 2){\\n                days+=28;\\n                arr[i] = days;\\n                continue;\\n            }   \\n            if(i<=7){\\n                days += i%2 == 0 ? 30 : 31;\\n            }else{\\n                days += i%2 == 0 ? 31 : 30;\\n            }\\n            arr[i] = days;\\n        }\\n    }\\n\\n    public int countDaysTogether(String aa, String la, String ab, String lb) {\\n        int alicecame = dayOfTheYear(aa.split(\"-\"));\\n        int aliceleave = dayOfTheYear(la.split(\"-\"));\\n        int bobcame = dayOfTheYear(ab.split(\"-\"));\\n        int bobleave = dayOfTheYear(lb.split(\"-\"));\\n        if(aliceleave < bobcame || bobleave < alicecame)\\n            return 0;\\n        int secondcame = alicecame > bobcame ? alicecame : bobcame;\\n        int firstleave = aliceleave < bobleave ? aliceleave : bobleave;\\n\\n        return firstleave - secondcame+1;\\n    }\\n\\n    public int dayOfTheYear(String [] date){\\n        int res = 0;\\n        int month = Integer.parseInt(date[0])-1;\\n        res+= arr[month];\\n        res += Integer.parseInt(date[1]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547734,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun countDaysTogether(arriveAlice: String, leaveAlice: String, arriveBob: String, leaveBob: String): Int {\\n        val months = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\\n        val days = IntArray(13)\\n        for ((i, total) in months.withIndex()) days[i+1] = days[i] + total\\n        val aliceStartMonth = arriveAlice.take(2).toInt()\\n        val aliceStartDay = arriveAlice.takeLast(2).toInt()\\n        val aliceEndMonth = leaveAlice.take(2).toInt()\\n        val aliceEndDay = leaveAlice.takeLast(2).toInt()\\n        val aliceStart = days[aliceStartMonth-1] + aliceStartDay\\n        val aliceEnd = days[aliceEndMonth-1] + aliceEndDay\\n\\n        val bobStartMonth = arriveBob.take(2).toInt()\\n        val bobStartDay = arriveBob.takeLast(2).toInt()\\n        val bobEndMonth = leaveBob.take(2).toInt()\\n        val bobEndDay = leaveBob.takeLast(2).toInt()\\n        val bobStart = days[bobStartMonth-1] + bobStartDay\\n        val bobEnd = days[bobEndMonth-1] + bobEndDay\\n\\n        val min = maxOf(aliceStart, bobStart)\\n        val max = minOf(aliceEnd, bobEnd)\\n        return maxOf(0, max-min+1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countDaysTogether(arriveAlice: String, leaveAlice: String, arriveBob: String, leaveBob: String): Int {\\n        val months = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\\n        val days = IntArray(13)\\n        for ((i, total) in months.withIndex()) days[i+1] = days[i] + total\\n        val aliceStartMonth = arriveAlice.take(2).toInt()\\n        val aliceStartDay = arriveAlice.takeLast(2).toInt()\\n        val aliceEndMonth = leaveAlice.take(2).toInt()\\n        val aliceEndDay = leaveAlice.takeLast(2).toInt()\\n        val aliceStart = days[aliceStartMonth-1] + aliceStartDay\\n        val aliceEnd = days[aliceEndMonth-1] + aliceEndDay\\n\\n        val bobStartMonth = arriveBob.take(2).toInt()\\n        val bobStartDay = arriveBob.takeLast(2).toInt()\\n        val bobEndMonth = leaveBob.take(2).toInt()\\n        val bobEndDay = leaveBob.takeLast(2).toInt()\\n        val bobStart = days[bobStartMonth-1] + bobStartDay\\n        val bobEnd = days[bobEndMonth-1] + bobEndDay\\n\\n        val min = maxOf(aliceStart, bobStart)\\n        val max = minOf(aliceEnd, bobEnd)\\n        return maxOf(0, max-min+1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505017,
                "title": "convert-to-days-in-year",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        aA, lA = self.getDaysOfYear(arriveAlice), self.getDaysOfYear(leaveAlice)\\n        aB, lB = self.getDaysOfYear(arriveBob), self.getDaysOfYear(leaveBob)\\n        s, e = max(aA, aB), min(lA, lB)\\n        if s > e:\\n            return 0\\n        return e - s + 1\\n        \\n    def getDaysOfYear(self, dateStr):\\n        months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        month, day = int(dateStr.split(\\'-\\')[0]), int(dateStr.split(\\'-\\')[1])\\n        return sum(months[:month - 1]) + day\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        aA, lA = self.getDaysOfYear(arriveAlice), self.getDaysOfYear(leaveAlice)\\n        aB, lB = self.getDaysOfYear(arriveBob), self.getDaysOfYear(leaveBob)\\n        s, e = max(aA, aB), min(lA, lB)\\n        if s > e:\\n            return 0\\n        return e - s + 1\\n        \\n    def getDaysOfYear(self, dateStr):\\n        months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n        month, day = int(dateStr.split(\\'-\\')[0]), int(dateStr.split(\\'-\\')[1])\\n        return sum(months[:month - 1]) + day\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500628,
                "title": "java-additional-method-solution-with-explaining",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use different strategies to resolve the problem: parsing input strings to Date, counting days after parsing input Strings to Integer values, brute force etc..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create method getDays(String date). This method returns the day of the year from string value. Knowing all days of the year we easily find the matching using two Set containers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int [] year  = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        Set<Integer> aliceDays = new HashSet<>();\\n        Set<Integer> bobDays = new HashSet<>();\\n\\n        for(int i=getDays(arriveAlice);i<=getDays(leaveAlice);i++)\\n            aliceDays.add(i);\\n        for(int i=getDays(arriveBob);i<=getDays(leaveBob);i++)\\n            bobDays.add(i);\\n\\n        aliceDays.retainAll(bobDays);\\n\\n        return aliceDays.size();\\n\\n    }\\n\\n    private int getDays(String date){\\n        int result=0;\\n        int index=0;\\n        while (Integer.valueOf(date.split(\"-\")[0])-1!=index)\\n        {\\n            result+=year[index++];\\n        }\\n        result+=Integer.valueOf(date.split(\"-\")[1]);\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int [] year  = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    public int countDaysTogether(String arriveAlice, String leaveAlice, String arriveBob, String leaveBob) {\\n\\n        Set<Integer> aliceDays = new HashSet<>();\\n        Set<Integer> bobDays = new HashSet<>();\\n\\n        for(int i=getDays(arriveAlice);i<=getDays(leaveAlice);i++)\\n            aliceDays.add(i);\\n        for(int i=getDays(arriveBob);i<=getDays(leaveBob);i++)\\n            bobDays.add(i);\\n\\n        aliceDays.retainAll(bobDays);\\n\\n        return aliceDays.size();\\n\\n    }\\n\\n    private int getDays(String date){\\n        int result=0;\\n        int index=0;\\n        while (Integer.valueOf(date.split(\"-\")[0])-1!=index)\\n        {\\n            result+=year[index++];\\n        }\\n        result+=Integer.valueOf(date.split(\"-\")[1]);\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453039,
                "title": "c-solution-beats-100-fast-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        if (leaveAlice < arriveBob || leaveBob < arriveAlice)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int ans = 0;\\n            int days[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};\\n            string end = min(leaveAlice, leaveBob);\\n            string start = max(arriveAlice, arriveBob);\\n            int start_month = stoi(start.substr(0,2));\\n            int end_month = stoi(end.substr(0,2));\\n            int start_date = stoi(start.substr(3,2));\\n            int end_date = stoi(end.substr(3,2));\\n\\n            if (start_month != end_month)\\n                for (int month = start_month; month < end_month; month++)\\n                    ans += days[month];\\n\\n            ans = ans + end_date - start_date + 1;\\n   \\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        if (leaveAlice < arriveBob || leaveBob < arriveAlice)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            int ans = 0;\\n            int days[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};\\n            string end = min(leaveAlice, leaveBob);\\n            string start = max(arriveAlice, arriveBob);\\n            int start_month = stoi(start.substr(0,2));\\n            int end_month = stoi(end.substr(0,2));\\n            int start_date = stoi(start.substr(3,2));\\n            int end_date = stoi(end.substr(3,2));\\n\\n            if (start_month != end_month)\\n                for (int month = start_month; month < end_month; month++)\\n                    ans += days[month];\\n\\n            ans = ans + end_date - start_date + 1;\\n   \\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440738,
                "title": "c-easy-and-short-min-max",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> D = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\n\\n    int parse(string & s)\\n    {\\n        return D[(s[0] - \\'0\\') * 10 + (s[1] - \\'0\\') - 1] + (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n    }\\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        for (int i = 1; i < D.size(); i++)\\n            D[i] += D[i - 1];\\n\\n        int a = parse(arriveAlice);\\n        int b = parse(leaveAlice);\\n        int c = parse(arriveBob);\\n        int d = parse(leaveBob);\\n\\n        return max(0, min(b, d) - max(a, c) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> D = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\\n\\n    int parse(string & s)\\n    {\\n        return D[(s[0] - \\'0\\') * 10 + (s[1] - \\'0\\') - 1] + (s[3] - \\'0\\') * 10 + (s[4] - \\'0\\');\\n    }\\n\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob)\\n    {\\n        for (int i = 1; i < D.size(); i++)\\n            D[i] += D[i - 1];\\n\\n        int a = parse(arriveAlice);\\n        int b = parse(leaveAlice);\\n        int c = parse(arriveBob);\\n        int d = parse(leaveBob);\\n\\n        return max(0, min(b, d) - max(a, c) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427135,
                "title": "lc-2409-e-python3-prefix-sum",
                "content": "Calculate the corresponding days for each month using the prefix sum and then write the process as requested.\\n\\n```Python3 []\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        month_days = list(accumulate([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], initial=0))\\n        alice_arrive_day = month_days[int(arriveAlice[:2])-1] + int(arriveAlice[3:])\\n        alice_leave_day = month_days[int(leaveAlice[:2])-1] + int(leaveAlice[3:])\\n        bob_arrive_day = month_days[int(arriveBob[:2])-1] + int(arriveBob[3:])\\n        bob_leave_day = month_days[int(leaveBob[:2])-1] + int(leaveBob[3:])\\n\\n        return max(0, min(alice_leave_day, bob_leave_day) - max(alice_arrive_day, bob_arrive_day) + 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        month_days = list(accumulate([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], initial=0))\\n        alice_arrive_day = month_days[int(arriveAlice[:2])-1] + int(arriveAlice[3:])\\n        alice_leave_day = month_days[int(leaveAlice[:2])-1] + int(leaveAlice[3:])\\n        bob_arrive_day = month_days[int(arriveBob[:2])-1] + int(arriveBob[3:])\\n        bob_leave_day = month_days[int(leaveBob[:2])-1] + int(leaveBob[3:])\\n\\n        return max(0, min(alice_leave_day, bob_leave_day) - max(alice_arrive_day, bob_arrive_day) + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424114,
                "title": "simple-solution-by-finding-the-day-in-years-of-each-date",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int[] preDays = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };\\n\\n        int ParseDay(string date)\\n        {\\n            //return preDays[date[0] * 10 + date[1] - 529] + date[3] * 10 + date[4] - 528;\\n            var arr = date.Split(\\'-\\').Select(int.Parse).ToArray();\\n            return preDays[arr[0] - 1] + arr[1];\\n        }\\n\\n        int aa = ParseDay(arriveAlice), la = ParseDay(leaveAlice);\\n        int ab = ParseDay(arriveBob), lb = ParseDay(leaveBob);\\n\\n        return aa > lb || ab > la\\n            ? 0\\n            : (la > lb ? lb : la) - (aa > ab ? aa : ab) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        int[] preDays = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };\\n\\n        int ParseDay(string date)\\n        {\\n            //return preDays[date[0] * 10 + date[1] - 529] + date[3] * 10 + date[4] - 528;\\n            var arr = date.Split(\\'-\\').Select(int.Parse).ToArray();\\n            return preDays[arr[0] - 1] + arr[1];\\n        }\\n\\n        int aa = ParseDay(arriveAlice), la = ParseDay(leaveAlice);\\n        int ab = ParseDay(arriveBob), lb = ParseDay(leaveBob);\\n\\n        return aa > lb || ab > la\\n            ? 0\\n            : (la > lb ? lb : la) - (aa > ab ? aa : ab) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422342,
                "title": "python-explained-runtime-8-ms-beats-97-30",
                "content": "![Screenshot 2023-04-16 11.17.37 AM.png](https://assets.leetcode.com/users/images/d1ec51b2-002a-4d9d-a803-6b2518fb861a_1681624411.4825795.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):\\n        \"\"\"\\n        :type arriveAlice: str\\n        :type leaveAlice: str\\n        :type arriveBob: str\\n        :type leaveBob: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # My Code.\\n\\n        # Importing date from datetime module.\\n        from datetime import date\\n\\n        # Getting max date between Alice & Bob\\'s arrival.\\n        # That\\'s the date from when they both will be together.\\n        a = max(arriveAlice, arriveBob)\\n\\n        # Getting min date between Alice & Bob\\'s departure.\\n        # That\\'s the date till both of them were together.\\n        b = min(leaveAlice, leaveBob)\\n\\n        # Defining a function, that converts str MM-DD to int MM-DD in tuple.\\n        def intdate(s):\\n            return tuple(map(int, s.split(\\'-\\')))\\n\\n        # Getting int of start date.\\n        c = intdate(a)\\n\\n        # Getting int of end date.\\n        d = intdate(b)\\n\\n        # If end date is smaller than start date.\\n        if d < c:\\n            return 0\\n\\n        # Subtracting 1 date from another. Doesn\\'t matter which from which.\\n        # Using abs() to get positive int.\\n        # Adding 1 to the end result & returning the final value.\\n        return abs(date(2019, c[0], c[1]) - date(2019, d[0], d[1])).days + 1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "![Screenshot 2023-04-16 11.17.37 AM.png](https://assets.leetcode.com/users/images/d1ec51b2-002a-4d9d-a803-6b2518fb861a_1681624411.4825795.png)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countDaysTogether(self, arriveAlice, leaveAlice, arriveBob, leaveBob):\\n        \"\"\"\\n        :type arriveAlice: str\\n        :type leaveAlice: str\\n        :type arriveBob: str\\n        :type leaveBob: str\\n        :rtype: int\\n        \"\"\"\\n\\n        # My Code.\\n\\n        # Importing date from datetime module.\\n        from datetime import date\\n\\n        # Getting max date between Alice & Bob\\'s arrival.\\n        # That\\'s the date from when they both will be together.\\n        a = max(arriveAlice, arriveBob)\\n\\n        # Getting min date between Alice & Bob\\'s departure.\\n        # That\\'s the date till both of them were together.\\n        b = min(leaveAlice, leaveBob)\\n\\n        # Defining a function, that converts str MM-DD to int MM-DD in tuple.\\n        def intdate(s):\\n            return tuple(map(int, s.split(\\'-\\')))\\n\\n        # Getting int of start date.\\n        c = intdate(a)\\n\\n        # Getting int of end date.\\n        d = intdate(b)\\n\\n        # If end date is smaller than start date.\\n        if d < c:\\n            return 0\\n\\n        # Subtracting 1 date from another. Doesn\\'t matter which from which.\\n        # Using abs() to get positive int.\\n        # Adding 1 to the end result & returning the final value.\\n        return abs(date(2019, c[0], c[1]) - date(2019, d[0], d[1])).days + 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 3416971,
                "title": "python-code-is-clear-af-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n log n) - hope so\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n\\n        month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\n        count = 0\\n\\n        if arriveAlice > arriveBob:\\n            arriveDay = int(arriveAlice[3:]) \\n            arriveMon = int(arriveAlice[:2])\\n        else:\\n            arriveDay = int(arriveBob[3:]) \\n            arriveMon = int(arriveBob[:2])\\n            \\n        if leaveAlice > leaveBob:\\n            leaveDay  = int(leaveBob[3:]) \\n            leaveMon = int(leaveBob[:2])\\n        else:\\n            leaveDay  = int(leaveAlice[3:])\\n            leaveMon = int(leaveAlice[:2])\\n        \\n\\n        for mon in range(arriveMon, leaveMon + 1):\\n\\n            if mon == arriveMon:\\n                start = arriveDay\\n            else:\\n                start = 1\\n\\n            if mon == leaveMon:\\n                end = leaveDay\\n            else:\\n                end = month[mon - 1]\\n\\n            for day in range(start, end + 1):\\n                count += 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n\\n        month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\\n\\n        count = 0\\n\\n        if arriveAlice > arriveBob:\\n            arriveDay = int(arriveAlice[3:]) \\n            arriveMon = int(arriveAlice[:2])\\n        else:\\n            arriveDay = int(arriveBob[3:]) \\n            arriveMon = int(arriveBob[:2])\\n            \\n        if leaveAlice > leaveBob:\\n            leaveDay  = int(leaveBob[3:]) \\n            leaveMon = int(leaveBob[:2])\\n        else:\\n            leaveDay  = int(leaveAlice[3:])\\n            leaveMon = int(leaveAlice[:2])\\n        \\n\\n        for mon in range(arriveMon, leaveMon + 1):\\n\\n            if mon == arriveMon:\\n                start = arriveDay\\n            else:\\n                start = 1\\n\\n            if mon == leaveMon:\\n                end = leaveDay\\n            else:\\n                end = month[mon - 1]\\n\\n            for day in range(start, end + 1):\\n                count += 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404289,
                "title": "python-simple-solution-with-date",
                "content": "# Code\\n```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        latest_start = max(arriveAlice, arriveBob)\\n        earliest_end = min(leaveAlice, leaveBob)\\n        if latest_start <= earliest_end:\\n            return (date(2001, *map(int, earliest_end.split(\\'-\\'))) - \\n                    date(2001, *map(int, latest_start.split(\\'-\\')))).days + 1\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\\n        latest_start = max(arriveAlice, arriveBob)\\n        earliest_end = min(leaveAlice, leaveBob)\\n        if latest_start <= earliest_end:\\n            return (date(2001, *map(int, earliest_end.split(\\'-\\'))) - \\n                    date(2001, *map(int, latest_start.split(\\'-\\')))).days + 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399045,
                "title": "c-convert-to-days-from-boy",
                "content": "```\\nclass Solution {\\n    constexpr static int daysInmonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int str2n(string str) {\\n        return (str.front() - \\'0\\') * 10 + (str.back() - \\'1\\');\\n    }\\n    int md2d(int m, int d) { // month and date to total days\\n        return accumulate(daysInmonth, daysInmonth + m, 0) + d;\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        array<int,2> duration1 = {\\n            md2d( str2n(arriveAlice.substr(0,2)), str2n(arriveAlice.substr(3,2)) ),\\n            md2d( str2n(leaveAlice.substr(0,2)), str2n(leaveAlice.substr(3,2)) )\\n        };\\n        \\n        array<int,2> duration2 = {\\n            md2d( str2n(arriveBob.substr(0,2)), str2n(arriveBob.substr(3,2)) ),\\n            md2d( str2n(leaveBob.substr(0,2)), str2n(leaveBob.substr(3,2)) )\\n        };\\n        \\n        if(duration1[0] > duration2[0])\\n            swap(duration1, duration2);\\n        \\n        return max(0,  min(duration1[1], duration2[1]) - max(duration1[0], duration2[0]) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    constexpr static int daysInmonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\\n    \\n    int str2n(string str) {\\n        return (str.front() - \\'0\\') * 10 + (str.back() - \\'1\\');\\n    }\\n    int md2d(int m, int d) { // month and date to total days\\n        return accumulate(daysInmonth, daysInmonth + m, 0) + d;\\n    }\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n        array<int,2> duration1 = {\\n            md2d( str2n(arriveAlice.substr(0,2)), str2n(arriveAlice.substr(3,2)) ),\\n            md2d( str2n(leaveAlice.substr(0,2)), str2n(leaveAlice.substr(3,2)) )\\n        };\\n        \\n        array<int,2> duration2 = {\\n            md2d( str2n(arriveBob.substr(0,2)), str2n(arriveBob.substr(3,2)) ),\\n            md2d( str2n(leaveBob.substr(0,2)), str2n(leaveBob.substr(3,2)) )\\n        };\\n        \\n        if(duration1[0] > duration2[0])\\n            swap(duration1, duration2);\\n        \\n        return max(0,  min(duration1[1], duration2[1]) - max(duration1[0], duration2[0]) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395654,
                "title": "beats-100-so-many-conditions",
                "content": "brute checking\\nwhen bob comes firts or alice comes first\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\n        map<int,int> mp;\\n        mp[0] = 0;\\n        mp[1] = 31;\\n        mp[2] = 28;\\n        mp[3] = 31;\\n        mp[4] = 30;\\n        mp[5] = 31;\\n        mp[6] = 30;\\n        mp[7] = 31;\\n        mp[8] = 31;\\n        mp[9] = 30;\\n        mp[10] = 31;\\n        mp[11] = 30;\\n        mp[12] = 31;\\n\\n        for(int i=2;i<=12;i++){\\n            mp[i] = mp[i]+mp[i-1];\\n        }\\n\\n        // for(auto i:mp){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n\\n        int ans = 0;\\n\\n        int aaM = stoi(arriveAlice.substr(0,2));\\n        int aaD =stoi(arriveAlice.substr(3,2));\\n\\n        int alM = stoi(leaveAlice.substr(0,2));\\n        int alD = stoi(leaveAlice.substr(3,2));\\n\\n\\n        int baM = stoi(arriveBob.substr(0,2));\\n        int baD =stoi(arriveBob.substr(3,2));\\n\\n        int blM = stoi(leaveBob.substr(0,2));\\n        int blD = stoi(leaveBob.substr(3,2));\\n\\n        cout<<aaM<<\" \"<<aaD<<\" \"<<alM<<\" \"<<alD<<endl;\\n        cout<<baM<<\" \"<<baD<<\" \"<<blM<<\" \"<<blD<<endl;\\n\\n        \\n\\n        int aliceDaysArr = mp[aaM-1] + aaD;\\n        int aliceDaysLeave = mp[alM-1] + alD;\\n\\n        int bobDaysArr = mp[baM-1] + baD;\\n        int bobDaysLeave = mp[blM-1] + blD;\\n\\n        \\n        cout<<aliceDaysArr<<\" \"<<aliceDaysLeave<<\" \"<<endl;\\n        cout<<bobDaysArr<<\" \"<<bobDaysLeave<<\" \"<<endl;\\n\\n        // bob arriving first\\n        if(bobDaysArr<=aliceDaysArr){\\n            cout<<\"here \"<<endl;\\n            if(aliceDaysLeave<=bobDaysLeave){\\n                ans =  (aliceDaysLeave - aliceDaysArr) + 1;\\n            }\\n            if(aliceDaysLeave>bobDaysLeave){\\n                ans =  bobDaysLeave - aliceDaysArr +1;\\n            }\\n\\n        }\\n        // alice arrives first\\n        if(aliceDaysArr<=bobDaysArr){\\n            cout<<\"here\"<<endl;\\n            if(bobDaysLeave<=aliceDaysLeave){\\n                ans =  (bobDaysLeave - bobDaysArr) + 1;\\n            }\\n            if(bobDaysLeave>aliceDaysLeave){\\n                ans =  aliceDaysLeave - bobDaysArr +1;\\n            }\\n\\n        }\\n        if(ans>0){\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\\n\\n        map<int,int> mp;\\n        mp[0] = 0;\\n        mp[1] = 31;\\n        mp[2] = 28;\\n        mp[3] = 31;\\n        mp[4] = 30;\\n        mp[5] = 31;\\n        mp[6] = 30;\\n        mp[7] = 31;\\n        mp[8] = 31;\\n        mp[9] = 30;\\n        mp[10] = 31;\\n        mp[11] = 30;\\n        mp[12] = 31;\\n\\n        for(int i=2;i<=12;i++){\\n            mp[i] = mp[i]+mp[i-1];\\n        }\\n\\n        // for(auto i:mp){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n\\n        int ans = 0;\\n\\n        int aaM = stoi(arriveAlice.substr(0,2));\\n        int aaD =stoi(arriveAlice.substr(3,2));\\n\\n        int alM = stoi(leaveAlice.substr(0,2));\\n        int alD = stoi(leaveAlice.substr(3,2));\\n\\n\\n        int baM = stoi(arriveBob.substr(0,2));\\n        int baD =stoi(arriveBob.substr(3,2));\\n\\n        int blM = stoi(leaveBob.substr(0,2));\\n        int blD = stoi(leaveBob.substr(3,2));\\n\\n        cout<<aaM<<\" \"<<aaD<<\" \"<<alM<<\" \"<<alD<<endl;\\n        cout<<baM<<\" \"<<baD<<\" \"<<blM<<\" \"<<blD<<endl;\\n\\n        \\n\\n        int aliceDaysArr = mp[aaM-1] + aaD;\\n        int aliceDaysLeave = mp[alM-1] + alD;\\n\\n        int bobDaysArr = mp[baM-1] + baD;\\n        int bobDaysLeave = mp[blM-1] + blD;\\n\\n        \\n        cout<<aliceDaysArr<<\" \"<<aliceDaysLeave<<\" \"<<endl;\\n        cout<<bobDaysArr<<\" \"<<bobDaysLeave<<\" \"<<endl;\\n\\n        // bob arriving first\\n        if(bobDaysArr<=aliceDaysArr){\\n            cout<<\"here \"<<endl;\\n            if(aliceDaysLeave<=bobDaysLeave){\\n                ans =  (aliceDaysLeave - aliceDaysArr) + 1;\\n            }\\n            if(aliceDaysLeave>bobDaysLeave){\\n                ans =  bobDaysLeave - aliceDaysArr +1;\\n            }\\n\\n        }\\n        // alice arrives first\\n        if(aliceDaysArr<=bobDaysArr){\\n            cout<<\"here\"<<endl;\\n            if(bobDaysLeave<=aliceDaysLeave){\\n                ans =  (bobDaysLeave - bobDaysArr) + 1;\\n            }\\n            if(bobDaysLeave>aliceDaysLeave){\\n                ans =  aliceDaysLeave - bobDaysArr +1;\\n            }\\n\\n        }\\n        if(ans>0){\\n            return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1881413,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Weird couple :)**"
                    },
                    {
                        "username": "coderrsc",
                        "content": "thats what she said"
                    },
                    {
                        "username": "Suffolk",
                        "content": "convert to seconds, problem is converted to find overlap of 2 int arrays (if they have).\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Brute force."
                    }
                ]
            },
            {
                "id": 1918158,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Weird couple :)**"
                    },
                    {
                        "username": "coderrsc",
                        "content": "thats what she said"
                    },
                    {
                        "username": "Suffolk",
                        "content": "convert to seconds, problem is converted to find overlap of 2 int arrays (if they have).\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Brute force."
                    }
                ]
            },
            {
                "id": 1846544,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Weird couple :)**"
                    },
                    {
                        "username": "coderrsc",
                        "content": "thats what she said"
                    },
                    {
                        "username": "Suffolk",
                        "content": "convert to seconds, problem is converted to find overlap of 2 int arrays (if they have).\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Brute force."
                    }
                ]
            },
            {
                "id": 1736884,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "**Weird couple :)**"
                    },
                    {
                        "username": "coderrsc",
                        "content": "thats what she said"
                    },
                    {
                        "username": "Suffolk",
                        "content": "convert to seconds, problem is converted to find overlap of 2 int arrays (if they have).\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Brute force."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Matching of Players With Trainers",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>players</code>, where <code>players[i]</code> represents the <strong>ability</strong> of the <code>i<sup>th</sup></code> player. You are also given a <strong>0-indexed</strong> integer array <code>trainers</code>, where <code>trainers[j]</code> represents the <strong>training capacity </strong>of the <code>j<sup>th</sup></code> trainer.</p>\n\n<p>The <code>i<sup>th</sup></code> player can <strong>match</strong> with the <code>j<sup>th</sup></code> trainer if the player&#39;s ability is <strong>less than or equal to</strong> the trainer&#39;s training capacity. Additionally, the <code>i<sup>th</sup></code> player can be matched with at most one trainer, and the <code>j<sup>th</sup></code> trainer can be matched with at most one player.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of matchings between </em><code>players</code><em> and </em><code>trainers</code><em> that satisfy these conditions.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> players = [4,7,9], trainers = [8,2,5,8]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nOne of the ways we can form two matchings is as follows:\n- players[0] can be matched with trainers[0] since 4 &lt;= 8.\n- players[1] can be matched with trainers[3] since 7 &lt;= 8.\nIt can be proven that 2 is the maximum number of matchings that can be formed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> players = [1,1,1], trainers = [10]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong>\nThe trainer can be matched with any of the 3 players.\nEach player can only be matched with one trainer, so the maximum answer is 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= players.length, trainers.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= players[i], trainers[j] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2589677,
                "title": "greedy",
                "content": "We are matching trainers with players in order of the training capacity.\\n\\nSince capacity is non-decreasing, we can pick any player with ability less than the current capacity. To make it simple, we pick a player with the smallest ability.\\n\\nIf the problem would require maximizing players\\' ability, we would sort capacities and abilities in the descending order.\\n\\n**C++**\\n```cpp\\nint matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n    sort(begin(p), end(p));\\n    sort(begin(t), end(t));\\n    int j = 0;\\n    for (int i = 0; i < t.size() && j < p.size(); ++i)\\n        j += p[j] <= t[i];\\n    return j;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n    sort(begin(p), end(p));\\n    sort(begin(t), end(t));\\n    int j = 0;\\n    for (int i = 0; i < t.size() && j < p.size(); ++i)\\n        j += p[j] <= t[i];\\n    return j;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587934,
                "title": "c-two-pointer-related-problems",
                "content": "```cpp\\nint matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int N = players.size(), M = trainers.size();\\n\\n        int j = 0, ans = 0, maxIndex = 0;\\n\\n        for(int i = 0; i < N && j < M; i++) {\\n            int need = players[i];\\n\\t\\t\\t\\n\\t\\t\\t// When the jth trainer ability is less, move to next trainer\\n            while(trainers[j] < need) {\\n                j++;\\n                if(j == M) return ans; // If we move next to last trainer, return the answer.\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// We got out right trainer for ith player, increment the answer and move to next trainer\\n            if(trainers[j] >= need) {\\n                ans++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\t\\n**Related Problems**\\n[1. Two Sum](https://leetcode.com/problems/two-sum/)\\n[2. Container With Most Water ](https://leetcode.com/problems/container-with-most-water/)\\n[3. 3Sum ](https://leetcode.com/problems/3sum/)\\n[4. Minimum Window Substring ](https://leetcode.com/problems/minimum-window-substring/)\\n[5. Remove Duplicates from Sorted List ](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\\n[6. Reorder List ](https://leetcode.com/problems/reorder-list/)\\n[7. Maximum Product Subarray ](https://leetcode.com/problems/maximum-product-subarray/)\\n[8. Palindrome Linked List ](https://leetcode.com/problems/palindrome-linked-list/)\\n[9. Subarray Product Less Than K ](https://leetcode.com/problems/subarray-product-less-than-k/)\\n[10. Backspace String Compare ](https://leetcode.com/problems/backspace-string-compare/)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int N = players.size(), M = trainers.size();\\n\\n        int j = 0, ans = 0, maxIndex = 0;\\n\\n        for(int i = 0; i < N && j < M; i++) {\\n            int need = players[i];\\n\\t\\t\\t\\n\\t\\t\\t// When the jth trainer ability is less, move to next trainer\\n            while(trainers[j] < need) {\\n                j++;\\n                if(j == M) return ans; // If we move next to last trainer, return the answer.\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// We got out right trainer for ith player, increment the answer and move to next trainer\\n            if(trainers[j] >= need) {\\n                ans++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587908,
                "title": "sort-and-count-java",
                "content": "**Code:**\\n\\n    public int matchPlayersAndTrainers(int[] player, int[] train) {\\n        Arrays.sort(player);\\n        Arrays.sort(train);\\n        int i = 0, j = 0, res = 0;\\n        while(j<train.length && i<player.length) {\\n            if(player[i]>train[j])\\n                while(j<train.length && train[j]<player[i]) // find trainer\\n                    j++;\\n            else { res++; i++; j++; } // can train.\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "**Code:**\\n\\n    public int matchPlayersAndTrainers(int[] player, int[] train) {\\n        Arrays.sort(player);\\n        Arrays.sort(train);\\n        int i = 0, j = 0, res = 0;\\n        while(j<train.length && i<player.length) {\\n            if(player[i]>train[j])\\n                while(j<train.length && train[j]<player[i]) // find trainer\\n                    j++;\\n            else { res++; i++; j++; } // can train.\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2587948,
                "title": "java-python-3-sort-both-w-brief-explanation-and-analysis",
                "content": "Sort both arrays, then traverse `players` and for each one binary search `trainers` with the starting index as previous result + `1`.\\n\\n```java\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int idx = 0, match = 0;\\n        for (int p : players) {\\n            idx = binarySearch(trainers, p, idx);\\n            if (idx >= trainers.length) {\\n                return match;\\n            }\\n            ++match;\\n            ++idx;\\n        }\\n        return match;\\n    }\\n    private int binarySearch(int[] trainers, int p, int lo) {\\n        int hi = trainers.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (trainers[mid] < p) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\\n\\n\\n```python\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        trainers.sort()\\n        match = idx = 0\\n        for p in sorted(players):\\n            idx = bisect.bisect_left(trainers, p, idx)\\n            if idx >= len(trainers):\\n                return match\\n            match += 1\\n            idx += 1\\n        return match\\n```\\n\\n----\\n\\nActually, no need to do binary search:\\n\\n```java\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int match = 0, i = 0;\\n        for (int p : players) {\\n            while (i < trainers.length && p > trainers[i]) {\\n                ++i;\\n            }\\n            if (i == trainers.length) {\\n                return match;\\n            }\\n            ++match;\\n            ++i;\\n        }\\n        return match;\\n    }\\n```\\n```python\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        m, n = len(players), len(trainers)\\n        idx = match = 0\\n        trainers.sort()\\n        for p in sorted(players):\\n            while idx < n and  p > trainers[idx]:\\n                idx += 1\\n            if idx == n:\\n                return match\\n            match += 1\\n            idx += 1\\n        return match\\n```\\n\\n\\n**Analysis:**\\n\\nTime: `O(PlogP + TlogT)`, space: `O(P + T)` - including sorting space, where `P = players.length, T = trainers.length`.",
                "solutionTags": [],
                "code": "```java\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int idx = 0, match = 0;\\n        for (int p : players) {\\n            idx = binarySearch(trainers, p, idx);\\n            if (idx >= trainers.length) {\\n                return match;\\n            }\\n            ++match;\\n            ++idx;\\n        }\\n        return match;\\n    }\\n    private int binarySearch(int[] trainers, int p, int lo) {\\n        int hi = trainers.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (trainers[mid] < p) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\n```python\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        trainers.sort()\\n        match = idx = 0\\n        for p in sorted(players):\\n            idx = bisect.bisect_left(trainers, p, idx)\\n            if idx >= len(trainers):\\n                return match\\n            match += 1\\n            idx += 1\\n        return match\\n```\n```java\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int match = 0, i = 0;\\n        for (int p : players) {\\n            while (i < trainers.length && p > trainers[i]) {\\n                ++i;\\n            }\\n            if (i == trainers.length) {\\n                return match;\\n            }\\n            ++match;\\n            ++i;\\n        }\\n        return match;\\n    }\\n```\n```python\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        m, n = len(players), len(trainers)\\n        idx = match = 0\\n        trainers.sort()\\n        for p in sorted(players):\\n            while idx < n and  p > trainers[idx]:\\n                idx += 1\\n            if idx == n:\\n                return match\\n            match += 1\\n            idx += 1\\n        return match\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2587893,
                "title": "using-two-priorityqueues",
                "content": "\\n    class Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        //using two max heap\\n        Queue<Integer> q1=new PriorityQueue<>(Collections.reverseOrder());\\n        Queue<Integer> q2=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int x:players)q1.add(x);\\n        for(int y:trainers)q2.add(y);\\n        int c=0;\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            int t1=q1.peek();\\n            int t2=q2.peek();\\n            //we can do mapping players-->trainer\\n            if(t1<=t2){\\n                q1.poll();\\n                q2.poll();\\n                c++;\\n            }\\n            //cannot do mapping removing the players\\n            else{\\n                q1.poll();\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        //using two max heap\\n        Queue<Integer> q1=new PriorityQueue<>(Collections.reverseOrder());\\n        Queue<Integer> q2=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int x:players)q1.add(x);\\n        for(int y:trainers)q2.add(y);\\n        int c=0;\\n        while(!q1.isEmpty() && !q2.isEmpty()){\\n            int t1=q1.peek();\\n            int t2=q2.peek();\\n            //we can do mapping players-->trainer\\n            if(t1<=t2){\\n                q1.poll();\\n                q2.poll();\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2587925,
                "title": "easy-java-solution-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] p, int[] t) {\\n        Arrays.sort(p);\\n        Arrays.sort(t);\\n        int i=0,j=0,c=0;\\n        while(i<p.length&&j<t.length)\\n        {\\n            if(p[i]<=t[j])\\n            {\\n                i++;\\n                j++;\\n                c++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int matchPlayersAndTrainers(int[] p, int[] t) {\\n        Arrays.sort(p);\\n        Arrays.sort(t);\\n        int i=0,j=0,c=0;\\n        while(i<p.length&&j<t.length)\\n        {\\n            if(p[i]<=t[j])\\n            {\\n                i++;\\n                j++;\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2587899,
                "title": "c-greedy-approach-use-sorting-2-pointers",
                "content": "**Please upvote if you find this solution helpful :)**\\n```\\nclass Solution \\n{\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        \\n        int count=0;\\n        int s1=0, s2=0;\\n        \\n        while(s1<players.size() && s2<trainers.size())\\n        {\\n            if(players[s1] <= trainers[s2])\\n            {\\n                count++;\\n                s1++;\\n                s2++;\\n            }\\n            \\n            else if(players[s1] > trainers[s2])\\n            {\\n                s2++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        \\n        int count=0;\\n        int s1=0, s2=0;\\n        \\n        while(s1<players.size() && s2<trainers.size())\\n        {\\n            if(players[s1] <= trainers[s2])\\n            {\\n                count++;\\n                s1++;\\n                s2++;\\n            }\\n            \\n            else if(players[s1] > trainers[s2])\\n            {\\n                s2++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753086,
                "title": "multiset-approach",
                "content": "****Multiset Approach****\\n**Tc : O(n log n) && Sc : O(n)**\\nThis question could also be done in O(max(m , n)) using two pointers where n is the size of players and m is the size of trainers\\n\\n```\\nint matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        int j = 0;\\n        int ans = 0;\\n        int n = p.size();\\n        multiset<int> ms;\\n        for(int i = 0 ; i < t.size() ; i++){\\n            ms.insert(t[i]);\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            auto lt = ms.lower_bound(p[i]);\\n            if(lt == ms.end()){\\n                continue;\\n            }\\n            else{\\n                ans++;\\n            }\\n            ms.erase(lt);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nint matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        int j = 0;\\n        int ans = 0;\\n        int n = p.size();\\n        multiset<int> ms;\\n        for(int i = 0 ; i < t.size() ; i++){\\n            ms.insert(t[i]);\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            auto lt = ms.lower_bound(p[i]);\\n            if(lt == ms.end()){\\n                continue;\\n            }\\n            else{\\n                ans++;\\n            }\\n            ms.erase(lt);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671448,
                "title": "c-simple-solution-two-pointer-sort-90-faster",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs from the question, we can conclude that we should allot a trainer with nearest smaller player, so in order to do that we will sort both arrays and use two pointer approach which will be with the variables pointing to the last elements of both the arrays and if players[i]<=trainers[j] we will increase the count and shift those two indexes to previous elements else we will only shift the player\\'s index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        int i=players.size()-1;\\n        int j=trainers.size()-1;\\n        int cnt=0;\\n        while(i>=0 and j>=0){\\n            if(players[i]<=trainers[j]){\\n                cnt++;\\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        int i=players.size()-1;\\n        int j=trainers.size()-1;\\n        int cnt=0;\\n        while(i>=0 and j>=0){\\n            if(players[i]<=trainers[j]){\\n                cnt++;\\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588038,
                "title": "javascript-sort",
                "content": "```\\n/**\\n * @param {number[]} players\\n * @param {number[]} trainers\\n * @return {number}\\n */\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a, b) => a - b);\\n    trainers.sort((a, b) => a - b);\\n    \\n    let i = 0;\\n    for (let j = 0; j < trainers.length; j++) {\\n        if (players[i] <= trainers[j]) {\\n            i++;\\n        }\\n    }\\n    \\n    return i;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} players\\n * @param {number[]} trainers\\n * @return {number}\\n */\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a, b) => a - b);\\n    trainers.sort((a, b) => a - b);\\n    \\n    let i = 0;\\n    for (let j = 0; j < trainers.length; j++) {\\n        if (players[i] <= trainers[j]) {\\n            i++;\\n        }\\n    }\\n    \\n    return i;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550574,
                "title": "using-sort-c-easy-to-understand",
                "content": "sort both array to get minimum element first from both arrays.\\nif(v1[i]<=v2[j]){\\n    match is possible \\n    increment i and j\\n    }\\nelse{\\n    match not possible so i want increse capacity of trainer.\\n}\\n# Complexity\\n- Time complexity:\\nO((max size of any array)*(log((max size of any array))))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& v1, vector<int>& v2) {\\n        int i = 0, j = 0, m = v1.size(), n = v2.size();\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        int ans = 0;\\n        while(i<m && j < n){\\n            if(v1[i]<=v2[j]){//if match is possible\\n                ans++;i++;j++;\\n            }else{//not possible increase capacity of trainer.\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& v1, vector<int>& v2) {\\n        int i = 0, j = 0, m = v1.size(), n = v2.size();\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        int ans = 0;\\n        while(i<m && j < n){\\n            if(v1[i]<=v2[j]){//if match is possible\\n                ans++;i++;j++;\\n            }else{//not possible increase capacity of trainer.\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413610,
                "title": "c-two-pointer-binary-search-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we sort both arrays, then we need to find the first index at which `trainers[j] >= players[i]` for every `players[i]`. Why? Because only this way, the optimal number of matches can be made. If we take any higher value from the `trainers` array, we might not be able to make the optimal match.\\n\\nTo do this, we can simply have one pointer to track the index of the current available trainer (after the match of the previous trainer) and another to track the player index.\\n\\nI have also included detailed binary search code, as it was my first intuition to solve this problem. It takes more time because, in the worst case, it calls the binary search for every element of `players`.  \\n\\n\\n# Complexity\\n- Time complexity: O(NlogN), where N is the size of the larger of the two input vectors (players and trainers). This time is taken by sorting of the arrays.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n## 1. 2 Pointers\\n```\\nclass Solution {\\npublic:\\n    \\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n\\n        int count=0,i=0,j=0; \\n        while(i<players.size() and j<trainers.size()){\\n            if(players[i]<=trainers[j]){ // if condition is satisfied, move on to next trainer and player\\n                ++i; ++j;\\n                ++count;\\n            }else{\\n                j++; // if condition is not satisfied, check for next trainer\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n## 2. Binary Search\\n```cpp\\nclass Solution {\\npublic:\\n    int possible(int p, vector<int>& trainers, int l){\\n        int r=trainers.size()-1;\\n        while(l<r){\\n            int mid=(l+r)/2;\\n            if(trainers[mid]<p) l=mid+1;\\n            else r=mid;\\n        }\\n        return r;\\n    }\\n    \\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n\\n        int count=0, st=0;\\n        for(int i=0;i<players.size();++i){\\n            int idx = possible(players[i],trainers,st); // index at which the trainers value is larger than or equal to players for first time \\n            if(idx<trainers.size() and trainers[idx]>=players[i]) {\\n                count++;\\n                st=idx+1; // now search should start from next index\\n                if(st>=trainers.size()) break; \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n\\n        int count=0,i=0,j=0; \\n        while(i<players.size() and j<trainers.size()){\\n            if(players[i]<=trainers[j]){ // if condition is satisfied, move on to next trainer and player\\n                ++i; ++j;\\n                ++count;\\n            }else{\\n                j++; // if condition is not satisfied, check for next trainer\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int possible(int p, vector<int>& trainers, int l){\\n        int r=trainers.size()-1;\\n        while(l<r){\\n            int mid=(l+r)/2;\\n            if(trainers[mid]<p) l=mid+1;\\n            else r=mid;\\n        }\\n        return r;\\n    }\\n    \\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n\\n        int count=0, st=0;\\n        for(int i=0;i<players.size();++i){\\n            int idx = possible(players[i],trainers,st); // index at which the trainers value is larger than or equal to players for first time \\n            if(idx<trainers.size() and trainers[idx]>=players[i]) {\\n                count++;\\n                st=idx+1; // now search should start from next index\\n                if(st>=trainers.size()) break; \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326659,
                "title": "python3-easy-understanding",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, p: List[int], t: List[int]) -> int:\\n        p.sort()\\n        t.sort()\\n        i = j = res = 0\\n        while i < len(p) and j < len(t):\\n            if p[i] <= t[j]:\\n                res += 1\\n                i += 1\\n            j += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, p: List[int], t: List[int]) -> int:\\n        p.sort()\\n        t.sort()\\n        i = j = res = 0\\n        while i < len(p) and j < len(t):\\n            if p[i] <= t[j]:\\n                res += 1\\n                i += 1\\n            j += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797048,
                "title": "not-a-medium-level-answer-two-pointer-simple",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the elements\\nthen check each element until we got trainer value greater than the value of player.\\nthen increase the count;\\nif not then go to next value of player\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int count = 0;\\n        int j = trainers.length-1;  \\n        for(int i=players.length-1; i>=0 && j>=0; ){\\n            if(players[i] <= trainers[j]){\\n                count++;\\n                j--;\\n                i--;\\n            }else if(players[i] > trainers[j]){\\n                i--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int count = 0;\\n        int j = trainers.length-1;  \\n        for(int i=players.length-1; i>=0 && j>=0; ){\\n            if(players[i] <= trainers[j]){\\n                count++;\\n                j--;\\n                i--;\\n            }else if(players[i] > trainers[j]){\\n                i--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745290,
                "title": "java-solution-for-beginners-sorting",
                "content": "![image](https://assets.leetcode.com/users/images/40a4817d-726e-4a9c-9813-2dd89d95c349_1666770673.5629609.png)\\n\\n\\n**Upvote if you like my solution**\\n\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int count = 0;\\n        for(int i = 0,j = 0;i<players.length && j<trainers.length;){\\n            if(players[i]<=trainers[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int count = 0;\\n        for(int i = 0,j = 0;i<players.length && j<trainers.length;){\\n            if(players[i]<=trainers[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620258,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int j = 0, matches = 0;\\n        for(int i=0; i<trainers.length && j < players.length; i++){\\n            if(players[j] <= trainers[i]){\\n                j++;\\n                matches++;\\n            }\\n        }\\n        return matches;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a,b) => a-b);\\n    trainers.sort((a,b) => a-b);\\n    let j = 0, matches = 0;\\n    for(let i=0; i<trainers.length && j < players.length; i++){\\n        if(players[j] <= trainers[i]){\\n            j++;\\n            matches++;\\n        }\\n    }\\n    return matches;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def matchPlayersAndTrainers(self, players, trainers):\\n        players.sort()\\n        trainers.sort()\\n        j = matches = 0\\n        for i in range(len(trainers)):\\n            if j < len(players) and players[j] <= trainers[i]:\\n                j += 1\\n                matches += 1\\n        return matches\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int j = 0, matches = 0;\\n        for(int i=0; i<trainers.length && j < players.length; i++){\\n            if(players[j] <= trainers[i]){\\n                j++;\\n                matches++;\\n            }\\n        }\\n        return matches;\\n    }\\n}\\n```\n```\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a,b) => a-b);\\n    trainers.sort((a,b) => a-b);\\n    let j = 0, matches = 0;\\n    for(let i=0; i<trainers.length && j < players.length; i++){\\n        if(players[j] <= trainers[i]){\\n            j++;\\n            matches++;\\n        }\\n    }\\n    return matches;\\n};\\n```\n```\\nclass Solution(object):\\n    def matchPlayersAndTrainers(self, players, trainers):\\n        players.sort()\\n        trainers.sort()\\n        j = matches = 0\\n        for i in range(len(trainers)):\\n            if j < len(players) and players[j] <= trainers[i]:\\n                j += 1\\n                matches += 1\\n        return matches\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594478,
                "title": "python-3-heap-8-lines-t-m-71-100",
                "content": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        ans = 0\\n        trainers.sort()\\n        heapify(players)\\n\\n        for t in trainers:\\n            if players and players[0] <= t:\\n                heappop(players)\\n                ans+= 1\\n\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        ans = 0\\n        trainers.sort()\\n        heapify(players)\\n\\n        for t in trainers:\\n            if players and players[0] <= t:\\n                heappop(players)\\n                ans+= 1\\n\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2588196,
                "title": "easy-two-pointers-sorting-with-java",
                "content": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int res=0,i=0,j=0,p=players.length,t=trainers.length;\\n        Arrays.sort(players); Arrays.sort(trainers);\\n        while(i<p && j<t){\\n            if(players[i]<=trainers[j]){\\n                res++;\\n                i++;\\n                j++;\\n            }else if(players[i]>trainers[j]){\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int res=0,i=0,j=0,p=players.length,t=trainers.length;\\n        Arrays.sort(players); Arrays.sort(trainers);\\n        while(i<p && j<t){\\n            if(players[i]<=trainers[j]){\\n                res++;\\n                i++;\\n                j++;\\n            }else if(players[i]>trainers[j]){\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588037,
                "title": "easy-c-0ms",
                "content": "**class Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n        priority_queue <int, vector<int>, greater<int>> pq1;\\n        for (auto x:players)\\n            pq1.push(x);\\n        \\n        priority_queue <int, vector<int>, greater<int>> pq2;\\n        for (auto x:trainers)\\n            pq2.push(x);\\n        \\n        \\n        int cnt=0;\\n        \\n        while (!pq1.empty() && !pq2.empty())\\n        {\\n            if (pq1.top()>pq2.top())\\n            {\\n                pq2.pop();\\n            }\\n            else\\n            {\\n                cnt++;\\n                pq1.pop();\\n                pq2.pop();\\n            }\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};**",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n        priority_queue <int, vector<int>, greater<int>> pq1;\\n        for (auto x:players)\\n            pq1.push(x);\\n        \\n        priority_queue <int, vector<int>, greater<int>> pq2;\\n        for (auto x:trainers)\\n            pq2.push(x);\\n        \\n        \\n        int cnt=0;\\n        \\n        while (!pq1.empty() && !pq2.empty())\\n        {\\n            if (pq1.top()>pq2.top())\\n            {\\n                pq2.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2587952,
                "title": "c-o-nlogn-2-pointer-greedy-sorting",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n        \\n        int n=p.size(), m=t.size();\\n        \\n        int c=0;\\n        int i=n-1, j=m-1;\\n        while(i>=0 && j>=0){\\n            if(p[i]>t[j]){\\n                i--;\\n            }else{\\n                c++;\\n                i--, j--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n        \\n        int n=p.size(), m=t.size();\\n        \\n        int c=0;\\n        int i=n-1, j=m-1;\\n        while(i>=0 && j>=0){\\n            if(p[i]>t[j]){\\n                i--;\\n            }else{\\n                c++;\\n                i--, j--;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587936,
                "title": "simple-and-easy-java-c-python",
                "content": "In Java:\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] p, int[] t) {\\n        int n = p.length;\\n        int m = t.length;\\n        int i=0,j=0;\\n        Arrays.sort(p);\\n        Arrays.sort(t);\\n        int ans = 0;\\n        while(i<n && j<m){\\n            while(j<m && t[j] < p[i]) j++;\\n            if(j<m){\\n                ans++;\\n                i++;j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**In C++:**\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        int n = p.size();\\n        int m = t.size();\\n        int i=0,j=0;\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n        int ans = 0;\\n        while(i<n && j<m){\\n            while(j<m && t[j] < p[i]) j++;\\n            if(j<m){\\n                ans++;\\n                i++;j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**In Python :**\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        result = 0\\n        for i in range(len(players)):\\n            if len(players)==0 or len(trainers)==0:\\n                break;\\n            if players[-1]<=trainers[-1]:\\n                players.pop()\\n                trainers.pop()\\n                result+=1\\n            else:\\n                players.pop()\\n        return result\\n```\\n\\n### **Happy Coding** \\uD83D\\uDE0A!!!\\n### If you get value from this, then show some love by ***upvoting*** it !!\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] p, int[] t) {\\n        int n = p.length;\\n        int m = t.length;\\n        int i=0,j=0;\\n        Arrays.sort(p);\\n        Arrays.sort(t);\\n        int ans = 0;\\n        while(i<n && j<m){\\n            while(j<m && t[j] < p[i]) j++;\\n            if(j<m){\\n                ans++;\\n                i++;j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        int n = p.size();\\n        int m = t.size();\\n        int i=0,j=0;\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n        int ans = 0;\\n        while(i<n && j<m){\\n            while(j<m && t[j] < p[i]) j++;\\n            if(j<m){\\n                ans++;\\n                i++;j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        result = 0\\n        for i in range(len(players)):\\n            if len(players)==0 or len(trainers)==0:\\n                break;\\n            if players[-1]<=trainers[-1]:\\n                players.pop()\\n                trainers.pop()\\n                result+=1\\n            else:\\n                players.pop()\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587932,
                "title": "c-java-python-greedy-easily-understandable",
                "content": "The idea is to sort them both in increasing order and try to train as much players as possible. \\n\\nTime complexity: **O(max(nlogn, mlogm))**\\nwhere n = number of players and m = number of trainers\\nSpace complexity: **O(1)**\\n\\n\\u2714 C++:\\n\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int i = players.size() - 1, j = trainers.size() - 1, matchings = 0;\\n        while(i >= 0 and j >= 0) {\\n\\t\\t\\t// cannot be trained \\n            if(players[i] > trainers[j])\\n                --i;\\n            else {\\n                ++matchings;\\n                --i;\\n                --j;\\n            }\\n        }\\n        return matchings;\\n    }\\n};\\n```\\n\\n\\u2714 Java:\\n\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i = players.length - 1, j = trainers.length - 1, matchings = 0;\\n        while(i >= 0 && j >= 0) {\\n\\t\\t\\t// cannot be trained \\n            if(players[i] > trainers[j])\\n                --i;\\n            else {\\n                ++matchings;\\n                --i;\\n                --j;\\n            }\\n        }\\n        return matchings;\\n    }\\n}\\n```\\n\\n\\u2714 Python: \\n\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players, trainers = sorted(players), sorted(trainers)\\n        i, j, matchings = len(players) - 1, len(trainers) - 1, 0\\n        while i >= 0 and j >= 0:\\n\\t\\t\\t# cannot be trained \\n            if players[i] > trainers[j]:\\n                 i -= 1\\n            else:\\n                matchings, i, j = matchings + 1, i - 1, j - 1\\n        return matchings\\n```\\n\\nThanks a lot for reading! ^_^\\n\\uD83D\\uDCAF An upvote would be appreciated.\\n\\uD83D\\uDC47 Comment down your doubts (if any).",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int i = players.size() - 1, j = trainers.size() - 1, matchings = 0;\\n        while(i >= 0 and j >= 0) {\\n\\t\\t\\t// cannot be trained \\n            if(players[i] > trainers[j])\\n                --i;\\n            else {\\n                ++matchings;\\n                --i;\\n                --j;\\n            }\\n        }\\n        return matchings;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i = players.length - 1, j = trainers.length - 1, matchings = 0;\\n        while(i >= 0 && j >= 0) {\\n\\t\\t\\t// cannot be trained \\n            if(players[i] > trainers[j])\\n                --i;\\n            else {\\n                ++matchings;\\n                --i;\\n                --j;\\n            }\\n        }\\n        return matchings;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players, trainers = sorted(players), sorted(trainers)\\n        i, j, matchings = len(players) - 1, len(trainers) - 1, 0\\n        while i >= 0 and j >= 0:\\n\\t\\t\\t# cannot be trained \\n            if players[i] > trainers[j]:\\n                 i -= 1\\n            else:\\n                matchings, i, j = matchings + 1, i - 1, j - 1\\n        return matchings\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645975,
                "title": "easy-c-solution-with-pseudocode",
                "content": "Intiuition - \\n1) sort both the arrays.\\n2) Now make two pointers which intially points towards the starting of the arrays ; \\n3) Make a variable ans which will store the count when the fav condition occurs ; \\n4) Now run a run until weather the first pointer or second pointer crosses the size of their respective arrays ; \\n5) if (players[i] <= trainers[j]) which is the fav condition so we do ans++ and now move both the pointers forward ; \\n6) else we only move the trainers pointer forward as their might be the fav cond. later in the vector; \\n7) When we traverse and the loop ends we are left with the ans value ; \\n\\n\\n\\n         class Solution {\\n          public:\\n         int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n          sort(players.begin(),players.end());\\n          sort(trainers.begin(),trainers.end());\\n          int i = 0 ; int j=0 ; \\n          int n = players.size() ; \\n          int m = trainers.size() ; \\n          int ans = 0 ;\\n          while(i<n && j<m){\\n            if(players[i]<=trainers[j]){\\n                ans++ ; \\n                i++ ; j++ ; \\n            }\\n            else if(players[i]> trainers[j]){\\n                j++ ; \\n            }\\n        }\\n        return ans ; \\n        \\n         }\\n       };",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\n          public:\\n         int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n          sort(players.begin(),players.end());\\n          sort(trainers.begin(),trainers.end());\\n          int i = 0 ; int j=0 ; \\n          int n = players.size() ; \\n          int m = trainers.size() ; \\n          int ans = 0 ;\\n          while(i<n && j<m){\\n            if(players[i]<=trainers[j]){\\n                ans++ ; \\n                i++ ; j++ ; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2736601,
                "title": "c-two-pointer-related-problems",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n{\\n   int count=0;\\n   sort(players.begin(),players.end());\\n   sort(trainers.begin(),trainers.end());\\n   \\n   int idx=players.size()-1;\\n   int temp=trainers.size()-1;\\n   \\n   while(idx>=0 and temp>=0)\\n   {\\n   \\t   if(players[idx] > trainers[temp])\\n   \\t   {\\n   \\t      \\tidx--;\\n\\t   }\\n\\t   else if(players[idx] <= trainers[temp])\\n\\t   {\\n\\t   \\t    count++;\\n\\t   \\t    idx--;\\n\\t   \\t    temp--;\\n\\t   }\\n   }\\n   return count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n{\\n   int count=0;\\n   sort(players.begin(),players.end());\\n   sort(trainers.begin(),trainers.end());\\n   \\n   int idx=players.size()-1;\\n   int temp=trainers.size()-1;\\n   \\n   while(idx>=0 and temp>=0)\\n   {\\n   \\t   if(players[idx] > trainers[temp])\\n   \\t   {\\n   \\t      \\tidx--;\\n\\t   }\\n\\t   else if(players[idx] <= trainers[temp])\\n\\t   {\\n\\t   \\t    count++;\\n\\t   \\t    idx--;\\n\\t   \\t    temp--;\\n\\t   }\\n   }\\n   return count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705912,
                "title": "two-pointers",
                "content": "```\\n//TWO  POINTER APPROACH\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0;\\n        int j=0;\\n        int cnt=0;\\n        while(i<players.size() && j<trainers.size()){\\n            if(players[i]<=trainers[j]){\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }     \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n//TWO  POINTER APPROACH\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0;\\n        int j=0;\\n        int cnt=0;\\n        while(i<players.size() && j<trainers.size()){\\n            if(players[i]<=trainers[j]){\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }     \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589142,
                "title": "c-best-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n\\t//STEP1: SORT BOTH VECTOR\\n\\t\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int len1=players.size();\\n        int len2=  trainers.size();\\n        \\n        int i=0;  //POINTER FOR PLAYERS\\n        int j=0; //POINTER FOR TRAINERS\\n        int count=0;\\n        while(i<len1){\\n            if(j==len2) break;\\n            \\n            int num=players[i]; \\n            // USE  LOWER BOUND TO KNOW THE INDEX VALUE OF THE TRAINER WHICH IS GREATER OR EQUAL TO             //THE  PLAYERS VALUE\\n\\t\\t\\t\\n             j=lower_bound(trainers.begin()+j,trainers.end(),num)-trainers.begin();\\n             \\n            if(j>=len2) break;\\n            else if(trainers[j]>=num){\\n                count++;\\n                i++;\\n                \\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n\\t//STEP1: SORT BOTH VECTOR\\n\\t\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int len1=players.size();\\n        int len2=  trainers.size();\\n        \\n        int i=0;  //POINTER FOR PLAYERS\\n        int j=0; //POINTER FOR TRAINERS\\n        int count=0;\\n        while(i<len1){\\n            if(j==len2) break;\\n            \\n            int num=players[i]; \\n            // USE  LOWER BOUND TO KNOW THE INDEX VALUE OF THE TRAINER WHICH IS GREATER OR EQUAL TO             //THE  PLAYERS VALUE\\n\\t\\t\\t\\n             j=lower_bound(trainers.begin()+j,trainers.end(),num)-trainers.begin();\\n             \\n            if(j>=len2) break;\\n            else if(trainers[j]>=num){\\n                count++;\\n                i++;\\n                \\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588515,
                "title": "c-2-pointer-7-lines-code",
                "content": "```\\nint matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n    sort(p.begin(), p.end());\\n    sort(t.begin(), t.end());\\n    int n = p.size(), m = t.size();\\n    int i = 0;\\n    for (int j = 0; j < m && i < n; j++) {\\n        if (p[i] <= t[j]) i++;\\n    }\\n    return i;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n    sort(p.begin(), p.end());\\n    sort(t.begin(), t.end());\\n    int n = p.size(), m = t.size();\\n    int i = 0;\\n    for (int j = 0; j < m && i < n; j++) {\\n        if (p[i] <= t[j]) i++;\\n    }\\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588449,
                "title": "easy-solution-very-few-lines",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int> &players, vector<int> &trainers) {\\n        sort(trainers.begin(), trainers.end());\\n        sort(players.begin(), players.end());\\n        int i = 0, j = 0, cnt = 0;\\n        while (i < players.size() and j < trainers.size()) {\\n            if (players[i] <= trainers[j++]) cnt++, i++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int> &players, vector<int> &trainers) {\\n        sort(trainers.begin(), trainers.end());\\n        sort(players.begin(), players.end());\\n        int i = 0, j = 0, cnt = 0;\\n        while (i < players.size() and j < trainers.size()) {\\n            if (players[i] <= trainers[j++]) cnt++, i++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588410,
                "title": "just-sort-it",
                "content": "**Idea(Greedy solution)**: Sort both the vectors.Try to match player with largest ability to trainer with largest capacity,if possible otherwise player canot be matched\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t)\\n    {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n        \\n        \\n        int ans =0;\\n        \\n        while(p.size()&&t.size()) // if trainers and players are available\\n        {\\n            \\n            while(p.size()>0&&p.back()>t.back())    // if there is not trainer available of player with p.back() \\n\\t\\t\\t{                                                             //capacity,remove that player\\n\\t\\t    \\tp.pop_back();                                    \\n            }\\n            \\n            if(p.size())      // if atleast one player is  remaining, means matching found\\n            {\\n                ans++;\\n                p.pop_back();  // remove player\\n                t.pop_back();  // remove trainer\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t)\\n    {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n        \\n        \\n        int ans =0;\\n        \\n        while(p.size()&&t.size()) // if trainers and players are available\\n        {\\n            \\n            while(p.size()>0&&p.back()>t.back())    // if there is not trainer available of player with p.back() \\n\\t\\t\\t{                                                             //capacity,remove that player\\n\\t\\t    \\tp.pop_back();                                    \\n            }\\n            \\n            if(p.size())      // if atleast one player is  remaining, means matching found\\n            {\\n                ans++;\\n                p.pop_back();  // remove player\\n                t.pop_back();  // remove trainer\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588078,
                "title": "python-sort-and-binary-search",
                "content": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], t: List[int]) -> int:\\n        players.sort()\\n        t.sort()        \\n        result = 0\\n        i = -1\\n        for p in players:\\n            i = bisect_left(t, p, i + 1)\\n            if i < len(t): result += 1\\n            else: break\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], t: List[int]) -> int:\\n        players.sort()\\n        t.sort()        \\n        result = 0\\n        i = -1\\n        for p in players:\\n            i = bisect_left(t, p, i + 1)\\n            if i < len(t): result += 1\\n            else: break\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480470,
                "title": "beats-90-cpp-sol",
                "content": "\\n# Approach\\nApproach is very simple we need the trainers to be greater than or equal to players so we can assure that here order doesn\\'t matter we just need the count so, sort the array and then use the two pointers approach... I will highly recommend to go through the code once...\\n\\n# **Upvote if it helps \\uD83E\\uDD79**\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int idx = 0;\\n        for(int i = 0; i<trainers.size(); i++){\\n            if( idx < players.size() && trainers[i] >= players[idx]){\\n                idx++;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int idx = 0;\\n        for(int i = 0; i<trainers.size(); i++){\\n            if( idx < players.size() && trainers[i] >= players[idx]){\\n                idx++;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369101,
                "title": "c-solution-using-binary-search-with-detailed-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // Define a binary search function to find the smallest trainer who can train a player.\\n    int binarySearch(vector<int>& trainers, int target, int lo, int hi) {\\n        \\n        // Loop until lo and hi pointers meet.\\n        while(lo < hi) {\\n            \\n            // Calculate mid pointer.\\n            int mid = lo + (hi - lo)/2;\\n            \\n            // If the trainer can train the player, update hi pointer.\\n            if(trainers[mid] >= target) {\\n                hi = mid;\\n            }\\n            \\n            // If the trainer cannot train the player, update lo pointer.\\n            else {\\n                lo = mid + 1;\\n            }\\n            \\n        }\\n        \\n        // If all trainers are exhausted or the smallest trainer cannot train the player, return -1.\\n        if(lo >= trainers.size() or trainers[lo] < target) {\\n            return -1;\\n        }\\n        \\n        // Return the index of the smallest trainer who can train the player.\\n        return lo;\\n    }\\n    \\n    // Define a function to match players and trainers.\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n        // Sort players and trainers.\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        \\n        // Initialize lo and hi pointers.\\n        int lo = 0, hi = trainers.size() - 1;\\n        \\n        // Initialize the answer.\\n        int ans = 0;\\n        \\n        // Loop through each player.\\n        for(int i = 0; i < players.size(); i++) {\\n            \\n            // Find the smallest trainer who can train the player.\\n            int idx = binarySearch(trainers, players[i], lo, hi);\\n            \\n            // If no trainer can train the player, break the loop.\\n            if(idx == -1) {\\n                break;\\n            }\\n            \\n            // Increment the answer and update the lo pointer.\\n            ans++;\\n            lo = idx + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Define a binary search function to find the smallest trainer who can train a player.\\n    int binarySearch(vector<int>& trainers, int target, int lo, int hi) {\\n        \\n        // Loop until lo and hi pointers meet.\\n        while(lo < hi) {\\n            \\n            // Calculate mid pointer.\\n            int mid = lo + (hi - lo)/2;\\n            \\n            // If the trainer can train the player, update hi pointer.\\n            if(trainers[mid] >= target) {\\n                hi = mid;\\n            }\\n            \\n            // If the trainer cannot train the player, update lo pointer.\\n            else {\\n                lo = mid + 1;\\n            }\\n            \\n        }\\n        \\n        // If all trainers are exhausted or the smallest trainer cannot train the player, return -1.\\n        if(lo >= trainers.size() or trainers[lo] < target) {\\n            return -1;\\n        }\\n        \\n        // Return the index of the smallest trainer who can train the player.\\n        return lo;\\n    }\\n    \\n    // Define a function to match players and trainers.\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n        // Sort players and trainers.\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        \\n        // Initialize lo and hi pointers.\\n        int lo = 0, hi = trainers.size() - 1;\\n        \\n        // Initialize the answer.\\n        int ans = 0;\\n        \\n        // Loop through each player.\\n        for(int i = 0; i < players.size(); i++) {\\n            \\n            // Find the smallest trainer who can train the player.\\n            int idx = binarySearch(trainers, players[i], lo, hi);\\n            \\n            // If no trainer can train the player, break the loop.\\n            if(idx == -1) {\\n                break;\\n            }\\n            \\n            // Increment the answer and update the lo pointer.\\n            ans++;\\n            lo = idx + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085162,
                "title": "simple-neat-approach-using-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Idea is to create min heap for both array & pop from\\n// trainers until we find a trainer capacity>=player, \\n//if found res increased by one pop that trainer cause one player one trainer.\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        priority_queue<int,vector<int>,greater<int>>p(players.begin(),players.end());\\n        priority_queue<int,vector<int>,greater<int>>q(trainers.begin(),trainers.end());\\n        int res=0;\\n        while(!p.empty() && !q.empty()){\\n            if(p.top()>q.top())q.pop();\\n            else if(p.top()<=q.top()){\\n                res++;\\n                p.pop();\\n                q.pop();\\n            }\\n        }\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Idea is to create min heap for both array & pop from\\n// trainers until we find a trainer capacity>=player, \\n//if found res increased by one pop that trainer cause one player one trainer.\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        priority_queue<int,vector<int>,greater<int>>p(players.begin(),players.end());\\n        priority_queue<int,vector<int>,greater<int>>q(trainers.begin(),trainers.end());\\n        int res=0;\\n        while(!p.empty() && !q.empty()){\\n            if(p.top()>q.top())q.pop();\\n            else if(p.top()<=q.top()){\\n                res++;\\n                p.pop();\\n                q.pop();\\n            }\\n        }\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053746,
                "title": "c-sorting-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort both the arrays.\\nuse two pointers to itterate throught the arrays and compare the values .\\nif condition satisfies increment the count and move to next element in both arrays.\\nelse move to next element in trainers array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0,j=0,count=0;\\n        while(i<players.size() && j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                count++;\\n                i++;j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0,j=0,count=0;\\n        while(i<players.size() && j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                count++;\\n                i++;j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828978,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int N = players.size(), M = trainers.size();\\n\\n        int j = 0, ans = 0, maxIndex = 0;\\n\\n        for(int i = 0; i < N && j < M; i++) {\\n            int need = players[i];\\n\\t\\t\\t\\n            while(trainers[j] < need) {\\n                j++;\\n                if(j == M) return ans; \\n            }\\n\\t\\t\\t\\n            if(trainers[j] >= need) {\\n                ans++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int N = players.size(), M = trainers.size();\\n\\n        int j = 0, ans = 0, maxIndex = 0;\\n\\n        for(int i = 0; i < N && j < M; i++) {\\n            int need = players[i];\\n\\t\\t\\t\\n            while(trainers[j] < need) {\\n                j++;\\n                if(j == M) return ans; \\n            }\\n\\t\\t\\t\\n            if(trainers[j] >= need) {\\n                ans++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669676,
                "title": "basic-practice-two-pointer-method-or-heap-simulation",
                "content": "1- Solution formats\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers_v1(self, players: List[int], trainers: List[int]) -> int:\\n        \"\"\"\\n        two-pointer trick\\n        \"\"\"\\n        players.sort()\\n        trainers.sort()\\n        m, n = len(players), len(trainers)\\n        i = j = 0\\n        res = 0\\n        while i < m and j < n:\\n            if players[i] <= trainers[j]:\\n                res += 1\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n        return res\\n    \\n    \\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        \"\"\"\\n        min heap ADT\\n        \"\"\"\\n        heapq.heapify(players)\\n        heapq.heapify(trainers)\\n        res = 0\\n        while players and trainers:\\n            if players[0] <= trainers[0]:\\n                res += 1\\n                heapq.heappop(players)\\n                heapq.heappop(trainers)\\n            else:\\n                heapq.heappop(trainers)\\n        return res\\n                \\n```\\n2- Video Explanation: [Click Video Here](https://youtu.be/OOdJ9SIJkGM;)\\n\\n3- Summary or Analysis\\n\\nMethod: two-pointer trick or heap simulation\\n\\nIdea: after sorting both players and trainers ascendingly, wecompare players\\nand trainers. If player <= trainer in ability, we match them, and look at next\\nplayer and trainer; otherwise, we look at next trainer.\\n\\nThe above idea can be realized using two-pointer trick or heap simulation.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers_v1(self, players: List[int], trainers: List[int]) -> int:\\n        \"\"\"\\n        two-pointer trick\\n        \"\"\"\\n        players.sort()\\n        trainers.sort()\\n        m, n = len(players), len(trainers)\\n        i = j = 0\\n        res = 0\\n        while i < m and j < n:\\n            if players[i] <= trainers[j]:\\n                res += 1\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n        return res\\n    \\n    \\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        \"\"\"\\n        min heap ADT\\n        \"\"\"\\n        heapq.heapify(players)\\n        heapq.heapify(trainers)\\n        res = 0\\n        while players and trainers:\\n            if players[0] <= trainers[0]:\\n                res += 1\\n                heapq.heappop(players)\\n                heapq.heappop(trainers)\\n            else:\\n                heapq.heappop(trainers)\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2623867,
                "title": "c-solution-sorting-fastest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n        int idx1=0;\\n        int idx2=0;\\n        int ans=0;\\n        while(idx2<t.size() and idx1<p.size())\\n        {\\n            if(t[idx2]>=p[idx1])\\n            {\\n                ans++;\\n                idx2++;\\n                idx1++;\\n            }\\n            else if(t[idx2]<p[idx1])\\n            {\\n                idx2++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n        int idx1=0;\\n        int idx2=0;\\n        int ans=0;\\n        while(idx2<t.size() and idx1<p.size())\\n        {\\n            if(t[idx2]>=p[idx1])\\n            {\\n                ans++;\\n                idx2++;\\n                idx1++;\\n            }\\n            else if(t[idx2]<p[idx1])\\n            {\\n                idx2++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614264,
                "title": "c-binary-search-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int ma=-1,ans=0;\\n        for(int i=0;i<players.size();i++){\\n            auto it=lower_bound(trainers.begin()+ma+1,trainers.end(),players[i]); //started with ma because every trainer can be assigned to only one player\\n            if(it!=trainers.end()){\\n                ans++;\\n                ma=it-trainers.begin();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int ma=-1,ans=0;\\n        for(int i=0;i<players.size();i++){\\n            auto it=lower_bound(trainers.begin()+ma+1,trainers.end(),players[i]); //started with ma because every trainer can be assigned to only one player\\n            if(it!=trainers.end()){\\n                ans++;\\n                ma=it-trainers.begin();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609589,
                "title": "two-pointers-gready-python",
                "content": "## Tc  -> O(n log n ) for sorting\\n## Sc -> O(1)\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        one = 0\\n        two = 0\\n        ans = 0\\n        while one < len(players) and two < len(trainers):\\n            if players[one] <= trainers[two]:\\n                one +=1\\n                two +=1\\n                ans +=1\\n            else:\\n                two +=1\\n        return ans\\n```\\n\\n\\t# \\uD83D\\uDE02 Random Dev Meme\\n<img src=\"https://random-memer.herokuapp.com/\" width=\"512px\"/>",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        one = 0\\n        two = 0\\n        ans = 0\\n        while one < len(players) and two < len(trainers):\\n            if players[one] <= trainers[two]:\\n                one +=1\\n                two +=1\\n                ans +=1\\n            else:\\n                two +=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602499,
                "title": "java-solution-easy-understandable",
                "content": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        \\n        int count = 0;\\n        int last = 0;\\n        for(int i = 0 ; i < players.length ; i++){\\n            for(int j = last ; j < trainers.length ; j++){\\n                if(players[i]<=trainers[j]){\\n                    count++;\\n                    last = j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        \\n        int count = 0;\\n        int last = 0;\\n        for(int i = 0 ; i < players.length ; i++){\\n            for(int j = last ; j < trainers.length ; j++){\\n                if(players[i]<=trainers[j]){\\n                    count++;\\n                    last = j+1;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598859,
                "title": "c-multiset-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        int n = p.size();\\n        \\n        multiset<int> s;\\n        \\n        for(auto x:t) s.insert(x);\\n        \\n        sort(p.begin(),p.end());\\n        int ans=0;\\n        for(int i=0;i<p.size();i++){\\n            auto it = s.lower_bound(p[i]);\\n            if(it!=s.end()){\\n                ans++;\\n                s.erase(it);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        int n = p.size();\\n        \\n        multiset<int> s;\\n        \\n        for(auto x:t) s.insert(x);\\n        \\n        sort(p.begin(),p.end());\\n        int ans=0;\\n        for(int i=0;i<p.size();i++){\\n            auto it = s.lower_bound(p[i]);\\n            if(it!=s.end()){\\n                ans++;\\n                s.erase(it);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597752,
                "title": "100-faster-runtime-and-memory-easy-understandable",
                "content": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()        \\n        i,j,ans = 0, 0, 0\\n        \\n        while i < len(players) and j < len(trainers):\\n            while j < len(trainers) and trainers[j] < players[i]:\\n                j += 1\\n            \\n            if j != len(trainers):\\n                ans += 1\\n                i += 1\\n                j += 1\\n        \\n        return ans\\n```\\n![image](https://assets.leetcode.com/users/images/2372a594-f05a-4d94-81dc-fddf29409a17_1663602822.0969987.png)\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()        \\n        i,j,ans = 0, 0, 0\\n        \\n        while i < len(players) and j < len(trainers):\\n            while j < len(trainers) and trainers[j] < players[i]:\\n                j += 1\\n            \\n            if j != len(trainers):\\n                ans += 1\\n                i += 1\\n                j += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596997,
                "title": "java-solution",
                "content": "\\'\\'\\'\\nimport java.util.*;\\nimport java.util.*;\\n\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(trainers);\\n        Arrays.sort(players);\\n        int count = 0;\\n        int j = trainers.length - 1;\\n        for (int i = players.length - 1; i >= 0; i--) {\\n            if (j >= 0 && trainers[j] >= players[i]) {\\n                count++;\\n                j--;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(trainers);\\n        Arrays.sort(players);\\n        int count = 0;\\n        int j = trainers.length - 1;\\n        for (int i = players.length - 1; i >= 0; i--) {\\n            if (j >= 0 && trainers[j] >= players[i]) {\\n                count++;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2595113,
                "title": "java-sorting",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int res = 0;\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        \\n        int t = trainers.length - 1;\\n        int p = players.length - 1;\\n        while(t >= 0 && p >= 0) {\\n            if(players[p] > trainers[t]) {\\n                p--;\\n            } else {\\n                res++;\\n                p--;\\n                t--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int res = 0;\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        \\n        int t = trainers.length - 1;\\n        int p = players.length - 1;\\n        while(t >= 0 && p >= 0) {\\n            if(players[p] > trainers[t]) {\\n                p--;\\n            } else {\\n                res++;\\n                p--;\\n                t--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591978,
                "title": "java-solution-two-pointers-sorting",
                "content": "```java \\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i,j,pairs;\\n        i=j=pairs=0;\\n        while(i<players.length&&j<trainers.length)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                i++;\\n                j++;\\n                pairs++;\\n            }\\n            else if(players[i]>trainers[i])\\n            {\\n                j++;\\n            }\\n        }\\n        return pairs;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i,j,pairs;\\n        i=j=pairs=0;\\n        while(i<players.length&&j<trainers.length)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                i++;\\n                j++;\\n                pairs++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2591966,
                "title": "python3-greedy-two-pointers-solution-beats-100",
                "content": "![image](https://assets.leetcode.com/users/images/8d22ac22-0037-495f-89c7-e308d54ed4de_1663490515.0716884.png)\\n\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        res = 0\\n        i, j = 0, 0\\n        while i < len(players) and j < len(trainers):\\n            if players[i] <= trainers[j]:\\n                res += 1\\n                i += 1\\n            j += 1\\n        return res\\n```\\n\\n- Sort players and trainers\\n- Use two pointers i and j to scan players and trainers\\n- We scan both in ascending order because we want to match them greedily",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        res = 0\\n        i, j = 0, 0\\n        while i < len(players) and j < len(trainers):\\n            if players[i] <= trainers[j]:\\n                res += 1\\n                i += 1\\n            j += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591290,
                "title": "extremely-simple-implementation-python3-faster-than-100-solutions",
                "content": "```py\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], t: List[int]) -> int:\\n        \\n        c = j = i = 0\\n        players.sort()\\n        t.sort()\\n        while i <= len(players) - 1 and j <= len(t) - 1:\\n                if players[i] <= t[j]:\\n                    \\n                    c += 1\\n                    i += 1\\n                j += 1\\n         return c\\n```\\nThe solution is pretty self explanatory. But if still anyone have any doubt feel free to comment below.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], t: List[int]) -> int:\\n        \\n        c = j = i = 0\\n        players.sort()\\n        t.sort()\\n        while i <= len(players) - 1 and j <= len(t) - 1:\\n                if players[i] <= t[j]:\\n                    \\n                    c += 1\\n                    i += 1\\n                j += 1\\n         return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589536,
                "title": "c-sort-two-pointer",
                "content": "```\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(begin(p),end(p));\\n        sort(begin(t),end(t));\\n        int i=0,j=0;\\n        int ans=0;\\n        while(i<p.size()&&j<t.size())\\n        {\\n            if(p[i]<=t[j])\\n            {\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(begin(p),end(p));\\n        sort(begin(t),end(t));\\n        int i=0,j=0;\\n        int ans=0;\\n        while(i<p.size()&&j<t.size())\\n        {\\n            if(p[i]<=t[j])\\n            {\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588937,
                "title": "java-simple-recursion-beginner-friendly-greedy-approach",
                "content": "\\n\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        return match(players, trainers, 0, 0);\\n    }\\n\\n    private int match(int[] players, int[] trainers, int idx1, int idx2) {\\n        if (idx1 == players.length || idx2 == trainers.length)\\n            return 0; // Return 0 as we cannot match further\\n\\n        int res = 0;\\n        if (players[idx1] <= trainers[idx2])\\n                                                                     // Add 1 as the match condition is satisfied and\\n            res += match(players, trainers, idx1 + 1, idx2 + 1) + 1; // we make a call to the next player and trainer as\\n                                                                     // they both are matched and cannot be used further\\n        else\\n            res += match(players, trainers, idx1, idx2 + 1); // Make a call to the next trainer until the current player\\n                                                             // is matched\\n\\n        return res;\\n    }\\n\\n    // Time Complexity: O(nlogn)\\n    // Space: O(1) (if recursion stack space is ignored)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "\\n\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        return match(players, trainers, 0, 0);\\n    }\\n\\n    private int match(int[] players, int[] trainers, int idx1, int idx2) {\\n        if (idx1 == players.length || idx2 == trainers.length)\\n            return 0; // Return 0 as we cannot match further\\n\\n        int res = 0;\\n        if (players[idx1] <= trainers[idx2])\\n                                                                     // Add 1 as the match condition is satisfied and\\n            res += match(players, trainers, idx1 + 1, idx2 + 1) + 1; // we make a call to the next player and trainer as\\n                                                                     // they both are matched and cannot be used further\\n        else\\n            res += match(players, trainers, idx1, idx2 + 1); // Make a call to the next trainer until the current player\\n                                                             // is matched\\n\\n        return res;\\n    }\\n\\n    // Time Complexity: O(nlogn)\\n    // Space: O(1) (if recursion stack space is ignored)",
                "codeTag": "Unknown"
            },
            {
                "id": 2588818,
                "title": "c-two-pointers-easy-understanding-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n     sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        \\n      \\n        \\n        int count=0;\\n        int n=players.size();\\n        int m=trainers.size();\\n        int i=0,j=0;\\n        while(i<n and j<m)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n     sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        \\n      \\n        \\n        int count=0;\\n        int n=players.size();\\n        int m=trainers.size();\\n        int i=0,j=0;\\n        while(i<n and j<m)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588810,
                "title": "java-sort-binary-search-optimized-solution",
                "content": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players) ;\\n        Arrays.sort(trainers) ;\\n        \\n        int result = 0 ;\\n        int low = 0, high = trainers.length-1 ;\\n        \\n        for (int p : players) {\\n            low = binarySearch(trainers, p, low, high) ;\\n            if (low > high) return result ;\\n            result++ ;\\n            low++ ;\\n        }\\n        \\n        return result ;\\n    }\\n    \\n    private int binarySearch(int[] trainers, int p, int low, int high) {\\n        while (low <= high) {\\n            int mid = low + (high-low)/2 ;\\n            \\n            if (trainers[mid] < p) low = mid+1 ;\\n            else high = mid-1 ;\\n        }\\n        \\n        return low ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players) ;\\n        Arrays.sort(trainers) ;\\n        \\n        int result = 0 ;\\n        int low = 0, high = trainers.length-1 ;\\n        \\n        for (int p : players) {\\n            low = binarySearch(trainers, p, low, high) ;\\n            if (low > high) return result ;\\n            result++ ;\\n            low++ ;\\n        }\\n        \\n        return result ;\\n    }\\n    \\n    private int binarySearch(int[] trainers, int p, int low, int high) {\\n        while (low <= high) {\\n            int mid = low + (high-low)/2 ;\\n            \\n            if (trainers[mid] < p) low = mid+1 ;\\n            else high = mid-1 ;\\n        }\\n        \\n        return low ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588689,
                "title": "python-easy-way",
                "content": "\\tclass Solution:\\n\\t\\tdef matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n\\t\\t\\tplayers = sorted(players)\\n\\t\\t\\ttrainers = sorted(trainers)\\n\\t\\t\\tmat1= len(players) - 1\\n\\t\\t\\tmat2= len(trainers) - 1\\n\\t\\t\\tresult = 0\\n\\t\\t\\twhile mat1>=0 and mat2>=0:\\n\\t\\t\\t\\tif players[mat1] <= trainers[mat2]:\\n\\t\\t\\t\\t\\tmat2 -= 1\\n\\t\\t\\t\\t\\tresult += 1\\n\\t\\t\\t\\tmat1-= 1\\n\\t\\t\\treturn result\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n\\t\\t\\tplayers = sorted(players)\\n\\t\\t\\ttrainers = sorted(trainers)\\n\\t\\t\\tmat1= len(players) - 1\\n\\t\\t\\tmat2= len(trainers) - 1\\n\\t\\t\\tresult = 0\\n\\t\\t\\twhile mat1>=0 and mat2>=0:\\n\\t\\t\\t\\tif players[mat1] <= trainers[mat2]:\\n\\t\\t\\t\\t\\tmat2 -= 1\\n\\t\\t\\t\\t\\tresult += 1\\n\\t\\t\\t\\tmat1-= 1\\n\\t\\t\\treturn result\\n",
                "codeTag": "Java"
            },
            {
                "id": 2588672,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        \\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        \\n        int tlength = trainers.length - 1;\\n        int plength = players.length - 1;\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        \\n        \\n        while(i <= plength && j <= tlength)\\n        {\\n            \\n            if(players[i] <= trainers[j] )\\n            {\\n                count++;\\n                i++;\\n                \\n            }\\n            j++;\\n            \\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        \\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        \\n        int tlength = trainers.length - 1;\\n        int plength = players.length - 1;\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        \\n        \\n        while(i <= plength && j <= tlength)\\n        {\\n            \\n            if(players[i] <= trainers[j] )\\n            {\\n                count++;\\n                i++;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2588560,
                "title": "easiest-two-pointers-java-solution-leetcode-biweekly-87",
                "content": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i = 0;\\n        int j = 0;\\n        int count =0;\\n        \\n        while(  i < players.length && j < trainers.length){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                count++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i = 0;\\n        int j = 0;\\n        int count =0;\\n        \\n        while(  i < players.length && j < trainers.length){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2588552,
                "title": "two-pointer-java-solution",
                "content": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int playersIndex = 0;\\n        int trainersIndex = 0;\\n        int count = 0;\\n        while (playersIndex < players.length && trainersIndex < trainers.length) {\\n            int player = players[playersIndex];\\n            int trainer = trainers[trainersIndex];\\n            if (player <= trainer) {\\n                count++;\\n                playersIndex++;\\n                trainersIndex++;\\n                continue;\\n            } else {\\n                trainersIndex++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int playersIndex = 0;\\n        int trainersIndex = 0;\\n        int count = 0;\\n        while (playersIndex < players.length && trainersIndex < trainers.length) {\\n            int player = players[playersIndex];\\n            int trainer = trainers[trainersIndex];\\n            if (player <= trainer) {\\n                count++;\\n                playersIndex++;\\n                trainersIndex++;\\n                continue;\\n            } else {\\n                trainersIndex++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588507,
                "title": "priority-queue-easy-to-understand-c-approach",
                "content": "class Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        priority_queue<int>st1;\\n        priority_queue<int>st2;\\n        for(int i=0;i<players.size();i++)\\n        {\\n            st1.push(players[i]);\\n        }\\n           for(int i=0;i<trainers.size();i++)\\n        {\\n            st2.push(trainers[i]);\\n        }\\n        \\n        int ans=0;\\n        while(1)\\n        {\\n        \\n            if(st2.empty()||st1.empty())\\n            {\\n            break;\\n            }\\n           if(st1.top()>st2.top())\\n           {\\n               st1.pop();\\n           }\\n            else if(st1.top()<=st2.top())\\n            {\\n                ans++;\\n                st1.pop();\\n                st2.pop();\\n            }\\n        }    \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        priority_queue<int>st1;\\n        priority_queue<int>st2;\\n        for(int i=0;i<players.size();i++)\\n        {\\n            st1.push(players[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2588450,
                "title": "python-code-using-recursion",
                "content": "We sort both the arrays and move index i for players and j for trainers respectively\\nif players[i]<=trainers[j] we move forward by counting it\\nelse we check for the next trainer if he can train the current player.\\n\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        n = len(players)\\n        m = len(trainers)\\n        players.sort()\\n        trainers.sort()\\n        dp = {}\\n        def helper(i,j):\\n            if i==n or j==m:\\n                return 0\\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n            if players[i]<=trainers[j]:\\n                dp[(i,j)] = 1+helper(i+1,j+1)\\n            else:\\n                dp[(i,j)] = helper(i,j+1)\\n            return dp[(i,j)]\\n        return helper(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        n = len(players)\\n        m = len(trainers)\\n        players.sort()\\n        trainers.sort()\\n        dp = {}\\n        def helper(i,j):\\n            if i==n or j==m:\\n                return 0\\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n            if players[i]<=trainers[j]:\\n                dp[(i,j)] = 1+helper(i+1,j+1)\\n            else:\\n                dp[(i,j)] = helper(i,j+1)\\n            return dp[(i,j)]\\n        return helper(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588435,
                "title": "c-solution-easy-concise-two-pointer-reverse-sort-o-nlog-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int cnt=0,j=0,n=players.size();\\n        sort(begin(players),end(players),greater<int>());\\n        sort(begin(trainers),end(trainers),greater<int>());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(trainers[j]>=players[i])\\n            {\\n                j++;\\n                cnt++;\\n                if(j==trainers.size()) //if trainer end then break\\n                    break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nPlease Upvote if you found this helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int cnt=0,j=0,n=players.size();\\n        sort(begin(players),end(players),greater<int>());\\n        sort(begin(trainers),end(trainers),greater<int>());\\n        for(int i=0;i<n;i++)\\n        {\\n            if(trainers[j]>=players[i])\\n            {\\n                j++;\\n                cnt++;\\n                if(j==trainers.size()) //if trainer end then break\\n                    break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588385,
                "title": "c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n       sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int n = players.size(),m = trainers.size();\\n        int i = 0,j = 0;\\n        int ans = 0;\\n        while(i<n and j<m){\\n             if(players[i]<=trainers[j]){\\n                 ++i,++j;\\n                 ++ans;\\n             }else if(trainers[j] < players[i]){\\n                 ++j;\\n             }else break;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n       sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int n = players.size(),m = trainers.size();\\n        int i = 0,j = 0;\\n        int ans = 0;\\n        while(i<n and j<m){\\n             if(players[i]<=trainers[j]){\\n                 ++i,++j;\\n                 ++ans;\\n             }else if(trainers[j] < players[i]){\\n                 ++j;\\n             }else break;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588311,
                "title": "java-two-approaches-brute-force-optimal-greedy-properly-commented",
                "content": "### ***Please Upvote !!!***\\n##### 1. Brute force approach (very bad):\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        // We create an arraylist for trainers so that we can remove elements from it\\n        List<Integer> tList = new ArrayList<>();\\n        for (int i : trainers) tList.add(i);       // adding the elements from trainers[]\\n\\n        int matchCount = 0;\\n\\n        for (int i = 0; i < players.length; i++) {\\n            for (int j = 0; j < tList.size(); j++) {\\n                if (players[i] <= tList.get(j)) {   // If yes, we get a match\\n                    matchCount++;\\n                    tList.remove(j);                // We remove that element because it can\\'t be used more than once\\n                    break;                          // We break out because a match has been found and we don\\'t want to look further in tList\\n                }\\n            }\\n        }\\n\\n        return matchCount;\\n    }\\n}\\n\\n// TC: O(n*logn + m*logm) + O(m) + O(m * n)\\n// SC: O(m)\\n```\\nWe could use the same given trainers array and when an element forms a match we could simply put a 0 or -1 in that place so that when we encounter 0 or -1 we would simply skip it. But it gives a TLE.\\nBut if we use an arraylist, we remove the element after it forms a match, therefore its length decreases and the inner for loop has to run lesser and lesser in worst case after every match is found. Therefore we don\\'t hit a TLE.\\n\\nThat\\'s my interpretation, ya\\'ll are welcome to put your thinking.\\n\\n##### 2. Greedy approach:\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int i = 0, j = 0, matchCount = 0;\\n\\n        while (i < players.length && j < trainers.length) {\\n\\n            if (players[i] <= trainers[j]) {    // If yes, we get a match, we move to next index in both arrays\\n                matchCount++;                   // because the current indices has been used and can\\'t be used again\\n                i++; j++;\\n            }\\n            else j++;                           // If not a match, we check if next element in trainers[] makes a match\\n        }\\n\\n        return matchCount;\\n    }\\n}\\n\\n// TC: O(n*logn + m*logn) + O(m + n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        // We create an arraylist for trainers so that we can remove elements from it\\n        List<Integer> tList = new ArrayList<>();\\n        for (int i : trainers) tList.add(i);       // adding the elements from trainers[]\\n\\n        int matchCount = 0;\\n\\n        for (int i = 0; i < players.length; i++) {\\n            for (int j = 0; j < tList.size(); j++) {\\n                if (players[i] <= tList.get(j)) {   // If yes, we get a match\\n                    matchCount++;\\n                    tList.remove(j);                // We remove that element because it can\\'t be used more than once\\n                    break;                          // We break out because a match has been found and we don\\'t want to look further in tList\\n                }\\n            }\\n        }\\n\\n        return matchCount;\\n    }\\n}\\n\\n// TC: O(n*logn + m*logm) + O(m) + O(m * n)\\n// SC: O(m)\\n```\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int i = 0, j = 0, matchCount = 0;\\n\\n        while (i < players.length && j < trainers.length) {\\n\\n            if (players[i] <= trainers[j]) {    // If yes, we get a match, we move to next index in both arrays\\n                matchCount++;                   // because the current indices has been used and can\\'t be used again\\n                i++; j++;\\n            }\\n            else j++;                           // If not a match, we check if next element in trainers[] makes a match\\n        }\\n\\n        return matchCount;\\n    }\\n}\\n\\n// TC: O(n*logn + m*logn) + O(m + n)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588310,
                "title": "c-sort-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.rbegin(),players.rend());\\n        sort(trainers.rbegin(),trainers.rend());\\n        int j=0, i=0, cnt=0;\\n        while(i<players.size() and j<trainers.size()){\\n            if(players[i]>trainers[j]){\\n                i++;\\n                continue;\\n            }\\n            i++,j++;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.rbegin(),players.rend());\\n        sort(trainers.rbegin(),trainers.rend());\\n        int j=0, i=0, cnt=0;\\n        while(i<players.size() and j<trainers.size()){\\n            if(players[i]>trainers[j]){\\n                i++;\\n                continue;\\n            }\\n            i++,j++;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588091,
                "title": "java-two-pointer-easy",
                "content": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] p, int[] t) {\\n        int count=0;\\n        Arrays.sort(p);\\n        Arrays.sort(t);\\n        \\n        int rt=t.length-1, rp=p.length-1;\\n        while(rt>=0 && rp>=0)\\n        {\\n            if(t[rt]>= p[rp])\\n            {\\n                count++;\\n                rt--;\\n            }\\n             rp--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] p, int[] t) {\\n        int count=0;\\n        Arrays.sort(p);\\n        Arrays.sort(t);\\n        \\n        int rt=t.length-1, rp=p.length-1;\\n        while(rt>=0 && rp>=0)\\n        {\\n            if(t[rt]>= p[rp])\\n            {\\n                count++;\\n                rt--;\\n            }\\n             rp--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588082,
                "title": "greedy-approach",
                "content": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int count = 0, i = 0, j = 0;\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        while(i < players.length && j < trainers.length){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                count++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int count = 0, i = 0, j = 0;\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        while(i < players.length && j < trainers.length){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                count++;\\n            }else{\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587928,
                "title": "maximum-matching-of-players-with-trainers",
                "content": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int res = 0;\\n        int pl = players.length;\\n        int tl = trainers.length;\\n        \\n        int i = pl-1, j = tl-1;\\n        while(i>=0 && j>=0){\\n            if(players[i]>trainers[j]){\\n                i--;\\n            }\\n            else{\\n                i--;\\n                j--;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int res = 0;\\n        int pl = players.length;\\n        int tl = trainers.length;\\n        \\n        int i = pl-1, j = tl-1;\\n        while(i>=0 && j>=0){\\n            if(players[i]>trainers[j]){\\n                i--;\\n            }\\n            else{\\n                i--;\\n                j--;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587904,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(), p.end());\\n        sort(t.begin(), t.end());\\n        \\n        int i = 0, j = 0, ans = 0;\\n        \\n        while(i < p.size() && j < t.size()) {\\n            if(p[i] <= t[j]) ans++, i++, j++;\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(), p.end());\\n        sort(t.begin(), t.end());\\n        \\n        int i = 0, j = 0, ans = 0;\\n        \\n        while(i < p.size() && j < t.size()) {\\n            if(p[i] <= t[j]) ans++, i++, j++;\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587890,
                "title": "java-easy-bruteforce-two-pointer-greedy",
                "content": "```\\nclass Solution {\\n\\n    public int matchPlayersAndTrainers(int[] p, int[] t) {\\n        Arrays.sort(p);\\n        Arrays.sort(t);\\n        int result = 0;\\n        int idx = t.length - 1;\\n        for (int i = p.length - 1; i >= 0; i--) {\\n            if (t[idx] >= p[i]) {\\n                idx--;\\n                result++;\\n            }\\n            if (idx == -1) break;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int matchPlayersAndTrainers(int[] p, int[] t) {\\n        Arrays.sort(p);\\n        Arrays.sort(t);\\n        int result = 0;\\n        int idx = t.length - 1;\\n        for (int i = p.length - 1; i >= 0; i--) {\\n            if (t[idx] >= p[i]) {\\n                idx--;\\n                result++;\\n            }\\n            if (idx == -1) break;\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587879,
                "title": "python3-sort-greedy",
                "content": "**Biweekly Contest 87 Submission**\\n\\n**Sort + Greedy**\\n1. Sort both Players (`P`) and Trainers (`T`) in non-increasing order.\\n2. Iterate while `P` and `T` have elements.\\n3. If there is a player that can match with a trainer then pop both stacks (removing the pair).\\n4. If there is no match only pop `T` (remove that trainer and try the next player until we cannot find a player or we run out of trainers).\\n5. Return the amount of players popped from stack `P`.\\n\\n**Code**\\n```Python3 []\\nclass Solution:\\n    def matchPlayersAndTrainers(self, P: List[int], T: List[int]) -> int:\\n\\t\\t#Sort\\n        P, T = sorted(P, reverse=True), sorted(T, reverse=True)\\n        \\n\\t\\t#Original amount of players\\n        n = len(P)\\n        \\n\\t\\t#Greedy\\n        while T and P:\\n            if P[-1] <= T[-1]: P.pop()\\n            T.pop()\\n                \\n\\t\\t#Amount of players popped\\n        return n - len(P)\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def matchPlayersAndTrainers(self, P: List[int], T: List[int]) -> int:\\n\\t\\t#Sort\\n        P, T = sorted(P, reverse=True), sorted(T, reverse=True)\\n        \\n\\t\\t#Original amount of players\\n        n = len(P)\\n        \\n\\t\\t#Greedy\\n        while T and P:\\n            if P[-1] <= T[-1]: P.pop()\\n            T.pop()\\n                \\n\\t\\t#Amount of players popped\\n        return n - len(P)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087521,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& play, vector<int>& tra) {\\n        sort(play.begin(),play.end());\\n        sort(tra.begin(),tra.end());\\n\\n        int n=play.size();\\n        int m=tra.size();\\n        int i=0,j=0,cnt=0;\\n\\n        while(i<n and j<m){\\n            if(play[i]<=tra[j]){\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& play, vector<int>& tra) {\\n        sort(play.begin(),play.end());\\n        sort(tra.begin(),tra.end());\\n\\n        int n=play.size();\\n        int m=tra.size();\\n        int i=0,j=0,cnt=0;\\n\\n        while(i<n and j<m){\\n            if(play[i]<=tra[j]){\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else j++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079592,
                "title": "easy-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& v1, vector<int>& v2) {\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        int i=0,j=0;\\n        int c=0;\\n        while(i<v1.size() && j<v2.size())\\n        {\\n            if(v1[i]<=v2[j])\\n            {\\n               c++;\\n               i++;\\n               j++;\\n            }\\n            else\\n            j++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& v1, vector<int>& v2) {\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end());\\n        int i=0,j=0;\\n        int c=0;\\n        while(i<v1.size() && j<v2.size())\\n        {\\n            if(v1[i]<=v2[j])\\n            {\\n               c++;\\n               i++;\\n               j++;\\n            }\\n            else\\n            j++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075126,
                "title": "two-pointer-approch-and-optimize-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(trainers);\\n        Arrays.sort(players);\\n\\n        int res=0;\\n        int i=0, j=0;\\n        while(i<players.length && j<trainers.length){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                res++;\\n            } else if(players[i] > trainers[j]){\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(trainers);\\n        Arrays.sort(players);\\n\\n        int res=0;\\n        int i=0, j=0;\\n        while(i<players.length && j<trainers.length){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                res++;\\n            } else if(players[i] > trainers[j]){\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036009,
                "title": "java-simple-sort",
                "content": "\\n\\n# Complexity\\n- Time complexity: Nlog(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        //sort it\\n        Arrays.sort(trainers);\\n        Arrays.sort(players) ;\\n        int res = 0 ,i =0 , j=0 ;\\n        while( i < players.length && j < trainers.length){\\n            if( players[i] <= trainers[j]){\\n                i++;\\n                res++;\\n            }\\n            j++;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        //sort it\\n        Arrays.sort(trainers);\\n        Arrays.sort(players) ;\\n        int res = 0 ,i =0 , j=0 ;\\n        while( i < players.length && j < trainers.length){\\n            if( players[i] <= trainers[j]){\\n                i++;\\n                res++;\\n            }\\n            j++;\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035563,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int c=0;\\n        Arrays.sort(players);\\n         Arrays.sort(trainers);\\n         int a=0;\\n        for(int i=0;i<players.length;i++){\\n            for(int j=a;j<trainers.length;j++){\\n                if(players[i]<=trainers[j]){\\n                    c++;\\n                  a=j+1;\\n                   break;\\n                }\\n            }\\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int c=0;\\n        Arrays.sort(players);\\n         Arrays.sort(trainers);\\n         int a=0;\\n        for(int i=0;i<players.length;i++){\\n            for(int j=a;j<trainers.length;j++){\\n                if(players[i]<=trainers[j]){\\n                    c++;\\n                  a=j+1;\\n                   break;\\n                }\\n            }\\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019211,
                "title": "c-two-pointer-approach-sorting-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intution is, after sorting the trainer and player array, if the ability of a player is greater than a trainer then it might be lesser than some other trainer so we won\\'t skip the player but if the capacity of a trainer is lesser than a student then we can skip the triner\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Steps :**\\n1. Sort the given arrays in ascending order.\\n2. Have 2 pointers and place them on the 0th index of both the arrays.\\n3. Check if the capacity of a trainer is lesser than the ability of the current player then skip the trainer.\\n4. Else elect the trainer for the student and move forward till you exhaust one of the array.\\n\\n# Complexity\\n- Time complexity: O(n*logn) Due to sorting of the arrays.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        int n1 = p.size(), n2 = t.size();\\n\\n        sort(p.begin(), p.end());\\n        sort(t.begin(), t.end());\\n\\n        int i = 0, j = 0;\\n        int ans = 0;\\n        while(i < n1 && j < n2){\\n            if(t[j] >= p[i]){\\n                ans++; i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        int n1 = p.size(), n2 = t.size();\\n\\n        sort(p.begin(), p.end());\\n        sort(t.begin(), t.end());\\n\\n        int i = 0, j = 0;\\n        int ans = 0;\\n        while(i < n1 && j < n2){\\n            if(t[j] >= p[i]){\\n                ans++; i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017880,
                "title": "simple-c-solution-2-pointers-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int i =0;\\n        int j =0;\\n        int count =0;\\n        while(i <= players.size()-1  && j <= trainers.size()-1){\\n            if(players[i] <= trainers[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int i =0;\\n        int j =0;\\n        int count =0;\\n        while(i <= players.size()-1  && j <= trainers.size()-1){\\n            if(players[i] <= trainers[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994416,
                "title": "simple-solution-using-sorting-and-two-pointer",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0,j=0;\\n        while(i<players.size()&&j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0,j=0;\\n        while(i<players.size()&&j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            i++;\\n            j++;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987803,
                "title": "simple-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince order is not important & can take only when tr>=ply so sort and move iteratively. Also using Binary search after sorting won\\'t be beneficial and will add extra time complexity-thus TLE. \\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& ply, vector<int>& tr) {\\n        sort(ply.begin(), ply.end());\\n        sort(tr.begin(), tr.end());\\n\\n        ll cnt=0, i=0, j=0, n=ply.size(), m=tr.size();\\n\\n        //since sorted USE 2 PTR  --\\n        //lower_bound will give TLE: {extra logm of Binary Search}\\n        //auto indx=lower_bound(tr.begin(), tr.end(), ply[i]);\\n     \\n        while(i<n && j<m){\\n            //if trainer potential is less than player\\'s\\n            while(j<m && tr[j] < ply[i])j++;\\n\\n            if(j<m && ply[i]<=tr[j]){\\n                cnt++;\\n                j++;\\n            }\\n            i++;       \\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& ply, vector<int>& tr) {\\n        sort(ply.begin(), ply.end());\\n        sort(tr.begin(), tr.end());\\n\\n        ll cnt=0, i=0, j=0, n=ply.size(), m=tr.size();\\n\\n        //since sorted USE 2 PTR  --\\n        //lower_bound will give TLE: {extra logm of Binary Search}\\n        //auto indx=lower_bound(tr.begin(), tr.end(), ply[i]);\\n     \\n        while(i<n && j<m){\\n            //if trainer potential is less than player\\'s\\n            while(j<m && tr[j] < ply[i])j++;\\n\\n            if(j<m && ply[i]<=tr[j]){\\n                cnt++;\\n                j++;\\n            }\\n            i++;       \\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984623,
                "title": "don-t-make-it-hard-2-pointers-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int i=0;\\n        int j=0;\\n\\n        int m=players.size();\\n        int n = trainers.size();\\n\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int ans = 0;\\n        while(i<m && j<n){\\n            if(players[i] <= trainers[j]){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int i=0;\\n        int j=0;\\n\\n        int m=players.size();\\n        int n = trainers.size();\\n\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int ans = 0;\\n        while(i<m && j<n){\\n            if(players[i] <= trainers[j]){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975923,
                "title": "simple-and-understandable-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int ans =0;\\n        int i=0, j=0;\\n        while(i < players.length && j < trainers.length){\\n            if(players[i] <= trainers[j]){\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int ans =0;\\n        int i=0, j=0;\\n        while(i < players.length && j < trainers.length){\\n            if(players[i] <= trainers[j]){\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973137,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(trainers);\\n        Arrays.sort(players);\\n        int count = 0;\\n        int i = 0, j = 0;\\n        while(i < players.length && j < trainers.length){\\n            if(trainers[j] >= players[i]){\\n                i++;\\n                j++;\\n                count++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(trainers);\\n        Arrays.sort(players);\\n        int count = 0;\\n        int i = 0, j = 0;\\n        while(i < players.length && j < trainers.length){\\n            if(trainers[j] >= players[i]){\\n                i++;\\n                j++;\\n                count++;\\n            } else {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972389,
                "title": "python-2-pointers-o-nlogn-with-explanation",
                "content": "# Intuition\\nIterate through the lists using two pointers with a single pass\\n\\n# Approach\\nGo through each of the lists. It is important that the list is sorted first because we want to be greedy and pair each player with a trainer whenever possible.\\n\\nWhenever we pair each player and trainer, we increase the pointers `t` and `p` with the result. Because we want to match as many players as possible, whenever `player[p] > trainer[t]` we will increment the pointer for the trainer to try and match the next possible trainer.\\n\\n# Complexity\\n- Time complexity:\\nSort: $$O(nLogN)$$\\nSingle pass: $$O(n)$$\\nOverall: $$O(nLogN)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        trainers.sort()\\n        players.sort()\\n\\n        t, p, res = 0, 0, 0\\n\\n        while p < len(players) and t < len(trainers):\\n            if players[p] <= trainers[t]:\\n                p += 1\\n                t += 1\\n                res += 1\\n            \\n            elif players[p] > trainers[t]:\\n                t += 1\\n        \\n        return res\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        trainers.sort()\\n        players.sort()\\n\\n        t, p, res = 0, 0, 0\\n\\n        while p < len(players) and t < len(trainers):\\n            if players[p] <= trainers[t]:\\n                p += 1\\n                t += 1\\n                res += 1\\n            \\n            elif players[p] > trainers[t]:\\n                t += 1\\n        \\n        return res\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951265,
                "title": "explained-in-comments-n-log-n-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// see this solution first -> https://leetcode.com/problems/maximize-greatness-of-an-array/solutions/3951192/explained-in-comments-sorting-7-to-10-line-code-c/\\n\\n\\n\\n        // so what we will do here is, we will go till the end of trainers array, because we need to exhaust trainers first\\n        // since we have sorted both the arrays\\n        // and we need trainers[i] >= players[j]\\n        // so, we will take the first trainers element and compare it with the first element of the players array\\n        // case 1 -> if its the trainers capacity is less than players then we wont do anything, since the for loop will itself take us to the next trainers element, and since its sorted, we are making an increment in the trainers capacity\\n        // case 2 -> if its the trainers capacity is more than or equal to the players capacity then we increase the count and move to the next player\\n        // and since we have the players array sorted as well, we are moving to the next big player\\n        // reapeat ( for loop )\\n\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n        // sort both the arrays first\\n        sort(players.begin(), players.end() );\\n        sort(trainers.begin(), trainers.end() );\\n\\n        int s = 0; // iterator for players array\\n        int count = 0;\\n\\n        for( int i = 0; i<trainers.size(); i++ ){\\n            if( s < players.size() ){\\n                if ( trainers[i] >= players[s] ) {\\n                    count++;\\n                    s++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// see this solution first -> https://leetcode.com/problems/maximize-greatness-of-an-array/solutions/3951192/explained-in-comments-sorting-7-to-10-line-code-c/\\n\\n\\n\\n        // so what we will do here is, we will go till the end of trainers array, because we need to exhaust trainers first\\n        // since we have sorted both the arrays\\n        // and we need trainers[i] >= players[j]\\n        // so, we will take the first trainers element and compare it with the first element of the players array\\n        // case 1 -> if its the trainers capacity is less than players then we wont do anything, since the for loop will itself take us to the next trainers element, and since its sorted, we are making an increment in the trainers capacity\\n        // case 2 -> if its the trainers capacity is more than or equal to the players capacity then we increase the count and move to the next player\\n        // and since we have the players array sorted as well, we are moving to the next big player\\n        // reapeat ( for loop )\\n\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n        // sort both the arrays first\\n        sort(players.begin(), players.end() );\\n        sort(trainers.begin(), trainers.end() );\\n\\n        int s = 0; // iterator for players array\\n        int count = 0;\\n\\n        for( int i = 0; i<trainers.size(); i++ ){\\n            if( s < players.size() ){\\n                if ( trainers[i] >= players[s] ) {\\n                    count++;\\n                    s++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950710,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n            Arrays.sort(trainers);\\n            Arrays.sort(players);\\n            int matching=0;\\n            int countedUntil=0;\\n            outer:for(int i=0;i<players.length;i++)\\n            {\\n            \\n                if(countedUntil>trainers.length)\\n                break outer;\\n               inner: for (int j=countedUntil;j<trainers.length;j++)\\n                {\\n                    if(players[i]<=trainers[j])\\n                    {\\n                    matching+=1;\\n                    countedUntil=j+1;\\n                        break inner;\\n                    }\\n\\n                }\\n            }\\n            return matching;\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n            Arrays.sort(trainers);\\n            Arrays.sort(players);\\n            int matching=0;\\n            int countedUntil=0;\\n            outer:for(int i=0;i<players.length;i++)\\n            {\\n            \\n                if(countedUntil>trainers.length)\\n                break outer;\\n               inner: for (int j=countedUntil;j<trainers.length;j++)\\n                {\\n                    if(players[i]<=trainers[j])\\n                    {\\n                    matching+=1;\\n                    countedUntil=j+1;\\n                        break inner;\\n                    }\\n\\n                }\\n            }\\n            return matching;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944441,
                "title": "detailed-explanation-2-approaches-greedy-heap-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 arrays and maximum score possible? That sounds like DP. But looking at the constraints, we would get a TLE. Okay, what\\'s the other way that we can look at it? Maybe we could check if the smallest player can pair up with the smallest trainer. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use two min heaps to store the players and trainers. \\nNext, we will compare the top elements of the two heaps. \\nIf the top element of the players heap is greater than the top element of the trainers heap, then we no longer have any use for the trainer\\'s top element, and so we will pop it, and check for the next trainer\\'s element in the heap.\\nHowever, if we find that the top element of the players heap is <= the top element of the trainers heap, that means that they can pair up with each other, and so we will add 1 to our result, and pop both these elements, and continue our search.\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        priority_queue<int, vector<int>, greater<int>> minply, mintrn;\\n        for(auto it : players){\\n            minply.push(it);\\n        }\\n        for(auto it : trainers){\\n            mintrn.push(it);\\n        }\\n        int count = 0;\\n        while(minply.size()>0 && mintrn.size()>0){\\n            int plytop = minply.top();\\n            int trntop = mintrn.top();\\n            if(plytop>trntop){\\n                mintrn.pop();\\n            }\\n            else{\\n                count++;\\n                minply.pop();\\n                mintrn.pop();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n**DP Approach (Will give TLE)**\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> dp;\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        dp.resize(players.size(), vector<int>(trainers.size(), -1));\\n        return rec(0, 0, players, trainers);\\n    }\\n    int rec(int i, int j, vector<int>& players, vector<int>& trainers){\\n        //base case\\n        if(i>=players.size() || j>=trainers.size()) return 0;\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int ans =0;\\n        if(players[i]<=trainers[j]){\\n            ans = 1 + rec(i+1, j+1, players, trainers);\\n            ans = max(ans, rec(i+1, j, players, trainers));\\n            ans = max(ans, rec(i, j+1, players, trainers));\\n        }\\n        else{\\n            ans = rec(i, j+1, players, trainers);\\n            ans = max(ans, rec(i+1, j, players, trainers));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        priority_queue<int, vector<int>, greater<int>> minply, mintrn;\\n        for(auto it : players){\\n            minply.push(it);\\n        }\\n        for(auto it : trainers){\\n            mintrn.push(it);\\n        }\\n        int count = 0;\\n        while(minply.size()>0 && mintrn.size()>0){\\n            int plytop = minply.top();\\n            int trntop = mintrn.top();\\n            if(plytop>trntop){\\n                mintrn.pop();\\n            }\\n            else{\\n                count++;\\n                minply.pop();\\n                mintrn.pop();\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> dp;\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        dp.resize(players.size(), vector<int>(trainers.size(), -1));\\n        return rec(0, 0, players, trainers);\\n    }\\n    int rec(int i, int j, vector<int>& players, vector<int>& trainers){\\n        //base case\\n        if(i>=players.size() || j>=trainers.size()) return 0;\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int ans =0;\\n        if(players[i]<=trainers[j]){\\n            ans = 1 + rec(i+1, j+1, players, trainers);\\n            ans = max(ans, rec(i+1, j, players, trainers));\\n            ans = max(ans, rec(i, j+1, players, trainers));\\n        }\\n        else{\\n            ans = rec(i, j+1, players, trainers);\\n            ans = max(ans, rec(i+1, j, players, trainers));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939904,
                "title": "simple-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& pl, vector<int>& tr) {\\n        sort(tr.begin(),tr.end());\\n        sort(pl.begin(),pl.end());\\n        int sz1=pl.size(),sz2=tr.size();\\n        int i=0,j=0;\\n        while(i<sz1 and j<sz2)\\n          {\\n              if(pl[i]<=tr[j])\\n                {\\n                    i++;\\n                    j++;\\n                }\\n                else\\n                  j++;\\n          }\\n          return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& pl, vector<int>& tr) {\\n        sort(tr.begin(),tr.end());\\n        sort(pl.begin(),pl.end());\\n        int sz1=pl.size(),sz2=tr.size();\\n        int i=0,j=0;\\n        while(i<sz1 and j<sz2)\\n          {\\n              if(pl[i]<=tr[j])\\n                {\\n                    i++;\\n                    j++;\\n                }\\n                else\\n                  j++;\\n          }\\n          return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921962,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    {\\n        int i,j,ans;\\n        i=0;\\n        j=0;\\n        ans=0;\\n\\n        sort(players.begin(),players.end());        \\n        sort(trainers.begin(),trainers.end());\\n\\n        while(i<players.size() && j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                i++;\\n                j++;\\n                ans++;\\n            }\\n\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    {\\n        int i,j,ans;\\n        i=0;\\n        j=0;\\n        ans=0;\\n\\n        sort(players.begin(),players.end());        \\n        sort(trainers.begin(),trainers.end());\\n\\n        while(i<players.size() && j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                i++;\\n                j++;\\n                ans++;\\n            }\\n\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905202,
                "title": "easiest-way-sorting-techniques",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int n=players.size();\\n        int m=trainers.size();\\n        int j=0,c=0,i=0;\\n        while(i<n && j<m){\\n            if(players[i]<=trainers[j]){\\n                c++;\\n                i++;\\n                j++;\\n            }\\n            else if(players[i]>trainers[j]){\\n                j++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int n=players.size();\\n        int m=trainers.size();\\n        int j=0,c=0,i=0;\\n        while(i<n && j<m){\\n            if(players[i]<=trainers[j]){\\n                c++;\\n                i++;\\n                j++;\\n            }\\n            else if(players[i]>trainers[j]){\\n                j++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894298,
                "title": "the-easiest-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n\\n        int count=0,i=0,j=0; \\n        while(i<players.size() and j<trainers.size()){\\n            if(players[i]<=trainers[j]){ // if condition is satisfied, move on to next trainer and player\\n                ++i; ++j;\\n                ++count;\\n            }else{\\n                j++; // if condition is not satisfied, check for next trainer\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n\\n        int count=0,i=0,j=0; \\n        while(i<players.size() and j<trainers.size()){\\n            if(players[i]<=trainers[j]){ // if condition is satisfied, move on to next trainer and player\\n                ++i; ++j;\\n                ++count;\\n            }else{\\n                j++; // if condition is not satisfied, check for next trainer\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881414,
                "title": "java-one-traversal-100-beat-execution-time",
                "content": "# Intuition\\nPlayers who is having less or equal strength can match to a trainer, not the ones having more strength\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int i = players.length-1; \\n        int j = trainers.length-1;\\n        int pair = 0;\\n        while (i>=0 && j>=0) {\\n            while (i>=0 && players[i] > trainers[j]) {\\n                i--;\\n            }\\n            if (i>=0 && players[i] <= trainers[j]) {\\n                pair++;\\n                i--;\\n                j--;\\n            }\\n        }\\n        return pair;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int i = players.length-1; \\n        int j = trainers.length-1;\\n        int pair = 0;\\n        while (i>=0 && j>=0) {\\n            while (i>=0 && players[i] > trainers[j]) {\\n                i--;\\n            }\\n            if (i>=0 && players[i] <= trainers[j]) {\\n                pair++;\\n                i--;\\n                j--;\\n            }\\n        }\\n        return pair;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877006,
                "title": "swift-2410-maximum-matching-of-players-with-trainers",
                "content": "```\\nclass Solution {\\n    func matchPlayersAndTrainers(_ players: [Int], _ trainers: [Int]) -> Int {\\n        let players = players.sorted()\\n        let trainers = trainers.sorted()\\n\\n        var playerIndex = 0, trainerIndex = 0\\n\\n        while playerIndex < players.count && trainerIndex < trainers.count {\\n            if players[playerIndex] <= trainers[trainerIndex] {\\n                playerIndex += 1\\n                trainerIndex += 1\\n            } else {\\n                trainerIndex += 1\\n            }\\n        }\\n\\n        return playerIndex\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func matchPlayersAndTrainers(_ players: [Int], _ trainers: [Int]) -> Int {\\n        let players = players.sorted()\\n        let trainers = trainers.sorted()\\n\\n        var playerIndex = 0, trainerIndex = 0\\n\\n        while playerIndex < players.count && trainerIndex < trainers.count {\\n            if players[playerIndex] <= trainers[trainerIndex] {\\n                playerIndex += 1\\n                trainerIndex += 1\\n            } else {\\n                trainerIndex += 1\\n            }\\n        }\\n\\n        return playerIndex\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868112,
                "title": "c-solution-two-pointers",
                "content": "```\\nint matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n\\tsort(begin(p), end(p));\\n\\tsort(begin(t), end(t));\\n\\tint i = 0;\\n\\tfor (int j = 0; j < t.size() && i < p.size(); j++) {\\n\\t\\tif (p[i] <= t[j])\\n\\t\\t\\ti++;\\n\\t}\\n\\treturn i;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n\\tsort(begin(p), end(p));\\n\\tsort(begin(t), end(t));\\n\\tint i = 0;\\n\\tfor (int j = 0; j < t.size() && i < p.size(); j++) {\\n\\t\\tif (p[i] <= t[j])\\n\\t\\t\\ti++;\\n\\t}\\n\\treturn i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3860908,
                "title": "rust-sorting-n-log-n-time-log-n-space",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn match_players_and_trainers(mut players: Vec<i32>, mut trainers: Vec<i32>) -> i32 {\\n        players.sort_unstable();\\n        trainers.sort_unstable();\\n\\n        let mut i = 0;\\n        trainers.into_iter().filter(|&c| if i < players.len() && players[i] <= c { i += 1; true } else { false }).count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn match_players_and_trainers(mut players: Vec<i32>, mut trainers: Vec<i32>) -> i32 {\\n        players.sort_unstable();\\n        trainers.sort_unstable();\\n\\n        let mut i = 0;\\n        trainers.into_iter().filter(|&c| if i < players.len() && players[i] <= c { i += 1; true } else { false }).count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3857595,
                "title": "easy-and-100-efficiant-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int n=players.size();\\n        int m=trainers.size();\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        while(i<n && j<m)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int n=players.size();\\n        int m=trainers.size();\\n        int i=0;\\n        int j=0;\\n        int count=0;\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        while(i<n && j<m)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857186,
                "title": "c-greedy-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MatchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Array.Sort(players);\\n        Array.Sort(trainers);\\n\\n        var playerIteration = 0;\\n        var trainerIteration = 0;\\n\\n        while (playerIteration < players.Length && trainerIteration < trainers.Length)\\n        {\\n            if (players[playerIteration] <= trainers[trainerIteration])\\n            {\\n                playerIteration++;\\n                trainerIteration++;\\n            }\\n            else\\n            {\\n                trainerIteration++;\\n            }\\n        }\\n\\n        return playerIteration;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MatchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Array.Sort(players);\\n        Array.Sort(trainers);\\n\\n        var playerIteration = 0;\\n        var trainerIteration = 0;\\n\\n        while (playerIteration < players.Length && trainerIteration < trainers.Length)\\n        {\\n            if (players[playerIteration] <= trainers[trainerIteration])\\n            {\\n                playerIteration++;\\n                trainerIteration++;\\n            }\\n            else\\n            {\\n                trainerIteration++;\\n            }\\n        }\\n\\n        return playerIteration;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856711,
                "title": "c-using-sort-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:\\nTime complexity of this program is dominating by sort therefore time compplexity is O(n*log(n))\\n- Space complexity:\\nSpace complexity of this program is O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n\\n        int cnt=0;\\n        int a = -1;\\n        int i=0;\\n        int j=0;\\n        int p = players.size();\\n        int t = trainers.size();\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n\\n        while(i<p && j<t)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n\\n        int cnt=0;\\n        int a = -1;\\n        int i=0;\\n        int j=0;\\n        int p = players.size();\\n        int t = trainers.size();\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n\\n        while(i<p && j<t)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                cnt++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839572,
                "title": "two-pointers-solution-easy-to-understand-java",
                "content": "\\n\\n# Approach\\n- Two pointers, one pointing towards the players array whereas the another one pointing towards the trainers array.\\n\\n- If the rule is satisfied, then both the pointers will move ahead by one and our counter will also get increased by one.\\n\\n- But, in case where trainers lack in providing training to the players, then only the trainer pointer will be increased by one.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        int count = 0;\\n\\n        while(i < players.length && j < trainers.length){\\n\\n            if(players[i] > trainers[j]){\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n                count++;\\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        int count = 0;\\n\\n        while(i < players.length && j < trainers.length){\\n\\n            if(players[i] > trainers[j]){\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n                count++;\\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827726,
                "title": "c-two-pointers-sorting-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int n1 = players.size(), n2 = trainers.size();\\n        sort(trainers.begin(), trainers.end());\\n        sort(players.begin(), players.end());\\n        int j = 0;\\n        int i = 0;\\n        int ans = 0;\\n        while(j<n2 && i<n1){\\n            if(players[i]<=trainers[j]){\\n                ans++;\\n                j++;\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int n1 = players.size(), n2 = trainers.size();\\n        sort(trainers.begin(), trainers.end());\\n        sort(players.begin(), players.end());\\n        int j = 0;\\n        int i = 0;\\n        int ans = 0;\\n        while(j<n2 && i<n1){\\n            if(players[i]<=trainers[j]){\\n                ans++;\\n                j++;\\n                i++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826137,
                "title": "sort-and-compare",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n\\n        players.sort()\\n        trainers.sort()\\n\\n        i = j = count = 0\\n\\n        while i< len(players) and j < len(trainers):\\n            if players[i] <= trainers[j]:\\n                count += 1\\n                i += 1\\n            j += 1\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n\\n        players.sort()\\n        trainers.sort()\\n\\n        i = j = count = 0\\n\\n        while i< len(players) and j < len(trainers):\\n            if players[i] <= trainers[j]:\\n                count += 1\\n                i += 1\\n            j += 1\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822743,
                "title": "easy-sort-cpp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int i=0, j=0, ans=0;\\n        while(i<players.size() && j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                i++;\\n                j++;\\n                ans++;\\n            }\\n            else\\n                j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int i=0, j=0, ans=0;\\n        while(i<players.size() && j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                i++;\\n                j++;\\n                ans++;\\n            }\\n            else\\n                j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821796,
                "title": "c-sorting-most-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n     sort(players.begin(),players.end());\\n     sort(trainers.begin(),trainers.end());\\n     \\n     int pp=0;\\n     int tp=0;\\n     int n=players.size();\\n     int m=trainers.size();\\n     int count=0;\\n     while(pp<n and tp<m)\\n     {\\n      if(players[pp]<=trainers[tp])\\n      {\\n          count++;\\n          pp++;\\n          tp++;\\n      }\\n      else if(players[pp]>trainers[tp])\\n      {\\n          tp++;\\n      }\\n      else\\n      {\\n          pp++;\\n      }\\n     \\n\\n     }\\n return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n     sort(players.begin(),players.end());\\n     sort(trainers.begin(),trainers.end());\\n     \\n     int pp=0;\\n     int tp=0;\\n     int n=players.size();\\n     int m=trainers.size();\\n     int count=0;\\n     while(pp<n and tp<m)\\n     {\\n      if(players[pp]<=trainers[tp])\\n      {\\n          count++;\\n          pp++;\\n          tp++;\\n      }\\n      else if(players[pp]>trainers[tp])\\n      {\\n          tp++;\\n      }\\n      else\\n      {\\n          pp++;\\n      }\\n     \\n\\n     }\\n return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819974,
                "title": "java-two-pointer-solution-o-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i=players.length-1;\\n        int j=trainers.length-1;\\n        int count=0;\\n        while(i>=0&&j>=0)\\n        {\\n            if(players[i]<=trainers[j]){\\n                count++;\\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }  \\n        return count;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i=players.length-1;\\n        int j=trainers.length-1;\\n        int count=0;\\n        while(i>=0&&j>=0)\\n        {\\n            if(players[i]<=trainers[j]){\\n                count++;\\n                i--;\\n                j--;\\n            }\\n            else{\\n                i--;\\n            }\\n        }  \\n        return count;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783758,
                "title": "easy-and-coincise-solution-two-pointers-approach-beats-98-8-of-runtime",
                "content": "# Complexity\\n- Time complexity:\\nO(nLog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def matchPlayersAndTrainers(self, players, trainers):\\n        \\n        trainers.sort()\\n        players.sort()\\n\\n        lP = len(players)\\n        ans = index = 0\\n\\n        for i in range(len(trainers)):\\n\\n            if index == lP:\\n                return ans\\n\\n            if players[index] <= trainers[i]:\\n                ans += 1\\n                index += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def matchPlayersAndTrainers(self, players, trainers):\\n        \\n        trainers.sort()\\n        players.sort()\\n\\n        lP = len(players)\\n        ans = index = 0\\n\\n        for i in range(len(trainers)):\\n\\n            if index == lP:\\n                return ans\\n\\n            if players[index] <= trainers[i]:\\n                ans += 1\\n                index += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777154,
                "title": "greedy-approach-using-two-pointers-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int ans=0;\\n        int j=0;\\n        for(int i=0;i<trainers.size();i++){\\n            if(j==players.size())\\n                break;\\n            else{\\n                if(trainers[i]>=players[j]){\\n                    ans++;\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int ans=0;\\n        int j=0;\\n        for(int i=0;i<trainers.size();i++){\\n            if(j==players.size())\\n                break;\\n            else{\\n                if(trainers[i]>=players[j]){\\n                    ans++;\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771483,
                "title": "ruby-greedy",
                "content": "# Complexity\\n- Time complexity: $$O(n log n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n# @param {Integer[]} players\\n# @param {Integer[]} trainers\\n# @return {Integer}\\ndef match_players_and_trainers(players, trainers)\\n  players.sort!\\n  trainers.sort!\\n  ans = 0\\n  i = j = 0\\n  while i < players.count && j < trainers.count\\n    if players[i] <= trainers[j]\\n      ans += 1\\n      i += 1 \\n    end\\n    j += 1\\n  end\\n  ans\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} players\\n# @param {Integer[]} trainers\\n# @return {Integer}\\ndef match_players_and_trainers(players, trainers)\\n  players.sort!\\n  trainers.sort!\\n  ans = 0\\n  i = j = 0\\n  while i < players.count && j < trainers.count\\n    if players[i] <= trainers[j]\\n      ans += 1\\n      i += 1 \\n    end\\n    j += 1\\n  end\\n  ans\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3769210,
                "title": "javascript-solution-complexity-analysis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} players\\n * @param {number[]} trainers\\n * @return {number}\\n */\\n/*\\nTime complexity -> NlogN (due to sorting)\\nSpace complexity -> LogN (considering merge sort)\\n*/\\n\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a, b) => a - b);\\n    trainers.sort((a, b) => a - b);\\n\\n    let p = 0, t = 0, count = 0;\\n\\n    while(p < players.length && t < trainers.length){\\n        if(players[p] <= trainers[t]) {\\n            count++; p++, t++;\\n        } else {\\n            t++;\\n        }\\n    } \\n\\n    return count;   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} players\\n * @param {number[]} trainers\\n * @return {number}\\n */\\n/*\\nTime complexity -> NlogN (due to sorting)\\nSpace complexity -> LogN (considering merge sort)\\n*/\\n\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a, b) => a - b);\\n    trainers.sort((a, b) => a - b);\\n\\n    let p = 0, t = 0, count = 0;\\n\\n    while(p < players.length && t < trainers.length){\\n        if(players[p] <= trainers[t]) {\\n            count++; p++, t++;\\n        } else {\\n            t++;\\n        }\\n    } \\n\\n    return count;   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749591,
                "title": "c-sorting-two-pointers-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        //INTUTION: Sort both players and trainers array, take two\\n        //pointer intialize with 0, that is i=0,and j=0, i pointing\\n        //to player and j pointing to trainer, if player[i]<=trainer[j]\\n        //we got matching otherwise increament j\\n\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0,j=0,ans=0;\\n        while(i<players.size() && j<trainers.size()){\\n            if(players[i]<=trainers[j]){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        //INTUTION: Sort both players and trainers array, take two\\n        //pointer intialize with 0, that is i=0,and j=0, i pointing\\n        //to player and j pointing to trainer, if player[i]<=trainer[j]\\n        //we got matching otherwise increament j\\n\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0,j=0,ans=0;\\n        while(i<players.size() && j<trainers.size()){\\n            if(players[i]<=trainers[j]){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724007,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} players\\n * @param {number[]} trainers\\n * @return {number}\\n */\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    // The ith player can match with the jth trainer if:\\n    //  the player\\'s ability is less than or equal to the trainer\\'s training capacity.\\n    //  the ith player can be matched with at most one trainer,\\n    //  and the jth trainer can be matched with at most one player.\\n\\n    players.sort((a,b)=>a-b);\\n    trainers.sort((a,b)=>a-b);\\n    let count = 0;\\n    let j = 0;\\n    let i = 0;\\n\\n    while(j < trainers.length){\\n        if (players[i] <= trainers[j]){\\n            count+=1\\n            i+=1;\\n        }\\n        j+=1;\\n    }\\n\\n    return count;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} players\\n * @param {number[]} trainers\\n * @return {number}\\n */\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    // The ith player can match with the jth trainer if:\\n    //  the player\\'s ability is less than or equal to the trainer\\'s training capacity.\\n    //  the ith player can be matched with at most one trainer,\\n    //  and the jth trainer can be matched with at most one player.\\n\\n    players.sort((a,b)=>a-b);\\n    trainers.sort((a,b)=>a-b);\\n    let count = 0;\\n    let j = 0;\\n    let i = 0;\\n\\n    while(j < trainers.length){\\n        if (players[i] <= trainers[j]){\\n            count+=1\\n            i+=1;\\n        }\\n        j+=1;\\n    }\\n\\n    return count;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722107,
                "title": "o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n        int n = players.size();\\n        int m = trainers.size();\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n\\n        while(i < n && j < m) {\\n\\n            if(players[i] <= trainers[j]) {\\n                i++;\\n                j++;\\n                ans++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n        int n = players.size();\\n        int m = trainers.size();\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n\\n        while(i < n && j < m) {\\n\\n            if(players[i] <= trainers[j]) {\\n                i++;\\n                j++;\\n                ans++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705007,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int maxMatches = 0, trainersIndex = 0, playersIndex = 0;\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        while(trainersIndex < trainers.length && playersIndex < players.length){\\n            if(players[playersIndex] <= trainers[trainersIndex]){\\n                maxMatches++;\\n                playersIndex++;\\n                trainersIndex++;\\n            }\\n            else if (players[playersIndex] > trainers[trainersIndex]){\\n                trainersIndex++;\\n            }\\n        }\\n        return maxMatches;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int maxMatches = 0, trainersIndex = 0, playersIndex = 0;\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        while(trainersIndex < trainers.length && playersIndex < players.length){\\n            if(players[playersIndex] <= trainers[trainersIndex]){\\n                maxMatches++;\\n                playersIndex++;\\n                trainersIndex++;\\n            }\\n            else if (players[playersIndex] > trainers[trainersIndex]){\\n                trainersIndex++;\\n            }\\n        }\\n        return maxMatches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695791,
                "title": "using-sort-c-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n       sort(players.begin(),players.end());\\n       sort(trainers.begin(),trainers.end());\\n       int i=0,j=0;\\n       int count=0;\\n        \\n        while(i<players.size() and j<trainers.size()){\\n            \\n            if(players[i]<=trainers[j]){\\n                count++;\\n                i++;j++;\\n                continue;\\n            }\\n            \\n            if(players[i]>trainers[j]){\\n                j++;\\n            }\\n            \\n        }\\n       \\n        \\n      return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        \\n       sort(players.begin(),players.end());\\n       sort(trainers.begin(),trainers.end());\\n       int i=0,j=0;\\n       int count=0;\\n        \\n        while(i<players.size() and j<trainers.size()){\\n            \\n            if(players[i]<=trainers[j]){\\n                count++;\\n                i++;j++;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3691182,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int p=0,t=0;\\n        int ans = 0;\\n        while(p<players.length && t<trainers.length){\\n            if(players[p]<=trainers[t]){\\n                ans++;\\n                p++;\\n                t++;\\n            }\\n            else{\\n                //players[p]>trainers[t]\\n                t++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int p=0,t=0;\\n        int ans = 0;\\n        while(p<players.length && t<trainers.length){\\n            if(players[p]<=trainers[t]){\\n                ans++;\\n                p++;\\n                t++;\\n            }\\n            else{\\n                //players[p]>trainers[t]\\n                t++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689820,
                "title": "java-using-2-priorityqueues",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        PriorityQueue<Integer> pqP = new PriorityQueue<>(), pqT = new PriorityQueue<>();\\n        for (int p : players) pqP.offer(p);\\n        for (int t : trainers) pqT.offer(t);\\n        int count = 0;\\n        while (!pqP.isEmpty() && !pqT.isEmpty()) {\\n            if (pqP.peek() <= pqT.peek()) {\\n                pqP.poll();\\n                pqT.poll();\\n                count++;\\n            } else {\\n                pqT.poll();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        PriorityQueue<Integer> pqP = new PriorityQueue<>(), pqT = new PriorityQueue<>();\\n        for (int p : players) pqP.offer(p);\\n        for (int t : trainers) pqT.offer(t);\\n        int count = 0;\\n        while (!pqP.isEmpty() && !pqT.isEmpty()) {\\n            if (pqP.peek() <= pqT.peek()) {\\n                pqP.poll();\\n                pqT.poll();\\n                count++;\\n            } else {\\n                pqT.poll();\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684589,
                "title": "easy-solution-sorting-two-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int p=players.length;\\n        int t=trainers.length;\\n        int i=0,j=0;\\n        int match=0;\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        while(i<p && j<t){\\n            if(players[i]<=trainers[j]){\\n                match++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            j++;\\n        }\\n        return match;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        int p=players.length;\\n        int t=trainers.length;\\n        int i=0,j=0;\\n        int match=0;\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        while(i<p && j<t){\\n            if(players[i]<=trainers[j]){\\n                match++;\\n                i++;\\n                j++;\\n            }\\n            else\\n            j++;\\n        }\\n        return match;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683285,
                "title": "python3-two-pointers-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> By sorting, we can keep one of the pointes in the players until we can match it. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        pairs = 0\\n        pidx, tidx = 0, 0\\n        while pidx < len(players) and tidx < len(trainers):\\n            if players[pidx] <= trainers[tidx]:\\n                # print(pidx, tidx)\\n                pairs += 1\\n                pidx += 1\\n                tidx += 1\\n            else:\\n                tidx += 1\\n        return pairs\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        pairs = 0\\n        pidx, tidx = 0, 0\\n        while pidx < len(players) and tidx < len(trainers):\\n            if players[pidx] <= trainers[tidx]:\\n                # print(pidx, tidx)\\n                pairs += 1\\n                pidx += 1\\n                tidx += 1\\n            else:\\n                tidx += 1\\n        return pairs\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682469,
                "title": "greedy-two-pointer-sorting-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        \\n        int i = 0, j = 0, n = players.size(), m = trainers.size();\\n        int count = 0;\\n        \\n        while(i < n && j < m) {\\n            if(players[i] <= trainers[j]) {\\n                i++;\\n                count++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        \\n        int i = 0, j = 0, n = players.size(), m = trainers.size();\\n        int count = 0;\\n        \\n        while(i < n && j < m) {\\n            if(players[i] <= trainers[j]) {\\n                i++;\\n                count++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681043,
                "title": "sorting-make-it-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first sort both of the array ,then take 2 pointers and check the condition for all the value of players . \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        n_players=sorted(players)\\n        n_trainers=sorted(trainers)\\n        i=0\\n        j=0\\n        count=0\\n        while i<len(n_players) and j<len(n_trainers):\\n            if n_players[i]<=n_trainers[j]:\\n                count+=1\\n                i+=1\\n                j+=1\\n            else:\\n                j+=1\\n        return (count)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        n_players=sorted(players)\\n        n_trainers=sorted(trainers)\\n        i=0\\n        j=0\\n        count=0\\n        while i<len(n_players) and j<len(n_trainers):\\n            if n_players[i]<=n_trainers[j]:\\n                count+=1\\n                i+=1\\n                j+=1\\n            else:\\n                j+=1\\n        return (count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680383,
                "title": "two-pointers-approach-simple-program-in-java",
                "content": "# Intuition\\nTwo Pointers Approach\\n\\n# Complexity\\n- Time complexity: O(nlogn) (Sorted the both arrays)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int i =0; //first Pointer for players\\n        int j =0; //second Pointer for trainers\\n\\n        int match = 0;\\n        //traverse the array with these two pointers and check if we found the match\\n        while(i < players.length && j < trainers.length){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                match++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return match;\\n    }\\n}\\n```\\n\\nIf you like this solution, please do upvote it",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n\\n        int i =0; //first Pointer for players\\n        int j =0; //second Pointer for trainers\\n\\n        int match = 0;\\n        //traverse the array with these two pointers and check if we found the match\\n        while(i < players.length && j < trainers.length){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                match++;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return match;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672323,
                "title": "maximum-watching-of-players-with-trainers-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        int i = players.size()-1;\\n        int j = trainers.size()-1;\\n        int ans = 0;\\n\\n        while(i>=0 and j>=0)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                i--;\\n                j--;\\n                ans++;\\n            }\\n            else\\n            {\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        int i = players.size()-1;\\n        int j = trainers.size()-1;\\n        int ans = 0;\\n\\n        while(i>=0 and j>=0)\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n                i--;\\n                j--;\\n                ans++;\\n            }\\n            else\\n            {\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652640,
                "title": "just-sort-and-everything-is-sorted",
                "content": "# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort( players );\\n        Arrays.sort( trainers );\\n\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n\\n        while( i < players.length && j < trainers.length ){\\n            if( players[i] <= trainers[j] ){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort( players );\\n        Arrays.sort( trainers );\\n\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n\\n        while( i < players.length && j < trainers.length ){\\n            if( players[i] <= trainers[j] ){\\n                ans++;\\n                i++;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649403,
                "title": "single-iteration-simplest-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        int i=0,j=0;\\n        int count=0;\\n        while(i<players.size() && j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n               count++;\\n               i++;\\n               j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        int i=0,j=0;\\n        int count=0;\\n        while(i<players.size() && j<trainers.size())\\n        {\\n            if(players[i]<=trainers[j])\\n            {\\n               count++;\\n               i++;\\n               j++;\\n            }\\n            else\\n            {\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646297,
                "title": "simple-c-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int i = 0, j = 0, matches = 0;\\n        while(i < players.size() && j < trainers.size()) {\\n            if(players[i] <= trainers[j]) {\\n                matches++;\\n                i++;\\n            } \\n                j++;                \\n        }\\n\\n        return matches;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int i = 0, j = 0, matches = 0;\\n        while(i < players.size() && j < trainers.size()) {\\n            if(players[i] <= trainers[j]) {\\n                matches++;\\n                i++;\\n            } \\n                j++;                \\n        }\\n\\n        return matches;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642109,
                "title": "easy-to-read-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution \\n{\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) \\n    {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i = 0, j = 0, count = 0;\\n        \\n        while (i < players.length && j < trainers.length) \\n        {\\n            if (players[i] > trainers[j]) \\n            { \\n                j++; \\n            }\\n            else if (players[i] <= trainers[j]) \\n            { \\n                count++; \\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) \\n    {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i = 0, j = 0, count = 0;\\n        \\n        while (i < players.length && j < trainers.length) \\n        {\\n            if (players[i] > trainers[j]) \\n            { \\n                j++; \\n            }\\n            else if (players[i] <= trainers[j]) \\n            { \\n                count++; \\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594230,
                "title": "elixir-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 396ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 100.8MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec match_players_and_trainers(players :: [integer], trainers :: [integer]) :: integer\\n  def match_players_and_trainers(players, trainers) do\\n    match_players_and_trainers(Enum.sort(players), Enum.sort(trainers), 0)\\n  end\\n\\n  @spec match_players_and_trainers(players :: [integer], trainers :: [integer], res :: integer) :: integer\\n  def match_players_and_trainers([p_hd | p_tl], [t_hd | t_tl], res) do\\n    if p_hd <= t_hd do\\n      match_players_and_trainers(p_tl, t_tl, res + 1)\\n    else\\n      match_players_and_trainers([p_hd | p_tl], t_tl, res)\\n    end\\n  end\\n\\n  def match_players_and_trainers([], _, res) do\\n    res\\n  end\\n\\n  def match_players_and_trainers(_, [], res) do\\n    res\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec match_players_and_trainers(players :: [integer], trainers :: [integer]) :: integer\\n  def match_players_and_trainers(players, trainers) do\\n    match_players_and_trainers(Enum.sort(players), Enum.sort(trainers), 0)\\n  end\\n\\n  @spec match_players_and_trainers(players :: [integer], trainers :: [integer], res :: integer) :: integer\\n  def match_players_and_trainers([p_hd | p_tl], [t_hd | t_tl], res) do\\n    if p_hd <= t_hd do\\n      match_players_and_trainers(p_tl, t_tl, res + 1)\\n    else\\n      match_players_and_trainers([p_hd | p_tl], t_tl, res)\\n    end\\n  end\\n\\n  def match_players_and_trainers([], _, res) do\\n    res\\n  end\\n\\n  def match_players_and_trainers(_, [], res) do\\n    res\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3566822,
                "title": "simple-sort-and-count",
                "content": "# Complexity\\n- Time complexity: O(nlog(n))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int player_pointer = players.size()-1;\\n        int trainer_pointer = trainers.size()-1;\\n        int ans = 0;\\n        while(player_pointer>=0 and trainer_pointer>=0){\\n            if(players[player_pointer]<=trainers[trainer_pointer]){\\n                ans++;\\n                player_pointer--;\\n                trainer_pointer--;\\n            }else{\\n                player_pointer--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n        int player_pointer = players.size()-1;\\n        int trainer_pointer = trainers.size()-1;\\n        int ans = 0;\\n        while(player_pointer>=0 and trainer_pointer>=0){\\n            if(players[player_pointer]<=trainers[trainer_pointer]){\\n                ans++;\\n                player_pointer--;\\n                trainer_pointer--;\\n            }else{\\n                player_pointer--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565781,
                "title": "c-soln-think-greedily-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int i = 0;\\n        int j = 0;\\n        int counter = 0;\\n\\n        sort(players.begin(),players.end(),greater<int>());\\n        sort(trainers.begin(),trainers.end(),greater<int>());\\n\\n        while(i < players.size() && j < trainers.size()){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                counter++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int i = 0;\\n        int j = 0;\\n        int counter = 0;\\n\\n        sort(players.begin(),players.end(),greater<int>());\\n        sort(trainers.begin(),trainers.end(),greater<int>());\\n\\n        while(i < players.size() && j < trainers.size()){\\n            if(players[i] <= trainers[j]){\\n                i++;\\n                j++;\\n                counter++;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560139,
                "title": "java-greedy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        \\n        int ability = 0;\\n        for (int capacity = 0 ; capacity < trainers.length && ability < players.length ; capacity ++) {\\n            if (players[ability] <= trainers[capacity]) {\\n                ability ++;\\n            }\\n        }\\n        \\n        return ability; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        \\n        int ability = 0;\\n        for (int capacity = 0 ; capacity < trainers.length && ability < players.length ; capacity ++) {\\n            if (players[ability] <= trainers[capacity]) {\\n                ability ++;\\n            }\\n        }\\n        \\n        return ability; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545841,
                "title": "java-short-simple-sorting-2-pointers",
                "content": "```\\npublic int matchPlayersAndTrainers(int[] parr, int[] tarr) {\\n\\tArrays.sort(parr);\\n\\tArrays.sort(tarr);\\n\\tint res=0;\\n\\tfor (int i=0,j=0;i<parr.length && j<tarr.length; j++){\\n\\t\\tif (parr[i]<=tarr[j]) {res++;i++;}\\n\\t}\\n\\treturn res; \\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int matchPlayersAndTrainers(int[] parr, int[] tarr) {\\n\\tArrays.sort(parr);\\n\\tArrays.sort(tarr);\\n\\tint res=0;\\n\\tfor (int i=0,j=0;i<parr.length && j<tarr.length; j++){\\n\\t\\tif (parr[i]<=tarr[j]) {res++;i++;}\\n\\t}\\n\\treturn res; \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543535,
                "title": "c-short-solution",
                "content": "\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n        int N =  players.size();\\n        int M = trainers.size();\\n        while(i < N && j < M) {\\n            if( players[i] <= trainers[j]) {\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(), trainers.end());\\n\\n        int i = 0;\\n        int j = 0;\\n        int ans = 0;\\n        int N =  players.size();\\n        int M = trainers.size();\\n        while(i < N && j < M) {\\n            if( players[i] <= trainers[j]) {\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534404,
                "title": "c-easy-solution-with-explanation",
                "content": "# EXPLANATION\\nWe sort both the given vectors.\\nWe created **ans** for final answer.\\nInitialised **i** for players vector and **j** for trainers vector from initial position.\\nChecked from begining until  **i** or **j** pointer gets out of range.\\nIncreamented the answer and players pointer if condition is satisfied.\\nFinally returned the answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int ans=0,i=0,j=0;\\n        while(i<players.size() && j<trainers.size()){\\n            if(players[i]<=trainers[j]){\\n                ans++,i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int ans=0,i=0,j=0;\\n        while(i<players.size() && j<trainers.size()){\\n            if(players[i]<=trainers[j]){\\n                ans++,i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496468,
                "title": "2pointers-python3-c",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        matches = 0\\n        trainer_idx = player_idx = 0\\n        m, n = len(players), len(trainers)\\n\\n        while player_idx < m and trainer_idx < n:\\n            if players[player_idx] <= trainers[trainer_idx]:\\n                matches += 1\\n                player_idx += 1\\n                trainer_idx += 1\\n            else:\\n                trainer_idx += 1\\n        \\n        return matches\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        std::sort(players.begin(), players.end());\\n        std::sort(trainers.begin(), trainers.end());\\n        int matches = 0, trainer_idx = 0, player_idx = 0;\\n        int m, n;\\n        m = players.size();\\n        n = trainers.size();\\n\\n        while (player_idx < m && trainer_idx < n) {\\n            if (players[player_idx] <= trainers[trainer_idx]) {\\n                matches++;\\n                player_idx++;\\n                trainer_idx++;\\n            }\\n            else\\n                trainer_idx++;\\n        }\\n        return matches;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python []\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        matches = 0\\n        trainer_idx = player_idx = 0\\n        m, n = len(players), len(trainers)\\n\\n        while player_idx < m and trainer_idx < n:\\n            if players[player_idx] <= trainers[trainer_idx]:\\n                matches += 1\\n                player_idx += 1\\n                trainer_idx += 1\\n            else:\\n                trainer_idx += 1\\n        \\n        return matches\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        std::sort(players.begin(), players.end());\\n        std::sort(trainers.begin(), trainers.end());\\n        int matches = 0, trainer_idx = 0, player_idx = 0;\\n        int m, n;\\n        m = players.size();\\n        n = trainers.size();\\n\\n        while (player_idx < m && trainer_idx < n) {\\n            if (players[player_idx] <= trainers[trainer_idx]) {\\n                matches++;\\n                player_idx++;\\n                trainer_idx++;\\n            }\\n            else\\n                trainer_idx++;\\n        }\\n        return matches;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490441,
                "title": "easy-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        i,j,ans=0,0,0\\n        players.sort()\\n        trainers.sort()\\n\\n        while (i < len(players)) & (j < len(trainers)):\\n            if players[i] <= trainers[j]:\\n                i+=1\\n                ans+=1\\n            j+=1\\n        return ans\\n\\n            \\n\\n\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        i,j,ans=0,0,0\\n        players.sort()\\n        trainers.sort()\\n\\n        while (i < len(players)) & (j < len(trainers)):\\n            if players[i] <= trainers[j]:\\n                i+=1\\n                ans+=1\\n            j+=1\\n        return ans\\n\\n            \\n\\n\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490106,
                "title": "c-solution-two-pointer",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int count=0;\\n        int i=0,j=0; \\n        \\n        while(i<players.size() and j<trainers.size()){\\n            if(players[i]<=trainers[j])\\n            {\\n                i++; \\n                j++;\\n                ++count;\\n            }\\n            else\\n            {\\n                j++; \\n            }\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int count=0;\\n        int i=0,j=0; \\n        \\n        while(i<players.size() and j<trainers.size()){\\n            if(players[i]<=trainers[j])\\n            {\\n                i++; \\n                j++;\\n                ++count;\\n            }\\n            else\\n            {\\n                j++; \\n            }\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483321,
                "title": "easy-java-greedy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i = 0;\\n        int j = 0;\\n        while (i < players.length && j < trainers.length) {\\n            if (trainers[j] >= players[i]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matchPlayersAndTrainers(int[] players, int[] trainers) {\\n        Arrays.sort(players);\\n        Arrays.sort(trainers);\\n        int i = 0;\\n        int j = 0;\\n        while (i < players.length && j < trainers.length) {\\n            if (trainers[j] >= players[i]) {\\n                i++;\\n            }\\n            j++;\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481438,
                "title": "simple-greedy-solution",
                "content": "# Intuition -- Simple Logic.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach -- Sort the arrays and then Greedily check for every element of players array and with a boolean array keep a track of every player assigned with trainer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int cnt=0;\\n        vector<int> check(trainers.size(),false);\\n// if((players.size()==1 || trainers.size()==1)&& players[0]<=trainers[0])return 1;\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0;\\n        int j=0;\\n        while(i<trainers.size()){\\n            int x=trainers[i]-players[j];\\n            i++;\\n            if(x>=0 && !check[i-1]){\\n                j++;\\n                check[i-1]=true;\\n                cnt++;\\n                if(j==players.size()) break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int cnt=0;\\n        vector<int> check(trainers.size(),false);\\n// if((players.size()==1 || trainers.size()==1)&& players[0]<=trainers[0])return 1;\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i=0;\\n        int j=0;\\n        while(i<trainers.size()){\\n            int x=trainers[i]-players[j];\\n            i++;\\n            if(x>=0 && !check[i-1]){\\n                j++;\\n                check[i-1]=true;\\n                cnt++;\\n                if(j==players.size()) break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474709,
                "title": "python-easy-understanding-solution-for-beginners",
                "content": "# Intuition\\n\\n# Approach\\nWe can use the 2 pointer approch as well by using the while loop and incrementing everytime by comaparing the values. I have Used 2 for Loop apporch for the beginners who are approching this problem.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity:O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        match = 0\\n        players.sort()\\n        trainers.sort()\\n        if players == trainers:\\n            return len(players)\\n        for i in range(len(players)):\\n            for j in range(len(trainers)):\\n                if players[i] <= trainers[j]:\\n                    match += 1\\n                    trainers.remove(trainers[j])\\n                    break\\n        return match\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        match = 0\\n        players.sort()\\n        trainers.sort()\\n        if players == trainers:\\n            return len(players)\\n        for i in range(len(players)):\\n            for j in range(len(trainers)):\\n                if players[i] <= trainers[j]:\\n                    match += 1\\n                    trainers.remove(trainers[j])\\n                    break\\n        return match\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473703,
                "title": "single-line-c-code-with-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n      sort(players.begin(),players.end()); sort(trainers.begin(),trainers.end());int p=players.size();int t=trainers.size();int i=0; for(int j=0;j<t;j++){if(i<p&&trainers[j]>=players[i]) i++;} return i;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n      sort(players.begin(),players.end()); sort(trainers.begin(),trainers.end());int p=players.size();int t=trainers.size();int i=0; for(int j=0;j<t;j++){if(i<p&&trainers[j]>=players[i]) i++;} return i;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468855,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int i=0,j=0,count=0;\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        while(i<players.size()&& j<trainers.size()){\\n            if(players[i]<=trainers[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int i=0,j=0,count=0;\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        while(i<players.size()&& j<trainers.size()){\\n            if(players[i]<=trainers[j]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                j++;\\n            }\\n        }return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464027,
                "title": "simple-and-efficient-py3-solution-to-matchplayersandtrainers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        i = j = 0\\n        while i < len(players) and j < len(trainers):\\n            if players[i] <= trainers[j]:\\n                i += 1\\n                trainers.pop(j)\\n            else:\\n                j += 1\\n        return i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        i = j = 0\\n        while i < len(players) and j < len(trainers):\\n            if players[i] <= trainers[j]:\\n                i += 1\\n                trainers.pop(j)\\n            else:\\n                j += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452941,
                "title": "greedy-and-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int ans=0;\\n        int j=0;\\n        int i=0;\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n        int n_trainers=trainers.size();\\n        int n_players=players.size();\\n        while(i<n_players && j<n_trainers){\\n            if(players[i]<=trainers[j]){\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int ans=0;\\n        int j=0;\\n        int i=0;\\n        sort(trainers.begin(),trainers.end());\\n        sort(players.begin(),players.end());\\n        int n_trainers=trainers.size();\\n        int n_players=players.size();\\n        while(i<n_players && j<n_trainers){\\n            if(players[i]<=trainers[j]){\\n                ans++;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441022,
                "title": "two-pointer-easy-understanding",
                "content": "``\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int p=players.size();\\n        int cnt=0,j=0;\\n        for(int i=0;i<trainers.size();i++){\\n            if(trainers[i]>=players[j]){\\n                cnt++;\\n                j++;\\n                if(p==j)\\n                    break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int p=players.size();\\n        int cnt=0,j=0;\\n        for(int i=0;i<trainers.size();i++){\\n            if(trainers[i]>=players[j]){\\n                cnt++;\\n                j++;\\n                if(p==j)\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3425155,
                "title": "c-heap-sorting",
                "content": "\\n\\n# Approach\\nsimple priority_queue 10 line solution\\n\\n# Complexity\\n- Time complexity:\\n- O(N)+O(Nlog(N))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& pl, vector<int>& tr) {\\n        priority_queue<int>pq;\\n        for(auto it :tr){\\n            pq.push(it);\\n        }\\n        sort(pl.begin(),pl.end());\\n        int i=pl.size()-1;\\n        int cnt=0;\\n        while(!pq.empty() && i>=0){\\n            if(pl[i]<=pq.top()){\\n                cnt++;\\n                 pq.pop();\\n            }\\n            i--;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& pl, vector<int>& tr) {\\n        priority_queue<int>pq;\\n        for(auto it :tr){\\n            pq.push(it);\\n        }\\n        sort(pl.begin(),pl.end());\\n        int i=pl.size()-1;\\n        int cnt=0;\\n        while(!pq.empty() && i>=0){\\n            if(pl[i]<=pq.top()){\\n                cnt++;\\n                 pq.pop();\\n            }\\n            i--;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414220,
                "title": "c-sorting-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int n = players.size();\\n        int m = trainers.size();\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            while(j < m && trainers[j] < players[i])\\n            {\\n                j++;\\n            }\\n            if(j < m && trainers[j] >= players[i])\\n            {\\n                ans++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int n = players.size();\\n        int m = trainers.size();\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0 ; i < n; i++)\\n        {\\n            while(j < m && trainers[j] < players[i])\\n            {\\n                j++;\\n            }\\n            if(j < m && trainers[j] >= players[i])\\n            {\\n                ans++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400603,
                "title": "sorting-and-greedy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        int i = 0;\\n        int j = 0;\\n        int ways = 0;\\n\\n        while (i < players.size()) {\\n            while(j < trainers.size() && players[i] > trainers[j]) {\\n                j++;\\n            } \\n            if (j< trainers.size() && players[i] <= trainers[j]) {\\n                ways++;j++;\\n            }\\n            i++;\\n        }\\n        return ways;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        int i = 0;\\n        int j = 0;\\n        int ways = 0;\\n\\n        while (i < players.size()) {\\n            while(j < trainers.size() && players[i] > trainers[j]) {\\n                j++;\\n            } \\n            if (j< trainers.size() && players[i] <= trainers[j]) {\\n                ways++;j++;\\n            }\\n            i++;\\n        }\\n        return ways;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400174,
                "title": "step-by-step-detailed-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort both the vectors.\\n2. For the ith player, find the jth trainer that is greater than ith player.\\n3. Store the jth index in a variable and continue finding the trainer for (i+1)th player from j+1 index. **(Because one player can be matched with one trainer only)**\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int n = players.size(), m = trainers.size(); // Storing size of players and trainers vector\\n        int count = 0; // Counter variable to store the result\\n        int prev = -1; // Variable to store index of previous trainer matched.\\n\\n        // Sort both the vectors\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        // Iterating over players vector\\n        for(int i = 0; i < n; i++){\\n            // Iterating over trainer vector starting from one index ahead of previously matched trainer\\n            for(int j = prev+1; j < m; j++){\\n                // Check if value of ith player is less than jth trainer\\n                if(players[i] <= trainers[j]){\\n                    count++; // Increment the counter\\n                    prev = j; // Store the index of jth trainer\\n                    break;\\n                }    \\n            }\\n        }   \\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        int n = players.size(), m = trainers.size(); // Storing size of players and trainers vector\\n        int count = 0; // Counter variable to store the result\\n        int prev = -1; // Variable to store index of previous trainer matched.\\n\\n        // Sort both the vectors\\n        sort(players.begin(), players.end());\\n        sort(trainers.begin(),trainers.end());\\n\\n        // Iterating over players vector\\n        for(int i = 0; i < n; i++){\\n            // Iterating over trainer vector starting from one index ahead of previously matched trainer\\n            for(int j = prev+1; j < m; j++){\\n                // Check if value of ith player is less than jth trainer\\n                if(players[i] <= trainers[j]){\\n                    count++; // Increment the counter\\n                    prev = j; // Store the index of jth trainer\\n                    break;\\n                }    \\n            }\\n        }   \\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397476,
                "title": "python3-binary-search-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        trainers = sorted(trainers)\\n        cnt = 0\\n        for p in players:\\n            if not trainers:\\n                break\\n            idx = bisect_left(trainers, p)\\n            if idx < len(trainers):\\n                cnt += 1\\n                trainers.pop(idx)\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        trainers = sorted(trainers)\\n        cnt = 0\\n        for p in players:\\n            if not trainers:\\n                break\\n            idx = bisect_left(trainers, p)\\n            if idx < len(trainers):\\n                cnt += 1\\n                trainers.pop(idx)\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393902,
                "title": "sorting-easy-approach",
                "content": "# Intuition\\nsorting\\n\\n# Approach\\nsorting the 2 arrays then for each player try to find the candidate trainer starting from the last chosen trainer +1;\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn+mlogm)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());//O(nlogn)\\n         sort(trainers.begin(),trainers.end());//O(mlogm)\\n         int i=0,result=0;\\n           for(auto player:players){//O(n+m)\\n                while(i<trainers.size()&&player>trainers[i]){\\n                    i+=1;\\n                }\\n                if(i<trainers.size()){\\n                    result+=1;\\n                    i+=1;\\n                }\\n           }\\n              return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n        sort(players.begin(),players.end());//O(nlogn)\\n         sort(trainers.begin(),trainers.end());//O(mlogm)\\n         int i=0,result=0;\\n           for(auto player:players){//O(n+m)\\n                while(i<trainers.size()&&player>trainers[i]){\\n                    i+=1;\\n                }\\n                if(i<trainers.size()){\\n                    result+=1;\\n                    i+=1;\\n                }\\n           }\\n              return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393604,
                "title": "simple-greedy-efficient-solution-agreed",
                "content": "# Please upvote if you like the solution\\n\\n# Code\\n```\\n/**\\n * @param {number[]} players\\n * @param {number[]} trainers\\n * @return {number}\\n */\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a, b) => a - b);\\n    trainers.sort((a, b) => a - b);\\n\\n    let i = 0, j = 0;\\n    while(i < players.length && j < trainers.length) {\\n        if(players[i] <= trainers[j]) {\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return Math.min(i, j);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} players\\n * @param {number[]} trainers\\n * @return {number}\\n */\\nvar matchPlayersAndTrainers = function(players, trainers) {\\n    players.sort((a, b) => a - b);\\n    trainers.sort((a, b) => a - b);\\n\\n    let i = 0, j = 0;\\n    while(i < players.length && j < trainers.length) {\\n        if(players[i] <= trainers[j]) {\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return Math.min(i, j);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391058,
                "title": "simplest-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    \\n    {\\n        int res = 0 ; \\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i = 0 , j = 0 ; \\n        while(i< players.size() && j<trainers.size())\\n        {\\n         if(players[i]<=trainers[j])\\n         {\\n             res ++ ; \\n             i++; \\n             j++; \\n         }\\n         else j++ ; \\n        }\\n        return res; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) \\n    \\n    {\\n        int res = 0 ; \\n        sort(players.begin(),players.end());\\n        sort(trainers.begin(),trainers.end());\\n        int i = 0 , j = 0 ; \\n        while(i< players.size() && j<trainers.size())\\n        {\\n         if(players[i]<=trainers[j])\\n         {\\n             res ++ ; \\n             i++; \\n             j++; \\n         }\\n         else j++ ; \\n        }\\n        return res; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390976,
                "title": "c-sorting-two-pointer-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n  // sort the players in increasing order;\\n        sort(players.begin(),players.end());\\n //sort the trainer in increasing order; \\n        sort(trainers.begin(),trainers.end());\\n        int n=players.size();\\n        int m=trainers.size();\\n        int i=0,j=0,cnt=0;\\n        while(i<n && j<m){\\n// move the ith pointer for each player;\\n            while(j<m && players[i]>trainers[j] ){\\n//       move the jth pointer until we got a trainer which is greater than  or equal to player;\\n                       j++;\\n            }\\n            if( j<m && players[i]<=trainers[j]){\\n// increase the counter if satisfy the condition;\\n                cnt++;\\n                j++;\\n            }\\n            i++;\\n        }\\n   return cnt;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matchPlayersAndTrainers(vector<int>& players, vector<int>& trainers) {\\n  // sort the players in increasing order;\\n        sort(players.begin(),players.end());\\n //sort the trainer in increasing order; \\n        sort(trainers.begin(),trainers.end());\\n        int n=players.size();\\n        int m=trainers.size();\\n        int i=0,j=0,cnt=0;\\n        while(i<n && j<m){\\n// move the ith pointer for each player;\\n            while(j<m && players[i]>trainers[j] ){\\n//       move the jth pointer until we got a trainer which is greater than  or equal to player;\\n                       j++;\\n            }\\n            if( j<m && players[i]<=trainers[j]){\\n// increase the counter if satisfy the condition;\\n                cnt++;\\n                j++;\\n            }\\n            i++;\\n        }\\n   return cnt;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390657,
                "title": "super-easy-2-pointer-approach-please-upvote-if-you-like-it-thanks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n\\n        players.sort()\\n        trainers.sort()\\n\\n        i,j = 0,0\\n        counter = 0\\n\\n        while i < len(players) and j < len(trainers):\\n            if players[i] <= trainers[j]:\\n                counter += 1\\n                i += 1\\n                j += 1\\n                \\n            else:\\n                j += 1\\n        return counter\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n\\n        players.sort()\\n        trainers.sort()\\n\\n        i,j = 0,0\\n        counter = 0\\n\\n        while i < len(players) and j < len(trainers):\\n            if players[i] <= trainers[j]:\\n                counter += 1\\n                i += 1\\n                j += 1\\n                \\n            else:\\n                j += 1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388261,
                "title": "python-just-find-the-minimum-capacity-match-explained",
                "content": "Just sort both the players and trainers. match the player with the trainer that has the smallest capacity differences.\\n\\n```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        \\n        ans, pidx, tidx = 0, 0, 0\\n        while pidx < len(players) and tidx < len(trainers):\\n            if players[pidx] <= trainers[tidx]:\\n                ans += 1\\n                pidx += 1\\n            tidx += 1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:\\n        players.sort()\\n        trainers.sort()\\n        \\n        ans, pidx, tidx = 0, 0, 0\\n        while pidx < len(players) and tidx < len(trainers):\\n            if players[pidx] <= trainers[tidx]:\\n                ans += 1\\n                pidx += 1\\n            tidx += 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1781357,
                "content": [
                    {
                        "username": "MaxKhor",
                        "content": "I believe this question is exactly the same as  [455. Assign Cookies](https://leetcode.com/problems/assign-cookies/), but one is easy and the other is medium."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "bruh"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "i-th player will be matched to the trainer whose training capacity is just greater than or equal to the ability of i-th player.\n\nso sort both arrays and use lower_bound function."
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "//What is wrong in this code??\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n            int i;\\n            int j;\\n            for(i=p.size()-1,j=t.size()-1;i>=0;i--)\\n            {\\n                if(p[i]<=t[j])\\n                {\\n                    break;\\n                }\\n            }\\n            int n=t.size();\\n            i=i+1;\\n            int res=min(n,i);\\n            return res;\\n        \\n    }\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks like **Easy**"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "https://leetcode.com/problems/maximize-greatness-of-an-array/ \\nhttps://leetcode.com/problems/assign-cookies/\\nThey all are same questions, with same approach , sort them and just run two pointers......"
                    }
                ]
            },
            {
                "id": 1997053,
                "content": [
                    {
                        "username": "MaxKhor",
                        "content": "I believe this question is exactly the same as  [455. Assign Cookies](https://leetcode.com/problems/assign-cookies/), but one is easy and the other is medium."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "bruh"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "i-th player will be matched to the trainer whose training capacity is just greater than or equal to the ability of i-th player.\n\nso sort both arrays and use lower_bound function."
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "//What is wrong in this code??\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n            int i;\\n            int j;\\n            for(i=p.size()-1,j=t.size()-1;i>=0;i--)\\n            {\\n                if(p[i]<=t[j])\\n                {\\n                    break;\\n                }\\n            }\\n            int n=t.size();\\n            i=i+1;\\n            int res=min(n,i);\\n            return res;\\n        \\n    }\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks like **Easy**"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "https://leetcode.com/problems/maximize-greatness-of-an-array/ \\nhttps://leetcode.com/problems/assign-cookies/\\nThey all are same questions, with same approach , sort them and just run two pointers......"
                    }
                ]
            },
            {
                "id": 1917926,
                "content": [
                    {
                        "username": "MaxKhor",
                        "content": "I believe this question is exactly the same as  [455. Assign Cookies](https://leetcode.com/problems/assign-cookies/), but one is easy and the other is medium."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "bruh"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "i-th player will be matched to the trainer whose training capacity is just greater than or equal to the ability of i-th player.\n\nso sort both arrays and use lower_bound function."
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "//What is wrong in this code??\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n            int i;\\n            int j;\\n            for(i=p.size()-1,j=t.size()-1;i>=0;i--)\\n            {\\n                if(p[i]<=t[j])\\n                {\\n                    break;\\n                }\\n            }\\n            int n=t.size();\\n            i=i+1;\\n            int res=min(n,i);\\n            return res;\\n        \\n    }\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks like **Easy**"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "https://leetcode.com/problems/maximize-greatness-of-an-array/ \\nhttps://leetcode.com/problems/assign-cookies/\\nThey all are same questions, with same approach , sort them and just run two pointers......"
                    }
                ]
            },
            {
                "id": 1881438,
                "content": [
                    {
                        "username": "MaxKhor",
                        "content": "I believe this question is exactly the same as  [455. Assign Cookies](https://leetcode.com/problems/assign-cookies/), but one is easy and the other is medium."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "bruh"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "i-th player will be matched to the trainer whose training capacity is just greater than or equal to the ability of i-th player.\n\nso sort both arrays and use lower_bound function."
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "//What is wrong in this code??\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n            int i;\\n            int j;\\n            for(i=p.size()-1,j=t.size()-1;i>=0;i--)\\n            {\\n                if(p[i]<=t[j])\\n                {\\n                    break;\\n                }\\n            }\\n            int n=t.size();\\n            i=i+1;\\n            int res=min(n,i);\\n            return res;\\n        \\n    }\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks like **Easy**"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "https://leetcode.com/problems/maximize-greatness-of-an-array/ \\nhttps://leetcode.com/problems/assign-cookies/\\nThey all are same questions, with same approach , sort them and just run two pointers......"
                    }
                ]
            },
            {
                "id": 1880894,
                "content": [
                    {
                        "username": "MaxKhor",
                        "content": "I believe this question is exactly the same as  [455. Assign Cookies](https://leetcode.com/problems/assign-cookies/), but one is easy and the other is medium."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "bruh"
                    },
                    {
                        "username": "_Anurag_Singhal_",
                        "content": "i-th player will be matched to the trainer whose training capacity is just greater than or equal to the ability of i-th player.\n\nso sort both arrays and use lower_bound function."
                    },
                    {
                        "username": "vaibhavsingh18",
                        "content": "//What is wrong in this code??\\n    int matchPlayersAndTrainers(vector<int>& p, vector<int>& t) {\\n        sort(p.begin(),p.end());\\n        sort(t.begin(),t.end());\\n            int i;\\n            int j;\\n            for(i=p.size()-1,j=t.size()-1;i>=0;i--)\\n            {\\n                if(p[i]<=t[j])\\n                {\\n                    break;\\n                }\\n            }\\n            int n=t.size();\\n            i=i+1;\\n            int res=min(n,i);\\n            return res;\\n        \\n    }\\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Looks like **Easy**"
                    },
                    {
                        "username": "Naren_np_1722",
                        "content": "https://leetcode.com/problems/maximize-greatness-of-an-array/ \\nhttps://leetcode.com/problems/assign-cookies/\\nThey all are same questions, with same approach , sort them and just run two pointers......"
                    }
                ]
            }
        ]
    },
    {
        "title": "Smallest Subarrays With Maximum Bitwise OR",
        "question_content": "<p>You are given a <strong>0-indexed</strong> array <code>nums</code> of length <code>n</code>, consisting of non-negative integers. For each index <code>i</code> from <code>0</code> to <code>n - 1</code>, you must determine the size of the <strong>minimum sized</strong> non-empty subarray of <code>nums</code> starting at <code>i</code> (<strong>inclusive</strong>) that has the <strong>maximum</strong> possible <strong>bitwise OR</strong>.</p>\n\n<ul>\n\t<li>In other words, let <code>B<sub>ij</sub></code> be the bitwise OR of the subarray <code>nums[i...j]</code>. You need to find the smallest subarray starting at <code>i</code>, such that bitwise OR of this subarray is equal to <code>max(B<sub>ik</sub>)</code> where <code>i &lt;= k &lt;= n - 1</code>.</li>\n</ul>\n\n<p>The bitwise OR of an array is the bitwise OR of all the numbers in it.</p>\n\n<p>Return <em>an integer array </em><code>answer</code><em> of size </em><code>n</code><em> where </em><code>answer[i]</code><em> is the length of the <strong>minimum</strong> sized subarray starting at </em><code>i</code><em> with <strong>maximum</strong> bitwise OR.</em></p>\n\n<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,2,1,3]\n<strong>Output:</strong> [3,3,2,2,1]\n<strong>Explanation:</strong>\nThe maximum possible bitwise OR starting at any index is 3. \n- Starting at index 0, the shortest subarray that yields it is [1,0,2].\n- Starting at index 1, the shortest subarray that yields the maximum bitwise OR is [0,2,1].\n- Starting at index 2, the shortest subarray that yields the maximum bitwise OR is [2,1].\n- Starting at index 3, the shortest subarray that yields the maximum bitwise OR is [1,3].\n- Starting at index 4, the shortest subarray that yields the maximum bitwise OR is [3].\nTherefore, we return [3,3,2,2,1]. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2]\n<strong>Output:</strong> [2,1]\n<strong>Explanation:\n</strong>Starting at index 0, the shortest subarray that yields the maximum bitwise OR is of length 2.\nStarting at index 1, the shortest subarray that yields the maximum bitwise OR is of length 1.\nTherefore, we return [2,1].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2588015,
                "title": "java-c-python-bit-solution-with-explanation",
                "content": "# **Intuition**\\nAssume the array has only 0 and 1.\\nThen the question changes:\\nIf `A[i] = 1`, shortest array is `[A[i]]`, length is 1.\\nIf `A[i] = 0`, we need to find the index `j` of next `1`,\\nthen `j - i + 1` is the length of shortest subarray.\\nIf no next 1, 1 is the length\\n\\nTo solve this problem,\\nwe can iterate the array reversely\\nand keep the index `j` of last time we saw 1.\\n`res[i] = max(1, last - i + 1)`\\n<br>\\n\\n# **Explanation**\\nFor `0 <= A[i] <= 10^9`,\\nwe simply do the above process for each bit.\\n`res[i] = max(1, max(last) - i + 1)`\\n<br>\\n\\n# **Complexity**\\nTime `O(30n)`\\nSpace `O(30)`\\n<br>\\n\\n**Java**\\n```java\\n    public int[] smallestSubarrays(int[] A) {\\n        int n = A.length, last[] = new int[30], res[] = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            res[i] = 1;\\n            for (int j = 0; j < 30; ++j) {\\n                if ((A[i] & (1 << j)) > 0)\\n                    last[j] = i;\\n                res[i] = Math.max(res[i], last[j] - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    vector<int> smallestSubarrays(vector<int>& A) {\\n        int last[30] = {}, n = A.size();\\n        vector<int> res(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = 0; j < 30; ++j) {\\n                if (A[i] & (1 << j))\\n                    last[j] = i;\\n                res[i] = max(res[i], last[j] - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def smallestSubarrays(self, A):\\n        last = [0] * 32\\n        n = len(A)\\n        res = [0] * n\\n        for i in range(n - 1, -1, -1):\\n            for j in range(32):\\n                if A[i] & (1 << j):\\n                    last[j] = i\\n            res[i] = max(1, max(last) - i + 1)\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int[] smallestSubarrays(int[] A) {\\n        int n = A.length, last[] = new int[30], res[] = new int[n];\\n        for (int i = n - 1; i >= 0; --i) {\\n            res[i] = 1;\\n            for (int j = 0; j < 30; ++j) {\\n                if ((A[i] & (1 << j)) > 0)\\n                    last[j] = i;\\n                res[i] = Math.max(res[i], last[j] - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> smallestSubarrays(vector<int>& A) {\\n        int last[30] = {}, n = A.size();\\n        vector<int> res(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = 0; j < 30; ++j) {\\n                if (A[i] & (1 << j))\\n                    last[j] = i;\\n                res[i] = max(res[i], last[j] - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def smallestSubarrays(self, A):\\n        last = [0] * 32\\n        n = len(A)\\n        res = [0] * n\\n        for i in range(n - 1, -1, -1):\\n            for j in range(32):\\n                if A[i] & (1 << j):\\n                    last[j] = i\\n            res[i] = max(1, max(last) - i + 1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2589058,
                "title": "simple-clean-c-code-o-n-solution-bit-manipulation",
                "content": "***Idea*** -*By looking at how OR works, we can see that bits can only be turned on with 1. So, start from the end and keep track of the minimum index that will keep the bit set. Then, take the maximum of all the indexes that contain set bits.*\\nfor this purpose, we maintain an Array named nearest of 32 bits which indicate the index of the `nearest` array element which set the particular `jth` bit at that particular instance. then we find the farthest set bit we found so far.\\nlet see an example -\\n`nums[] = {9,13,55,48,56};`\\nbit representation are as follow - \\n```\\ni   j--> 5 4 3 2 1 0\\n--------------------\\n9  ->    0 0 1 0 0 1\\n13 ->    0 0 1 1 0 1\\n55 ->    1 1 0 1 1 1\\n48 ->    1 1 0 0 0 0\\n56 ->    1 1 1 0 0 0\\n\\nlet see how we get length for first element (for 9) let\\'s find it manually.\\nat bit position 0 -> what is the nearest element who is set to 1. the answer is 9 itself so nearest[0] = 0 (i position of 9)\\nat bit position 1 ->  what is the nearest element who is set to 1. the answer is 55(2nd element) nearest[1] = 2 (i position of 55)\\nat bit position 2 ->  what is the nearest element who is set to 1. the answer is 13(1st element) nearest[2] = 1 (i position of 13)\\nat bit position 3 ->  what is the nearest element who is set to 1. the answer is 9 itself so nearest[3] = 0 (i position of 9)\\nat bit position 4 ->  what is the nearest element who is set to 1. the answer is 55(2nd element) nearest[4] = 2 (i position of 55)\\nat bit position 5 ->  what is the nearest element who is set to 1. the answer is 55(2st element) nearest[5] = 2 (i position of 55)\\n\\nnearest[] = {0,2,1,0,2,2};\\namong them the fathest nearest[j] = 2;\\nso if we start OR operation from 0th index then first time we get our maximum value at 2nd index.\\nso the smallest subset is nums[0..2] => of size 3;\\n\\nfor maintaining the nearest array we have to triverse nums from right to left\\nand keep updating nearest[j] if current element have a set bit at jth position.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        // for keeping track of last index of every bit till the ith index.\\n        // total bit in a data type int is 32.\\n        vector<int>nearest(32,-1);\\n        vector<int>ans(n);\\n        \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = 0; j<32; j++){\\n                // 1<<j -> a number with only set bit at jth position.\\n                // nums[i]&(1<<j) checks whether jth bit is set or not of nums[i];\\n                \\n                // if jth bit of nums[i] is set then we update nearest[j] to i;\\n                if(nums[i]&(1<<j)){\\n                    nearest[j] = i;\\n                }\\n            }\\n            \\n            // initially set lastSetBit to i because we have to start our set with ith element.\\n            int lastSetBit = i;\\n\\t\\t\\t\\n            // now we have to find which one is the bit seted most farthest among all 32 bits. we need the index i for this bit.\\n            for(int j = 0; j<32; j++){\\n                // we keep updating lastSetBit if we get any greater \"i\" of set bit.\\n                lastSetBit = max(nearest[j],lastSetBit);\\n            }\\n            // from last set bit only we can get smallest subarray.\\n            // after this we get same value but our subarray size will increase.\\n            ans[i] = lastSetBit-i+1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```\\nPLEASE UPVOTE IF YOU FOUND IT HELPFUL\\uD83D\\uDE22\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B\\uFE0F",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\ni   j--> 5 4 3 2 1 0\\n--------------------\\n9  ->    0 0 1 0 0 1\\n13 ->    0 0 1 1 0 1\\n55 ->    1 1 0 1 1 1\\n48 ->    1 1 0 0 0 0\\n56 ->    1 1 1 0 0 0\\n\\nlet see how we get length for first element (for 9) let\\'s find it manually.\\nat bit position 0 -> what is the nearest element who is set to 1. the answer is 9 itself so nearest[0] = 0 (i position of 9)\\nat bit position 1 ->  what is the nearest element who is set to 1. the answer is 55(2nd element) nearest[1] = 2 (i position of 55)\\nat bit position 2 ->  what is the nearest element who is set to 1. the answer is 13(1st element) nearest[2] = 1 (i position of 13)\\nat bit position 3 ->  what is the nearest element who is set to 1. the answer is 9 itself so nearest[3] = 0 (i position of 9)\\nat bit position 4 ->  what is the nearest element who is set to 1. the answer is 55(2nd element) nearest[4] = 2 (i position of 55)\\nat bit position 5 ->  what is the nearest element who is set to 1. the answer is 55(2st element) nearest[5] = 2 (i position of 55)\\n\\nnearest[] = {0,2,1,0,2,2};\\namong them the fathest nearest[j] = 2;\\nso if we start OR operation from 0th index then first time we get our maximum value at 2nd index.\\nso the smallest subset is nums[0..2] => of size 3;\\n\\nfor maintaining the nearest array we have to triverse nums from right to left\\nand keep updating nearest[j] if current element have a set bit at jth position.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        // for keeping track of last index of every bit till the ith index.\\n        // total bit in a data type int is 32.\\n        vector<int>nearest(32,-1);\\n        vector<int>ans(n);\\n        \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = 0; j<32; j++){\\n                // 1<<j -> a number with only set bit at jth position.\\n                // nums[i]&(1<<j) checks whether jth bit is set or not of nums[i];\\n                \\n                // if jth bit of nums[i] is set then we update nearest[j] to i;\\n                if(nums[i]&(1<<j)){\\n                    nearest[j] = i;\\n                }\\n            }\\n            \\n            // initially set lastSetBit to i because we have to start our set with ith element.\\n            int lastSetBit = i;\\n\\t\\t\\t\\n            // now we have to find which one is the bit seted most farthest among all 32 bits. we need the index i for this bit.\\n            for(int j = 0; j<32; j++){\\n                // we keep updating lastSetBit if we get any greater \"i\" of set bit.\\n                lastSetBit = max(nearest[j],lastSetBit);\\n            }\\n            // from last set bit only we can get smallest subarray.\\n            // after this we get same value but our subarray size will increase.\\n            ans[i] = lastSetBit-i+1;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589637,
                "title": "closest-position-of-each-bit",
                "content": "My first idea was to count occurrences each bit, and use this information for a sliding window. \\n\\nThe implementation was tricky, so I decided to just use a segment tree for range bitwise OR queries (second solution below).\\n\\n> Even though the second solution is O(n log n), its runtime is a bit better. With `n` limited to `100,000`, `log2 n` is `~17`, So, it needs `17 * 100,000` operations, while the first solution takes `30 * 100,000` (30 bits to check for each number).\\n\\nLater, I realized that we do not need to count each bit if we process numbers right-to-left. We just need to track the closest position of each bit\\n\\n#### Closest Position of Each Bit\\nWe go right-to-left, and use `closest` array to track the closest (or smallest) position of each bit.\\n\\nWe can then use the maximum position among all bits to find out the shortest subarrays with all bits set.\\n\\nHere is an example for `[4, 2, 1, 5, 3, 1, 2, 1]` case:\\n![image](https://assets.leetcode.com/users/images/95a79fb0-3118-4d25-83f5-a187a2ff1a9c_1663774308.642698.png)\\n\\n**C++**\\n```cpp\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n    vector<int> res(nums.size()), closest(30);\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        for (int b = 0; b < 30; ++b)\\n            if (nums[i] & (1 << b))\\n                closest[b] = i;\\n        res[i] = max(1, *max_element(begin(closest), end(closest)) - i + 1);\\n    }\\n    return res;\\n}   \\n```\\n#### Segment Tree\\nWe can use a segment tree to query bitwise XOR of any interval in O(log n).\\n\\n**C++**\\n```cpp\\nint st[2 * (1 << 17)] = {}; // 2 ^ 16 < 100000 < 2 ^ 17\\nclass Solution {\\npublic:\\nint bit_or(int l, int r, int tl, int tr, int p = 1) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr)\\n        return st[p];\\n    int tm = (tl + tr) / 2;\\n    return bit_or(l, min(r, tm), tl, tm, p * 2) | bit_or(max(l, tm + 1), r, tm + 1, tr, p * 2 + 1);\\n}    \\nint build(vector<int>& nums, int tl, int tr, int p = 1) {\\n    if (tl == tr)\\n        return st[p] = nums[tl];\\n    int tm = (tl + tr) / 2;\\n    return st[p] = build(nums, tl, tm, p * 2) | build(nums, tm + 1, tr, p * 2 + 1);\\n}     \\nvector<int> smallestSubarrays(vector<int>& nums) {\\n    vector<int> res;\\n    build(nums, 0, nums.size() - 1);\\n    for (int i = 0, j = 0; i < nums.size(); j = max(++i, j)) {\\n        while (bit_or(i, j, 0, nums.size() - 1) < bit_or(i, nums.size() - 1, 0, nums.size() - 1))\\n            ++j;\\n        res.push_back(j - i + 1);\\n    } \\n    return res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n    vector<int> res(nums.size()), closest(30);\\n    for (int i = nums.size() - 1; i >= 0; --i) {\\n        for (int b = 0; b < 30; ++b)\\n            if (nums[i] & (1 << b))\\n                closest[b] = i;\\n        res[i] = max(1, *max_element(begin(closest), end(closest)) - i + 1);\\n    }\\n    return res;\\n}   \\n```\n```cpp\\nint st[2 * (1 << 17)] = {}; // 2 ^ 16 < 100000 < 2 ^ 17\\nclass Solution {\\npublic:\\nint bit_or(int l, int r, int tl, int tr, int p = 1) {\\n    if (l > r) \\n        return 0;\\n    if (l == tl && r == tr)\\n        return st[p];\\n    int tm = (tl + tr) / 2;\\n    return bit_or(l, min(r, tm), tl, tm, p * 2) | bit_or(max(l, tm + 1), r, tm + 1, tr, p * 2 + 1);\\n}    \\nint build(vector<int>& nums, int tl, int tr, int p = 1) {\\n    if (tl == tr)\\n        return st[p] = nums[tl];\\n    int tm = (tl + tr) / 2;\\n    return st[p] = build(nums, tl, tm, p * 2) | build(nums, tm + 1, tr, p * 2 + 1);\\n}     \\nvector<int> smallestSubarrays(vector<int>& nums) {\\n    vector<int> res;\\n    build(nums, 0, nums.size() - 1);\\n    for (int i = 0, j = 0; i < nums.size(); j = max(++i, j)) {\\n        while (bit_or(i, j, 0, nums.size() - 1) < bit_or(i, nums.size() - 1, 0, nums.size() - 1))\\n            ++j;\\n        res.push_back(j - i + 1);\\n    } \\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588586,
                "title": "java-o-n-31-time-slide-backwards-in-depth-easy-explanation-with-example",
                "content": "Let\\'s take the example of nums = [6,2,1,3,0]\\nIn binary notation, we have:\\nindex - value - binary notation\\n0 - 6 - 110\\n1 - 2 - 010\\n2 - 1 - 001\\n3 - 3 - 011\\n4 - 0 - 000\\n\\nWe can get the maximum bitwise or value for each index by looping from end to start:\\n0 - 7 (111) = 0 | 3 | 1  | 2 | 6\\n1 - 3 (011) = 0 | 3 | 1  | 2\\n2 - 3 (011) = 0 | 3 | 1\\n3 - 3 (011) = 0 | 3 \\n0 - 0 (000) = 0\\n\\nAn initial idea is to, for each index, loop from the index to the end of the array to find the minimum length yielding the value, but that is O(n^2) time, which is the brute-force approach. We want something better.\\n\\nAnother way of looking at the problem is to look at how the bits get set when iterating from a specific index ```i``` to  ```n-1``` (where ```n == nums.length```). Looking at nums:\\nFor index 0 (110), it has to reach index 2 (001) in order to get the rightmost bit set.\\n=> smallest subarray for index 0 is length 2 - 0 + 1 = 3\\n\\nFor index 1 (010), it has to reach index 2 (001) in order to get the rightmost bit set.\\n=> smallest subarray for index 1 is length 2 - 1 + 1 = 2\\n\\nFor index 2 (001), it has to reach index 3 (010) in order to get the 2nd rightmost bit set.\\n=> smallest subarray for index 1 is length 3 - 2 + 1 = 2\\n\\nFor index 3 (011), it has to reach index 3 (011) in order to both the 1st and 2nd rightmost bit set.\\n=> smallest subarray for index 1 is length 3 - 3 + 1 = 1\\n\\nFor index 4 (000), it has no indices to reach.\\n=> smallest subarray for index 1 is length 3 - 3 + 1 = 1\\n\\nWe can then tabulate these \"furthest indices\" by iterating from ```n-1``` to ```0``` and by using array ```store``` to track them. ```store``` has size 31 since each array element represents a binary digit. We update store at index ```j``` on the iteration for index ```i``` when the jth rightmost binary digit of ```nums[i]``` is set (We\\'ll just show the first three elements of ```store``` here for simplicity):\\ni - nums[i] - store[0] store[1] store[2]\\ni = 4 (nums[4] = 000): -1 -1 -1\\ni = 3 (nums[3] = 011): 3 3 -1\\ni = 2 (nums[2] = 001): 2 3 -1\\ni = 1 (nums[1] = 010): 2 1 -1\\ni = 0 (nums[0] = 110): 2 0 0\\n\\nAt iteration ```i```, max(store[0], ..., store[30]) then yields the furthest index we need to reach in order to get the max value.\\nmax(store[0], ..., store[30]) - i + 1 then yields the minimum length needed.\\nAn exception to this is when ```store[0] == ... == store[30] == -1```, then we set the minimum length to 1, since this only happens when the array is full of zeros from index ```i``` onwards.\\nFor the example:\\ni = 4: -1 (-1 means no bits have been set, we don\\'t need nums[j] with j > i to set bits => min length = 1)\\ni = 3: 3 (=> min length = 3 - 3 + 1 = 1)\\ni = 2: 3 (=> min length = 3 - 2 + 1 = 2)\\ni = 1: 2 (=> min length = 2 - 1 + 1 = 2)\\ni = 0: 2 (=> min length = 2 - 0 + 1 = 3)\\n\\nFinally we put all of the above into some Java code:\\n```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        \\n        int[] store = new int[31];\\n        Arrays.fill(store, -1);\\n        for(int i = n-1; i >= 0; --i){\\n            int temp = nums[i];\\n            for(int j = 0; j < 31; ++j){\\n                if((temp & 1) == 1){\\n                    store[j] = i;\\n                }\\n                temp >>= 1;\\n            }\\n            \\n            int maxVal = Integer.MIN_VALUE;\\n            for(int val: store){\\n                maxVal = Math.max(maxVal, val);\\n            }\\n            if(maxVal == -1){\\n                ans[i] = 1;\\n            }else{\\n                ans[i] = maxVal - i + 1;    \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```i```\n```n-1```\n```n == nums.length```\n```n-1```\n```0```\n```store```\n```store```\n```j```\n```i```\n```nums[i]```\n```store```\n```i```\n```store[0] == ... == store[30] == -1```\n```i```\n```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        \\n        int[] store = new int[31];\\n        Arrays.fill(store, -1);\\n        for(int i = n-1; i >= 0; --i){\\n            int temp = nums[i];\\n            for(int j = 0; j < 31; ++j){\\n                if((temp & 1) == 1){\\n                    store[j] = i;\\n                }\\n                temp >>= 1;\\n            }\\n            \\n            int maxVal = Integer.MIN_VALUE;\\n            for(int val: store){\\n                maxVal = Math.max(maxVal, val);\\n            }\\n            if(maxVal == -1){\\n                ans[i] = 1;\\n            }else{\\n                ans[i] = maxVal - i + 1;    \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587930,
                "title": "simple-observation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> bit(32, -1);\\n        vector<int> dp(n, 0);\\n        dp[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--)\\n        {\\n            dp[i] = (dp[i+1]|nums[i]);\\n        }\\n        vector<int> ans;\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            for(int b = 0; b <31; b++)\\n            {\\n                if((nums[i]&(1<<b)))\\n                {\\n                     bit[b] = i;\\n                }\\n            }\\n            int maxi = i;\\n            for(int b = 0; b < 31; b++)\\n            {\\n                if((dp[i]&(1<<b)))\\n                    maxi = max(maxi, bit[b]);\\n            }\\n            ans.push_back(maxi - i + 1);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> bit(32, -1);\\n        vector<int> dp(n, 0);\\n        dp[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--)\\n        {\\n            dp[i] = (dp[i+1]|nums[i]);\\n        }\\n        vector<int> ans;\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            for(int b = 0; b <31; b++)\\n            {\\n                if((nums[i]&(1<<b)))\\n                {\\n                     bit[b] = i;\\n                }\\n            }\\n            int maxi = i;\\n            for(int b = 0; b < 31; b++)\\n            {\\n                if((dp[i]&(1<<b)))\\n                    maxi = max(maxi, bit[b]);\\n            }\\n            ans.push_back(maxi - i + 1);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587929,
                "title": "c-sliding-window-100-faster",
                "content": "**Same as Last Contests**\\nhttps://leetcode.com/problems/longest-nice-subarray/discuss/2527311/c-sliding-window-bit\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n\\tbool check(vector<int> &maxiv , int len , vector<int> &vis) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (maxiv[i] != 0 and vis[i] == 0) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tvoid add(int a , int len , vector<int> &vis) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (((a >> i) & 1) == 1) vis[i]++;\\n\\t\\t}\\n\\t}\\n\\tvoid addmaxi(int a , int len , vector<int> &maxiv) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (((a >> i) & 1) == 1) maxiv[i]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid clear(int a , int len , vector<int> &vis) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (((a >> i) & 1) == 1) vis[i]--;\\n\\t\\t}\\n\\t}\\n\\tvoid clearfrom(int a , int len , vector<int> &maxiv) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (((a >> i) & 1) == 1) maxiv[i]--;\\n\\t\\t}\\n\\t}\\n\\n\\tbool empty(vector<int> &maxiv , int len) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (maxiv[i] != 0) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tvector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        // calc maximum bits in nums\\n        int maxi = 0;\\n        for(auto x : nums) maxi = maxi|x;\\n\\n\\t\\tint n = nums.size() , i =0  , j= 0 , len;\\n\\t\\tif (maxi != 0) len = log2(maxi);\\n\\t\\telse len = 0;\\n\\n\\n\\n\\t\\tvector<int> maxiv(len + 1, 0);\\n\\t\\tfor (auto x : nums) {\\n\\t\\t\\taddmaxi(x, len, maxiv);\\n\\t\\t}\\n\\n\\n\\t\\t// checking visited bits\\n\\t\\tvector<int> vis(len + 1, 0);\\n\\n\\n\\t\\t//returning ans\\n\\t\\tvector<int> ans(n, 0);\\n\\n\\t\\twhile (i < n and j < n) {\\n\\n\\t\\t\\t// maxiv is empty then all elements after is 0\\n\\t\\t\\tif (empty(maxiv, len)) j++;\\n\\n\\n\\t\\t\\t// checking for window\\n\\t\\t\\twhile (!check(maxiv, len, vis) and j < n) {\\n\\t\\t\\t\\tadd(nums[j], len, vis);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\tif (j < n and check(maxiv, len, vis)) {\\n\\t\\t\\t\\tans[i] = j - i;\\n\\t\\t\\t\\tclear(nums[i], len, vis);\\n\\t\\t\\t\\tclearfrom(nums[i], len, maxiv);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\t// remaining last elements which ended at n\\n\\t\\twhile (i < j) {\\n\\t\\t\\tans[i] = j - i;\\n\\t\\t\\tclear(nums[i], len, vis);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool check(vector<int> &maxiv , int len , vector<int> &vis) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (maxiv[i] != 0 and vis[i] == 0) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tvoid add(int a , int len , vector<int> &vis) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (((a >> i) & 1) == 1) vis[i]++;\\n\\t\\t}\\n\\t}\\n\\tvoid addmaxi(int a , int len , vector<int> &maxiv) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (((a >> i) & 1) == 1) maxiv[i]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid clear(int a , int len , vector<int> &vis) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (((a >> i) & 1) == 1) vis[i]--;\\n\\t\\t}\\n\\t}\\n\\tvoid clearfrom(int a , int len , vector<int> &maxiv) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (((a >> i) & 1) == 1) maxiv[i]--;\\n\\t\\t}\\n\\t}\\n\\n\\tbool empty(vector<int> &maxiv , int len) {\\n\\t\\tfor (int i = 0 ; i <= len ; i++) {\\n\\t\\t\\tif (maxiv[i] != 0) return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tvector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        // calc maximum bits in nums\\n        int maxi = 0;\\n        for(auto x : nums) maxi = maxi|x;\\n\\n\\t\\tint n = nums.size() , i =0  , j= 0 , len;\\n\\t\\tif (maxi != 0) len = log2(maxi);\\n\\t\\telse len = 0;\\n\\n\\n\\n\\t\\tvector<int> maxiv(len + 1, 0);\\n\\t\\tfor (auto x : nums) {\\n\\t\\t\\taddmaxi(x, len, maxiv);\\n\\t\\t}\\n\\n\\n\\t\\t// checking visited bits\\n\\t\\tvector<int> vis(len + 1, 0);\\n\\n\\n\\t\\t//returning ans\\n\\t\\tvector<int> ans(n, 0);\\n\\n\\t\\twhile (i < n and j < n) {\\n\\n\\t\\t\\t// maxiv is empty then all elements after is 0\\n\\t\\t\\tif (empty(maxiv, len)) j++;\\n\\n\\n\\t\\t\\t// checking for window\\n\\t\\t\\twhile (!check(maxiv, len, vis) and j < n) {\\n\\t\\t\\t\\tadd(nums[j], len, vis);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\tif (j < n and check(maxiv, len, vis)) {\\n\\t\\t\\t\\tans[i] = j - i;\\n\\t\\t\\t\\tclear(nums[i], len, vis);\\n\\t\\t\\t\\tclearfrom(nums[i], len, maxiv);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\t// remaining last elements which ended at n\\n\\t\\twhile (i < j) {\\n\\t\\t\\tans[i] = j - i;\\n\\t\\t\\tclear(nums[i], len, vis);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861191,
                "title": "python3-8-lines-t-m-92-79",
                "content": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:        \\n\\n        n, ans, bits = len(nums), deque(), defaultdict(int)\\n\\n        for i in range(n)[::-1]:               \\n            I = i\\n\\n            for b in range(31):\\n                if nums[i] & (1 << b): bits[b] = i\\n                elif b in bits and I < bits[b]: I = bits[b] \\n\\n            ans.appendleft(I+1-i)\\n\\n        return list(ans)\\n\\t\\t\\nhttps://leetcode.com/submissions/detail/810617730/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:        \\n\\n        n, ans, bits = len(nums), deque(), defaultdict(int)\\n\\n        for i in range(n)[::-1]:               \\n            I = i\\n\\n            for b in range(31):\\n                if nums[i] & (1 << b): bits[b] = i\\n                elif b in bits and I < bits[b]: I = bits[b] \\n\\n            ans.appendleft(I+1-i)\\n\\n        return list(ans)\\n\\t\\t\\nhttps://leetcode.com/submissions/detail/810617730/",
                "codeTag": "Java"
            },
            {
                "id": 2594397,
                "title": "c-bit-wise-index-transform-from-back-fast-100-116ms",
                "content": "### Solution 1: index per bit, transform from the back\\n\\nFor each bit we keep track of the \"nearst\" index at which it is set and if we scan from the back we can rewrite ```nums``` as we go.\\n\\n```\\n    static vector<int> smallestSubarrays(vector<int>& nums) {\\n        array<int, 30> idx = {};\\n        for (int i = size(nums) - 1; i >= 0; --i) {\\n            const int num = nums[i];\\n            for (int j = 0; j < size(idx); ++j) {\\n                if (num & (1 << j)) {\\n                    idx[j] = i;\\n                }\\n            }\\n            const int mx = *max_element(begin(idx), end(idx));\\n            nums[i] = max(mx, i) - i + 1;\\n        }\\n        return nums;\\n    }\\n```\\n\\n_As always: Feedback, comments, and questions are welcome. Please upvote if you like the post._",
                "solutionTags": [],
                "code": "```nums```\n```\\n    static vector<int> smallestSubarrays(vector<int>& nums) {\\n        array<int, 30> idx = {};\\n        for (int i = size(nums) - 1; i >= 0; --i) {\\n            const int num = nums[i];\\n            for (int j = 0; j < size(idx); ++j) {\\n                if (num & (1 << j)) {\\n                    idx[j] = i;\\n                }\\n            }\\n            const int mx = *max_element(begin(idx), end(idx));\\n            nums[i] = max(mx, i) - i + 1;\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588576,
                "title": "c-solution-using-fenwink-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int N=1e5+10;\\n    int bit[100005];\\n    void update(int i,int val)\\n    {\\n        i++;\\n        while(i<N)\\n        {\\n            bit[i]|=val;\\n            i+=(i&-i);\\n        }\\n    }\\n    int find(int i)\\n    {\\n        i++;\\n        int sum=0;\\n        while(i>0)\\n        {\\n            sum|=bit[i];\\n            i-=(i&-i);\\n        }\\n        return sum;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int>ans(n,0);\\n        int total=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            total|=nums[i];\\n            update(i,nums[i]);\\n            int l=i;\\n            int r=n-1;\\n            int index=n-1;\\n            while(l<=r)\\n            {\\n                int mid=(l+r)/2;\\n                if(find(mid)==total)\\n                {\\n                    index=mid;\\n                    r=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            ans[i]=(index-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N=1e5+10;\\n    int bit[100005];\\n    void update(int i,int val)\\n    {\\n        i++;\\n        while(i<N)\\n        {\\n            bit[i]|=val;\\n            i+=(i&-i);\\n        }\\n    }\\n    int find(int i)\\n    {\\n        i++;\\n        int sum=0;\\n        while(i>0)\\n        {\\n            sum|=bit[i];\\n            i-=(i&-i);\\n        }\\n        return sum;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int>ans(n,0);\\n        int total=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            total|=nums[i];\\n            update(i,nums[i]);\\n            int l=i;\\n            int r=n-1;\\n            int index=n-1;\\n            while(l<=r)\\n            {\\n                int mid=(l+r)/2;\\n                if(find(mid)==total)\\n                {\\n                    index=mid;\\n                    r=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            ans[i]=(index-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587986,
                "title": "c-binary-search-segtree",
                "content": "First, precompute the maximum for each subarray starting at `i`.\\nThen, initialize an OR segtree.\\nFinally, for each `i`, binary search for the length and verify `mid` using the segtree.\\n```\\ntemplate<class T>\\nclass stt{\\n\\tpublic:\\n\\tvector<T> t;\\n\\tint n;\\n\\tstt(int _n, vector<int>& a){\\n\\t\\tn = _n;\\n\\t\\tt = vector<T>(2*n, 0);\\n\\t\\tfor(int i=0;i< n;i++) t[n+i] = a[i];\\n\\t\\tfor (int i = n - 1; i > 0; --i) t[i] = t[i<<1] | t[i<<1|1];\\n\\t}\\n\\tT query(int l, int r){\\n\\t\\tT res = 0;\\n\\t\\tfor(l+=n, r+=n; l < r; l>>=1, r>>=1){\\n\\t\\t\\tif(l&1) res |= t[l++];\\n\\t\\t\\tif(r&1) res |= t[--r];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int ma[n];\\n        int cur = 0;\\n        for (int i = n-1; i >= 0; i--){cur |= nums[i]; ma[i] = cur;}\\n        \\n        vector<int> re(n);\\n        stt<int> st(n, nums);\\n        for(int i = 0; i < n; i ++){\\n            int l = 1, r = n-i;\\n            while(l<r){\\n                int mid = (l+r)/2;\\n                int cure = st.query(i, i+mid);\\n                if(cure == ma[i]) r = mid;\\n                else l = mid+1;\\n            }\\n            re[i] = l;\\n        }            \\n        return re;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\ntemplate<class T>\\nclass stt{\\n\\tpublic:\\n\\tvector<T> t;\\n\\tint n;\\n\\tstt(int _n, vector<int>& a){\\n\\t\\tn = _n;\\n\\t\\tt = vector<T>(2*n, 0);\\n\\t\\tfor(int i=0;i< n;i++) t[n+i] = a[i];\\n\\t\\tfor (int i = n - 1; i > 0; --i) t[i] = t[i<<1] | t[i<<1|1];\\n\\t}\\n\\tT query(int l, int r){\\n\\t\\tT res = 0;\\n\\t\\tfor(l+=n, r+=n; l < r; l>>=1, r>>=1){\\n\\t\\t\\tif(l&1) res |= t[l++];\\n\\t\\t\\tif(r&1) res |= t[--r];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int ma[n];\\n        int cur = 0;\\n        for (int i = n-1; i >= 0; i--){cur |= nums[i]; ma[i] = cur;}\\n        \\n        vector<int> re(n);\\n        stt<int> st(n, nums);\\n        for(int i = 0; i < n; i ++){\\n            int l = 1, r = n-i;\\n            while(l<r){\\n                int mid = (l+r)/2;\\n                int cure = st.query(i, i+mid);\\n                if(cure == ma[i]) r = mid;\\n                else l = mid+1;\\n            }\\n            re[i] = l;\\n        }            \\n        return re;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587973,
                "title": "simple-map-and-set-that-s-it",
                "content": "```\\n// well idea to keep track of all the index array where \\n// jth bit( where j is from 0 to 30)  is set\\n// now while traversing through the array\\n// just check if jth bit is 0 if yes then find the next\\n// closest index where jth bit is 1\\n// similary check from all jth bits(0-30)\\n// and out of all furthest is our answer\\n// if jth bit is already 1 then we don\\'t need to do anything\\n\\n vector<int> smallestSubarrays(vector<int>& nums) \\n    {\\n        vector<int>bits(32,0);\\n        int n = nums.size();\\n        vector<int>ans;\\n        map<int,int> mp;\\n        map<int,set<int>> mset;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<31;j++)\\n            {\\n                if(nums[i]&((int)pow(2,j)))\\n                {\\n                    mp[j]++;\\n                    mset[j].insert(i);\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int idx =i;\\n            for(int j=30;j>=0;j--)\\n            {\\n                if(mp.find(j)!=mp.end() && (nums[i]&((int)pow(2,j)))==0)\\n                    idx = max(idx,*(mset[j].begin()));\\n                \\n                else if(nums[i]&((int)pow(2,j)))\\n                    mset[j].erase(i);\\n                \\n            }\\n            ans.push_back(idx-i+1);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\n// well idea to keep track of all the index array where \\n// jth bit( where j is from 0 to 30)  is set\\n// now while traversing through the array\\n// just check if jth bit is 0 if yes then find the next\\n// closest index where jth bit is 1\\n// similary check from all jth bits(0-30)\\n// and out of all furthest is our answer\\n// if jth bit is already 1 then we don\\'t need to do anything\\n\\n vector<int> smallestSubarrays(vector<int>& nums) \\n    {\\n        vector<int>bits(32,0);\\n        int n = nums.size();\\n        vector<int>ans;\\n        map<int,int> mp;\\n        map<int,set<int>> mset;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<31;j++)\\n            {\\n                if(nums[i]&((int)pow(2,j)))\\n                {\\n                    mp[j]++;\\n                    mset[j].insert(i);\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int idx =i;\\n            for(int j=30;j>=0;j--)\\n            {\\n                if(mp.find(j)!=mp.end() && (nums[i]&((int)pow(2,j)))==0)\\n                    idx = max(idx,*(mset[j].begin()));\\n                \\n                else if(nums[i]&((int)pow(2,j)))\\n                    mset[j].erase(i);\\n                \\n            }\\n            ans.push_back(idx-i+1);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587963,
                "title": "python-3-binary-search-solution-with-intuition-and-steps",
                "content": "\\n### Intuitition:\\nWhile applying bitwise OR on an array from the beginning to the end, once a bit is set to 1, it will not be set back to 0 anymore, as `1|?=1`. \\n\\nTo find the smallest length array with maximum bitwise OR sum. we only need to find the first occurrence of the number since each index in the array with bit = 1 for each bit \\n\\n### Detailed Steps:\\n- Limit in the problem indicates that each number n <= 10^9 which menas that n < 2^30 and there are at most 30 bits for numbers in the array.\\n- For each bit, create a list to record the index of numbers in the array which has this bit equals to 1 `(n >> bit) % 2 == 1`. For example, for [0, 1, 3, 2], the index array for bit 0 is  [0, 2] and the index array for bit 1 is [2.3].  This step has `Complexity =  O(n * k)` where k = 30 in this problem.\\n- For each index i in the number list, for each bit, find the first occurrence index of a number with this bit equals to 1. Put these occurrence index in the list IND. The smallest length array for index i is `max(IND) - i + 1`. For example,` for [1, 0, 3, 2], i = 1`, when i = 0, IND = [0, 2] and the result array should have `length = 2 - 0 + 1 = 3`, which is [1, 0, 3]. This step has` Complexity = O(nlogn * k)`\\n\\n\\n### Solution:\\n```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        maximum_bits = int(log(10**9, 2)) + 1\\n        index_for_each_bit = [[] for _ in range(maximum_bits)]\\n        # Create lists to record the index of numbers in the array with each bit = 1\\n        for i in range(len(nums)):\\n            n = nums[i]\\n            for bit in range(maximum_bits):\\n                if n % 2 == 1:\\n                    index_for_each_bit[bit].append(i)\\n                n >>= 1\\n\\n        res = []\\n        for i in range(len(nums)):\\n            cur_idx = [i]\\n            n = nums[i]\\n            # Find the first occurrence index of the number with each bit equals to 1\\n            for bit in range(maximum_bits):\\n                bit_index = index_for_each_bit[bit]\\n                if n % 2 == 0:\\n                    k = bisect_left(bit_index, i)\\n                    if k < len(bit_index):\\n                       cur_idx.append(bit_index[k])\\n                n >>= 1\\n            res.append(max(cur_idx) - i + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        maximum_bits = int(log(10**9, 2)) + 1\\n        index_for_each_bit = [[] for _ in range(maximum_bits)]\\n        # Create lists to record the index of numbers in the array with each bit = 1\\n        for i in range(len(nums)):\\n            n = nums[i]\\n            for bit in range(maximum_bits):\\n                if n % 2 == 1:\\n                    index_for_each_bit[bit].append(i)\\n                n >>= 1\\n\\n        res = []\\n        for i in range(len(nums)):\\n            cur_idx = [i]\\n            n = nums[i]\\n            # Find the first occurrence index of the number with each bit equals to 1\\n            for bit in range(maximum_bits):\\n                bit_index = index_for_each_bit[bit]\\n                if n % 2 == 0:\\n                    k = bisect_left(bit_index, i)\\n                    if k < len(bit_index):\\n                       cur_idx.append(bit_index[k])\\n                n >>= 1\\n            res.append(max(cur_idx) - i + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587898,
                "title": "c-suffix-array-for-bits-for-storing-bits-position-accepted",
                "content": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        \\n        vector<int> temp = nums;\\n        int n=nums.size();\\n        \\n        \\n        vector<int> ans(n,-1);\\n        vector<vector<int>> bits(32,vector<int>(n,n));\\n        \\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            \\n            for(int j=n-1;j>=0;j--){\\n                \\n                if(((nums[j] >> i)&1) == 1){\\n                    bits[i][j] = j;\\n                }else{\\n                    if(j!=(n-1))bits[i][j] = bits[i][j+1];\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        for(int j=0;j<n-1;j++)\\n        {\\n            int len=INT_MIN;\\n            for(int i=0;i<32;i++)\\n            {\\n                if(bits[i][j+1]!=n){\\n                    len=max(len,bits[i][j]);\\n                }\\n            }\\n            \\n            if(len!=INT_MIN){\\n                ans[j]=len-j+1;\\n            }else{\\n                ans[j]=1;\\n            }\\n        }\\n        ans[n-1]=1;\\n        \\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        \\n        vector<int> temp = nums;\\n        int n=nums.size();\\n        \\n        \\n        vector<int> ans(n,-1);\\n        vector<vector<int>> bits(32,vector<int>(n,n));\\n        \\n        \\n        for(int i=0;i<32;i++)\\n        {\\n            \\n            for(int j=n-1;j>=0;j--){\\n                \\n                if(((nums[j] >> i)&1) == 1){\\n                    bits[i][j] = j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2587880,
                "title": "c-binary-search-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int sz=nums.size();\\n        vector<vector<int>>arr(31);\\n        int j=0;\\n        // arr[i] will store the indices of values in which ith bit is on\\n        for(auto & ele:nums){\\n            for(int i=0;i<31;i++){\\n                if((ele>>i)&1)\\n                    arr[i].push_back(j);\\n            }\\n            j++;\\n        }\\n        // suf[i] will store maximum or starting at this index\\n        vector<int>suf=nums;\\n        for(int i=sz-2;i>=0;i--)\\n            suf[i]=nums[i]|suf[i+1];\\n        vector<int>ans(sz,0);\\n        for(int i=0;i<sz;i++){\\n            // assume max OR value starting at this index is \"x\", then we will check if \"kth\" bit is on or off,\\n            // if its on then we want to find the minimum greater index which can set its bit on,we are doing this using binary search.\\n            int res=1;\\n            for(int k=0;k<31;k++){\\n                if((suf[i]>>k)&1){\\n                    auto it=lower_bound(begin(arr[k]),end(arr[k]),i);\\n                    int len=(*it)-i+1;\\n                    res=max(res,len);\\n                }\\n            }\\n            ans[i]=res;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** is it helps:)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int sz=nums.size();\\n        vector<vector<int>>arr(31);\\n        int j=0;\\n        // arr[i] will store the indices of values in which ith bit is on\\n        for(auto & ele:nums){\\n            for(int i=0;i<31;i++){\\n                if((ele>>i)&1)\\n                    arr[i].push_back(j);\\n            }\\n            j++;\\n        }\\n        // suf[i] will store maximum or starting at this index\\n        vector<int>suf=nums;\\n        for(int i=sz-2;i>=0;i--)\\n            suf[i]=nums[i]|suf[i+1];\\n        vector<int>ans(sz,0);\\n        for(int i=0;i<sz;i++){\\n            // assume max OR value starting at this index is \"x\", then we will check if \"kth\" bit is on or off,\\n            // if its on then we want to find the minimum greater index which can set its bit on,we are doing this using binary search.\\n            int res=1;\\n            for(int k=0;k<31;k++){\\n                if((suf[i]>>k)&1){\\n                    auto it=lower_bound(begin(arr[k]),end(arr[k]),i);\\n                    int len=(*it)-i+1;\\n                    res=max(res,len);\\n                }\\n            }\\n            ans[i]=res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550671,
                "title": "c-simple-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v1,int &x){\\n        for(int i = 0; i <=31; i++){\\n            if(!v1[i] && (x&(1<<i))){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)return {1};\\n        vector<int> v1(32,0);\\n        int i = 0, j = 0,k;\\n        vector<int> ans;\\n        vector<int> v2(n);\\n        v2[n-1] = nums[n-1];\\n        for(i = n-2; i >= 0; i--){\\n            v2[i] = (nums[i]|v2[i+1]);\\n        }\\n        // for(auto &i: v2)cout<<i<<\" \";\\n        i = 0, j = 0;\\n        while(i<n){\\n            if(v2[i]==0){\\n                ans.push_back(1);\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            while(j<n && check(v1,v2[i])){\\n                for(k = 0; k <= 31; k++){\\n                    if(nums[j]&(1<<k)){\\n                        v1[k]++;\\n                    }\\n                }\\n                j++;\\n            }\\n            ans.push_back(j-i);\\n            for(k = 0; k <= 31; k++){\\n                if(nums[i]&(1<<k)){\\n                    v1[k]--;\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v1,int &x){\\n        for(int i = 0; i <=31; i++){\\n            if(!v1[i] && (x&(1<<i))){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)return {1};\\n        vector<int> v1(32,0);\\n        int i = 0, j = 0,k;\\n        vector<int> ans;\\n        vector<int> v2(n);\\n        v2[n-1] = nums[n-1];\\n        for(i = n-2; i >= 0; i--){\\n            v2[i] = (nums[i]|v2[i+1]);\\n        }\\n        // for(auto &i: v2)cout<<i<<\" \";\\n        i = 0, j = 0;\\n        while(i<n){\\n            if(v2[i]==0){\\n                ans.push_back(1);\\n                i++;\\n                j++;\\n                continue;\\n            }\\n            while(j<n && check(v1,v2[i])){\\n                for(k = 0; k <= 31; k++){\\n                    if(nums[j]&(1<<k)){\\n                        v1[k]++;\\n                    }\\n                }\\n                j++;\\n            }\\n            ans.push_back(j-i);\\n            for(k = 0; k <= 31; k++){\\n                if(nums[i]&(1<<k)){\\n                    v1[k]--;\\n                }\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2588459,
                "title": "easy-bit-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int> &nums) {\\n        int n = nums.size();\\n        vector<int> res, bit(32, -1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            int idx = i;\\n            for (int j = 0; j < 32; j++) {\\n                if (nums[i] & (1 << j)) bit[j] = i;\\n                idx = max(idx, bit[j]);\\n            }\\n            res.push_back(idx - i + 1);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int> &nums) {\\n        int n = nums.size();\\n        vector<int> res, bit(32, -1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            int idx = i;\\n            for (int j = 0; j < 32; j++) {\\n                if (nums[i] & (1 << j)) bit[j] = i;\\n                idx = max(idx, bit[j]);\\n            }\\n            res.push_back(idx - i + 1);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588233,
                "title": "tracking-first-occurrence-of-each-set-bit",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<set<int>> bits_occurances(32);\\n        for(int i=0;i<32;i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] & (1<<i)) bits_occurances[i].insert(j);\\n            }\\n        }\\n        int n=nums.size();\\n        vector<int> ans(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                if(bits_occurances[j].size()>0){\\n                    auto it=bits_occurances[j].begin();\\n                    ans[i]= max(ans[i],(*it) - i +1);\\n                    if(*it==i) bits_occurances[j].erase(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<set<int>> bits_occurances(32);\\n        for(int i=0;i<32;i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] & (1<<i)) bits_occurances[i].insert(j);\\n            }\\n        }\\n        int n=nums.size();\\n        vector<int> ans(n,1);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                if(bits_occurances[j].size()>0){\\n                    auto it=bits_occurances[j].begin();\\n                    ans[i]= max(ans[i],(*it) - i +1);\\n                    if(*it==i) bits_occurances[j].erase(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604114,
                "title": "c-o-n-32-bits-manipulation",
                "content": "**C++ Code:**\\n\\n```\\n bool check(int &i,int &j,vector<vector<int>>&arr){\\n       for(int k=0;k<32;k++){\\n         if(arr[i][k]!=0 && arr[i][k]<=arr[j][k]){\\n             return false;\\n         }\\n     }\\n      return true;  \\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n     int n = nums.size();\\n     vector<vector<int>>arr(n,vector<int>(32,0));\\n        \\n      // decimal to binary conversion   \\n     for(int i=0;i<n;i++){\\n         int a = nums[i];\\n         int j = 31;\\n         while(a>0){\\n             if(a%2!=0) arr[i][j] = 1;\\n             j--;\\n             a = a/2;\\n         }\\n     }\\n        \\n     // calculating prefix sum\\n     for(int i=n-2;i>=0;i--){\\n         for(int j=0;j<32;j++){\\n             arr[i][j] += arr[i+1][j];\\n        }\\n     } \\n     \\n     vector<int>ans(n);\\n     ans[n-1]=1;\\n     int j=n-1;\\n     for(int i=n-2;i>=0;i--){\\n       while(i<j && check(i,j,arr)){\\n           j--;\\n       }\\n       cout<<j<<\" \";\\n        ans[i] = j-i+1;\\n     }\\n     return ans;   \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n bool check(int &i,int &j,vector<vector<int>>&arr){\\n       for(int k=0;k<32;k++){\\n         if(arr[i][k]!=0 && arr[i][k]<=arr[j][k]){\\n             return false;\\n         }\\n     }\\n      return true;  \\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n     int n = nums.size();\\n     vector<vector<int>>arr(n,vector<int>(32,0));\\n        \\n      // decimal to binary conversion   \\n     for(int i=0;i<n;i++){\\n         int a = nums[i];\\n         int j = 31;\\n         while(a>0){\\n             if(a%2!=0) arr[i][j] = 1;\\n             j--;\\n             a = a/2;\\n         }\\n     }\\n        \\n     // calculating prefix sum\\n     for(int i=n-2;i>=0;i--){\\n         for(int j=0;j<32;j++){\\n             arr[i][j] += arr[i+1][j];\\n        }\\n     } \\n     \\n     vector<int>ans(n);\\n     ans[n-1]=1;\\n     int j=n-1;\\n     for(int i=n-2;i>=0;i--){\\n       while(i<j && check(i,j,arr)){\\n           j--;\\n       }\\n       cout<<j<<\" \";\\n        ans[i] = j-i+1;\\n     }\\n     return ans;   \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2592689,
                "title": "java-simple",
                "content": "Step 1--> Firstly we have to check how many bits are set , it can be 1 ,2 ,3 or more .\\nwe all know the table of bitwise OR\\n0  0--> 0\\n1  1-->1\\n1  0-->1\\n1  1-->1\\nFrom here we can easily conclude that by adding more and more elements the value will remain equal  or can be increase \\nTake an Example -> [1,0,2,1,3]\\ncorresponding binary -->\\n[01, 0, 10, 01, 11]\\n0    1   2   3     4 index \\nNow , execution of step 1\\nno of bits      |    index\\n1  ->             |         0,3,4\\n2  ->             |          2,4\\n3 ->\\n4 ->\\n5 ->\\nHere we have to get the max from 0 ,2     here we get  2 so  its the no. of bits are set we dont have to go further.\\nWe can use TreeSet or PriorityQueue that will ultimately gives the maximum and then simply traverse the DS and get the maximum bit wise XOR of the smallest subarray .\\n```\\nclass Solution {\\n\\n    public int[] smallestSubarrays(int[] nums) {\\n        TreeSet<Integer>[] sys = new TreeSet[32];\\n        for (int i = 0; i < 32; i++) sys[i] = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < 32; j++) {\\n                if ((nums[i] >> j & 1) == 1) sys[j].add(i);\\n            }\\n        }\\n        int ans[] = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int max = i;\\n            for (TreeSet<Integer> set : sys) {\\n                if (!set.isEmpty()) {\\n                    max = Math.max(max, set.first());\\n                    set.remove(i);\\n                }\\n            }\\n            ans[i] = (max - i + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] smallestSubarrays(int[] nums) {\\n        TreeSet<Integer>[] sys = new TreeSet[32];\\n        for (int i = 0; i < 32; i++) sys[i] = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < 32; j++) {\\n                if ((nums[i] >> j & 1) == 1) sys[j].add(i);\\n            }\\n        }\\n        int ans[] = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int max = i;\\n            for (TreeSet<Integer> set : sys) {\\n                if (!set.isEmpty()) {\\n                    max = Math.max(max, set.first());\\n                    set.remove(i);\\n                }\\n            }\\n            ans[i] = (max - i + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588194,
                "title": "javascript",
                "content": "```\\nvar smallestSubarrays = function (nums) {\\n  const n = nums.length;\\n\\n  const res = Array(n).fill(0);\\n\\n  const last = Array(32).fill(0);\\n\\n  for (let i = n - 1; i >= 0; i--) {\\n    res[i] = 1;\\n\\n    for (let j = 0; j < 32; j++) {\\n      if (nums[i] & (1 << j)) {\\n        last[j] = i;\\n      }\\n      res[i] = Math.max(res[i], last[j] - i + 1);\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallestSubarrays = function (nums) {\\n  const n = nums.length;\\n\\n  const res = Array(n).fill(0);\\n\\n  const last = Array(32).fill(0);\\n\\n  for (let i = n - 1; i >= 0; i--) {\\n    res[i] = 1;\\n\\n    for (let j = 0; j < 32; j++) {\\n      if (nums[i] & (1 << j)) {\\n        last[j] = i;\\n      }\\n      res[i] = Math.max(res[i], last[j] - i + 1);\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588186,
                "title": "super-weird",
                "content": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int max[]=new int[33],i,j=-1,arr[]=new int[33],n=nums.length,x=0, res[]= new int[n];\\n        for(int num: nums){\\n            x=x|num;\\n        }\\n        or(max,x,1);\\n        for(i=0;i<n;i++){\\n            while(j<n && !isEqual(arr,max)){\\n                j++;\\n                if(j<n) or(arr,nums[j],1);\\n                if(j==n){\\n                    for(int lp=0;lp<33;lp++){\\n                        max[lp]=arr[lp];\\n                        arr[lp]=0;\\n                    }\\n                    j=i-1;\\n                }\\n            }\\n            res[i]=Math.max(j-i+1,1);\\n            if(j==n) res[i]--;\\n            or(arr,nums[i],-1);\\n        }\\n        return res;\\n    }\\n    boolean isEqual(int arr[], int max[]){\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]*max[i]==0 && arr[i]+max[i]!=0)return false;\\n        }\\n        return true;\\n    }\\n    void or(int arr[], int num, int val){\\n        int i=0;\\n        while(num>0){\\n            if((num&1)==1){\\n                arr[i]+=val;\\n            }\\n            i++;\\n            num=num>>1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int max[]=new int[33],i,j=-1,arr[]=new int[33],n=nums.length,x=0, res[]= new int[n];\\n        for(int num: nums){\\n            x=x|num;\\n        }\\n        or(max,x,1);\\n        for(i=0;i<n;i++){\\n            while(j<n && !isEqual(arr,max)){\\n                j++;\\n                if(j<n) or(arr,nums[j],1);\\n                if(j==n){\\n                    for(int lp=0;lp<33;lp++){\\n                        max[lp]=arr[lp];\\n                        arr[lp]=0;\\n                    }\\n                    j=i-1;\\n                }\\n            }\\n            res[i]=Math.max(j-i+1,1);\\n            if(j==n) res[i]--;\\n            or(arr,nums[i],-1);\\n        }\\n        return res;\\n    }\\n    boolean isEqual(int arr[], int max[]){\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]*max[i]==0 && arr[i]+max[i]!=0)return false;\\n        }\\n        return true;\\n    }\\n    void or(int arr[], int num, int val){\\n        int i=0;\\n        while(num>0){\\n            if((num&1)==1){\\n                arr[i]+=val;\\n            }\\n            i++;\\n            num=num>>1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588184,
                "title": "easy-o-n-32-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int[] map = new int[32];\\n        int[] res = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int num = nums[i];\\n            for (int j = 0; j <= 31; j++) {\\n                int mask = 1 << (j);\\n                if ((num & mask) > 0) {\\n                    map[j] = i;\\n                }\\n            }\\n            \\n            int max = i;\\n            for (int e : map) max = Math.max(e, max);\\n            res[i] = max - i + 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int[] map = new int[32];\\n        int[] res = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            int num = nums[i];\\n            for (int j = 0; j <= 31; j++) {\\n                int mask = 1 << (j);\\n                if ((num & mask) > 0) {\\n                    map[j] = i;\\n                }\\n            }\\n            \\n            int max = i;\\n            for (int e : map) max = Math.max(e, max);\\n            res[i] = max - i + 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588093,
                "title": "overkill-used-segment-trees-binary-search-c",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass segTree {\\n  private:\\n    vector<int> tree, arr;\\n    int n;\\n\\n    void build(int index, int low, int high)\\n    {\\n        if (low == high) {\\n            tree[index] = arr[low];\\n            return;\\n        }\\n\\n        int mid = (low + high) >> 1;\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n\\n        build(left, low, mid);\\n        build(right, mid + 1, high);\\n\\n        tree[index] = tree[left] | tree[right];\\n    }\\n\\n    void updateUtil(int index, int low, int high, int pos, int val)\\n    {\\n        if (low == high) {\\n            tree[index] = val;\\n            return;\\n        }\\n\\n        int mid = (low + high) >> 1;\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n\\n        if (pos <= mid)\\n            updateUtil(left, low, mid, pos, val);\\n        else\\n            updateUtil(right, mid + 1, high, pos, val);\\n\\n        tree[index] = tree[left] + tree[right];\\n    }\\n\\n    int queryUtil(int index, int low, int high, int qLeft, int qRight)\\n    {\\n        // (qLeft, qRight) [low, high] (qLeft, qRight)\\n\\n        if (qRight < low || high < qLeft) {\\n            return 0;\\n        }\\n\\n        // (qLeft (low, right) qRight)\\n        if (qLeft <= low and high <= qRight) {\\n            return tree[index];\\n        }\\n\\n        int mid = (low + high) >> 1;\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n\\n        int LeftSum = queryUtil(left, low, mid, qLeft, qRight);\\n        int RightSum = queryUtil(right, mid + 1, high, qLeft, qRight);\\n\\n        return LeftSum | RightSum;\\n    }\\n\\n  public:\\n    segTree(vector<int> &nums)\\n    {\\n        this->n = nums.size();\\n        this->arr = nums;\\n        tree.resize(4 * n + 1);\\n\\n        build(0, 0, n - 1);\\n    }\\n\\n    void update(int index, int val)\\n    {\\n        updateUtil(0, 0, n - 1, index, val);\\n    }\\n\\n    int query(int left, int right)\\n    {\\n        return queryUtil(0, 0, n - 1, left, right);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        segTree sgt(nums);\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            int l = i, r = n - 1;\\n            int mx = sgt.query(i, n - 1);\\n            \\n            int ind = n - 1;\\n            while(l <= r) {\\n                int mid = (l + r) / 2;\\n                \\n                if ((nums[i] | sgt.query(i, mid)) == mx) {\\n                    ind = mid;\\n                    r = mid - 1;\\n                }\\n                else {\\n                    l = mid + 1;\\n                }\\n            }\\n            \\n            ans.push_back(ind - i + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/7cf7a50a-0e63-4fa5-8a65-5dd03c532ca5_1663483306.2416594.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nclass segTree {\\n  private:\\n    vector<int> tree, arr;\\n    int n;\\n\\n    void build(int index, int low, int high)\\n    {\\n        if (low == high) {\\n            tree[index] = arr[low];\\n            return;\\n        }\\n\\n        int mid = (low + high) >> 1;\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n\\n        build(left, low, mid);\\n        build(right, mid + 1, high);\\n\\n        tree[index] = tree[left] | tree[right];\\n    }\\n\\n    void updateUtil(int index, int low, int high, int pos, int val)\\n    {\\n        if (low == high) {\\n            tree[index] = val;\\n            return;\\n        }\\n\\n        int mid = (low + high) >> 1;\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n\\n        if (pos <= mid)\\n            updateUtil(left, low, mid, pos, val);\\n        else\\n            updateUtil(right, mid + 1, high, pos, val);\\n\\n        tree[index] = tree[left] + tree[right];\\n    }\\n\\n    int queryUtil(int index, int low, int high, int qLeft, int qRight)\\n    {\\n        // (qLeft, qRight) [low, high] (qLeft, qRight)\\n\\n        if (qRight < low || high < qLeft) {\\n            return 0;\\n        }\\n\\n        // (qLeft (low, right) qRight)\\n        if (qLeft <= low and high <= qRight) {\\n            return tree[index];\\n        }\\n\\n        int mid = (low + high) >> 1;\\n        int left = 2 * index + 1;\\n        int right = 2 * index + 2;\\n\\n        int LeftSum = queryUtil(left, low, mid, qLeft, qRight);\\n        int RightSum = queryUtil(right, mid + 1, high, qLeft, qRight);\\n\\n        return LeftSum | RightSum;\\n    }\\n\\n  public:\\n    segTree(vector<int> &nums)\\n    {\\n        this->n = nums.size();\\n        this->arr = nums;\\n        tree.resize(4 * n + 1);\\n\\n        build(0, 0, n - 1);\\n    }\\n\\n    void update(int index, int val)\\n    {\\n        updateUtil(0, 0, n - 1, index, val);\\n    }\\n\\n    int query(int left, int right)\\n    {\\n        return queryUtil(0, 0, n - 1, left, right);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        segTree sgt(nums);\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            int l = i, r = n - 1;\\n            int mx = sgt.query(i, n - 1);\\n            \\n            int ind = n - 1;\\n            while(l <= r) {\\n                int mid = (l + r) / 2;\\n                \\n                if ((nums[i] | sgt.query(i, mid)) == mx) {\\n                    ind = mid;\\n                    r = mid - 1;\\n                }\\n                else {\\n                    l = mid + 1;\\n                }\\n            }\\n            \\n            ans.push_back(ind - i + 1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2605209,
                "title": "closest-bit-o-n-c",
                "content": "Remember the last position you saw a \\'1\\' for each bit in 32 bits int.\\nFor each element find the idx you found the \\'1\\' that it furthest appart. That is the minimum length of the array.\\n\\n```\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\n\\tvector<int> ans(n);\\n\\n\\tunordered_map<int,int> idx;\\n\\tfor (int i = 0; i < 32; ++i) {\\n\\t\\tidx[1 << i] = n;\\n\\t}\\n\\n\\tfor (int i = n - 1, m = 0, j = 0; i >= 0; --i) {\\n\\t\\tj = i;\\n\\t\\tm |= nums[i];\\n\\t\\tfor (int num = m; num; ) {\\n\\t\\t\\tint lsb = (num & -num);\\n\\t\\t\\tif (nums[i] & lsb) idx[lsb] = i; // closest satisfied                \\n\\t\\t\\tj = max(j, idx[lsb]); // furthest j\\n\\t\\t\\tnum ^= lsb; // flip\\n\\t\\t}\\n\\t\\tans[i] = j - i + 1;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\n\\tvector<int> ans(n);\\n\\n\\tunordered_map<int,int> idx;\\n\\tfor (int i = 0; i < 32; ++i) {\\n\\t\\tidx[1 << i] = n;\\n\\t}\\n\\n\\tfor (int i = n - 1, m = 0, j = 0; i >= 0; --i) {\\n\\t\\tj = i;\\n\\t\\tm |= nums[i];\\n\\t\\tfor (int num = m; num; ) {\\n\\t\\t\\tint lsb = (num & -num);\\n\\t\\t\\tif (nums[i] & lsb) idx[lsb] = i; // closest satisfied                \\n\\t\\t\\tj = max(j, idx[lsb]); // furthest j\\n\\t\\t\\tnum ^= lsb; // flip\\n\\t\\t}\\n\\t\\tans[i] = j - i + 1;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2598845,
                "title": "rust-26-ms-fastest-100-one-pass-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/810097381/) employs a one-pass algorithm to update first-occurence positions of bits. It demonstrated **26 ms runtime (100.00%)** and used **3.5 MB memory (80.29%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn smallest_subarrays(nums: Vec<i32>) -> Vec<i32> \\n    {\\n        let mut ret: Vec<i32> = vec![1;nums.len()];\\n        \\n        // [1] when performing OR operation on an array, \\n        //     we care only about the first occurence of each bit,\\n        //     because all subsequent occurences do not change the result;\\n        //     thus, we should arrange a storage \\'bit_idx\\' for the positions of \\n        //     the first occurence of each bit; \\n        let mut bit_idx: [i32;30] = [0;30];\\n\\n        let mut max_pos : i32;\\n        let mut bit     : i32;\\n        \\n        // [2] for a one-pass solution, we iterate over \\'nums\\' from the end;\\n        //     this allows us to dynamically update the first occurence of bits;\\n        //     terminal zeros are skipped, their respective minimal subarray size is 1\\n        for (pos, &n) in nums.iter().enumerate().rev().skip_while(|(_,n)| **n == 0)\\n        {\\n            // [3] for each bit, update the earliest/first position it was seen at;\\n            //     here we use an arithmetic way to update \\'bit_idx\\',\\n            //     use of conditional statement is slower\\n            for b in 0..30\\n            {\\n                bit = (n >> b) & 1;\\n                bit_idx[b] = (1 - bit) * bit_idx[b] + bit * (pos as i32);\\n            }\\n\\n            // [4] minimal subarray/window is the one that accounts for all bits\\n            //     that were seen at least once \\n            max_pos = *bit_idx.iter().max().unwrap();\\n            ret[pos] = max_pos - pos as i32 + 1;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn smallest_subarrays(nums: Vec<i32>) -> Vec<i32> \\n    {\\n        let mut ret: Vec<i32> = vec![1;nums.len()];\\n        \\n        // [1] when performing OR operation on an array, \\n        //     we care only about the first occurence of each bit,\\n        //     because all subsequent occurences do not change the result;\\n        //     thus, we should arrange a storage \\'bit_idx\\' for the positions of \\n        //     the first occurence of each bit; \\n        let mut bit_idx: [i32;30] = [0;30];\\n\\n        let mut max_pos : i32;\\n        let mut bit     : i32;\\n        \\n        // [2] for a one-pass solution, we iterate over \\'nums\\' from the end;\\n        //     this allows us to dynamically update the first occurence of bits;\\n        //     terminal zeros are skipped, their respective minimal subarray size is 1\\n        for (pos, &n) in nums.iter().enumerate().rev().skip_while(|(_,n)| **n == 0)\\n        {\\n            // [3] for each bit, update the earliest/first position it was seen at;\\n            //     here we use an arithmetic way to update \\'bit_idx\\',\\n            //     use of conditional statement is slower\\n            for b in 0..30\\n            {\\n                bit = (n >> b) & 1;\\n                bit_idx[b] = (1 - bit) * bit_idx[b] + bit * (pos as i32);\\n            }\\n\\n            // [4] minimal subarray/window is the one that accounts for all bits\\n            //     that were seen at least once \\n            max_pos = *bit_idx.iter().max().unwrap();\\n            ret[pos] = max_pos - pos as i32 + 1;\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2598489,
                "title": "c-bitwise-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> closed(30);\\n        vector<int> res(nums.size());\\n        for(int i = nums.size()- 1; i >= 0; i--){\\n            for(int j = 0; j < 30; j++)\\n                if(nums[i] & (1 << j))\\n                    closed[j] = i;\\n            res[i] = max(1, *max_element(closed.begin(), closed.end()) - i + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> closed(30);\\n        vector<int> res(nums.size());\\n        for(int i = nums.size()- 1; i >= 0; i--){\\n            for(int j = 0; j < 30; j++)\\n                if(nums[i] & (1 << j))\\n                    closed[j] = i;\\n            res[i] = max(1, *max_element(closed.begin(), closed.end()) - i + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596647,
                "title": "python-closest-bit",
                "content": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        def get_bits(x):\\n            index = 0\\n            while x > 0:\\n                if x & 1:\\n                    yield index\\n                index += 1\\n                x >>= 1\\n                \\n        nums_len = len(nums)\\n        last_bit_index = [nums_len] * 31\\n        result = [1] * nums_len\\n        cur_bits = set()\\n        for index in range(nums_len - 1, -1, -1):\\n            x = nums[index]\\n            x_bits = list(get_bits(x))\\n            for b in x_bits:\\n                last_bit_index[b] = index + 1\\n            cur_bits.update(x_bits)\\n            for b in cur_bits:\\n                result[index] = max(result[index], last_bit_index[b] - index)\\n                \\n        return result\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        def get_bits(x):\\n            index = 0\\n            while x > 0:\\n                if x & 1:\\n                    yield index\\n                index += 1\\n                x >>= 1\\n                \\n        nums_len = len(nums)\\n        last_bit_index = [nums_len] * 31\\n        result = [1] * nums_len\\n        cur_bits = set()\\n        for index in range(nums_len - 1, -1, -1):\\n            x = nums[index]\\n            x_bits = list(get_bits(x))\\n            for b in x_bits:\\n                last_bit_index[b] = index + 1\\n            cur_bits.update(x_bits)\\n            for b in cur_bits:\\n                result[index] = max(result[index], last_bit_index[b] - index)\\n                \\n        return result\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593350,
                "title": "c-individual-bits-queue",
                "content": "```\\npublic int[] SmallestSubarrays(int[] nums)\\n{\\n\\tvar bits = Enumerable.Range(0, 32).Select(_ => new Queue<int>()).ToArray();\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tvar n = nums[i];\\n\\t\\tint bidx = 0;\\n\\t\\twhile (n > 0)\\n\\t\\t{\\n\\t\\t\\tif ((n & 1) > 0)\\n\\t\\t\\t\\tbits[bidx].Enqueue(i);\\n\\t\\t\\tn >>= 1;\\n\\t\\t\\tbidx++;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tvar max = 1;\\n\\t\\tfor (int j = 0; j < bits.Length; j++)\\n\\t\\t{\\n\\t\\t\\twhile (bits[j].TryPeek(out var idx) && idx < i)\\n\\t\\t\\t\\tbits[j].Dequeue();\\n\\t\\t\\tif (bits[j].Count > 0)\\n\\t\\t\\t\\tmax = Math.Max(max, bits[j].Peek() - i + 1);\\n\\t\\t}\\n\\t\\tnums[i] = max;\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] SmallestSubarrays(int[] nums)\\n{\\n\\tvar bits = Enumerable.Range(0, 32).Select(_ => new Queue<int>()).ToArray();\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tvar n = nums[i];\\n\\t\\tint bidx = 0;\\n\\t\\twhile (n > 0)\\n\\t\\t{\\n\\t\\t\\tif ((n & 1) > 0)\\n\\t\\t\\t\\tbits[bidx].Enqueue(i);\\n\\t\\t\\tn >>= 1;\\n\\t\\t\\tbidx++;\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 0; i < nums.Length; i++)\\n\\t{\\n\\t\\tvar max = 1;\\n\\t\\tfor (int j = 0; j < bits.Length; j++)\\n\\t\\t{\\n\\t\\t\\twhile (bits[j].TryPeek(out var idx) && idx < i)\\n\\t\\t\\t\\tbits[j].Dequeue();\\n\\t\\t\\tif (bits[j].Count > 0)\\n\\t\\t\\t\\tmax = Math.Max(max, bits[j].Peek() - i + 1);\\n\\t\\t}\\n\\t\\tnums[i] = max;\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592621,
                "title": "faster-than-100-and-memory-usage-less-than-100",
                "content": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& v) {\\n        int n=v.size();\\n        vector<int> ans;\\n        vector<int> dp(31);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<31;j++)\\n            {\\n              if(v[i] & 1<<j)\\n                  dp[j]=i;\\n            }\\n            int mx=0;\\n            for(int j=0;j<31;j++)\\n                mx=max(mx,dp[j]);\\n            ans.push_back(max(1,mx-i+1));\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& v) {\\n        int n=v.size();\\n        vector<int> ans;\\n        vector<int> dp(31);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=0;j<31;j++)\\n            {\\n              if(v[i] & 1<<j)\\n                  dp[j]=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2591604,
                "title": "c-o-n-30",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> dp(32,INT_MAX);\\n        vector<int> re(nums.size(),1);\\n        int sum = 0;\\n        for(int i = nums.size()-1;i>=0;--i){\\n            sum=sum|nums[i];\\n            int k = i;\\n            for(int j = 0; j<30;++j){ \\n                if(nums[i]&(1<<j)) dp[j] = min(dp[j],i);\\n                if(dp[j]!=INT_MAX) k = max(k,dp[j]);\\n            }\\n            re[i] = k-i+1;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> dp(32,INT_MAX);\\n        vector<int> re(nums.size(),1);\\n        int sum = 0;\\n        for(int i = nums.size()-1;i>=0;--i){\\n            sum=sum|nums[i];\\n            int k = i;\\n            for(int j = 0; j<30;++j){ \\n                if(nums[i]&(1<<j)) dp[j] = min(dp[j],i);\\n                if(dp[j]!=INT_MAX) k = max(k,dp[j]);\\n            }\\n            re[i] = k-i+1;\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591242,
                "title": "c-sliding-window-explained-with-comment",
                "content": "//Just like sliding window, we do this code as well. We maintain a map, tha store , that which index has been repeated and how many time, Eg :- 101 and 110 , map will have(indices like 2nd , 1st,0th) , then 0th index:- 1 , 1st index :- 1 , 2nd index :- 2)\\n\\nkeep 2 pointers i and j , from end\\n\\nLogic, start from end and move to start, at each step , add the indices of jth index, now we try to remove indices of ith index if, the map size is still same , else stop removing. Length will be (i-j+1)\\n\\n\\n \\n \\n **CODE :- ** \\n \\n \\n    void add(int n , unordered_map<int,int> & m)\\n    {\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            int r = n%2;\\n            n/=2;\\n            if(r == 1)\\n            {\\n                m[i]++;\\n            }\\n            i++;\\n        }\\n    }\\n    \\n     void del(int n , unordered_map<int,int> & m)\\n    {\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            int r = n%2;\\n            n/=2;\\n            if(r == 1)\\n            {\\n                m[i]--;\\n                if(m[i] == 0)\\n                {\\n                    m.erase(i);\\n                }\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = n-1 , j = n-2 ;\\n        \\n        vector<int> ans(n,1);\\n        \\n        unordered_map<int,int> m ;\\n        int sum = nums[n-1];\\n        \\n        add(nums[n-1] , m);\\n        while(j >= 0)\\n        {\\n            \\n            add(nums[j] , m);\\n            \\n            while(i > j)\\n            {\\n                int prev = m.size();\\n                del(nums[i],m);\\n                int new_val = m.size();\\n                \\n                if(prev == new_val)\\n                {\\n                    i--;\\n                }\\n                else\\n                {\\n                    add(nums[i],m);\\n                    break;\\n                }\\n                \\n                \\n            }\\n            \\n            ans[j] = i-j+1;\\n                \\n                j--;\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "//Just like sliding window, we do this code as well. We maintain a map, tha store , that which index has been repeated and how many time, Eg :- 101 and 110 , map will have(indices like 2nd , 1st,0th) , then 0th index:- 1 , 1st index :- 1 , 2nd index :- 2)\\n\\nkeep 2 pointers i and j , from end\\n\\nLogic, start from end and move to start, at each step , add the indices of jth index, now we try to remove indices of ith index if, the map size is still same , else stop removing. Length will be (i-j+1)\\n\\n\\n \\n \\n **CODE :- ** \\n \\n \\n    void add(int n , unordered_map<int,int> & m)\\n    {\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            int r = n%2;\\n            n/=2;\\n            if(r == 1)\\n            {\\n                m[i]++;\\n            }\\n            i++;\\n        }\\n    }\\n    \\n     void del(int n , unordered_map<int,int> & m)\\n    {\\n        int i = 0;\\n        while(n > 0)\\n        {\\n            int r = n%2;\\n            n/=2;\\n            if(r == 1)\\n            {\\n                m[i]--;\\n                if(m[i] == 0)\\n                {\\n                    m.erase(i);\\n                }\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = n-1 , j = n-2 ;\\n        \\n        vector<int> ans(n,1);\\n        \\n        unordered_map<int,int> m ;\\n        int sum = nums[n-1];\\n        \\n        add(nums[n-1] , m);\\n        while(j >= 0)\\n        {\\n            \\n            add(nums[j] , m);\\n            \\n            while(i > j)\\n            {\\n                int prev = m.size();\\n                del(nums[i],m);\\n                int new_val = m.size();\\n                \\n                if(prev == new_val)\\n                {\\n                    i--;\\n                }\\n                else\\n                {\\n                    add(nums[i],m);\\n                    break;\\n                }\\n                \\n                \\n            }\\n            \\n            ans[j] = i-j+1;\\n                \\n                j--;\\n            \\n            \\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2589907,
                "title": "c-segment-tree-binary-search",
                "content": "**PLEASE DO UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n```\\nclass Solution {\\n    vector<int>seg_tree;\\n    void build(int node,int s,int e,vector<int>& nums)\\n    {\\n        if(s>e)return;\\n        if(s==e){seg_tree[node]=nums[s];return;}\\n        int mid=s+(e-s)/2;\\n        build(2*node,s,mid,nums);\\n        build(2*node+1,mid+1,e,nums);\\n        seg_tree[node]=seg_tree[2*node]|seg_tree[2*node+1];\\n    }\\n    int range_OR(int node,int s,int e,int l,int r)\\n    {\\n        if(s>e||e<l||s>r)\\n            return 0;\\n        if(s>=l&&e<=r||s==e)return seg_tree[node];\\n        \\n        int mid=s+(e-s)/2;\\n        int left_OR=range_OR(2*node,s,mid,l,r);\\n        int right_OR=range_OR(2*node+1,mid+1,e,l,r);\\n        return left_OR|right_OR;\\n    }\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v(n);\\n        v[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)v[i]=nums[i]|v[i+1];\\n        \\n        seg_tree=vector<int>(4*n);\\n        build(1,0,n-1,nums);\\n        vector<int>res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int max_OR=v[i];\\n            int lo=i,hi=n-1;\\n            while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                int rangeOR=range_OR(1,0,n-1,i,mid);\\n                if(rangeOR<max_OR)\\n                    lo=mid+1;\\n                else\\n                    hi=mid-1;\\n            }\\n            res[i]=lo-i+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>seg_tree;\\n    void build(int node,int s,int e,vector<int>& nums)\\n    {\\n        if(s>e)return;\\n        if(s==e){seg_tree[node]=nums[s];return;}\\n        int mid=s+(e-s)/2;\\n        build(2*node,s,mid,nums);\\n        build(2*node+1,mid+1,e,nums);\\n        seg_tree[node]=seg_tree[2*node]|seg_tree[2*node+1];\\n    }\\n    int range_OR(int node,int s,int e,int l,int r)\\n    {\\n        if(s>e||e<l||s>r)\\n            return 0;\\n        if(s>=l&&e<=r||s==e)return seg_tree[node];\\n        \\n        int mid=s+(e-s)/2;\\n        int left_OR=range_OR(2*node,s,mid,l,r);\\n        int right_OR=range_OR(2*node+1,mid+1,e,l,r);\\n        return left_OR|right_OR;\\n    }\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>v(n);\\n        v[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)v[i]=nums[i]|v[i+1];\\n        \\n        seg_tree=vector<int>(4*n);\\n        build(1,0,n-1,nums);\\n        vector<int>res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int max_OR=v[i];\\n            int lo=i,hi=n-1;\\n            while(lo<=hi)\\n            {\\n                int mid=lo+(hi-lo)/2;\\n                int rangeOR=range_OR(1,0,n-1,i,mid);\\n                if(rangeOR<max_OR)\\n                    lo=mid+1;\\n                else\\n                    hi=mid-1;\\n            }\\n            res[i]=lo-i+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589180,
                "title": "c-bit-operation-no-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    void dec2bin(int n, vector<int>& binbits) {\\n        for (int i = 0; i < 30; i++) {\\n            binbits[i] = n % 2;\\n            n /= 2;\\n        }\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<deque<int>> contibutes(30);\\n        vector<int> ans(nums.size());\\n        vector<int> binbits(30);\\n        for (int i = 0; i < nums.size(); i++) {\\n            dec2bin(nums[i], binbits);\\n            for (int j = 0; j < 30; j++) \\n                if (binbits[j] == 1) contibutes[j].push_back(i);\\n        }\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            vector<int> onesIdx;\\n            for (int i = 0; i < 30; i++) if (contibutes[i].size()) onesIdx.push_back(i);\\n            int tmax = -1;\\n            for (int& idx : onesIdx) tmax = max(tmax, contibutes[idx][0]);\\n            ans[i] = max(tmax-i+1, 1);\\n            for (int j = 0; j < 30; j++) if (contibutes[j][0] == i) contibutes[j].pop_front();\\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dec2bin(int n, vector<int>& binbits) {\\n        for (int i = 0; i < 30; i++) {\\n            binbits[i] = n % 2;\\n            n /= 2;\\n        }\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<deque<int>> contibutes(30);\\n        vector<int> ans(nums.size());\\n        vector<int> binbits(30);\\n        for (int i = 0; i < nums.size(); i++) {\\n            dec2bin(nums[i], binbits);\\n            for (int j = 0; j < 30; j++) \\n                if (binbits[j] == 1) contibutes[j].push_back(i);\\n        }\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            vector<int> onesIdx;\\n            for (int i = 0; i < 30; i++) if (contibutes[i].size()) onesIdx.push_back(i);\\n            int tmax = -1;\\n            for (int& idx : onesIdx) tmax = max(tmax, contibutes[idx][0]);\\n            ans[i] = max(tmax-i+1, 1);\\n            for (int j = 0; j < 30; j++) if (contibutes[j][0] == i) contibutes[j].pop_front();\\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588920,
                "title": "python-bitmasking-o-31-n",
                "content": "Keep track of all bits which have been set by latest index from right.Your answer is maximum of those.If that bit is never set anytime, don\\'t consider that index for answer.\\n```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        ans=[1]*n\\n        arr=[-1]*31\\n        for i in range(n-1,-1,-1):\\n            mmax=-1\\n            for idx in range(31):\\n                if (nums[i] & (1<<idx))!=0:\\n                    arr[idx]=i\\n                mmax=max(mmax,arr[idx])\\n            if mmax!=-1:\\n                ans[i]=mmax-i+1\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        ans=[1]*n\\n        arr=[-1]*31\\n        for i in range(n-1,-1,-1):\\n            mmax=-1\\n            for idx in range(31):\\n                if (nums[i] & (1<<idx))!=0:\\n                    arr[idx]=i\\n                mmax=max(mmax,arr[idx])\\n            if mmax!=-1:\\n                ans[i]=mmax-i+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588712,
                "title": "100-tc-100-sc-bit-manipuation-explained-python-super-fast",
                "content": "![image](https://assets.leetcode.com/users/images/6dc31098-5267-472f-b795-ebbef278e52e_1663437342.138748.png)\\n\\nLogic: When we do an OR operation, once a bit becomes 1, it stays 1 afterwards no matter how many OR operations you do. So when we iterate from left to right, as soon as a bit becomes 1, that is the best index (least possible) we will need to travel to make that bit 1. \\n\\n**We need to start from the end and update the least index required for making each bit 1. Once we update, the max index needed to make any bit 1 is the answer for the current index.**\\n\\nEg: [1, **3**] -> bitform =  [01, **11**]\\n**We iterate from right to left**\\ncurrIndex = 1\\nmax index to make LSB (rightmost bit) 1 = 1\\nmax index to make MSB (leftmost bit) 1 = 1\\nbestBitIndex = [1, 1]\\n\\n[**1**, 3] -> bitform =  [**01**, 11]\\ncurrIndex = 0\\nmax index to make LSB (rightmost bit) 1 = 0 (we dont need to go till index 1 now, this bit will stay 1 starting from index 0)\\nmax index to make MSB (leftmost bit) 1 = 1 (in order to make this bit 1, we still have to travel till index 1)\\nbestBitIndex = [1, 0]\\n\\nUpvote if you understood the logic :) \\n\\n```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        ans = [None] * len(nums)\\n        n = len(nums)\\n        bestBitIndices = [0] * 32\\n\\n        for numIndex in range(len(nums) - 1, -1, -1):\\n            \\n            for bitIndex in range(32):\\n                if nums[numIndex] & (1 << bitIndex):\\n\\t\\t\\t\\t    # if 0 we need to atleast travel till the current index\\n                    if bestBitIndices[bitIndex] == 0:\\n                        bestBitIndices[bitIndex] = numIndex\\n                    else:\\n                        bestBitIndices[bitIndex] = min(bestBitIndices[bitIndex], numIndex)\\n                    \\n            ans[numIndex] = max(1, max(bestBitIndices) - numIndex + 1)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        ans = [None] * len(nums)\\n        n = len(nums)\\n        bestBitIndices = [0] * 32\\n\\n        for numIndex in range(len(nums) - 1, -1, -1):\\n            \\n            for bitIndex in range(32):\\n                if nums[numIndex] & (1 << bitIndex):\\n\\t\\t\\t\\t    # if 0 we need to atleast travel till the current index\\n                    if bestBitIndices[bitIndex] == 0:\\n                        bestBitIndices[bitIndex] = numIndex\\n                    else:\\n                        bestBitIndices[bitIndex] = min(bestBitIndices[bitIndex], numIndex)\\n                    \\n            ans[numIndex] = max(1, max(bestBitIndices) - numIndex + 1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588421,
                "title": "sliding-window-intuitive",
                "content": "First find the maximum OR of the array arr and then search for the maximum or from the start. Once the maximum OR is found update the maximum OR if required and remove the leftmost element of the array from the current OR.\\n```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int[] res=new int[nums.length];\\n        int freq[]=new int[32];\\n        int or=0;\\n        for(int i:nums){\\n            or|=i;\\n            addFreq(i,freq);\\n        }\\n        int l=0;\\n        int r=0;\\n        int cur=0;\\n        int cFreq[]=new int[32];\\n        while(r<nums.length){\\n            if(or==0){\\n                res[l]=1;\\n                l++;\\n                r++;\\n                continue;\\n            }\\n            cur|=nums[r];\\n            addFreq(nums[r],cFreq);\\n            while(l<nums.length&&cur==or&&cur!=0){\\n                res[l]=r-l+1;\\n                dFreq(nums[l],freq);\\n                or=update(freq);\\n                dFreq(nums[l],cFreq);\\n                cur=update(cFreq);\\n                l++;\\n            }\\n            \\n            r++;\\n        }\\n        res[nums.length-1]=1;\\n        return res;\\n    }\\n    \\n    public void addFreq(int i,int[] freq){\\n        int j=0;\\n        while(i>0){\\n            int bit=i&1;\\n            i=i>>1;\\n            if(bit==1) freq[j]++;\\n            j++;\\n        }\\n        \\n    }\\n    \\n    public void dFreq(int i,int[] freq){\\n        int j=0;\\n        while(i>0){\\n            int bit=i&1;\\n            i=i>>1;\\n            if(bit==1) freq[j]--;\\n            j++;\\n        }\\n    }\\n    \\n    public int update(int[] freq){\\n        int ans=0;\\n        for(int i=0;i<32;i++){\\n            if(freq[i]>0)\\n            ans|=(1<<i);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n}\\n````",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int[] res=new int[nums.length];\\n        int freq[]=new int[32];\\n        int or=0;\\n        for(int i:nums){\\n            or|=i;\\n            addFreq(i,freq);\\n        }\\n        int l=0;\\n        int r=0;\\n        int cur=0;\\n        int cFreq[]=new int[32];\\n        while(r<nums.length){\\n            if(or==0){\\n                res[l]=1;\\n                l++;\\n                r++;\\n                continue;\\n            }\\n            cur|=nums[r];\\n            addFreq(nums[r],cFreq);\\n            while(l<nums.length&&cur==or&&cur!=0){\\n                res[l]=r-l+1;\\n                dFreq(nums[l],freq);\\n                or=update(freq);\\n                dFreq(nums[l],cFreq);\\n                cur=update(cFreq);\\n                l++;\\n            }\\n            \\n            r++;\\n        }\\n        res[nums.length-1]=1;\\n        return res;\\n    }\\n    \\n    public void addFreq(int i,int[] freq){\\n        int j=0;\\n        while(i>0){\\n            int bit=i&1;\\n            i=i>>1;\\n            if(bit==1) freq[j]++;\\n            j++;\\n        }\\n        \\n    }\\n    \\n    public void dFreq(int i,int[] freq){\\n        int j=0;\\n        while(i>0){\\n            int bit=i&1;\\n            i=i>>1;\\n            if(bit==1) freq[j]--;\\n            j++;\\n        }\\n    }\\n    \\n    public int update(int[] freq){\\n        int ans=0;\\n        for(int i=0;i<32;i++){\\n            if(freq[i]>0)\\n            ans|=(1<<i);\\n        }\\n        return ans;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588364,
                "title": "c-bit-maipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& a) \\n    {\\n      vector<int> ans(a.size(),1);\\n      vector<int> temp(30,0);\\n      for(int i=a.size()-1; i>=0; i--)\\n      {\\n        int maxval=0;\\n        for(int j=0;j<30;j++)\\n        {\\n          if(((1<<j) & a[i])==0)\\n            maxval=max(maxval,temp[j]);\\n          ans[i]=max(maxval-i+1,1); \\n        }\\n        \\n        for(int j=0;j<30;j++)\\n        {\\n          if((1<<j) & a[i])\\n            temp[j]=i;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& a) \\n    {\\n      vector<int> ans(a.size(),1);\\n      vector<int> temp(30,0);\\n      for(int i=a.size()-1; i>=0; i--)\\n      {\\n        int maxval=0;\\n        for(int j=0;j<30;j++)\\n        {\\n          if(((1<<j) & a[i])==0)\\n            maxval=max(maxval,temp[j]);\\n          ans[i]=max(maxval-i+1,1); \\n        }\\n        \\n        for(int j=0;j<30;j++)\\n        {\\n          if((1<<j) & a[i])\\n            temp[j]=i;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588344,
                "title": "o-n-binary-search-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& v) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0 ; i<v.size() ; ++i) {\\n            for(int j=0 ; j<31 ; ++j) {\\n                if(v[i]&(1<<j)) {\\n                    mp[j].push_back(i);\\n                }\\n            }\\n        }\\n        vector<int> ans(v.size());\\n        for(int i=0 ; i<v.size() ; ++i) {\\n            int mx=i;\\n            for(int j=0 ; j<31 ; ++j) {\\n                auto len = lower_bound(begin(mp[j]), end(mp[j]), i);\\n                if(len != mp[j].end()) {\\n                    mx = max(mx, *len);\\n                }\\n            }\\n            ans[i] = mx-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& v) {\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0 ; i<v.size() ; ++i) {\\n            for(int j=0 ; j<31 ; ++j) {\\n                if(v[i]&(1<<j)) {\\n                    mp[j].push_back(i);\\n                }\\n            }\\n        }\\n        vector<int> ans(v.size());\\n        for(int i=0 ; i<v.size() ; ++i) {\\n            int mx=i;\\n            for(int j=0 ; j<31 ; ++j) {\\n                auto len = lower_bound(begin(mp[j]), end(mp[j]), i);\\n                if(len != mp[j].end()) {\\n                    mx = max(mx, *len);\\n                }\\n            }\\n            ans[i] = mx-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588289,
                "title": "c-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(31));\\n        \\n        for(int i = 0; i < 31; i++) {\\n            if(nums[n-1] & (1<<i)) \\n                dp[n-1][i] = n-1;\\n        }\\n        \\n        for(int i = n-2; i >= 0; i--) {\\n            dp[i] = dp[i+1];\\n            for(int j = 0; j < 31; j++) {\\n                if(nums[i] & (1<<j))\\n                    dp[i][j] = i;\\n            }\\n        }\\n        \\n        vector<int> ans(n, 1);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < 31; j++)\\n                ans[i] = max(ans[i], dp[i][j]-i+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> dp(n, vector<int>(31));\\n        \\n        for(int i = 0; i < 31; i++) {\\n            if(nums[n-1] & (1<<i)) \\n                dp[n-1][i] = n-1;\\n        }\\n        \\n        for(int i = n-2; i >= 0; i--) {\\n            dp[i] = dp[i+1];\\n            for(int j = 0; j < 31; j++) {\\n                if(nums[i] & (1<<j))\\n                    dp[i][j] = i;\\n            }\\n        }\\n        \\n        vector<int> ans(n, 1);\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < 31; j++)\\n                ans[i] = max(ans[i], dp[i][j]-i+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588284,
                "title": "c-brute-force-solution-using-map",
                "content": "Approach: \\n* For every index i, starting from the end, we are using all the Bitwise OR results from index i + 1 along with the size of the subarray. \\n* If two subarrays have same Bitwise OR result then we keep only the shorter subarray. For this we are using a map. \\n* For index i, we find the maximum Bitwise OR result having the smallest size.\\n\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<unordered_map<int, int>> ops(n);\\n        ops[n - 1][nums.back()] = 1;\\n        \\n        vector<int> res(n, 1); \\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            int mx = nums[i], mxs = 1;\\n            for(auto [v, s]: ops[i + 1]){\\n                int x = nums[i] | v;\\n                if(ops[i].count(x))\\n                    ops[i][x] = min(ops[i][x], s + 1);\\n                else ops[i][x] = s + 1;\\n                if(x >= mx){\\n                    if(mx == x){\\n                        mxs = min(mxs, s + 1);\\n                    }\\n                    else {\\n                        mx = x;\\n                        mxs = s + 1;\\n                    }                    \\n                }\\n            }  \\n            ops[i][nums[i]] = 1;\\n            res[i] = mxs;\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<unordered_map<int, int>> ops(n);\\n        ops[n - 1][nums.back()] = 1;\\n        \\n        vector<int> res(n, 1); \\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            int mx = nums[i], mxs = 1;\\n            for(auto [v, s]: ops[i + 1]){\\n                int x = nums[i] | v;\\n                if(ops[i].count(x))\\n                    ops[i][x] = min(ops[i][x], s + 1);\\n                else ops[i][x] = s + 1;\\n                if(x >= mx){\\n                    if(mx == x){\\n                        mxs = min(mxs, s + 1);\\n                    }\\n                    else {\\n                        mx = x;\\n                        mxs = s + 1;\\n                    }                    \\n                }\\n            }  \\n            ops[i][nums[i]] = 1;\\n            res[i] = mxs;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588282,
                "title": "solved-by-two-pointers",
                "content": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[] max = new int[n];\\n        int now = 0;\\n\\t\\t//1. The maximum value is calculated first (going back from N-1)\\n        for(int i = n-1; i >= 0; i--){\\n            now |= nums[i];\\n            max[i] = now;\\n        }\\n        int[] bit = new int[31];\\n        int right = 0;\\n        now = 0;\\n        int[] cnt = new int[n];\\n        for(int i = 0; i < n; i++){\\n\\t\\t    //2. Keep adding until the maximum value is reached.\\n            while(right < n && now < max[i]){\\n                for(int j = 0; j < 31; j++){\\n                    if((nums[right] >> j) % 2 == 1){\\n                        bit[j]++;\\n\\t\\t\\t\\t\\t\\t//3. OR value increases when that bit goes 0 => 1\\n                        if(bit[j] == 1){\\n                            now += (1 << j);\\n                        }\\n                    }\\n                }\\n                right++;\\n            }\\n            cnt[i] = Math.max(1,right-i);\\n\\t\\t\\t// 4. Remove nums[i] from the OR value\\n            for(int j = 0; j < 31; j++){\\n                if((nums[i] >> j) % 2 == 1){\\n                    bit[j]--;\\n                    if(bit[j] == 0){\\n\\t\\t\\t\\t\\t    // 5. OR value decreases when the bit becomes 1 => 0\\n                        now -= (1 << j);\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[] max = new int[n];\\n        int now = 0;\\n\\t\\t//1. The maximum value is calculated first (going back from N-1)\\n        for(int i = n-1; i >= 0; i--){\\n            now |= nums[i];\\n            max[i] = now;\\n        }\\n        int[] bit = new int[31];\\n        int right = 0;\\n        now = 0;\\n        int[] cnt = new int[n];\\n        for(int i = 0; i < n; i++){\\n\\t\\t    //2. Keep adding until the maximum value is reached.\\n            while(right < n && now < max[i]){\\n                for(int j = 0; j < 31; j++){\\n                    if((nums[right] >> j) % 2 == 1){\\n                        bit[j]++;\\n\\t\\t\\t\\t\\t\\t//3. OR value increases when that bit goes 0 => 1\\n                        if(bit[j] == 1){\\n                            now += (1 << j);\\n                        }\\n                    }\\n                }\\n                right++;\\n            }\\n            cnt[i] = Math.max(1,right-i);\\n\\t\\t\\t// 4. Remove nums[i] from the OR value\\n            for(int j = 0; j < 31; j++){\\n                if((nums[i] >> j) % 2 == 1){\\n                    bit[j]--;\\n                    if(bit[j] == 0){\\n\\t\\t\\t\\t\\t    // 5. OR value decreases when the bit becomes 1 => 0\\n                        now -= (1 << j);\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588164,
                "title": "c-cpp-bit-solution-explaination-o-30",
                "content": "```\\n\\t\\t// jai shri ram\\n\\t\\t//we are using the or property if the ith idx is one then it will not change further.\\n\\t\\t// we are checking the min idx from cur idx that is responsible for set the ith bit and updating it from right to left  \\n\\t\\tvector<int>mp(31,-1);\\n        vector<int>ans;\\n        int n=nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<=30;j++){\\n                int mask=(1<<j); \\n                if((mask & nums[i])){ //checking the jth bit is set or not\\n                    mp[j]=i; // if the bit is set then update the jth bit to cur idx means this jth bit can be set by this idx;\\n                }\\n            }\\n            int res=-1;\\n            for(auto x:mp){\\n                res=max(res,x); // finding the max idx which are contributing to max or\\n            }\\n            if(res!=-1) ans.push_back(res-i+1);\\n            else if(res==-1 && nums[i]==0) ans.push_back(1); // if there are zeroes to the right side then no bit is set then the ans will be 1.\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\t\\t// jai shri ram\\n\\t\\t//we are using the or property if the ith idx is one then it will not change further.\\n\\t\\t// we are checking the min idx from cur idx that is responsible for set the ith bit and updating it from right to left  \\n\\t\\tvector<int>mp(31,-1);\\n        vector<int>ans;\\n        int n=nums.size();\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<=30;j++){\\n                int mask=(1<<j); \\n                if((mask & nums[i])){ //checking the jth bit is set or not\\n                    mp[j]=i; // if the bit is set then update the jth bit to cur idx means this jth bit can be set by this idx;\\n                }\\n            }\\n            int res=-1;\\n            for(auto x:mp){\\n                res=max(res,x); // finding the max idx which are contributing to max or\\n            }\\n            if(res!=-1) ans.push_back(res-i+1);\\n            else if(res==-1 && nums[i]==0) ans.push_back(1); // if there are zeroes to the right side then no bit is set then the ans will be 1.\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588110,
                "title": "secret-python-answer-sliding-window-with-double-dictionary-of-binary-count",
                "content": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n\\n        def create(m):\\n            t = 0\\n            for n in m:\\n                if m[n] > 0:\\n                    t = t | (1 << n)\\n            return t\\n        \\n        def add(a,m):\\n            ans = bin( a )\\n            s = str(ans)[2:]\\n            for i, b in enumerate( s[::-1]):\\n                if b == \\'1\\':\\n                    m[i] += 1\\n\\n        def remove(a,m):\\n            ans = bin( a )\\n            s = str(ans)[2:]\\n            for i, b in enumerate( s[::-1]):\\n                if b == \\'1\\':\\n                    m[i] -= 1\\n        \\n        res = []\\n\\n        \\n        n = defaultdict(int)\\n        for i in nums:\\n            add(i,n)\\n\\n        \\n        m = defaultdict(int)\\n        r = 0\\n        c = 0\\n\\n        for i,v in enumerate(nums):\\n            # The last check is for if nums[i] == 0, in that case we still want to add to the map\\n            while r < len(nums) and (create(m) != create(n) or (c==0 and nums[i] ==0)):\\n                add(nums[r],m)\\n                r+=1\\n                c+=1\\n\\n            res.append(c)\\n\\n            remove(nums[i],m)\\n            remove(nums[i],n)\\n            c-=1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n\\n        def create(m):\\n            t = 0\\n            for n in m:\\n                if m[n] > 0:\\n                    t = t | (1 << n)\\n            return t\\n        \\n        def add(a,m):\\n            ans = bin( a )\\n            s = str(ans)[2:]\\n            for i, b in enumerate( s[::-1]):\\n                if b == \\'1\\':\\n                    m[i] += 1\\n\\n        def remove(a,m):\\n            ans = bin( a )\\n            s = str(ans)[2:]\\n            for i, b in enumerate( s[::-1]):\\n                if b == \\'1\\':\\n                    m[i] -= 1\\n        \\n        res = []\\n\\n        \\n        n = defaultdict(int)\\n        for i in nums:\\n            add(i,n)\\n\\n        \\n        m = defaultdict(int)\\n        r = 0\\n        c = 0\\n\\n        for i,v in enumerate(nums):\\n            # The last check is for if nums[i] == 0, in that case we still want to add to the map\\n            while r < len(nums) and (create(m) != create(n) or (c==0 and nums[i] ==0)):\\n                add(nums[r],m)\\n                r+=1\\n                c+=1\\n\\n            res.append(c)\\n\\n            remove(nums[i],m)\\n            remove(nums[i],n)\\n            c-=1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588074,
                "title": "explained-reverse-sliding-window-with-bit-manipulation-counting",
                "content": "Do sliding window in reverse.\\nAdd the set bits from the L index element to the bits array , meaning if L element is 2 then add one to 1st index of bits array since 2=(10) in binary.\\nthen try to remove the right elements by removing its set bits from bits array. if any bit you are removing has only 1 value that means if you remove right element the it would decrease the OR result so we will not remove that right element \\nthe we will save r-l+1 as the as for L index.\\n\\nTime Complexity is linear meaning O(N) where N is the size of the nums array.\\nSpace complexity is O{1), because we are just using an array of size 32 irrespective of nums array size.\\n\\nTime complexity is linear because it is just a normal sliding window and l and r can at max traverse the array once . the Inner loops will just run 32 times so they won\\'t add any extra complexity to our solution.\\n\\n```\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int>bits(32,0);\\n        \\n        int r=nums.size()-1;\\n        int l=nums.size()-1;\\n        vector<int>ans;\\n        \\n        while(l>=0){\\n            \\n            int temp=nums[r];\\n            \\n            for(int i=0;i<32;i++){\\n                if(nums[l]&(1<<i)){\\n                    bits[i]++;\\n                }\\n            }\\n            \\n            \\n            bool notchange=false;\\n            while(r>l and !notchange){;\\n                notchange=false;\\n                vector<int>temp=bits;\\n                for(int i=0;i<32;i++){\\n                    if(nums[r]&(1<<i)){\\n                        if(bits[i]==1){\\n                            notchange=true;\\n                            break;\\n                        }\\n                        temp[i]--;\\n                    }\\n                }\\n                if(notchange)break;\\n                r--;\\n                bits=temp;\\n            }\\n            ans.push_back(r-l+1);\\n            l--;\\n        }\\n        \\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int>bits(32,0);\\n        \\n        int r=nums.size()-1;\\n        int l=nums.size()-1;\\n        vector<int>ans;\\n        \\n        while(l>=0){\\n            \\n            int temp=nums[r];\\n            \\n            for(int i=0;i<32;i++){\\n                if(nums[l]&(1<<i)){\\n                    bits[i]++;\\n                }\\n            }\\n            \\n            \\n            bool notchange=false;\\n            while(r>l and !notchange){;\\n                notchange=false;\\n                vector<int>temp=bits;\\n                for(int i=0;i<32;i++){\\n                    if(nums[r]&(1<<i)){\\n                        if(bits[i]==1){\\n                            notchange=true;\\n                            break;\\n                        }\\n                        temp[i]--;\\n                    }\\n                }\\n                if(notchange)break;\\n                r--;\\n                bits=temp;\\n            }\\n            ans.push_back(r-l+1);\\n            l--;\\n        }\\n        \\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587977,
                "title": "prefixsum-binary-search-java",
                "content": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[][] prefix = new int[n+1][32];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                prefix[i+1][j] =  prefix[i][j];\\n                if(((1<<j)&nums[i])!=0) prefix[i+1][j]++;\\n            }\\n        }\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            int l = i+1,r = n;\\n            while(l<r){\\n                int mid = (l+r)/2;\\n                boolean f =  true;\\n                for(int j=0;j<32;j++){\\n                    if((prefix[r][j]-prefix[i][j])!=0&&(prefix[mid][j]-prefix[i][j])==0)  {\\n                        f = false;\\n                        break;\\n                    }\\n                }\\n                if(f)  r = mid;\\n                else  l = mid+1;\\n            }\\n            ans[i] = r - i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[][] prefix = new int[n+1][32];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<32;j++){\\n                prefix[i+1][j] =  prefix[i][j];\\n                if(((1<<j)&nums[i])!=0) prefix[i+1][j]++;\\n            }\\n        }\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            int l = i+1,r = n;\\n            while(l<r){\\n                int mid = (l+r)/2;\\n                boolean f =  true;\\n                for(int j=0;j<32;j++){\\n                    if((prefix[r][j]-prefix[i][j])!=0&&(prefix[mid][j]-prefix[i][j])==0)  {\\n                        f = false;\\n                        break;\\n                    }\\n                }\\n                if(f)  r = mid;\\n                else  l = mid+1;\\n            }\\n            ans[i] = r - i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587954,
                "title": "sliding-window-on-bits-c",
                "content": "The key idea is to start fom the end and keep removing the element which do not alter the value of the maximum bitwise OR.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isOk(vector<int> &crt, vector<int> &last){\\n        vector<int> temp(crt);\\n        for(int i = 0; i<64; i++){\\n            temp[i] = temp[i] - last[i];\\n        }\\n        for(int i = 0; i<64; i++){\\n            if(!temp[i]&&crt[i])return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        vector<vector<int>> bits(nums.size(), vector<int>(64, 0));\\n        for(int i = 0; i<nums.size(); i++){\\n            int temp = nums[i];\\n            int k = 0;\\n            while(temp){\\n                bits[i][k++] = temp%2;\\n                temp = temp/2;\\n            }\\n        }\\n        ans[nums.size()-1] = 1;\\n        vector<int> crt = bits[nums.size()-1];\\n        int last = nums.size()-1;\\n        for(int i = nums.size()-2; i>=0; i--){\\n            for(int j = 0; j<64; j++){\\n                crt[j] += bits[i][j];\\n            }\\n            while(last>i&&isOk(crt, bits[last])){\\n                for(int k = 0; k<64; k++){\\n                    crt[k] = crt[k] - bits[last][k];\\n                }\\n                last--;\\n            }\\n            ans[i] = last-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isOk(vector<int> &crt, vector<int> &last){\\n        vector<int> temp(crt);\\n        for(int i = 0; i<64; i++){\\n            temp[i] = temp[i] - last[i];\\n        }\\n        for(int i = 0; i<64; i++){\\n            if(!temp[i]&&crt[i])return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        vector<vector<int>> bits(nums.size(), vector<int>(64, 0));\\n        for(int i = 0; i<nums.size(); i++){\\n            int temp = nums[i];\\n            int k = 0;\\n            while(temp){\\n                bits[i][k++] = temp%2;\\n                temp = temp/2;\\n            }\\n        }\\n        ans[nums.size()-1] = 1;\\n        vector<int> crt = bits[nums.size()-1];\\n        int last = nums.size()-1;\\n        for(int i = nums.size()-2; i>=0; i--){\\n            for(int j = 0; j<64; j++){\\n                crt[j] += bits[i][j];\\n            }\\n            while(last>i&&isOk(crt, bits[last])){\\n                for(int k = 0; k<64; k++){\\n                    crt[k] = crt[k] - bits[last][k];\\n                }\\n                last--;\\n            }\\n            ans[i] = last-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587944,
                "title": "python-segment-tree-and-sliding-window-two-pointers",
                "content": "**Explanation:**\\n1. Create a segment tree to calculate the bitwise OR for the intervals in the array.\\n2. Starting from the end of the array and traversing back, we can apply the sliding window/two pointers method. \\n3. Whenever we satisfy the condition: (bitwise OR between[left, right-1] == bitwise OR between[left, right]), that means we don\\'t need the num at the right pointer to get a larger bitwise OR value. We can then greedily shrink the window by decreasing the right pointer to get a smaller length of the subarray.\\n\\n```\\nclass SegTree:\\n\\n    def __init__(self, nums):\\n        self.n = n = len(nums)\\n        self.tree = [0] * (2 * n)\\n        for i in range(n):\\n            self.tree[i + n] = nums[i]\\n        for i in range(n-1, 0, -1):\\n            self.tree[i] = self.tree[2 * i] | self.tree[2 * i + 1]\\n        \\n    def orRange(self, left, right):\\n        left += self.n\\n        right += self.n + 1\\n        orRes = 0\\n        while left < right:\\n            if left % 2 == 1:\\n                orRes |= self.tree[left]\\n                left += 1\\n            \\n            if right % 2 == 1:\\n                right -= 1\\n                orRes |= self.tree[right]\\n                \\n            left //= 2\\n            right //= 2\\n        return orRes\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        \\n        segtree = SegTree(nums)\\n        \\n        ans = [1] * len(nums)\\n        l = len(nums) - 1\\n        r = len(nums) - 1\\n        \\n        while l >= 0:\\n\\n            while r > l and segtree.orRange(l, r-1) == segtree.orRange(l, r):\\n                r -= 1\\n                \\n            ans[l] = r - l + 1\\n            l -= 1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```\\nclass SegTree:\\n\\n    def __init__(self, nums):\\n        self.n = n = len(nums)\\n        self.tree = [0] * (2 * n)\\n        for i in range(n):\\n            self.tree[i + n] = nums[i]\\n        for i in range(n-1, 0, -1):\\n            self.tree[i] = self.tree[2 * i] | self.tree[2 * i + 1]\\n        \\n    def orRange(self, left, right):\\n        left += self.n\\n        right += self.n + 1\\n        orRes = 0\\n        while left < right:\\n            if left % 2 == 1:\\n                orRes |= self.tree[left]\\n                left += 1\\n            \\n            if right % 2 == 1:\\n                right -= 1\\n                orRes |= self.tree[right]\\n                \\n            left //= 2\\n            right //= 2\\n        return orRes\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        \\n        segtree = SegTree(nums)\\n        \\n        ans = [1] * len(nums)\\n        l = len(nums) - 1\\n        r = len(nums) - 1\\n        \\n        while l >= 0:\\n\\n            while r > l and segtree.orRange(l, r-1) == segtree.orRange(l, r):\\n                r -= 1\\n                \\n            ans[l] = r - l + 1\\n            l -= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587881,
                "title": "a-few-solutions",
                "content": "Process the input array `A` from right-to-left.\\n\\n* For each `i`<sup>th</sup> index, do we `have` what we `need`?\\n    * If not, we fulfill the `need` with the left-most `j`<sup>th</sup> index based upon the `last` seen `k`<sup>th</sup> bit needed.\\n\\nNote: `need` is the running total of bitwise-OR of values of the input array `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun smallestSubarrays(A: IntArray): IntArray {\\n        var N = A.size\\n        var ans = IntArray(N)\\n        var last = IntArray(32)  // last index of each 0..31 bit set (what we need to be added onto what we have)\\n        var (have, need) = Pair(0, 0)\\n        for (i in N - 1 downTo 0) {\\n            var j = i\\n            have = A[i]\\n            need = A[i] or need\\n            for (k in 0..31) {\\n                if (have and (1 shl k) != 0) last[k] = i\\n                if (need and (1 shl k) != 0) j = Math.max(j, last[k])\\n            }\\n            ans[i] = j - i + 1  // +1 for i..j inclusive\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet smallestSubarrays = (A, have = 0, need = 0) => {\\n    let N = A.length;\\n    let ans = Array(N);\\n    let last = Array(32);  // last index of each 0..31 bit set (what we need to be added onto what we have)\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let j = i;\\n        have = A[i];\\n        need = A[i] | need;\\n        for (let k = 0; k < 32; ++k) {\\n            if (have & (1 << k)) last[k] = i;\\n            if (need & (1 << k)) j = Math.max(j, last[k]);\\n        }\\n        ans[i] = j - i + 1;  // +1 for i..j inclusive\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def smallestSubarrays(self, A: List[int], need = 0) -> List[int]:\\n        N = len(A)\\n        ans = [0] * N\\n        last = [0] * 32  # last index of each 0..31 bit set (what we need to be added onto what we have)\\n        for i in range(N - 1, -1, -1):\\n            j = i\\n            have = A[i]\\n            need = A[i] | need\\n            for k in range(32):\\n                if have & (1 << k): last[k] = i\\n                if need & (1 << k): j = max(j, last[k])\\n            ans[i] = j - i + 1  # +1 for i..j inclusive\\n        return ans\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn smallest_subarrays(A: VI) -> VI {\\n        let N = A.len();\\n        let mut ans = vec![0; N];\\n        let mut last = vec![0; 32];  // last index of each 0..31 bit set (what we need to be added onto what we have)\\n        let (mut have, mut need) = (0, 0);\\n        for i in (0..N).rev() {\\n            let mut j = i;\\n            have = A[i];\\n            need = A[i] | need;\\n            for k in 0..32 {\\n                if have & (1 << k) != 0 { last[k] = i; }\\n                if need & (1 << k) != 0 { j = max(j, last[k]) }\\n            }\\n            ans[i] = (j - i + 1) as i32;  // +1 for i..j inclusive\\n        }\\n        ans\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallestSubarrays(VI& A, int have = 0, int need = 0) {\\n        int N = A.size();\\n        VI ans(N);\\n        VI last(32);  // last index of each 0..31 bit set (what we need to be added onto what we have)\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto j = i;\\n            have = A[i];\\n            need = A[i] | need;\\n            for (auto k{ 0 }; k < 32; ++k) {\\n                if (have & (1 << k)) last[k] = i;\\n                if (need & (1 << k)) j = max(j, last[k]);\\n            }\\n            ans[i] = j - i + 1;  // +1 for i..j inclusive\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun smallestSubarrays(A: IntArray): IntArray {\\n        var N = A.size\\n        var ans = IntArray(N)\\n        var last = IntArray(32)  // last index of each 0..31 bit set (what we need to be added onto what we have)\\n        var (have, need) = Pair(0, 0)\\n        for (i in N - 1 downTo 0) {\\n            var j = i\\n            have = A[i]\\n            need = A[i] or need\\n            for (k in 0..31) {\\n                if (have and (1 shl k) != 0) last[k] = i\\n                if (need and (1 shl k) != 0) j = Math.max(j, last[k])\\n            }\\n            ans[i] = j - i + 1  // +1 for i..j inclusive\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nlet smallestSubarrays = (A, have = 0, need = 0) => {\\n    let N = A.length;\\n    let ans = Array(N);\\n    let last = Array(32);  // last index of each 0..31 bit set (what we need to be added onto what we have)\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let j = i;\\n        have = A[i];\\n        need = A[i] | need;\\n        for (let k = 0; k < 32; ++k) {\\n            if (have & (1 << k)) last[k] = i;\\n            if (need & (1 << k)) j = Math.max(j, last[k]);\\n        }\\n        ans[i] = j - i + 1;  // +1 for i..j inclusive\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def smallestSubarrays(self, A: List[int], need = 0) -> List[int]:\\n        N = len(A)\\n        ans = [0] * N\\n        last = [0] * 32  # last index of each 0..31 bit set (what we need to be added onto what we have)\\n        for i in range(N - 1, -1, -1):\\n            j = i\\n            have = A[i]\\n            need = A[i] | need\\n            for k in range(32):\\n                if have & (1 << k): last[k] = i\\n                if need & (1 << k): j = max(j, last[k])\\n            ans[i] = j - i + 1  # +1 for i..j inclusive\\n        return ans\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn smallest_subarrays(A: VI) -> VI {\\n        let N = A.len();\\n        let mut ans = vec![0; N];\\n        let mut last = vec![0; 32];  // last index of each 0..31 bit set (what we need to be added onto what we have)\\n        let (mut have, mut need) = (0, 0);\\n        for i in (0..N).rev() {\\n            let mut j = i;\\n            have = A[i];\\n            need = A[i] | need;\\n            for k in 0..32 {\\n                if have & (1 << k) != 0 { last[k] = i; }\\n                if need & (1 << k) != 0 { j = max(j, last[k]) }\\n            }\\n            ans[i] = (j - i + 1) as i32;  // +1 for i..j inclusive\\n        }\\n        ans\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallestSubarrays(VI& A, int have = 0, int need = 0) {\\n        int N = A.size();\\n        VI ans(N);\\n        VI last(32);  // last index of each 0..31 bit set (what we need to be added onto what we have)\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto j = i;\\n            have = A[i];\\n            need = A[i] | need;\\n            for (auto k{ 0 }; k < 32; ++k) {\\n                if (have & (1 << k)) last[k] = i;\\n                if (need & (1 << k)) j = max(j, last[k]);\\n            }\\n            ans[i] = j - i + 1;  // +1 for i..j inclusive\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086456,
                "title": "python-bit-hashmap-reverse-traversal-o-n-log-max-nums-tc",
                "content": "a much more challenging problem than I expected, you need to spot some tricks.\\n1. traverse in reversal\\n2. the maximum_or must be or the whole array, hence, the right subarray max or must be \\nthe \\'suffing accumulative or\\'\\n3. hashmap goes into comparing current nums with current maximum suffix or. If cur num bit is 0 and cur or is 1 in this digit, mean we want to find a number with 1 at that digit to or with it. We use a hashmap to store the last index we encounter in that bit digit. Of all cases, we know the maximum last index we include all 1 digits we need.\\n```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        run_or = 0\\n        dp = []\\n        hashmap = {}\\n        for i in range(len(nums)-1,-1,-1):\\n            run_or |= nums[i]\\n            temp = 1\\n            minimax = i\\n            counts = 0\\n            while temp <= run_or:\\n                if nums[i] & temp:\\n                    hashmap[counts] = i\\n                if run_or&temp and  nums[i]&temp == 0:\\n                    minimax = max(minimax,hashmap[counts])\\n                counts += 1\\n                temp <<=1\\n            dp.append(minimax-i+1)\\n        return dp[::-1]",
                "solutionTags": [],
                "code": "class Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        run_or = 0\\n        dp = []\\n        hashmap = {}",
                "codeTag": "Java"
            },
            {
                "id": 4000401,
                "title": "c-python-solution-with-explanation",
                "content": "Traverse nums reversely,\\nuse an array to record which index is the latest 1 bit appears in 32 bits.\\nAnd find furthest index of 1 bit, the length of subarray is furthest index - i + 1.\\n![image](https://assets.leetcode.com/users/images/6545636b-145c-47fd-a46d-ec6493794a2b_1693816614.9771085.png)\\n\\ntc isO(32n), sc is O(32).\\n\\n### python\\n```python\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        cloest = [-1] * 32\\n        ans = [0] * len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            furthest = i\\n            for j in range(32):\\n                if nums[i] >> j & 1:\\n                    cloest[j] = i\\n                if cloest[j] > furthest: furthest = cloest[j]\\n            ans[i] = furthest - i + 1\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int closest [32] {0};\\n        vector<int> ans (nums.size());\\n        for (int i = nums.size() - 1, furthest; i >= 0; i-=1) {\\n            furthest = i;\\n            for (int j = 0; j < 32; j+=1) {\\n                if (nums[i] >> j & 1)\\n                    closest[j] = i;\\n                if (closest[j] > furthest) furthest = closest[j];\\n            }\\n            ans[i] = furthest - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        cloest = [-1] * 32\\n        ans = [0] * len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            furthest = i\\n            for j in range(32):\\n                if nums[i] >> j & 1:\\n                    cloest[j] = i\\n                if cloest[j] > furthest: furthest = cloest[j]\\n            ans[i] = furthest - i + 1\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int closest [32] {0};\\n        vector<int> ans (nums.size());\\n        for (int i = nums.size() - 1, furthest; i >= 0; i-=1) {\\n            furthest = i;\\n            for (int j = 0; j < 32; j+=1) {\\n                if (nums[i] >> j & 1)\\n                    closest[j] = i;\\n                if (closest[j] > furthest) furthest = closest[j];\\n            }\\n            ans[i] = furthest - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977581,
                "title": "c-operation-on-each-bit",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int orr=0;\\n        int n=nums.size();\\n        vector<int>val(n,0);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            orr=orr|nums[i];\\n            val[i]=orr;\\n        }\\n        vector<int>ans;\\n        map<int,set<int>>bits;\\n        for(int i=0;i<n;i++)\\n        {    \\n           \\n            for(int j=0;j<32;j++)\\n            {   \\n                \\n                if(((nums[i])&(1<<j)))\\n                {   \\n                    bits[j].insert(i);\\n                }\\n            }\\n        }\\n   \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int maxxbit=val[i];\\n            int len=-1e9;\\n            for(int j=0;j<32;j++)\\n            {\\n                if((maxxbit&(1<<j)))\\n                {\\n                    auto it=bits[j].lower_bound(i);\\n                    int idx=*it;\\n                    len=max(len,idx-i+1);\\n                }\\n            }\\n            if(len==-1e9) ans.push_back(1);\\n            else\\n            ans.push_back(len);                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int orr=0;\\n        int n=nums.size();\\n        vector<int>val(n,0);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            orr=orr|nums[i];\\n            val[i]=orr;\\n        }\\n        vector<int>ans;\\n        map<int,set<int>>bits;\\n        for(int i=0;i<n;i++)\\n        {    \\n           \\n            for(int j=0;j<32;j++)\\n            {   \\n                \\n                if(((nums[i])&(1<<j)))\\n                {   \\n                    bits[j].insert(i);\\n                }\\n            }\\n        }\\n   \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int maxxbit=val[i];\\n            int len=-1e9;\\n            for(int j=0;j<32;j++)\\n            {\\n                if((maxxbit&(1<<j)))\\n                {\\n                    auto it=bits[j].lower_bound(i);\\n                    int idx=*it;\\n                    len=max(len,idx-i+1);\\n                }\\n            }\\n            if(len==-1e9) ans.push_back(1);\\n            else\\n            ans.push_back(len);                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897364,
                "title": "bits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& arr) {\\n    int n=arr.size();\\n    vector<vector<int>>suffix(n);\\n    vector<int>suff(32,n);\\n    int sum=0;\\n    \\n    for(int i=n-1;i>=0;i--){\\n        for(int j=0;j<32;j++){\\n            if(arr[i]&(1<<j)){\\n              suff[j]=i;\\n             }\\n        }\\n        suffix[i]=suff;\\n        sum |=arr[i];\\n    }\\n    vector<int>ans;\\n    for(int i=0;i<n;i++){\\n        int right=i;\\n        for(int j=0;j<32;j++){\\n            if(suffix[i][j]!=n){\\n                right=max(right,suffix[i][j]);\\n            }\\n        }\\n        cout<<right<<endl;\\n        ans.push_back(right-i+1);\\n    }\\n    //cout<<endl;\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& arr) {\\n    int n=arr.size();\\n    vector<vector<int>>suffix(n);\\n    vector<int>suff(32,n);\\n    int sum=0;\\n    \\n    for(int i=n-1;i>=0;i--){\\n        for(int j=0;j<32;j++){\\n            if(arr[i]&(1<<j)){\\n              suff[j]=i;\\n             }\\n        }\\n        suffix[i]=suff;\\n        sum |=arr[i];\\n    }\\n    vector<int>ans;\\n    for(int i=0;i<n;i++){\\n        int right=i;\\n        for(int j=0;j<32;j++){\\n            if(suffix[i][j]!=n){\\n                right=max(right,suffix[i][j]);\\n            }\\n        }\\n        cout<<right<<endl;\\n        ans.push_back(right-i+1);\\n    }\\n    //cout<<endl;\\n    return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3736978,
                "title": "c-easy-and-precise-sliding-window-solution-with-bit-count",
                "content": "# Intuition\\n<!--. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCreate a bit_vec (Vector) that stores tha count of bits that found till now\\n\\nExample\\n\\nn= [1,1,2,2,3,3]  max_or = 3\\n    i=0,j=0;\\n\\nbit_vec[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0......32 times }\\n\\nnext\\nn = [1,1,2,2,3,3]  \\n     i=0, j =2   at this position we found or = 3 so increment i\\n\\nbit_vec[] = { 2 ,1, 0 ,0 ,0 ,0 ,0  .... 32 times}\\n\\nn = [1,1,2,2,3,3]\\nres [3,0,0,0,0,0]\\n      i=1, j=2 still the or is => \\'3\\' so increment the i\\nbit_vec[]= { 1,1,0,0,0,0,.... 32 times};\\n\\nnotice how bit_vec[0] changes from 2-1 becuse , as the i incremented we need to decrement the count of bits from the bit_vec;\\n\\nand if j reached the end bit i has not the recursively call the same fucntion\\n\\nPlease upvote the solution if you found helpful it helps me keep motivated\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(32*N) not sure (please suggest as not sure about how many time reursion can go)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO(N) => for result vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getOR(vector<int> &bit_vec)  // to convet the bit_vec into number  example bit_vec[] = {2,3,4, 0 ,0,0,} => 7 as first 3 bits are set\\n    {\\n        int ans  =0;\\n        for(int i =0 ; i<32 ; i++)\\n          if(bit_vec[i] >0)\\n               ans = ans | (1<<i);   \\n        return ans;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        vector<int> bit_vec(32,0);\\n        vector<int> res((int)nums.size(), 1);\\n\\n        int OR =0;\\n\\n        for(int &i : nums)\\n        OR = OR |i;\\n\\n        int j =0 , i =0;\\n\\n        for(j =0 ;j< nums.size(); ++j)\\n        {\\n            int a = nums[j];\\n            int k =0;\\n            while(a) // add bit count of current numebr to vector\\n            {\\n                if(a & 1)\\n                bit_vec[k]++;\\n                a >>=1;\\n                ++k;\\n            }\\n\\n            while(i <=j and getOR(bit_vec) >= OR) // increment i uthil there is maximum or\\n            {\\n                res[i] = j-i+1;\\n                \\n                a= nums[i]; k=0;\\n                while(a) // remove the bit count from vector\\n                {\\n                    if(a & 1)\\n                    bit_vec[k]--;\\n                    a >>=1;\\n                    ++k;\\n                }\\n                i++;\\n            }\\n        }\\n        if(i< nums.size()) // if i is still less than nums size then recursively call the function \\n        {\\n            vector<int> t(nums.begin()+i,nums.end());\\n            auto v = smallestSubarrays( t);\\n\\n            for(int k = i ;k< nums.size() ; k++)\\n              res[k] =v[k-i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getOR(vector<int> &bit_vec)  // to convet the bit_vec into number  example bit_vec[] = {2,3,4, 0 ,0,0,} => 7 as first 3 bits are set\\n    {\\n        int ans  =0;\\n        for(int i =0 ; i<32 ; i++)\\n          if(bit_vec[i] >0)\\n               ans = ans | (1<<i);   \\n        return ans;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        vector<int> bit_vec(32,0);\\n        vector<int> res((int)nums.size(), 1);\\n\\n        int OR =0;\\n\\n        for(int &i : nums)\\n        OR = OR |i;\\n\\n        int j =0 , i =0;\\n\\n        for(j =0 ;j< nums.size(); ++j)\\n        {\\n            int a = nums[j];\\n            int k =0;\\n            while(a) // add bit count of current numebr to vector\\n            {\\n                if(a & 1)\\n                bit_vec[k]++;\\n                a >>=1;\\n                ++k;\\n            }\\n\\n            while(i <=j and getOR(bit_vec) >= OR) // increment i uthil there is maximum or\\n            {\\n                res[i] = j-i+1;\\n                \\n                a= nums[i]; k=0;\\n                while(a) // remove the bit count from vector\\n                {\\n                    if(a & 1)\\n                    bit_vec[k]--;\\n                    a >>=1;\\n                    ++k;\\n                }\\n                i++;\\n            }\\n        }\\n        if(i< nums.size()) // if i is still less than nums size then recursively call the function \\n        {\\n            vector<int> t(nums.begin()+i,nums.end());\\n            auto v = smallestSubarrays( t);\\n\\n            for(int k = i ;k< nums.size() ; k++)\\n              res[k] =v[k-i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736977,
                "title": "c-easy-and-precise-sliding-window-solution-with-bit-count",
                "content": "# Intuition\\n<!--. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCreate a bit_vec (Vector) that stores tha count of bits that found till now\\n\\nExample\\n\\nn= [1,1,2,2,3,3]  max_or = 3\\n    i=0,j=0;\\n\\nbit_vec[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0......32 times }\\n\\nnext\\nn = [1,1,2,2,3,3]  \\n     i=0, j =2   at this position we found or = 3 so increment i\\n\\nbit_vec[] = { 2 ,1, 0 ,0 ,0 ,0 ,0  .... 32 times}\\n\\nn = [1,1,2,2,3,3]\\nres [3,0,0,0,0,0]\\n      i=1, j=2 still the or is => \\'3\\' so increment the i\\nbit_vec[]= { 1,1,0,0,0,0,.... 32 times};\\n\\nnotice how bit_vec[0] changes from 2-1 becuse , as the i incremented we need to decrement the count of bits from the bit_vec;\\n\\nand if j reached the end bit i has not the recursively call the same fucntion\\n\\nPlease upvote the solution if you found helpful it helps me keep motivated\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(32*N) not sure (please suggest as not sure about how many time reursion can go)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO(N) => for result vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getOR(vector<int> &bit_vec)  // to convet the bit_vec into number  example bit_vec[] = {2,3,4, 0 ,0,0,} => 7 as first 3 bits are set\\n    {\\n        int ans  =0;\\n        for(int i =0 ; i<32 ; i++)\\n          if(bit_vec[i] >0)\\n               ans = ans | (1<<i);   \\n        return ans;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        vector<int> bit_vec(32,0);\\n        vector<int> res((int)nums.size(), 1);\\n\\n        int OR =0;\\n\\n        for(int &i : nums)\\n        OR = OR |i;\\n\\n        int j =0 , i =0;\\n\\n        for(j =0 ;j< nums.size(); ++j)\\n        {\\n            int a = nums[j];\\n            int k =0;\\n            while(a) // add bit count of current numebr to vector\\n            {\\n                if(a & 1)\\n                bit_vec[k]++;\\n                a >>=1;\\n                ++k;\\n            }\\n\\n            while(i <=j and getOR(bit_vec) >= OR) // increment i uthil there is maximum or\\n            {\\n                res[i] = j-i+1;\\n                \\n                a= nums[i]; k=0;\\n                while(a) // remove the bit count from vector\\n                {\\n                    if(a & 1)\\n                    bit_vec[k]--;\\n                    a >>=1;\\n                    ++k;\\n                }\\n                i++;\\n            }\\n        }\\n        if(i< nums.size()) // if i is still less than nums size then recursively call the function \\n        {\\n            vector<int> t(nums.begin()+i,nums.end());\\n            auto v = smallestSubarrays( t);\\n\\n            for(int k = i ;k< nums.size() ; k++)\\n              res[k] =v[k-i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getOR(vector<int> &bit_vec)  // to convet the bit_vec into number  example bit_vec[] = {2,3,4, 0 ,0,0,} => 7 as first 3 bits are set\\n    {\\n        int ans  =0;\\n        for(int i =0 ; i<32 ; i++)\\n          if(bit_vec[i] >0)\\n               ans = ans | (1<<i);   \\n        return ans;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        vector<int> bit_vec(32,0);\\n        vector<int> res((int)nums.size(), 1);\\n\\n        int OR =0;\\n\\n        for(int &i : nums)\\n        OR = OR |i;\\n\\n        int j =0 , i =0;\\n\\n        for(j =0 ;j< nums.size(); ++j)\\n        {\\n            int a = nums[j];\\n            int k =0;\\n            while(a) // add bit count of current numebr to vector\\n            {\\n                if(a & 1)\\n                bit_vec[k]++;\\n                a >>=1;\\n                ++k;\\n            }\\n\\n            while(i <=j and getOR(bit_vec) >= OR) // increment i uthil there is maximum or\\n            {\\n                res[i] = j-i+1;\\n                \\n                a= nums[i]; k=0;\\n                while(a) // remove the bit count from vector\\n                {\\n                    if(a & 1)\\n                    bit_vec[k]--;\\n                    a >>=1;\\n                    ++k;\\n                }\\n                i++;\\n            }\\n        }\\n        if(i< nums.size()) // if i is still less than nums size then recursively call the function \\n        {\\n            vector<int> t(nums.begin()+i,nums.end());\\n            auto v = smallestSubarrays( t);\\n\\n            for(int k = i ;k< nums.size() ; k++)\\n              res[k] =v[k-i];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692148,
                "title": "dynamic-programming-approach-with-python",
                "content": "# Intuition\\n> We can iterate through nums in reverse order to find the maximum OR reachable from each index. After this we will iterate through nums from each index until we will reach the target OR. We will use dynamic programming to improve time efficiency.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport sys\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n\\n        def helper(i, item, target):\\n\\n            #Dynamic programming\\n            if (i, item, target) in dp:\\n                return dp[i, item, target]\\n            \\n            #Has target been reached in the current index\\n            temp = item | nums[i]\\n            if temp == target:\\n                dp[i, item, target] = 1\\n            #Recursion call\\n            else:\\n                dp[i, item, target] = helper(i+1, temp, target) + 1\\n\\n            return dp[i, item, target]\\n\\n        #Increase recursion limit\\n        sys.setrecursionlimit(10**6)\\n        n = len(nums)\\n\\n        #Find the maximum or reachable from each index\\n        item = 0\\n        max_or = []\\n        for i in range(n):\\n            item |= nums[-i-1]\\n            max_or.append(item)        \\n        max_or.reverse()\\n\\n        #Iterate through the array\\n        dp = {}\\n        output = []\\n        for i in range(n):\\n            output.append(helper(i, 0, max_or[i]))\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nimport sys\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n\\n        def helper(i, item, target):\\n\\n            #Dynamic programming\\n            if (i, item, target) in dp:\\n                return dp[i, item, target]\\n            \\n            #Has target been reached in the current index\\n            temp = item | nums[i]\\n            if temp == target:\\n                dp[i, item, target] = 1\\n            #Recursion call\\n            else:\\n                dp[i, item, target] = helper(i+1, temp, target) + 1\\n\\n            return dp[i, item, target]\\n\\n        #Increase recursion limit\\n        sys.setrecursionlimit(10**6)\\n        n = len(nums)\\n\\n        #Find the maximum or reachable from each index\\n        item = 0\\n        max_or = []\\n        for i in range(n):\\n            item |= nums[-i-1]\\n            max_or.append(item)        \\n        max_or.reverse()\\n\\n        #Iterate through the array\\n        dp = {}\\n        output = []\\n        for i in range(n):\\n            output.append(helper(i, 0, max_or[i]))\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664329,
                "title": "very-simple-and-easy-solution-using-segment-tree-two-pointer-prefix-or",
                "content": "# Intuition\\nFirst find the maximum value for each subarray using reverse prefix or\\nthen start from the right hand side and try to reduce the boundary \\nsee the solution you will easily understand.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n\\nclass SegmentTree{\\n  vector <int> seg;\\n    public:\\n    SegmentTree(int n)\\n    {\\n        seg.resize(4*n,0);\\n    }\\n    void build(int node,int l,int r,vector <int> &nums)\\n    {\\n        if(l==r)\\n        {\\n            seg[node] = nums[l];\\n            return;\\n        }\\n        int mid = (l+r)>>1;\\n        build(2*node+1,l,mid,nums);\\n        build(2*node+2,mid+1,r,nums);\\n        \\n        seg[node] = seg[2*node+1]|seg[2*node+2];\\n    }\\n    \\n    int query(int node,int left,int right,int l,int r)\\n    {\\n        if(l>r||r<left||right<l) return 0;\\n        if(l>=left&&r<=right) return seg[node];\\n        \\n        int mid = (l+r)>>1;\\n        return query(2*node+1,left,right,l,mid) | query(2*node+2,left,right,mid+1,r);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        SegmentTree segmentTree(n);\\n       segmentTree.build(0,0,n-1,nums);\\n        vector <int> maxOR(n);\\n        maxOR[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            maxOR[i] = maxOR[i+1] | nums[i];\\n        }\\n        int i=n-2,j=n-1;\\n        vector <int> ans(n);\\n        ans[n-1] = 1;\\n        \\n        while(i>=0)\\n        {\\n            while(i<j&&segmentTree.query(0,i,j-1,0,n-1)>=maxOR[i])\\n                j--;\\n            ans[i] = j-i+1;\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Segment Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass SegmentTree{\\n  vector <int> seg;\\n    public:\\n    SegmentTree(int n)\\n    {\\n        seg.resize(4*n,0);\\n    }\\n    void build(int node,int l,int r,vector <int> &nums)\\n    {\\n        if(l==r)\\n        {\\n            seg[node] = nums[l];\\n            return;\\n        }\\n        int mid = (l+r)>>1;\\n        build(2*node+1,l,mid,nums);\\n        build(2*node+2,mid+1,r,nums);\\n        \\n        seg[node] = seg[2*node+1]|seg[2*node+2];\\n    }\\n    \\n    int query(int node,int left,int right,int l,int r)\\n    {\\n        if(l>r||r<left||right<l) return 0;\\n        if(l>=left&&r<=right) return seg[node];\\n        \\n        int mid = (l+r)>>1;\\n        return query(2*node+1,left,right,l,mid) | query(2*node+2,left,right,mid+1,r);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        SegmentTree segmentTree(n);\\n       segmentTree.build(0,0,n-1,nums);\\n        vector <int> maxOR(n);\\n        maxOR[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            maxOR[i] = maxOR[i+1] | nums[i];\\n        }\\n        int i=n-2,j=n-1;\\n        vector <int> ans(n);\\n        ans[n-1] = 1;\\n        \\n        while(i>=0)\\n        {\\n            while(i<j&&segmentTree.query(0,i,j-1,0,n-1)>=maxOR[i])\\n                j--;\\n            ans[i] = j-i+1;\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614808,
                "title": "a-middle-earth-tale-of-smallest-subarrays-and-maximum-bitwise-or",
                "content": "**Solution**\\n\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n\\n        def update_last_seen_bits(num, index, last_seen_bits):\\n            \"\"\"Updates the last seen indices of each bit in \\'num\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    last_seen_bits[bit_index] = index\\n                bit_index += 1\\n\\n        # Calculate the maximum bit length to cover all bits in \\'nums\\'.\\n        max_bit_length = max(1, max(n.bit_length() for n in nums))\\n\\n        # Initialize the last seen bits array.\\n        last_seen_bits = [0] * max_bit_length\\n\\n        # Initialize the result array.\\n        result = [0] * len(nums)\\n\\n        # Iterate over \\'nums\\' in reverse order.\\n        for i in range(len(nums) - 1, -1, -1):\\n            update_last_seen_bits(nums[i], i, last_seen_bits)\\n            # The size of the smallest subarray with maximum bitwise OR \\n            # starting at \\'i\\' is the maximum last seen bit index - \\'i\\' + 1.\\n            result[i] = max(1, max(last_seen_bits) - i + 1)\\n\\n        return result\\n\\n```\\n\\n\\nIn the land of Middle-Earth, where shadows lie and algorithms thrive, we find ourselves on an epic quest. A quest not for the One Ring, but for an understanding of a powerful algorithmic problem - finding the smallest subarrays with maximum bitwise OR.\\n\\n## Setting Forth on the Quest\\n\\nThe brave fellowship of coders are given an array of non-negative integers, `nums`. Their task is to find, for each starting point in the array, the length of the smallest subarray which yields the maximum bitwise OR. The bitwise OR of an array is simply the bitwise OR of all its numbers. The output of their journey will be an array of integers, each representing the smallest subarray length with maximum bitwise OR, for each starting point in `nums`.\\n\\n## The Secret of the Last Seen Bits\\n\\nThe wise wizards of the fellowship devised a cunning strategy. They knew that to compute the maximum bitwise OR, they would need to understand the layout of the bits in each number. But they also knew that the bit length of any number, on most mortal and immortal computers, is limited to either 32 or 64 bits. Hence, they could create an array, `last_seen_bits`, to keep track of the last occurrence of each bit in the numbers from `nums`.\\n\\n```python\\nmax_bit_length = max(1, max(n.bit_length() for n in nums))\\nlast_seen_bits = [0] * max_bit_length\\n```\\nIn this part of the journey, the `max_bit_length` is calculated. This ensures that the `last_seen_bits` array covers all possible bits in `nums`. The `max(1, ...)` construction is used to handle the case where `nums` is an empty array.\\n\\n## The Journey Backwards\\n\\nThe wise wizards also knew that the smallest subarray with maximum bitwise OR, for each starting point in the array, can be found by traversing the array in reverse order. As they traverse `nums`, for each number, they go through its bits. For each bit that is set (1), they update the corresponding element in `last_seen_bits` to the current index. This enchantment is performed by the `update_last_seen_bits` function.\\n\\n```python\\ndef update_last_seen_bits(num, index, last_seen_bits):\\n\\tbit_index = 0\\n\\twhile (num >> bit_index):\\n\\t\\tif (num >> bit_index) & 1:\\n\\t\\t\\tlast_seen_bits[bit_index] = index\\n\\t\\tbit_index += 1\\n```\\n\\n## One Subarray to Rule Them All\\n\\nThe fellowship now understood that for each starting index `i`, the length of the smallest subarray with maximum bitwise OR is given by the maximum last seen bit index - `i` + 1. This is because the maximum bitwise OR starting at `i` must include all bits set in `nums[i]`, and hence must include all numbers up to the maximum last seen bit index. \\n\\n```python\\nresult = [0] * len(nums)\\nfor i in range(len(nums) - 1, -1, -1):\\n\\tupdate_last_seen_bits(nums[i], i, last_seen_bits)\\n\\tresult[i] = max(1, max(last_seen_bits) - i + 1)\\nreturn result\\n```\\n\\n## The Path to Mount Doom\\n\\nThis valiant strategy led the fellowship through their quest with both speed and precision. The time complexity of their journey is O(nm), where `n` is the number of elements in `nums` and `m` is the maximum bit length in `nums`. However, given that `m` is limited to either 32 or 64 on most machines, it can be treated as a constant factor, making the overall time complexity effectively O(n).\\n\\nTheir journey also left a small footprint. The space complexity of the solution is O(m), which arises from the need to store the result array and the `last_seen_bits` array. Again, given the constraints on `m`, it can be treated as a constant factor, yielding a space complexity of O(1).\\n\\n## Return of the King\\n\\nWith their quest completed, the fellowship has illuminated the path to understanding the smallest subarrays with maximum bitwise OR. Their tale serves as a reminder that even in the deepest darkness, there is a light that never goes out - the light of knowledge, of understanding, and of the joy of coding.",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n\\n        def update_last_seen_bits(num, index, last_seen_bits):\\n            \"\"\"Updates the last seen indices of each bit in \\'num\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    last_seen_bits[bit_index] = index\\n                bit_index += 1\\n\\n        # Calculate the maximum bit length to cover all bits in \\'nums\\'.\\n        max_bit_length = max(1, max(n.bit_length() for n in nums))\\n\\n        # Initialize the last seen bits array.\\n        last_seen_bits = [0] * max_bit_length\\n\\n        # Initialize the result array.\\n        result = [0] * len(nums)\\n\\n        # Iterate over \\'nums\\' in reverse order.\\n        for i in range(len(nums) - 1, -1, -1):\\n            update_last_seen_bits(nums[i], i, last_seen_bits)\\n            # The size of the smallest subarray with maximum bitwise OR \\n            # starting at \\'i\\' is the maximum last seen bit index - \\'i\\' + 1.\\n            result[i] = max(1, max(last_seen_bits) - i + 1)\\n\\n        return result\\n\\n```\n```python\\nmax_bit_length = max(1, max(n.bit_length() for n in nums))\\nlast_seen_bits = [0] * max_bit_length\\n```\n```python\\ndef update_last_seen_bits(num, index, last_seen_bits):\\n\\tbit_index = 0\\n\\twhile (num >> bit_index):\\n\\t\\tif (num >> bit_index) & 1:\\n\\t\\t\\tlast_seen_bits[bit_index] = index\\n\\t\\tbit_index += 1\\n```\n```python\\nresult = [0] * len(nums)\\nfor i in range(len(nums) - 1, -1, -1):\\n\\tupdate_last_seen_bits(nums[i], i, last_seen_bits)\\n\\tresult[i] = max(1, max(last_seen_bits) - i + 1)\\nreturn result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614642,
                "title": "the-jedi-path-to-unraveling-the-smallest-subarrays-with-maximum-bitwise-or",
                "content": "**Solution**\\n```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n\\n        def add_to_dict(num, bit_dict):\\n            \"\"\"Adds the bits of \\'num\\' to the dictionary \\'bit_dict\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    bit_dict[bit_index] += 1\\n                bit_index += 1\\n\\n        def remove_from_dict(num, bit_dict):\\n            \"\"\"Removes the bits of \\'num\\' from the dictionary \\'bit_dict\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    bit_dict[bit_index] -= 1\\n                    if bit_dict[bit_index] == 0:\\n                        del bit_dict[bit_index]\\n                bit_index += 1\\n\\n        bit_counts = defaultdict(int)\\n        for num in nums:\\n            add_to_dict(num, bit_counts)\\n\\n        current_bit_counts = defaultdict(int)\\n        right_ptr = 0\\n        ans = [0] * len(nums)\\n        \\n        for left_ptr, num in enumerate(nums):\\n            if len(bit_counts) == 0:\\n                for j in range(left_ptr, len(nums)):\\n                    ans[j] = 1\\n                break\\n            \\n            while len(current_bit_counts) != len(bit_counts):\\n                add_to_dict(nums[right_ptr], current_bit_counts)\\n                right_ptr += 1\\n                \\n            ans[left_ptr] = right_ptr - left_ptr\\n            \\n            remove_from_dict(num, bit_counts)\\n            remove_from_dict(num, current_bit_counts)\\n        \\n        return ans\\n\\n```\\n\\nIn a galaxy far, far away, the Jedi Council of Data Structures and Algorithms has uncovered a new challenge, one that requires a deep understanding of the Force, also known as Bit Manipulation and Sliding Window techniques. This complex task involves finding the smallest subarrays within a given array, such that the bitwise OR of each subarray is maximized. Worry not, young padawans. The path may be treacherous, but the Force is with us. We shall embark on this quest and solve this enigma together.\\n\\n## The Task at Hand\\n\\nOur mission is to determine the size of the smallest subarray with maximum possible bitwise OR starting at each index i in a given array, `nums`. The bitwise OR of an array is the bitwise OR of all numbers within it. Our output shall be an array of equal size, where each element corresponds to the length of the smallest subarray starting at the respective index in `nums` that achieves this maximum bitwise OR.\\n\\n## The Force of Sliding Windows and Bit Manipulation\\n\\nOur Jedi solution calls upon two powerful techniques in the coding universe - the Sliding Window and Bit Manipulation. The Sliding Window approach harnesses the powers of two pointers, `left_ptr` and `right_ptr`, that define our current window within the array. As these pointers traverse the galaxy of our array, they uncover the smallest subarray size needed to reach the maximum bitwise OR at each index. \\n\\nBit Manipulation, our second tool, comes into play when we\\'re calculating the bitwise OR for the numbers in our current window. We use it to track and manipulate the individual bits of our numbers, allowing us to reach the maximum bitwise OR with Jedi-like precision and efficiency.\\n\\n## The Path to the Solution\\n\\nNow, let\\'s embark on our coding journey together. Remember, a Jedi\\'s strength flows from the Force. \\n\\n```python\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n```\\n\\nThe first step in our journey is the creation of two helper functions, `add_to_dict` and `remove_from_dict`. These two functions use the power of Bit Manipulation to respectively add and remove the bits of a number to and from a dictionary:\\n\\n```python\\n        def add_to_dict(num, bit_dict):\\n            \"\"\"Adds the bits of \\'num\\' to the dictionary \\'bit_dict\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    bit_dict[bit_index] += 1\\n                bit_index += 1\\n\\n        def remove_from_dict(num, bit_dict):\\n            \"\"\"Removes the bits of \\'num\\' from the dictionary \\'bit_dict\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    bit_dict[bit_index] -= 1\\n                    if bit_dict[bit_index] == 0:\\n                        del bit_dict[bit_index]\\n                bit_index += 1\\n```\\n\\nHaving constructed our helper functions, we now create the `bit_counts` dictionary. This Jedi tool stores the count of each bit present in the bitwise OR of all numbers in `nums`:\\n\\n```python\\n        bit_counts = defaultdict(int)\\n        for num in nums:\\n            add_to_dict(num, bit_counts)\\n```\\n\\nNext, we initialize `current_bit_counts`, a dictionary that will keep track of the bits in the bitwise OR of the numbers within our current window. We also set up `right_ptr`, the pointer that will slide across `nums` to extend our\\n\\n current window:\\n\\n```python\\n        current_bit_counts = defaultdict(int)\\n        right_ptr = 0\\n        ans = [0] * len(nums)\\n```\\n\\nOur next task is to traverse the universe of our array with the `left_ptr` pointer. The current window starts at the `left_ptr` index, and we extend this window by moving `right_ptr` until the bitwise OR of the numbers in the window equals the maximum bitwise OR. This equality is checked by comparing `current_bit_counts` with `bit_counts`. \\n\\n```python\\n        for left_ptr, num in enumerate(nums):\\n            if len(bit_counts) == 0:\\n                for j in range(left_ptr, len(nums)):\\n                    ans[j] = 1\\n                break\\n            \\n            while len(current_bit_counts) != len(bit_counts):\\n                add_to_dict(nums[right_ptr], current_bit_counts)\\n                right_ptr += 1\\n                \\n            ans[left_ptr] = right_ptr - left_ptr\\n```\\n\\nThe last part of our journey involves moving the `left_ptr` to the right, effectively reducing the window size by one. The `num` at this index is removed from both `bit_counts` and `current_bit_counts` to reflect this change. This process continues until the entire array has been traversed:\\n\\n```python\\n            remove_from_dict(num, bit_counts)\\n            remove_from_dict(num, current_bit_counts)\\n        \\n        return ans\\n```\\n\\n## The Computational Complexity of the Force\\n\\nThe path we have tread together is not just the way of the Jedi, but also the way of Optimal Algorithm Design. Our approach here is efficient and elegant, boasting a time complexity of O(n). Each number in the array is processed exactly once due to the nature of the sliding window technique, which results in a linear time complexity. \\n\\nIn terms of space complexity, our solution sits at O(n). This arises from the need to store the output array `ans` and the dictionaries for bit counts, which in the worst-case scenario could be as large as the input array.\\n\\n## In a Galaxy not so far away\\u2026\\n\\nOur journey has now come to an end. We have successfully solved the problem with the wisdom of the Jedi, unraveling the secrets of Bit Manipulation and the Sliding Window technique. Remember, the Force will be with you. Always.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n\\n        def add_to_dict(num, bit_dict):\\n            \"\"\"Adds the bits of \\'num\\' to the dictionary \\'bit_dict\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    bit_dict[bit_index] += 1\\n                bit_index += 1\\n\\n        def remove_from_dict(num, bit_dict):\\n            \"\"\"Removes the bits of \\'num\\' from the dictionary \\'bit_dict\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    bit_dict[bit_index] -= 1\\n                    if bit_dict[bit_index] == 0:\\n                        del bit_dict[bit_index]\\n                bit_index += 1\\n\\n        bit_counts = defaultdict(int)\\n        for num in nums:\\n            add_to_dict(num, bit_counts)\\n\\n        current_bit_counts = defaultdict(int)\\n        right_ptr = 0\\n        ans = [0] * len(nums)\\n        \\n        for left_ptr, num in enumerate(nums):\\n            if len(bit_counts) == 0:\\n                for j in range(left_ptr, len(nums)):\\n                    ans[j] = 1\\n                break\\n            \\n            while len(current_bit_counts) != len(bit_counts):\\n                add_to_dict(nums[right_ptr], current_bit_counts)\\n                right_ptr += 1\\n                \\n            ans[left_ptr] = right_ptr - left_ptr\\n            \\n            remove_from_dict(num, bit_counts)\\n            remove_from_dict(num, current_bit_counts)\\n        \\n        return ans\\n\\n```\n```python\\nfrom collections import defaultdict\\nfrom typing import List\\n\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n```\n```python\\n        def add_to_dict(num, bit_dict):\\n            \"\"\"Adds the bits of \\'num\\' to the dictionary \\'bit_dict\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    bit_dict[bit_index] += 1\\n                bit_index += 1\\n\\n        def remove_from_dict(num, bit_dict):\\n            \"\"\"Removes the bits of \\'num\\' from the dictionary \\'bit_dict\\'.\"\"\"\\n            bit_index = 0\\n            while (num >> bit_index):\\n                if (num >> bit_index) & 1:\\n                    bit_dict[bit_index] -= 1\\n                    if bit_dict[bit_index] == 0:\\n                        del bit_dict[bit_index]\\n                bit_index += 1\\n```\n```python\\n        bit_counts = defaultdict(int)\\n        for num in nums:\\n            add_to_dict(num, bit_counts)\\n```\n```python\\n        current_bit_counts = defaultdict(int)\\n        right_ptr = 0\\n        ans = [0] * len(nums)\\n```\n```python\\n        for left_ptr, num in enumerate(nums):\\n            if len(bit_counts) == 0:\\n                for j in range(left_ptr, len(nums)):\\n                    ans[j] = 1\\n                break\\n            \\n            while len(current_bit_counts) != len(bit_counts):\\n                add_to_dict(nums[right_ptr], current_bit_counts)\\n                right_ptr += 1\\n                \\n            ans[left_ptr] = right_ptr - left_ptr\\n```\n```python\\n            remove_from_dict(num, bit_counts)\\n            remove_from_dict(num, current_bit_counts)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568432,
                "title": "simple-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<vector<int>> list(n, vector<int>(30));\\n        for(int i=0;i<n;i++) {\\n            int temp = nums[i];\\n            for(int j=0;j<30;j++) {\\n                list[i][j]=temp%2;\\n                temp/=2;\\n            }\\n        }\\n        \\n        vector<vector<int>>  prefix(n, vector<int>(30)), for_bi(30, vector<int>(n));\\n        prefix[0] = list[0];\\n        for(int i=1;i<n;i++) {\\n            for(int j=0;j<30;j++) {\\n                prefix[i][j]=prefix[i-1][j]+list[i][j];\\n                for_bi[j][i]=prefix[i][j];\\n            }\\n        }\\n        \\n        vector<int> compare(30);\\n        compare = prefix[n-1];\\n        \\n        vector<int> ans(n);\\n        ans[n-1] = 1;\\n        \\n        for(int i=0;i<n-1;i++) {\\n            int temp = 1;\\n            for(int j=0;j<30;j++) {\\n                if(prefix[i][j]<compare[j] && list[i][j]==0) {\\n                    vector<int>::iterator fk=lower_bound(for_bi[j].begin()+i,for_bi[j].end(),prefix[i][j]+1);\\n                    int x = (fk - (for_bi[j].begin()+i));\\n                    temp = max(temp, x + 1);\\n                }\\n            }\\n            ans[i]=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        vector<vector<int>> list(n, vector<int>(30));\\n        for(int i=0;i<n;i++) {\\n            int temp = nums[i];\\n            for(int j=0;j<30;j++) {\\n                list[i][j]=temp%2;\\n                temp/=2;\\n            }\\n        }\\n        \\n        vector<vector<int>>  prefix(n, vector<int>(30)), for_bi(30, vector<int>(n));\\n        prefix[0] = list[0];\\n        for(int i=1;i<n;i++) {\\n            for(int j=0;j<30;j++) {\\n                prefix[i][j]=prefix[i-1][j]+list[i][j];\\n                for_bi[j][i]=prefix[i][j];\\n            }\\n        }\\n        \\n        vector<int> compare(30);\\n        compare = prefix[n-1];\\n        \\n        vector<int> ans(n);\\n        ans[n-1] = 1;\\n        \\n        for(int i=0;i<n-1;i++) {\\n            int temp = 1;\\n            for(int j=0;j<30;j++) {\\n                if(prefix[i][j]<compare[j] && list[i][j]==0) {\\n                    vector<int>::iterator fk=lower_bound(for_bi[j].begin()+i,for_bi[j].end(),prefix[i][j]+1);\\n                    int x = (fk - (for_bi[j].begin()+i));\\n                    temp = max(temp, x + 1);\\n                }\\n            }\\n            ans[i]=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388957,
                "title": "python-find-the-largest-distance-for-each-bit-of-the-maximum-or-value",
                "content": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        # two sweeps\\n        len_n = len(nums)\\n        # sweep 1: find the maximum OR value at each index\\n        max_or = [0] * len_n\\n        idx, c_or = len_n - 1, 0\\n        while idx >= 0:\\n            c_or |= nums[idx]\\n            max_or[idx] = c_or\\n            idx -= 1\\n        \\n        # sweep 2: starting from the last number, track the closest index for every bit\\n        ans = [1] * len_n\\n        bidx = [None] * 32\\n        idx = len_n - 1\\n        while idx >= 0:\\n            i = 0\\n            n = nums[idx]\\n            while n:\\n                if n & 1:\\n                    bidx[i] = idx\\n                i += 1\\n                n >>= 1\\n            mor = max_or[idx]\\n            max_dist, i = 1, 0\\n            while mor:\\n                if mor & 1:\\n                    max_dist = max(max_dist, bidx[i] - idx + 1)\\n                i += 1\\n                mor >>= 1\\n            ans[idx] = max_dist\\n            idx -= 1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        # two sweeps\\n        len_n = len(nums)\\n        # sweep 1: find the maximum OR value at each index\\n        max_or = [0] * len_n\\n        idx, c_or = len_n - 1, 0\\n        while idx >= 0:\\n            c_or |= nums[idx]\\n            max_or[idx] = c_or\\n            idx -= 1\\n        \\n        # sweep 2: starting from the last number, track the closest index for every bit\\n        ans = [1] * len_n\\n        bidx = [None] * 32\\n        idx = len_n - 1\\n        while idx >= 0:\\n            i = 0\\n            n = nums[idx]\\n            while n:\\n                if n & 1:\\n                    bidx[i] = idx\\n                i += 1\\n                n >>= 1\\n            mor = max_or[idx]\\n            max_dist, i = 1, 0\\n            while mor:\\n                if mor & 1:\\n                    max_dist = max(max_dist, bidx[i] - idx + 1)\\n                i += 1\\n                mor >>= 1\\n            ans[idx] = max_dist\\n            idx -= 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340452,
                "title": "c-store-the-count-of-each-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we need to calculate the max OR starting at i.\\n`x[i]`: the maximum OR value starting from `i`.\\n\\nStarting from position 0, we extend the sliding window to the right `j`. Update `bits` array with `nums[j]`, meaing do the OR operation. \\n\\nNow we have a new OR value from `nums[i..j]`. \\n\\nCompare this new OR value with `x[i]`. If the values are the same, we find a minimum subarray for index `i`, the length is `j-i+1`.\\n\\nAfter finding the minimum subarray for index `i`, `nums[i]` is no longer needed and can be removed from `bits` array.\\n\\nWe keep shrinking the left boundry of the sliding window `i` as long as current XOR is equal to `num[i]`.\\n\\nFinally, when `i` or `j` reaches the end of the array, exit the loop.\\n\\nIf `i` is less than `j`, it means we cannot find a smaller subarray for these `i` and their subarray length will be `j-i`, meaning starting from every `i` till the end of the array.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> bits;\\n    inline int getNum() {\\n        int num = 0;\\n        for(int i=0; i<32; i++) {\\n            if(bits[i]>0) \\n                num |= (1<<i);\\n        }\\n        return num;\\n    }\\n    \\n    inline void addNum(int num) {\\n        for(int i=0; i<32; i++) {\\n            if(num & (1<<i)) {\\n                bits[i]++;\\n            }\\n        }\\n    }\\n    \\n    inline void removeNum(int num) {\\n        for(int i=0; i<32; i++) {\\n            if(num & (1<<i)) {\\n                bits[i]--;\\n            }\\n        }\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        // bits stores the count of each bit\\n        bits.resize(32, 0);\\n\\n        // calculate OR of every i\\n        int n = nums.size();\\n        vector<int> x(n, 0);\\n        for(int i=n-1; i>=0; i--) {\\n            x[i] = (i+1<n?x[i+1]:0) | nums[i];\\n        }\\n        \\n        vector<int> ret(n, 0);\\n        int i = 0, j = 0;\\n        while(i<n && j<n) {\\n            addNum(nums[j]);\\n            while(i<=j && x[i] == getNum()) {\\n                ret[i] = j-i+1;\\n                removeNum(nums[i]);\\n                ++i;\\n            }\\n            ++j;\\n        }\\n        while(i<j) {\\n            ret[i] = j-i;\\n            i++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bits;\\n    inline int getNum() {\\n        int num = 0;\\n        for(int i=0; i<32; i++) {\\n            if(bits[i]>0) \\n                num |= (1<<i);\\n        }\\n        return num;\\n    }\\n    \\n    inline void addNum(int num) {\\n        for(int i=0; i<32; i++) {\\n            if(num & (1<<i)) {\\n                bits[i]++;\\n            }\\n        }\\n    }\\n    \\n    inline void removeNum(int num) {\\n        for(int i=0; i<32; i++) {\\n            if(num & (1<<i)) {\\n                bits[i]--;\\n            }\\n        }\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        // bits stores the count of each bit\\n        bits.resize(32, 0);\\n\\n        // calculate OR of every i\\n        int n = nums.size();\\n        vector<int> x(n, 0);\\n        for(int i=n-1; i>=0; i--) {\\n            x[i] = (i+1<n?x[i+1]:0) | nums[i];\\n        }\\n        \\n        vector<int> ret(n, 0);\\n        int i = 0, j = 0;\\n        while(i<n && j<n) {\\n            addNum(nums[j]);\\n            while(i<=j && x[i] == getNum()) {\\n                ret[i] = j-i+1;\\n                removeNum(nums[i]);\\n                ++i;\\n            }\\n            ++j;\\n        }\\n        while(i<j) {\\n            ret[i] = j-i;\\n            i++;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290835,
                "title": "bitwise-implementation-bit-manipulation-c",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> smallestSubarrays(vector<int> &nums)\\n        {\\n            vector<int> ans;\\n            vector<vector < int>> bits(32);    // to store the ith bit is set at which positions \\n            for (int i = 0; i < 32; i++)\\n            {\\n                for (int j = 0; j < nums.size(); j++)\\n                {\\n                    if (nums[j] >> i &1)           // if this number has ith bit set then push_back its position in bits[i]\\n                    {\\n                        bits[i].push_back(j);\\n                    }\\n                }\\n            }\\n            vector<int> mx_or(nums.size());     // to find the max OR possible starting from current index \\n            int curr = 0;\\n            for (int i = nums.size() - 1; i >= 0; i--)    // We need to iterate backwards for linear time complexity\\n            {\\n                curr |= nums[i];\\n                mx_or[i] = curr;\\n            }\\n\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                int mx = 0;\\n                for (int j = 0; j < 32; j++)\\n                {\\n                    if (mx_or[i] >> j &1)                // if the jth bit is set in the max OR possible for this index \\n                    {\\n                        if ((nums[i] >> j &1) == 0)  // if it is not set in our current number i.e nums[i].We need to find the\\n\\t\\t\\t\\t\\t\\t                                           // next closest index at which this bit is set \\n                        {\\n\\n                            auto next = upper_bound(bits[j].begin(), bits[j].end(), i);  //  return next index at which jth bit is set\\n                            mx = max(mx, *next);   // we need to max for each bit that is not set to find the subarray \\n                        }\\n                    }\\n                }\\n                if (mx != 0)                             // mx indiactes the index till we need our subarray and starting point of this\\n                    ans.push_back(mx - i + 1);  // subarray is i,  so size of subarray equals mx-i+1\\n                else                                      // if mx is zero it means that our number i.e. nums[i] had all bit set as of max OR\\n                    ans.push_back(1);\\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> smallestSubarrays(vector<int> &nums)\\n        {\\n            vector<int> ans;\\n            vector<vector < int>> bits(32);    // to store the ith bit is set at which positions \\n            for (int i = 0; i < 32; i++)\\n            {\\n                for (int j = 0; j < nums.size(); j++)\\n                {\\n                    if (nums[j] >> i &1)           // if this number has ith bit set then push_back its position in bits[i]\\n                    {\\n                        bits[i].push_back(j);\\n                    }\\n                }\\n            }\\n            vector<int> mx_or(nums.size());     // to find the max OR possible starting from current index \\n            int curr = 0;\\n            for (int i = nums.size() - 1; i >= 0; i--)    // We need to iterate backwards for linear time complexity\\n            {\\n                curr |= nums[i];\\n                mx_or[i] = curr;\\n            }\\n\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                int mx = 0;\\n                for (int j = 0; j < 32; j++)\\n                {\\n                    if (mx_or[i] >> j &1)                // if the jth bit is set in the max OR possible for this index \\n                    {\\n                        if ((nums[i] >> j &1) == 0)  // if it is not set in our current number i.e nums[i].We need to find the\\n\\t\\t\\t\\t\\t\\t                                           // next closest index at which this bit is set \\n                        {\\n\\n                            auto next = upper_bound(bits[j].begin(), bits[j].end(), i);  //  return next index at which jth bit is set\\n                            mx = max(mx, *next);   // we need to max for each bit that is not set to find the subarray \\n                        }\\n                    }\\n                }\\n                if (mx != 0)                             // mx indiactes the index till we need our subarray and starting point of this\\n                    ans.push_back(mx - i + 1);  // subarray is i,  so size of subarray equals mx-i+1\\n                else                                      // if mx is zero it means that our number i.e. nums[i] had all bit set as of max OR\\n                    ans.push_back(1);\\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266754,
                "title": "bitwise-prefix-table-o-nlogn-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe could find index for max bitwise OR starting at 0 in one loop. Then starting with the second element we would either go till that index or even further.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider bitwise prefix table for the given example.\\n![Screen Shot 2023-03-06 at 21.19.32.png](https://assets.leetcode.com/users/images/4d96f90e-4044-413f-92eb-08827090e9b8_1678159189.791627.png)\\nNow using this table we can find max possible bitwise OR value starting from any element.\\nFor 1st element it would be integer representation of last element in prefix sum. (>0 value means bit is set).\\nFor 2nd element it would be last element - first element (subtracting from all bits).\\nAnd so on.\\n\\nAs in the Intuition, we will start iterating and keep doing bitwise OR until we find max possible for that element. \\n\\nNote: Except for the case of first element, we need to subtract previous element\\'s bitwise prefix before converting to integer for comparison.\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        max_bits = len(bin(max(nums)).split(\\'b\\')[1])\\n        prefix = [[0]*max_bits for i in range(len(nums))] # bitwise prefix table.\\n        ans = []\\n        for i in range(len(nums)):\\n            bits = bin(nums[i]).split(\\'b\\')[1]\\n            for j in range(len(bits)):\\n                prefix[i][-j-1]+=int(bits[-j-1])\\n            for j in range(max_bits):\\n                prefix[i][-j-1]+=prefix[i-1][-j-1] if i>0 else 0\\n        right_int = int(\\'\\'.join([\\'1\\' if prefix[-1][j]>0 else \\'0\\' for j in range(max_bits)]),2)\\n        l=r=0\\n        pref = [0 for j in range(max_bits)]\\n        while l!=len(nums):\\n            val = int(\\'\\'.join([\\'1\\' if prefix[r][j]-pref[j]>0 else \\'0\\' for j in range(max_bits)]),2)\\n            if val<right_int:\\n                r+=1\\n            else:\\n                ans.append(max(0,r-l)+1)\\n                l+=1\\n                pref = [prefix[l-1][j] for j in range(max_bits)]\\n                right_int = int(\\'\\'.join([\\'1\\' if prefix[-1][j]-pref[j]>0 else \\'0\\' for j in range(max_bits)]),2)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        max_bits = len(bin(max(nums)).split(\\'b\\')[1])\\n        prefix = [[0]*max_bits for i in range(len(nums))] # bitwise prefix table.\\n        ans = []\\n        for i in range(len(nums)):\\n            bits = bin(nums[i]).split(\\'b\\')[1]\\n            for j in range(len(bits)):\\n                prefix[i][-j-1]+=int(bits[-j-1])\\n            for j in range(max_bits):\\n                prefix[i][-j-1]+=prefix[i-1][-j-1] if i>0 else 0\\n        right_int = int(\\'\\'.join([\\'1\\' if prefix[-1][j]>0 else \\'0\\' for j in range(max_bits)]),2)\\n        l=r=0\\n        pref = [0 for j in range(max_bits)]\\n        while l!=len(nums):\\n            val = int(\\'\\'.join([\\'1\\' if prefix[r][j]-pref[j]>0 else \\'0\\' for j in range(max_bits)]),2)\\n            if val<right_int:\\n                r+=1\\n            else:\\n                ans.append(max(0,r-l)+1)\\n                l+=1\\n                pref = [prefix[l-1][j] for j in range(max_bits)]\\n                right_int = int(\\'\\'.join([\\'1\\' if prefix[-1][j]-pref[j]>0 else \\'0\\' for j in range(max_bits)]),2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256113,
                "title": "simple-and-detailed-c-solution",
                "content": "# Intuition\\nWe are asked to find least possible length for which the `bitwise OR` of subarray is euqal to maximum possible.\\nSo for each `index i` we have to find first index on right such that `bitwise OR between i, to ind = max`\\nFor bitwise OR to be equal to max, we need all the bits set for that number.\\n\\n# Observation\\nWe only need to look at the latest position of bit which is set from right.\\n\\n# Approach\\nSince we only care about latest set position from right, we updated `array v` for each index i and `res[i]=max(distance for all set bits)`\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(1)$bit\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> v(32, -1);\\n        int n = nums.size();\\n\\n        vector<int> res(n);\\n\\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            for(int pos = 0; pos < 32; ++pos)\\n            {\\n                if((1 << pos) & nums[i])\\n                {\\n                    v[pos] = i;\\n                }\\n            }\\n            int ans = 1;\\n            for(int pos = 0; pos < 32; ++pos)\\n            {\\n                if(v[pos] != -1)\\n                ans = max(ans, v[pos] - i + 1);\\n            }\\n            res[i] = ans;\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\n> ## Please upvote if find helpfull\\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> v(32, -1);\\n        int n = nums.size();\\n\\n        vector<int> res(n);\\n\\n        for(int i = n - 1; i >= 0; --i)\\n        {\\n            for(int pos = 0; pos < 32; ++pos)\\n            {\\n                if((1 << pos) & nums[i])\\n                {\\n                    v[pos] = i;\\n                }\\n            }\\n            int ans = 1;\\n            for(int pos = 0; pos < 32; ++pos)\\n            {\\n                if(v[pos] != -1)\\n                ans = max(ans, v[pos] - i + 1);\\n            }\\n            res[i] = ans;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212224,
                "title": "2-solutions",
                "content": "**linked_list**\\n**time: `O(32N)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/2f0e9283-fb66-4c8e-99c2-b4c4ed544a06_1676991354.2937353.png)\\n\\nMore abstract diagram:\\n\\n![image](https://assets.leetcode.com/users/images/0162aeb9-4c70-40eb-b23f-75657b28ca8b_1677014421.5925732.png)\\n\\n```\\nvector<int> smallestSubarrays(vector<int>& n)\\n{\\n\\tvector out(size(n),1);   \\n\\tforward_list<int> l;\\n\\tfor(int i(size(n)-1); i>=0; --i)\\n\\t{\\n\\t\\tl.push_front(i); \\n\\t\\tint s{n[i]};\\n\\t\\tfor(auto j{begin(l)}; next(j)!=end(l); )\\n\\t\\t\\tif((s|n[*next(j)])==s)\\n\\t\\t\\t\\tl.erase_after(j);\\n\\t\\t\\telse\\n\\t\\t\\t\\ts|=n[*++j], out[i]=*j-i+1;   \\n\\t}\\n\\treturn out;\\n}\\n```\\n**bits**\\n**time: `O(32N)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/6234d94f-0806-4e25-9ed2-e35f07f350ea_1676987792.7360404.png)\\n\\n```\\nvector<int> smallestSubarrays(vector<int>& n)\\n{\\n\\tvector out(size(n),1);\\n\\tfor(int i(size(n)-1), d[32]{}; i>=0; --i)\\n\\t\\tfor(int j{}; j<32; ++j)\\n\\t\\t{\\n\\t\\t\\tif(n[i]&(1<<j)) d[j]=i;\\n\\t\\t\\tout[i] = max(out[i], d[j]-i+1);\\n\\t\\t}   \\n\\treturn out;\\n}\\n```\\n**Similar problem:**\\n[898. Bitwise ORs of Subarrays](https://leetcode.com/problems/bitwise-ors-of-subarrays/discuss/3211951/linked_list-unordered_set)\\n[2411. Smallest Subarrays With Maximum Bitwise OR](https://leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or/discuss/3212224/2-solutions)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> smallestSubarrays(vector<int>& n)\\n{\\n\\tvector out(size(n),1);   \\n\\tforward_list<int> l;\\n\\tfor(int i(size(n)-1); i>=0; --i)\\n\\t{\\n\\t\\tl.push_front(i); \\n\\t\\tint s{n[i]};\\n\\t\\tfor(auto j{begin(l)}; next(j)!=end(l); )\\n\\t\\t\\tif((s|n[*next(j)])==s)\\n\\t\\t\\t\\tl.erase_after(j);\\n\\t\\t\\telse\\n\\t\\t\\t\\ts|=n[*++j], out[i]=*j-i+1;   \\n\\t}\\n\\treturn out;\\n}\\n```\n```\\nvector<int> smallestSubarrays(vector<int>& n)\\n{\\n\\tvector out(size(n),1);\\n\\tfor(int i(size(n)-1), d[32]{}; i>=0; --i)\\n\\t\\tfor(int j{}; j<32; ++j)\\n\\t\\t{\\n\\t\\t\\tif(n[i]&(1<<j)) d[j]=i;\\n\\t\\t\\tout[i] = max(out[i], d[j]-i+1);\\n\\t\\t}   \\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3208506,
                "title": "c-solution-with-images",
                "content": "# Prerequisite\\n- Sliding window\\n- bit manipulation : \\n    finding bit representation of any number.\\n    finding number from its bit representation i.e. power of 2 concept\\n\\n# Intuition\\n- I knew that I need some way to find that what is the maximal value possible for index i : so used suffix array . \\n- suppose I am finding ans for substring starting at i and I got maximal ans at j then my answer is : answer[i] = j-i+1 . Now then I will do i++ ....... So sliding window kind of thing came to my mind\\n- All that was left : bit manipulation\\n\\n# Approach\\n- First store the OR of all elements starting from last to first in suffix array i.e. store[i] = (nums[i] | nums[i+1] ...... | nums[n-1])\\n\\n- dp array of size 32 to store the bit count . dp array will help us to store prefix bitwise-or and this will help us to update our bitwise-or value when we will shift our window forward . \\n    Suppose array contain : 1 , 3 then dp will be updated in following way : \\n    \\n![image.png](https://assets.leetcode.com/users/images/69e96e52-923a-4562-88b7-9f239a97c414_1676870669.2838552.png)\\n\\n- temp variable to store the bitwise-or when moving from left to right\\n\\n    \\n![image.png](https://assets.leetcode.com/users/images/fc37ad12-cc2e-43aa-a3c4-5ec692d35a25_1676871111.8564804.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> store(n , 0);\\n        long long ors = 0;\\n\\n        ///Storing bitwise-or from right to left\\n        for(int i=n-1;i>=0;i--){\\n            ors = ors | nums[i];\\n            store[i] = ors;\\n        }\\n\\n        vector<int> sol;//we will store our answer\\n        vector<int> dp(32 , 0); // array to store bit\\n\\n        int i =0 , j= 0;\\n        long long temp =0; // to store bitwise-or\\n\\n        //sliding window concept\\n        while(j<n){\\n            int pos = 0;\\n            int x = nums[j];\\n\\n            //find each bit\\n            while(x){\\n                if(x&1){\\n                    if(dp[pos] == 0)\\n                        temp += pow(2 , pos);  //forming number using bit\\n                    dp[pos] ++;\\n                }\\n                x >>=1;\\n                pos++;\\n            }\\n\\n            /// if we get maximal possible bitwise-or for position i : we found the answer\\n            if(temp == store[i]){\\n                while(i<=j && temp == store[i]){\\n                    sol.push_back(j-i+1);\\n                    x= nums[i];\\n                    pos = 0;\\n                    while(x){\\n                        if(x&1){\\n                            dp[pos] --;\\n                            if(dp[pos] == 0)\\n                            temp -= pow(2 , pos);\\n                        }\\n                        x >>=1;\\n                        pos++;\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> store(n , 0);\\n        long long ors = 0;\\n\\n        ///Storing bitwise-or from right to left\\n        for(int i=n-1;i>=0;i--){\\n            ors = ors | nums[i];\\n            store[i] = ors;\\n        }\\n\\n        vector<int> sol;//we will store our answer\\n        vector<int> dp(32 , 0); // array to store bit\\n\\n        int i =0 , j= 0;\\n        long long temp =0; // to store bitwise-or\\n\\n        //sliding window concept\\n        while(j<n){\\n            int pos = 0;\\n            int x = nums[j];\\n\\n            //find each bit\\n            while(x){\\n                if(x&1){\\n                    if(dp[pos] == 0)\\n                        temp += pow(2 , pos);  //forming number using bit\\n                    dp[pos] ++;\\n                }\\n                x >>=1;\\n                pos++;\\n            }\\n\\n            /// if we get maximal possible bitwise-or for position i : we found the answer\\n            if(temp == store[i]){\\n                while(i<=j && temp == store[i]){\\n                    sol.push_back(j-i+1);\\n                    x= nums[i];\\n                    pos = 0;\\n                    while(x){\\n                        if(x&1){\\n                            dp[pos] --;\\n                            if(dp[pos] == 0)\\n                            temp -= pow(2 , pos);\\n                        }\\n                        x >>=1;\\n                        pos++;\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066922,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n\\n        vector<int> count(32, 0);\\n\\n        int cur = 0;\\n        vector<int> dp(nums.size(), 0);\\n        for(int i=nums.size()-1;i>=0;i--) {\\n            cur |= nums[i];\\n            int tmp = cur;\\n            while(tmp!=0) {\\n                if(tmp%2==1) {\\n                    dp[i]++;\\n                }\\n                tmp/=2;\\n            }\\n        }\\n        \\n        int j = nums.size()-1;\\n        int cur_count = 0;\\n        vector<int> res;\\n\\n        auto update_func = [&](int ele, int add_val) {\\n            for(int k=0;k<32;k++) {\\n                bool flag = (1<<k)&ele;\\n                if(flag) {\\n                    count[k]+=add_val;\\n                    if(count[k] == 1 && add_val == 1) {\\n                        cur_count++;\\n                    }else if(count[k] == 0 && add_val == -1) {\\n                        cur_count--;\\n                    }\\n                }\\n            }\\n        };\\n\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            int target_count = dp[i];\\n            int cur_val = nums[i];\\n\\n            update_func(cur_val, 1);\\n            while(j>i) {\\n                update_func(nums[j], -1);\\n                if(target_count!=cur_count) {\\n                    update_func(nums[j], 1);\\n                    break;\\n                }else {\\n                    j--;\\n                }\\n            }\\n\\n            res.push_back(j-i+1);\\n        }\\n\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n\\n        vector<int> count(32, 0);\\n\\n        int cur = 0;\\n        vector<int> dp(nums.size(), 0);\\n        for(int i=nums.size()-1;i>=0;i--) {\\n            cur |= nums[i];\\n            int tmp = cur;\\n            while(tmp!=0) {\\n                if(tmp%2==1) {\\n                    dp[i]++;\\n                }\\n                tmp/=2;\\n            }\\n        }\\n        \\n        int j = nums.size()-1;\\n        int cur_count = 0;\\n        vector<int> res;\\n\\n        auto update_func = [&](int ele, int add_val) {\\n            for(int k=0;k<32;k++) {\\n                bool flag = (1<<k)&ele;\\n                if(flag) {\\n                    count[k]+=add_val;\\n                    if(count[k] == 1 && add_val == 1) {\\n                        cur_count++;\\n                    }else if(count[k] == 0 && add_val == -1) {\\n                        cur_count--;\\n                    }\\n                }\\n            }\\n        };\\n\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            int target_count = dp[i];\\n            int cur_val = nums[i];\\n\\n            update_func(cur_val, 1);\\n            while(j>i) {\\n                update_func(nums[j], -1);\\n                if(target_count!=cur_count) {\\n                    update_func(nums[j], 1);\\n                    break;\\n                }else {\\n                    j--;\\n                }\\n            }\\n\\n            res.push_back(j-i+1);\\n        }\\n\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044391,
                "title": "c-simple-bitwise-with-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        vector<vector<int>> v1(n, vector<int> (32, -1));\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i)v1[i] = v1[i-1];\\n            for(int j=0;j<32;j++)\\n            {\\n                if((nums[i]&(1<<j))>>j)v1[i][j]=i;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int z = 0;\\n            for(int j=0;j<32;j++)\\n            {\\n                if(v1[n-1][j] >= i)\\n                {\\n                    z = z xor (1 << j);\\n                }\\n            }\\n            int l = i, r = n-1, res = n-1;\\n            while(l <= r)\\n            {\\n                int  mid = (l+r)/2;\\n                int x = 0;\\n                for(int j=0;j<32;j++)\\n                {\\n                    if(v1[mid][j] >= i)\\n                    {\\n                        x = x xor (1 << j);\\n                    }\\n                }\\n                if(x == z)\\n                {\\n                    res = mid;\\n                    r = mid-1;\\n                }\\n                else l = mid+1;\\n            }\\n            ans.push_back(res-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        vector<vector<int>> v1(n, vector<int> (32, -1));\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i)v1[i] = v1[i-1];\\n            for(int j=0;j<32;j++)\\n            {\\n                if((nums[i]&(1<<j))>>j)v1[i][j]=i;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int z = 0;\\n            for(int j=0;j<32;j++)\\n            {\\n                if(v1[n-1][j] >= i)\\n                {\\n                    z = z xor (1 << j);\\n                }\\n            }\\n            int l = i, r = n-1, res = n-1;\\n            while(l <= r)\\n            {\\n                int  mid = (l+r)/2;\\n                int x = 0;\\n                for(int j=0;j<32;j++)\\n                {\\n                    if(v1[mid][j] >= i)\\n                    {\\n                        x = x xor (1 << j);\\n                    }\\n                }\\n                if(x == z)\\n                {\\n                    res = mid;\\n                    r = mid-1;\\n                }\\n                else l = mid+1;\\n            }\\n            ans.push_back(res-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974548,
                "title": "o-n-c-modular-code-bits-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfor each index i ,we just need the min index till where we can get all the set bits possible , which are missing from current no.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse matrix to store index of element , having particular bit set \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> setBits(32);\\n        vector<int> ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            int num=nums[i];\\n            for(int j=0;j<32;j++){\\n                if(num & (1<<j)) {\\n                    setBits[j].push_back(i);\\n                }\\n            }\\n        }\\n        for(int j=0;j<32;j++){\\n                \\n                reverse(setBits[j].begin(),setBits[j].end());\\n            }\\n        \\n\\n        for(int i=0;i<n;i++){\\n            int num=nums[i];\\n            int idx=i;\\n            for(int j=0;j<32;j++){\\n                if((num & (1<<j))==0 && setBits[j].size()!=0) {\\n                    idx=max(idx,setBits[j].back());\\n                   \\n                }\\n            }\\n            ans[i]=(idx-i+1);\\n\\n            for(int j=0;j<32;j++){\\n                if((num & (1<<j))) {\\n                    setBits[j].pop_back();\\n                   \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n/*\\n\\n\\n 1 0 1 0 0 1\\n 1 0 0 1 1 1\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> setBits(32);\\n        vector<int> ans(n);\\n        \\n        for(int i=0;i<n;i++){\\n            int num=nums[i];\\n            for(int j=0;j<32;j++){\\n                if(num & (1<<j)) {\\n                    setBits[j].push_back(i);\\n                }\\n            }\\n        }\\n        for(int j=0;j<32;j++){\\n                \\n                reverse(setBits[j].begin(),setBits[j].end());\\n            }\\n        \\n\\n        for(int i=0;i<n;i++){\\n            int num=nums[i];\\n            int idx=i;\\n            for(int j=0;j<32;j++){\\n                if((num & (1<<j))==0 && setBits[j].size()!=0) {\\n                    idx=max(idx,setBits[j].back());\\n                   \\n                }\\n            }\\n            ans[i]=(idx-i+1);\\n\\n            for(int j=0;j<32;j++){\\n                if((num & (1<<j))) {\\n                    setBits[j].pop_back();\\n                   \\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n/*\\n\\n\\n 1 0 1 0 0 1\\n 1 0 0 1 1 1\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937750,
                "title": "suffix-bit-position-extremely-efficient",
                "content": "We just store the smallest position in suffix for everybit that turns on that bit by doing OR.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int[] arr = new int[31];\\n        int[] dp = new int[nums.length];\\n        dp[nums.length-1] = 1;\\n        for(int i = 0; i < 31; i++){\\n            arr[i] = (nums[nums.length-1] & (1 << i)) != 0 ? nums.length-1:0;\\n        }\\n        for(int i = nums.length-2; i >= 0; i--){\\n            int idx = 0;\\n            for(int j = 0; j < 31; j++){\\n                arr[j] = ((nums[i] & (1 << j)) != 0) ? i:arr[j];\\n                idx = Math.max(arr[j], idx);\\n            }\\n            dp[i] = idx - i + 1;\\n            if(dp[i] <= 0){\\n                dp[i] = 1;\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int[] arr = new int[31];\\n        int[] dp = new int[nums.length];\\n        dp[nums.length-1] = 1;\\n        for(int i = 0; i < 31; i++){\\n            arr[i] = (nums[nums.length-1] & (1 << i)) != 0 ? nums.length-1:0;\\n        }\\n        for(int i = nums.length-2; i >= 0; i--){\\n            int idx = 0;\\n            for(int j = 0; j < 31; j++){\\n                arr[j] = ((nums[i] & (1 << j)) != 0) ? i:arr[j];\\n                idx = Math.max(arr[j], idx);\\n            }\\n            dp[i] = idx - i + 1;\\n            if(dp[i] <= 0){\\n                dp[i] = 1;\\n            }\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903438,
                "title": "c-98-13-faster-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        ll n=nums.size();\\n        vector<int>bits(32,0),answer(n);\\n        for(ll i=n-1;i>=0;i--){\\n            ll target=nums[i];\\n            for(ll j=0;j<=31;j++){\\n                if(target&(1LL<<j)){\\n                    if(bits[j]==0){\\n                        bits[j]=i;\\n                    }\\n                    else{\\n                        bits[j]=min(bits[j],(int)i);\\n                    }\\n                }\\n            }\\n            answer[i]=max((ll)1,*max_element(bits.begin(),bits.end())-i+1);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        ll n=nums.size();\\n        vector<int>bits(32,0),answer(n);\\n        for(ll i=n-1;i>=0;i--){\\n            ll target=nums[i];\\n            for(ll j=0;j<=31;j++){\\n                if(target&(1LL<<j)){\\n                    if(bits[j]==0){\\n                        bits[j]=i;\\n                    }\\n                    else{\\n                        bits[j]=min(bits[j],(int)i);\\n                    }\\n                }\\n            }\\n            answer[i]=max((ll)1,*max_element(bits.begin(),bits.end())-i+1);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751660,
                "title": "o-n",
                "content": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        vector<int> dp(32,0);\\n        \\n        vector<int> ans(nums.size());\\n        for(int i = nums.size()-1;i > -1;i--){\\n            \\n            int num = nums[i];\\n            int maxi = i;\\n            \\n            for(int j = 0;j < 32;j++){\\n                \\n                if(num & 1<<j) dp[j] = i;\\n                \\n                maxi = max(maxi,dp[j]);\\n            }\\n            \\n            \\n            ans[i] = maxi - i + 1;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        vector<int> dp(32,0);\\n        \\n        vector<int> ans(nums.size());\\n        for(int i = nums.size()-1;i > -1;i--){\\n            \\n            int num = nums[i];\\n            int maxi = i;\\n            \\n            for(int j = 0;j < 32;j++){\\n                \\n                if(num & 1<<j) dp[j] = i;\\n                \\n                maxi = max(maxi,dp[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2745791,
                "title": "c",
                "content": "Runtime: 395 ms, faster than 100.00% of C online submissions for Smallest Subarrays With Maximum Bitwise OR.\\nMemory Usage: 41.9 MB, less than 81.82% of C online submissions for Smallest Subarrays With Maximum Bitwise OR.\\n```\\nint* smallestSubarrays(int* nums, int numsSize, int* returnSize){\\n    int n = numsSize;\\n    *returnSize = n;\\n    int* ans = malloc(n * sizeof(int));\\n    int* pos = calloc( 31 , sizeof(int));\\n    for(int i = n-1; i >= 0; i--){\\n        int val = nums[i];\\n        for(int j = 0; j < 31; j++){\\n            if(val%2){\\n                pos[j] = i;\\n            }\\n            val = val / 2;\\n            if(val == 0)\\n                break;\\n        }\\n        int right =0;\\n        for(int k = 0; k < 31; k++){\\n            if(pos[k] > right)\\n                right = pos[k] ;\\n        }\\n        if(right == 0)\\n            ans[i] = 1;\\n        else\\n            ans[i] = right - i + 1;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* smallestSubarrays(int* nums, int numsSize, int* returnSize){\\n    int n = numsSize;\\n    *returnSize = n;\\n    int* ans = malloc(n * sizeof(int));\\n    int* pos = calloc( 31 , sizeof(int));\\n    for(int i = n-1; i >= 0; i--){\\n        int val = nums[i];\\n        for(int j = 0; j < 31; j++){\\n            if(val%2){\\n                pos[j] = i;\\n            }\\n            val = val / 2;\\n            if(val == 0)\\n                break;\\n        }\\n        int right =0;\\n        for(int k = 0; k < 31; k++){\\n            if(pos[k] > right)\\n                right = pos[k] ;\\n        }\\n        if(right == 0)\\n            ans[i] = 1;\\n        else\\n            ans[i] = right - i + 1;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2744118,
                "title": "c-2-pointer-count-bit",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> cntAll(32, 0), cnt(32, 0), res;\\n        for(auto x:nums) add(cntAll, x);\\n        for(int l=0,r=0,n=nums.size(); l<n; l++){           \\n            int maxOR = toInt(cntAll), curOR = toInt(cnt);\\n            while(curOR != maxOR){\\n                add(cnt, nums[r]);\\n                curOR |= nums[r++];\\n            }\\n            res.push_back(max(1, r-l));\\n            minus(cntAll, nums[l]);\\n            minus(cnt, nums[l]);\\n        }\\n        return res;\\n    }\\n    \\n    int toInt(vector<int>& cnt){\\n        int res = 0;\\n        for(int i=0;i<32;i++)\\n            if(cnt[i] > 0) res |= (1<<i);\\n        return res;\\n    }\\n    \\n    void add(vector<int>& cnt, int x){\\n        bitset<32> b(x);\\n        for(int i=0;i<32;i++)\\n            if(b[i]) cnt[i]++;\\n    }\\n    \\n    void minus(vector<int>& cnt, int x){\\n        bitset<32> b(x);\\n        for(int i=0;i<32;i++)\\n            if(b[i]) cnt[i]--;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> cntAll(32, 0), cnt(32, 0), res;\\n        for(auto x:nums) add(cntAll, x);\\n        for(int l=0,r=0,n=nums.size(); l<n; l++){           \\n            int maxOR = toInt(cntAll), curOR = toInt(cnt);\\n            while(curOR != maxOR){\\n                add(cnt, nums[r]);\\n                curOR |= nums[r++];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2729792,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>&v) {\\n      \\n        int n = v.size();\\n        vector<int>dp (32 , 0) ,  ans(n);\\n        for(int i = n-1;i>=0;i--) {            \\n            // Update\\n            for(int j = 0 ; j < 31;j ++) {\\n                   if((v[i] & (1 << j))){\\n                      \\n                       if(dp[j] == 0) dp[j] = i;\\n                       else\\n                          dp[j] = min(dp[j] , i);\\n                   }\\n            \\n            }\\n            // fill ans      \\n            ans[i] = max(1, (*max_element(dp.begin() , dp.end())  - i + 1));\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>&v) {\\n      \\n        int n = v.size();\\n        vector<int>dp (32 , 0) ,  ans(n);\\n        for(int i = n-1;i>=0;i--) {            \\n            // Update\\n            for(int j = 0 ; j < 31;j ++) {\\n                   if((v[i] & (1 << j))){\\n                      \\n                       if(dp[j] == 0) dp[j] = i;\\n                       else\\n                          dp[j] = min(dp[j] , i);\\n                   }\\n            \\n            }\\n            // fill ans      \\n            ans[i] = max(1, (*max_element(dp.begin() , dp.end())  - i + 1));\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712802,
                "title": "easy-binary-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void to_binary(int n, vector<int> &bin)\\n    {\\n        int i = 0;\\n        for(i = 0; i < 30; i++)\\n        {\\n            bin[i] = (n&1);\\n            n = (n >> 1);\\n        }\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        int n=nums.size(), k=0, i;\\n        vector<int> OR(n);\\n        \\n        for(i=n-1; i>=0; i--)\\n        {\\n            k = k | nums[i];\\n            OR[i] = k;\\n        }\\n        \\n        vector<vector<int>> bin(n, vector<int> (30,0));\\n        for(i = 0; i<n; i++)\\n        {\\n            to_binary(OR[i], bin[i]);\\n        }\\n        \\n        vector<vector<int>> pref(n+1, vector<int> (30,0));\\n        \\n        vector<int> binarry(30);\\n        for(i = 1; i <= n; i++)\\n        {\\n            to_binary(nums[i-1], binarry);\\n            for(int j = 0; j < 30; j++)\\n            {\\n                pref[i][j] = pref[i-1][j] + binarry[j]; \\n            }\\n        }\\n        \\n        vector<int> ans(n);\\n        int start = i+1, end = n ,mid, j;\\n        for(i = 0; i < n; i++)\\n        {\\n            start = i+1; end = n;   \\n            while(start < end)\\n            {\\n                mid = (start + end)/2;\\n                for( j = 0; j < 30; j++)\\n                {\\n                    if(pref[mid][j]-pref[i][j] < bin[i][j])\\n                        break;\\n                }\\n                if(j == 30)\\n                    end = mid;\\n                else\\n                    start = mid + 1;\\n            }\\n            \\n            ans[i] = end - i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void to_binary(int n, vector<int> &bin)\\n    {\\n        int i = 0;\\n        for(i = 0; i < 30; i++)\\n        {\\n            bin[i] = (n&1);\\n            n = (n >> 1);\\n        }\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        int n=nums.size(), k=0, i;\\n        vector<int> OR(n);\\n        \\n        for(i=n-1; i>=0; i--)\\n        {\\n            k = k | nums[i];\\n            OR[i] = k;\\n        }\\n        \\n        vector<vector<int>> bin(n, vector<int> (30,0));\\n        for(i = 0; i<n; i++)\\n        {\\n            to_binary(OR[i], bin[i]);\\n        }\\n        \\n        vector<vector<int>> pref(n+1, vector<int> (30,0));\\n        \\n        vector<int> binarry(30);\\n        for(i = 1; i <= n; i++)\\n        {\\n            to_binary(nums[i-1], binarry);\\n            for(int j = 0; j < 30; j++)\\n            {\\n                pref[i][j] = pref[i-1][j] + binarry[j]; \\n            }\\n        }\\n        \\n        vector<int> ans(n);\\n        int start = i+1, end = n ,mid, j;\\n        for(i = 0; i < n; i++)\\n        {\\n            start = i+1; end = n;   \\n            while(start < end)\\n            {\\n                mid = (start + end)/2;\\n                for( j = 0; j < 30; j++)\\n                {\\n                    if(pref[mid][j]-pref[i][j] < bin[i][j])\\n                        break;\\n                }\\n                if(j == 30)\\n                    end = mid;\\n                else\\n                    start = mid + 1;\\n            }\\n            \\n            ans[i] = end - i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679011,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<vector<int>>vect(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            while(nums[i]!=0){\\n                vect[i].push_back(nums[i]%2);\\n                nums[i]/=2;\\n            }\\n        }\\n    int ans=0;\\n    for(int i=0;i<nums.size();i++){\\n        int gh=vect[i].size();\\n        ans=max(ans,gh);\\n    }\\n    for(int i=0;i<nums.size();i++){\\n        while(vect[i].size()<ans){\\n            vect[i].push_back(0);\\n        }\\n    }\\n    vector<vector<int>>res(ans);\\n    for(int i=0;i<ans;i++){\\n        for(int j=0;j<nums.size();j++){\\n            if(vect[j][i]==1){\\n                res[i].push_back(j);\\n            }\\n        }\\n    }\\n    vector<int>answers(nums.size());\\n    vector<int>valeurs(ans);\\n        int rh=0;\\n    for(int i=0;i<nums.size();i++){\\n        rh=i;\\n        for(int j=0;j<ans;j++){\\n            while((valeurs[j]<res[j].size())and(res[j][valeurs[j]]<i)){\\n                valeurs[j]++;\\n            }\\n            if(valeurs[j]!=res[j].size()){\\n                int m=res[j][valeurs[j]];\\n                rh=max(rh,m);\\n            }\\n        }\\n    answers[i]=rh-i+1;\\n    }\\n    return answers;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<vector<int>>vect(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            while(nums[i]!=0){\\n                vect[i].push_back(nums[i]%2);\\n                nums[i]/=2;\\n            }\\n        }\\n    int ans=0;\\n    for(int i=0;i<nums.size();i++){\\n        int gh=vect[i].size();\\n        ans=max(ans,gh);\\n    }\\n    for(int i=0;i<nums.size();i++){\\n        while(vect[i].size()<ans){\\n            vect[i].push_back(0);\\n        }\\n    }\\n    vector<vector<int>>res(ans);\\n    for(int i=0;i<ans;i++){\\n        for(int j=0;j<nums.size();j++){\\n            if(vect[j][i]==1){\\n                res[i].push_back(j);\\n            }\\n        }\\n    }\\n    vector<int>answers(nums.size());\\n    vector<int>valeurs(ans);\\n        int rh=0;\\n    for(int i=0;i<nums.size();i++){\\n        rh=i;\\n        for(int j=0;j<ans;j++){\\n            while((valeurs[j]<res[j].size())and(res[j][valeurs[j]]<i)){\\n                valeurs[j]++;\\n            }\\n            if(valeurs[j]!=res[j].size()){\\n                int m=res[j][valeurs[j]];\\n                rh=max(rh,m);\\n            }\\n        }\\n    answers[i]=rh-i+1;\\n    }\\n    return answers;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645289,
                "title": "java-solution-easy-to-understand-and-clean-code",
                "content": "```\\npublic class Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        // maintain nearest set bit array\\n        int n = nums.length;\\n        int nearest[] = new int[31];\\n        int ans[] = new int[n];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int lastbit = i;\\n            for (int k = 0; k < 31; k++) {\\n                if ((nums[i] & (1 << k)) != 0)// set bit\\n                    nearest[k] = i;\\n                lastbit = Math.max(lastbit, nearest[k]);\\n\\n            }\\n            ans[i] = lastbit - i + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        // maintain nearest set bit array\\n        int n = nums.length;\\n        int nearest[] = new int[31];\\n        int ans[] = new int[n];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int lastbit = i;\\n            for (int k = 0; k < 31; k++) {\\n                if ((nums[i] & (1 << k)) != 0)// set bit\\n                    nearest[k] = i;\\n                lastbit = Math.max(lastbit, nearest[k]);\\n\\n            }\\n            ans[i] = lastbit - i + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643866,
                "title": "java-solution-using-binary-search",
                "content": "\\n\\n\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int lastoc[] = new int[32] ;\\n        int n = nums.length ;\\n        Map<Integer,ArrayList<Integer>> map = new HashMap<>() ;\\n        for(int i=0 ; i<32 ; i++){\\n            map.put(i , new ArrayList<>()) ;\\n        }\\n        for(int j=0 ; j<n ; j++){\\n            int el = nums[j] ;\\n            for(int i=0 ; i<32 ; i++){\\n                if((el&(1<<i))!=0){\\n                    map.get(i).add(j) ;\\n                }\\n            }\\n        }\\n        int ans[] = new int[n] ;\\n        for(int i=0 ; i<n ; i++){\\n            int el = nums[i] ;\\n            int index=i ;\\n            for(int j=0 ; j<32 ; j++){\\n                if((el&(1<<j))==0){\\n                    //binary search for set bit in jth index such that its greater than i\\n                    int nextindex = bs(map.get(j),i) ;\\n                    if(nextindex>index){\\n                        index = nextindex ;\\n                    }\\n                }\\n            }\\n            ans[i]=index-i+1 ;\\n        }\\n        return ans ;\\n    }\\n    int bs(ArrayList<Integer> list , int x){\\n        int ll=0 , rr=list.size()-1 ;\\n        int index=x ;\\n        while(ll<=rr){\\n            int mid = ll+(rr-ll)/2 ;\\n            if(list.get(mid)>x){\\n                index=list.get(mid) ;\\n                rr=mid-1 ;\\n            }\\n            else{\\n                ll=mid+1 ;\\n            }\\n        }\\n        return index ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int lastoc[] = new int[32] ;\\n        int n = nums.length ;\\n        Map<Integer,ArrayList<Integer>> map = new HashMap<>() ;\\n        for(int i=0 ; i<32 ; i++){\\n            map.put(i , new ArrayList<>()) ;\\n        }\\n        for(int j=0 ; j<n ; j++){\\n            int el = nums[j] ;\\n            for(int i=0 ; i<32 ; i++){\\n                if((el&(1<<i))!=0){\\n                    map.get(i).add(j) ;\\n                }\\n            }\\n        }\\n        int ans[] = new int[n] ;\\n        for(int i=0 ; i<n ; i++){\\n            int el = nums[i] ;\\n            int index=i ;\\n            for(int j=0 ; j<32 ; j++){\\n                if((el&(1<<j))==0){\\n                    //binary search for set bit in jth index such that its greater than i\\n                    int nextindex = bs(map.get(j),i) ;\\n                    if(nextindex>index){\\n                        index = nextindex ;\\n                    }\\n                }\\n            }\\n            ans[i]=index-i+1 ;\\n        }\\n        return ans ;\\n    }\\n    int bs(ArrayList<Integer> list , int x){\\n        int ll=0 , rr=list.size()-1 ;\\n        int index=x ;\\n        while(ll<=rr){\\n            int mid = ll+(rr-ll)/2 ;\\n            if(list.get(mid)>x){\\n                index=list.get(mid) ;\\n                rr=mid-1 ;\\n            }\\n            else{\\n                ll=mid+1 ;\\n            }\\n        }\\n        return index ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641002,
                "title": "c-code-easy-to-understand-soln",
                "content": "```\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ans(n);\\n        unordered_map<int,vector<int> > mp;\\n        \\n        for(int i=0;i<n;i++){\\n            int val = nums[i];\\n            for(int j=0;j<=31;j++){\\n                if(val&1){\\n                    mp[j].push_back(i);\\n                }\\n                val>>=1;\\n            }\\n        }\\n        \\n        ans[n-1] = 1;\\n        int prefix = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            prefix |= nums[i];\\n            int val = prefix;\\n            int maxi = i;\\n            for(int j=0;j<31;j++){\\n                if(val&1){\\n                    auto idx = lower_bound(mp[j].begin(),mp[j].end(),i);\\n                    maxi = max(maxi,(*idx));\\n                }\\n                val>>=1;\\n            }\\n            ans[i] = maxi-i+1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ans(n);\\n        unordered_map<int,vector<int> > mp;\\n        \\n        for(int i=0;i<n;i++){\\n            int val = nums[i];\\n            for(int j=0;j<=31;j++){\\n                if(val&1){\\n                    mp[j].push_back(i);\\n                }\\n                val>>=1;\\n            }\\n        }\\n        \\n        ans[n-1] = 1;\\n        int prefix = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            prefix |= nums[i];\\n            int val = prefix;\\n            int maxi = i;\\n            for(int j=0;j<31;j++){\\n                if(val&1){\\n                    auto idx = lower_bound(mp[j].begin(),mp[j].end(),i);\\n                    maxi = max(maxi,(*idx));\\n                }\\n                val>>=1;\\n            }\\n            ans[i] = maxi-i+1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640701,
                "title": "bit-operation-practice-bit-position-check-and-set-python",
                "content": "1- A solution format\\n```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        res = [1] * n\\n        # for each number, we check the bit positions to find the nearest right_index with \\n        # bit 1 in the corresponding position;\\n        right_bit_one_pos = [0] * 30\\n        for i in range(n-1, -1, -1):\\n            for j in range(30):\\n                if nums[i] & (1 << j):\\n                    right_bit_one_pos[j] = i\\n            res[i] = max(1, max(right_bit_one_pos) - i + 1)\\n        \\n        return res\\n```\\n2- Video Explanation: [Click Here](https://youtu.be/MZZigHpecA8;)\\n\\n3- Analysis or summay\\n\\n1. Method: Bit position check\\n\\nIdea: to make a subarray starting from index i have maximal bitwise OR result, we work with the binary form of the number, and try to find the\\nindex to the right to make all the bit position 1. This way, each bit position corresponds to a nearest right index j with bit position 1. \\nNote that here no index with that bit position being 1, we set the right index to be i itself.\\n\\nThis way the miminum length to maximize the bitwise OR result for the subarrary starting from i would be:\\n    ls = max(1, max j - i + 1)\\n    \\n    \\nAs math.log(10 ** 9, 2) = 29.8, we just need to check 30 bit positions for each number\\n    \\n    \\n2. Digest:\\n\\nnums = [1, 0, 0, 1, 0]\\nThis is special, all numbers with just 1 bit.\\nSo for each number, we check if it is 1, if so the\\nlength will be 1, and the array is [1].\\nIf a number is 0, then we try to locate the nearest right index for 1:\\nfor example, the nums[1] = 0, the next 1 is at index 3. so the length\\nis 3 - 1 + 1 = 3.\\n\\nFor the general case, we could check each bit position as above.\\n\\n\\nnums = [1, 0, 2, 1, 3]\\nnums = [01, 00, 10, 01, 11]\\n\\nAs for each number, we aim to find nearest/smallest right index for each bit, \\nWe could iterate the nums list from right to left, i.e., reversely:\\n\\nfor each number:\\n    for each bit position, we find the nearest right index with a one\\n    (if no ones, set the right index to be its index):\\n    \\n    We pick the largest such right index among all the bit positions, and\\n    compute the length: ls = max(1, max j - i + 1).\\n    \\n    This ls is the corresponding result for the number we currently look at.\\n    \\n    \\n    \\nWalkthrough:\\n\\nat i = 4, num = 3 = \"11\", [4, 4]: ls = max(1, 4 - 4 + 1) = 1\\nat i = 3, num = 1 = \"01\", [4, 3]: ls = max(1, 4 - 3 + 1) = 2\\nat i = 2, num = 2 = \"10\", [2, 3]: ls = max(1, 3 - 2 + 1) = 2\\nat i = 1, num = 0 = \"00\", [2, 3]: ls = max(1, 3 - 1 + 1) = 3\\nat i = 0, num = 1 = \"01\", [2, 0]: ls = max(1, 2 - 0 + 1) = 3\\n\\nSo the return is: [3, 3, 2, 2, 1]\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        res = [1] * n\\n        # for each number, we check the bit positions to find the nearest right_index with \\n        # bit 1 in the corresponding position;\\n        right_bit_one_pos = [0] * 30\\n        for i in range(n-1, -1, -1):\\n            for j in range(30):\\n                if nums[i] & (1 << j):\\n                    right_bit_one_pos[j] = i\\n            res[i] = max(1, max(right_bit_one_pos) - i + 1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640067,
                "title": "smallest-subarrays-python-solution-faster-89",
                "content": "class Solution:\\n\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:        \\n\\n        n, ans, bits = len(nums), deque(), defaultdict(int)\\n\\n        for i in range(n)[::-1]:               \\n            I = i\\n\\n            for b in range(31):\\n                if nums[i] & (1 << b): bits[b] = i\\n                elif b in bits and I < bits[b]: I = bits[b] \\n\\n            ans.appendleft(I+1-i)\\n\\n        return list(ans)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:        \\n\\n        n, ans, bits = len(nums), deque(), defaultdict(int)\\n\\n        for i in range(n)[::-1]:               \\n            I = i\\n\\n            for b in range(31):\\n                if nums[i] & (1 << b): bits[b] = i\\n                elif b in bits and I < bits[b]: I = bits[b] \\n\\n            ans.appendleft(I+1-i)\\n\\n        return list(ans)",
                "codeTag": "Java"
            },
            {
                "id": 2624178,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[] SmallestSubarrays(int[] nums) {\\n\\n        int[] result = new int[nums.Length];\\n        int[] bits = new int[32];\\n        int c = 0;\\n        int max =1;\\n        for(int i = nums.Length-1 ; i>=0; i--)\\n        {\\n            c= 0;\\n            max = 1;\\n            for (int j = 0 ; j<32 ; j++)\\n            {\\n                if((nums[i]&1) >0)\\n                    bits[c] = i;\\n\\n                nums[i]>>=1;\\n                max = Math.Max(max,bits[c]-i+1 );   \\n                c++; \\n            }\\n            result[i] = max;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] SmallestSubarrays(int[] nums) {\\n\\n        int[] result = new int[nums.Length];\\n        int[] bits = new int[32];\\n        int c = 0;\\n        int max =1;\\n        for(int i = nums.Length-1 ; i>=0; i--)\\n        {\\n            c= 0;\\n            max = 1;\\n            for (int j = 0 ; j<32 ; j++)\\n            {\\n                if((nums[i]&1) >0)\\n                    bits[c] = i;\\n\\n                nums[i]>>=1;\\n                max = Math.Max(max,bits[c]-i+1 );   \\n                c++; \\n            }\\n            result[i] = max;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624142,
                "title": "go-o-n-clean-bit-solution",
                "content": "```\\nfunc smallestSubarrays(nums []int) []int {\\n    var bitmap [30]int\\n\\n    for i := len(nums) - 1; i >= 0; i-- {\\n        for j := 0; (1 << j) <= nums[i]; j++ {\\n            if nums[i] & (1 << j) != 0 {\\n                bitmap[j] = i\\n            }\\n        }\\n        nums[i] = max(bitmap[:], i) - i + 1\\n    }\\n\\n    return nums\\n}\\n\\nfunc max(arr []int, i int) int {\\n    max := i\\n    for _, x := range arr {\\n        if x > max {\\n            max = x\\n        }\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc smallestSubarrays(nums []int) []int {\\n    var bitmap [30]int\\n\\n    for i := len(nums) - 1; i >= 0; i-- {\\n        for j := 0; (1 << j) <= nums[i]; j++ {\\n            if nums[i] & (1 << j) != 0 {\\n                bitmap[j] = i\\n            }\\n        }\\n        nums[i] = max(bitmap[:], i) - i + 1\\n    }\\n\\n    return nums\\n}\\n\\nfunc max(arr []int, i int) int {\\n    max := i\\n    for _, x := range arr {\\n        if x > max {\\n            max = x\\n        }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621434,
                "title": "bit-masking",
                "content": "\\n\\n        n = len(a)\\n        dp = [[0]*(n+1) for i in range(30)] \\n        res = []\\n        \\n        mask = 1\\n        for i in range(30): \\n            for j in range(n-1,-1,-1): \\n                if a[j]&mask: dp[i][j] = j \\n                else: dp[i][j] = dp[i][j+1] \\n            mask<<=1\\n        \\n        for i in range(n):\\n            left,right = i,i\\n            for j in range(30):\\n                if dp[j][i]!=0: \\n                    left = min(left,dp[j][i])\\n                    right = max(right,dp[j][i])\\n            res.append(right-left+1) \\n            \\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "\\n\\n        n = len(a)\\n        dp = [[0]*(n+1) for i in range(30)] \\n        res = []\\n        \\n        mask = 1\\n        for i in range(30): \\n            for j in range(n-1,-1,-1): \\n                if a[j]&mask: dp[i][j] = j \\n                else: dp[i][j] = dp[i][j+1] \\n            mask<<=1\\n        \\n        for i in range(n):\\n            left,right = i,i\\n            for j in range(30):\\n                if dp[j][i]!=0: \\n                    left = min(left,dp[j][i])\\n                    right = max(right,dp[j][i])\\n            res.append(right-left+1) \\n            \\n        return res\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2620866,
                "title": "javascript-leftward-scan-o-n-beats-100-cpu",
                "content": "I puzzled over this for a while and had to look up what other did.  Inspired by [this Java version](https://leetcode.com/problems/smallest-subarrays-with-maximum-bitwise-or/discuss/2589058/simple-clean-Ccode-oror-O(N)-solution-oror-Bit-Manipulation), I did mine in JavaScript, along with a nice optimization:\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallestSubarrays = function(nums) {\\n    const nearest = Array(32).fill(0);\\n    const retval = [];\\n    \\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        let farthestBit = i;\\n        \\n        for (let j = 0; j < 32; ++j) {\\n            if (nums[i] & (1 << j))\\n                nearest[j] = i;\\n            else if (nearest[j] > farthestBit)\\n                farthestBit = nearest[j];\\n        }\\n        \\n        retval.push(farthestBit - i + 1);\\n    }\\n    \\n    return retval.reverse();\\n};\\n```\\n\\n---\\nP.S.  The reason for `retval.revers()` is that `Array.unshift()` turns out so much slower!  Evidence:\\n\\n![image](https://assets.leetcode.com/users/images/c5898f4c-4c06-4994-9dd1-5b71a3ee9649_1664080394.8984246.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallestSubarrays = function(nums) {\\n    const nearest = Array(32).fill(0);\\n    const retval = [];\\n    \\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        let farthestBit = i;\\n        \\n        for (let j = 0; j < 32; ++j) {\\n            if (nums[i] & (1 << j))\\n                nearest[j] = i;\\n            else if (nearest[j] > farthestBit)\\n                farthestBit = nearest[j];\\n        }\\n        \\n        retval.push(farthestBit - i + 1);\\n    }\\n    \\n    return retval.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620119,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func smallestSubarrays(_ nums: [Int]) -> [Int] {\\n        nums.indices.reversed().reduce(into: ([Int](), Array(repeating: 0, count: 30))) { d, i in d.0.append((0 ..< 30).reduce(into:1) {r, j in d.1[j] = nums[i]&(1<<j) != 0 ? i:d.1[j];r = max(r,d.1[j]-i+1)})}.0.reversed()\\n    }\\n}\\n```\\n**NOTE:** This is technically a one-liner, since the `return` keyword could be omitted.\\n\\n---\\n\\n**One-Liner expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func smallestSubarrays(_ nums: [Int]) -> [Int] {\\n        nums.indices.reversed().reduce(into: (\\n\\t\\t\\t\\t\\tresult: [Int](),\\n\\t\\t\\t\\t\\tlast: Array(repeating: 0, count: 30))\\n\\t\\t) { data, i in\\n            data.result.append((0 ..< 30).reduce(1) { res, j in\\n                if nums[i] & (1 << j) != 0 {\\n                    data.last[j] = i\\n                }\\n                return max(res, data.last[j] - i + 1)\\n            })\\n        }.result.reversed()\\n    }\\n}\\n```\\n\\n---\\n\\n**Conventional Approach (accepted answer)**\\n```\\nclass Solution {\\n    func smallestSubarrays(_ nums: [Int]) -> [Int] {\\n        var result = [Int]()\\n        var lastBitSeen = Array(repeating: 0, count: 30)\\n        for i in nums.indices.reversed() {\\n            var res = 1\\n            for j in 0 ..< 30 {\\n                if nums[i] & (1 << j) != 0 {\\n                    lastBitSeen[j] = i\\n                }\\n                res = max(res, lastBitSeen[j] - i + 1)\\n            }\\n            result.append(res)\\n        }\\n        return result.reversed()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func smallestSubarrays(_ nums: [Int]) -> [Int] {\\n        nums.indices.reversed().reduce(into: ([Int](), Array(repeating: 0, count: 30))) { d, i in d.0.append((0 ..< 30).reduce(into:1) {r, j in d.1[j] = nums[i]&(1<<j) != 0 ? i:d.1[j];r = max(r,d.1[j]-i+1)})}.0.reversed()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func smallestSubarrays(_ nums: [Int]) -> [Int] {\\n        nums.indices.reversed().reduce(into: (\\n\\t\\t\\t\\t\\tresult: [Int](),\\n\\t\\t\\t\\t\\tlast: Array(repeating: 0, count: 30))\\n\\t\\t) { data, i in\\n            data.result.append((0 ..< 30).reduce(1) { res, j in\\n                if nums[i] & (1 << j) != 0 {\\n                    data.last[j] = i\\n                }\\n                return max(res, data.last[j] - i + 1)\\n            })\\n        }.result.reversed()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func smallestSubarrays(_ nums: [Int]) -> [Int] {\\n        var result = [Int]()\\n        var lastBitSeen = Array(repeating: 0, count: 30)\\n        for i in nums.indices.reversed() {\\n            var res = 1\\n            for j in 0 ..< 30 {\\n                if nums[i] & (1 << j) != 0 {\\n                    lastBitSeen[j] = i\\n                }\\n                res = max(res, lastBitSeen[j] - i + 1)\\n            }\\n            result.append(res)\\n        }\\n        return result.reversed()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620109,
                "title": "java-segment-tree-easy-understanding",
                "content": "step1 create presum , presum[i] means or-sum from nums[i]~nums[len-1]; \\nstep2 create  segment tree\\nstep3 use binary search to find the right index , the target is the presum[i]\\n```\\nclass Solution {\\n     public int[] smallestSubarrays(int[] nums) {\\n        int[] presum = new int[nums.length];\\n        presum[nums.length - 1] = nums[nums.length - 1];\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            presum[i] = presum[i + 1] | nums[i];\\n        }\\n        Node root = build(0, nums.length - 1, nums);\\n\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int r = search(root, presum[i], i, nums.length - 1);\\n            res[i] = r - i + 1;\\n        }\\n        return res;\\n    }\\n\\n    private int search(Node root, int target, int l, int r) {\\n        int left = l;\\n        int right = r;\\n        int res = r;\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (query(root,l,mid) >= target) {\\n                res = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private Node build(int start, int end, int[] nums) {\\n        if (start > end) {\\n            return null;\\n        }\\n        Node root = new Node(start, end, nums[start]);\\n\\n        if (start == end) {\\n            return root;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        root.left = build(start, mid, nums);\\n        root.right = build(mid + 1, end, nums);\\n\\n        root.sum = root.left.sum | root.right.sum;\\n        return root;\\n    }\\n\\n    private int query(Node node, int start, int end) {\\n        int sum = 0;\\n        if (node == null || start > node.e || end < node.s) {\\n            return sum;\\n        }\\n        if (start <= node.s && end >= node.e) {\\n            return node.sum;\\n        }\\n\\n        int mid = (node.s + node.e) / 2;\\n        if (start <= mid) {\\n            sum |= query(node.left, start, end);\\n        }\\n\\n        if (end >= mid + 1) {\\n            sum |= query(node.right, start, end);\\n        }\\n        return sum;\\n\\n    }\\n\\n\\n    class Node {\\n        int s;\\n        int e;\\n        Node left;\\n        Node right;\\n        int sum;\\n\\n        public Node(int s, int e, int sum) {\\n            this.s = s;\\n            this.e = e;\\n            this.sum = sum;\\n            this.left = null;\\n            this.right = null;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int[] smallestSubarrays(int[] nums) {\\n        int[] presum = new int[nums.length];\\n        presum[nums.length - 1] = nums[nums.length - 1];\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            presum[i] = presum[i + 1] | nums[i];\\n        }\\n        Node root = build(0, nums.length - 1, nums);\\n\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            int r = search(root, presum[i], i, nums.length - 1);\\n            res[i] = r - i + 1;\\n        }\\n        return res;\\n    }\\n\\n    private int search(Node root, int target, int l, int r) {\\n        int left = l;\\n        int right = r;\\n        int res = r;\\n        while (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (query(root,l,mid) >= target) {\\n                res = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private Node build(int start, int end, int[] nums) {\\n        if (start > end) {\\n            return null;\\n        }\\n        Node root = new Node(start, end, nums[start]);\\n\\n        if (start == end) {\\n            return root;\\n        }\\n\\n        int mid = (start + end) / 2;\\n        root.left = build(start, mid, nums);\\n        root.right = build(mid + 1, end, nums);\\n\\n        root.sum = root.left.sum | root.right.sum;\\n        return root;\\n    }\\n\\n    private int query(Node node, int start, int end) {\\n        int sum = 0;\\n        if (node == null || start > node.e || end < node.s) {\\n            return sum;\\n        }\\n        if (start <= node.s && end >= node.e) {\\n            return node.sum;\\n        }\\n\\n        int mid = (node.s + node.e) / 2;\\n        if (start <= mid) {\\n            sum |= query(node.left, start, end);\\n        }\\n\\n        if (end >= mid + 1) {\\n            sum |= query(node.right, start, end);\\n        }\\n        return sum;\\n\\n    }\\n\\n\\n    class Node {\\n        int s;\\n        int e;\\n        Node left;\\n        Node right;\\n        int sum;\\n\\n        public Node(int s, int e, int sum) {\\n            this.s = s;\\n            this.e = e;\\n            this.sum = sum;\\n            this.left = null;\\n            this.right = null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617998,
                "title": "c-bit-solution",
                "content": "**Idea** :- \\n1.]Subarray with maximum OR means we have to add more of more set bits in our subarray\\'s OR \\n2.]We have to find nearest number for each position set bit that\\'s why we are going to iterate from last to first\\n\\n**C++**\\n```\\n vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n,1);\\n        \\n        vector<int> last(30,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<30;j++){\\n                if(nums[i] & (1<<j)){\\n                    last[j]=i;\\n                }\\n                res[i]=max(res[i],last[j]-i+1);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> res(n,1);\\n        \\n        vector<int> last(30,0);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<30;j++){\\n                if(nums[i] & (1<<j)){\\n                    last[j]=i;\\n                }\\n                res[i]=max(res[i],last[j]-i+1);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606539,
                "title": "c-o-n-32-bit-manipulation",
                "content": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        vector<queue<int>> v(31);\\n        \\n        for(int i = 0;i < 31;i++){\\n            for(int j = 0;j < nums.size();j++){\\n                if(nums[j] & (1<<i)) v[i].push(j);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i = 0;i < nums.size();i++){\\n            \\n            int len = -1;\\n            for(int j = 0;j <= 30;j++){\\n                \\n                if(!v[j].empty()) {len = max(len,v[j].front());}\\n                if(v[j].front() == i) v[j].pop();\\n                \\n            }\\n            \\n            if(len != -1) ans.push_back(len-i+1);\\n            else ans.push_back(1);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Bit Manipulation",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        \\n        vector<queue<int>> v(31);\\n        \\n        for(int i = 0;i < 31;i++){\\n            for(int j = 0;j < nums.size();j++){\\n                if(nums[j] & (1<<i)) v[i].push(j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2605071,
                "title": "go-binary-search",
                "content": "```\\nvar magic = 32\\nfunc smallestSubarrays(nums []int) []int {\\n    list := make([]*[]int, magic)\\n    for i := 0; i < len(list); i++ {\\n        list[i] = &[]int{}\\n    }\\n    \\n    for i, v := range nums {\\n        for j := 0; j < magic; j++ {\\n            if (v & (1 << j)) != 0 {\\n                *(list[j]) = append(*(list[j]), i)\\n            }\\n        }\\n    }\\n    \\n    res := make([]int, len(nums))\\n    for i, _ := range nums {\\n        a := 0\\n        for j := 0; j < magic; j++ {\\n            tar := *list[j]\\n            index := sort.Search(len(tar), func(k int) bool {\\n                return tar[k] >= i\\n            })\\n            if index == len(tar) {\\n                a = max(a, i)\\n            } else {\\n                a = max(a, tar[index])\\n            }\\n        }\\n        res[i] = a - i + 1\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int  {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar magic = 32\\nfunc smallestSubarrays(nums []int) []int {\\n    list := make([]*[]int, magic)\\n    for i := 0; i < len(list); i++ {\\n        list[i] = &[]int{}\\n    }\\n    \\n    for i, v := range nums {\\n        for j := 0; j < magic; j++ {\\n            if (v & (1 << j)) != 0 {\\n                *(list[j]) = append(*(list[j]), i)\\n            }\\n        }\\n    }\\n    \\n    res := make([]int, len(nums))\\n    for i, _ := range nums {\\n        a := 0\\n        for j := 0; j < magic; j++ {\\n            tar := *list[j]\\n            index := sort.Search(len(tar), func(k int) bool {\\n                return tar[k] >= i\\n            })\\n            if index == len(tar) {\\n                a = max(a, i)\\n            } else {\\n                a = max(a, tar[index])\\n            }\\n        }\\n        res[i] = a - i + 1\\n    }\\n    return res\\n}\\n\\nfunc max(a int, b int) int  {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602963,
                "title": "100-understand-python3",
                "content": "#### Approach:\\n```python=\\narr: [1, 0, 1, 2, 3]\\nBits Representation of arr: [01, 00, 01, 10, 11], here we have only 2 bits.\\n\\nObservation:\\nThe 1st bit is present at idx: 0, 2, 4\\nThe 2nd bit is present at idx: 3, 4\\nThe 3rd bit\\nThe 4th bit\\n.\\n.\\n.\\n\\nStart iterating the array and checking for every index.\\xA0\\nLet\\'s say we are at the 0th index of the array. Then check for all the bits, which means the 1st-bit position(0 in our case), \\nthe 2nd-bit position(3 in our case, but why not 4, because we have to take the first number that appears, so before 4, 3 appears), and so on.\\n\\n```\\n\\n#### Code:\\n```python\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        ans = defaultdict(deque)\\n        for i in range(len(nums)):\\n            for bit in range(31):\\n                if nums[i] & (1 << bit):\\n                    ans[bit].append(i)\\n        res = []\\n        for i in range(len(nums)):\\n            end = i\\n            for _, arr in ans.items():\\n                if arr and i > arr[0]:\\n                    arr.popleft()\\n                if arr:\\n                    end = max(end, arr[0])\\n            res.append(end-i+1)\\n        return res\\n```\\n\\n#### Check out:\\n[https://github.com/Iamtripathisatyam](https://github.com/Iamtripathisatyam)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python=\\narr: [1, 0, 1, 2, 3]\\nBits Representation of arr: [01, 00, 01, 10, 11], here we have only 2 bits.\\n\\nObservation:\\nThe 1st bit is present at idx: 0, 2, 4\\nThe 2nd bit is present at idx: 3, 4\\nThe 3rd bit\\nThe 4th bit\\n.\\n.\\n.\\n\\nStart iterating the array and checking for every index.\\xA0\\nLet\\'s say we are at the 0th index of the array. Then check for all the bits, which means the 1st-bit position(0 in our case), \\nthe 2nd-bit position(3 in our case, but why not 4, because we have to take the first number that appears, so before 4, 3 appears), and so on.\\n\\n```\n```python\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        ans = defaultdict(deque)\\n        for i in range(len(nums)):\\n            for bit in range(31):\\n                if nums[i] & (1 << bit):\\n                    ans[bit].append(i)\\n        res = []\\n        for i in range(len(nums)):\\n            end = i\\n            for _, arr in ans.items():\\n                if arr and i > arr[0]:\\n                    arr.popleft()\\n                if arr:\\n                    end = max(end, arr[0])\\n            res.append(end-i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602594,
                "title": "java-bit-with-explanation",
                "content": "```\\n/*\\nThe main concept is to visualize each no. as binaries\\nso [1,0,2,1,3] in binary terms looks like\\n[01, 00, 10, 01, 11]\\n\\nMaximum bits required for 10^9 = 30 bits\\nbmax = \\u230Alog2(10^d)\\u230B + 1 = \\u230Ad\\xB7log2(10)\\u230B + 1\\n\\nSo creating a 30 bits array and each position in this array stores the nearest position from it\\nwhere this value is set, starting with its own index towards right.\\n\\nSo basically we started our iteration from the backend and for each number we are looking all\\nthe bits and if any bit is set we are storing its position and if any bit is set from a \\nnumber which is afterwards we are taking that into consideration as well when calculating \\nlength. \\nFor example\\nnumber 3 -> 11 binary representation sets \\nbitPosition[0] = 4(index) \\nbitPosition[1] = 4 (index)\\n\\nwhen we came to number 1 (index 3)\\nbitPosition[0] = 3 (index)\\nbitPosition[1] = 4 (index)\\n\\nHere in the second round bitPosition[1] = 4 remains as it is because 1 does not have any bit on\\n1st position (0 indexed), but 3 has which was the next number, which set this value. So that is\\nwhy we are taking max after each bit\\n*/\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int [] res = new int[nums.length];\\n        int [] bitPosition = new int[30];\\n        for(int i = nums.length - 1 ; i >= 0; i--)\\n        {\\n            res[i] = 1;\\n            for(int j = 0; j < 30; j++)\\n            {\\n                if((nums[i] & (1 << j)) > 0)\\n                    bitPosition[j] = i;\\n                \\n                res[i] = Math.max(res[i], bitPosition[j] - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nThe main concept is to visualize each no. as binaries\\nso [1,0,2,1,3] in binary terms looks like\\n[01, 00, 10, 01, 11]\\n\\nMaximum bits required for 10^9 = 30 bits\\nbmax = \\u230Alog2(10^d)\\u230B + 1 = \\u230Ad\\xB7log2(10)\\u230B + 1\\n\\nSo creating a 30 bits array and each position in this array stores the nearest position from it\\nwhere this value is set, starting with its own index towards right.\\n\\nSo basically we started our iteration from the backend and for each number we are looking all\\nthe bits and if any bit is set we are storing its position and if any bit is set from a \\nnumber which is afterwards we are taking that into consideration as well when calculating \\nlength. \\nFor example\\nnumber 3 -> 11 binary representation sets \\nbitPosition[0] = 4(index) \\nbitPosition[1] = 4 (index)\\n\\nwhen we came to number 1 (index 3)\\nbitPosition[0] = 3 (index)\\nbitPosition[1] = 4 (index)\\n\\nHere in the second round bitPosition[1] = 4 remains as it is because 1 does not have any bit on\\n1st position (0 indexed), but 3 has which was the next number, which set this value. So that is\\nwhy we are taking max after each bit\\n*/\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int [] res = new int[nums.length];\\n        int [] bitPosition = new int[30];\\n        for(int i = nums.length - 1 ; i >= 0; i--)\\n        {\\n            res[i] = 1;\\n            for(int j = 0; j < 30; j++)\\n            {\\n                if((nums[i] & (1 << j)) > 0)\\n                    bitPosition[j] = i;\\n                \\n                res[i] = Math.max(res[i], bitPosition[j] - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601662,
                "title": "c-o-nlogn-solution-with-binary-search-easy-to-understand",
                "content": "```\\n vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> res(nums.size(), 0);\\n        // indexs use to record the bit == 1 index for each position\\n        vector<vector<int>> indexs(31, vector<int> (1, -1));\\n        for(int i=0;i<nums.size();i++){\\n            int num = nums[i];\\n            int bit = 0;\\n            while(num>0){\\n                if((int)(num&1) == 1){\\n                    indexs[bit].push_back(i);\\n                }\\n                bit++;\\n                num = num >> 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int mx = i;\\n            int num = nums[i];\\n            for(int j=0;j<31;j++){\\n                // binary search in indexs[j] and find first iterator equal or greater than i\\n                auto t = lower_bound(indexs[j].begin(), indexs[j].end(), i);\\n                if(t!=indexs[j].end()){\\n                    mx = max(*t, mx);\\n                }\\n            }\\n            res[i] = mx-i+1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> res(nums.size(), 0);\\n        // indexs use to record the bit == 1 index for each position\\n        vector<vector<int>> indexs(31, vector<int> (1, -1));\\n        for(int i=0;i<nums.size();i++){\\n            int num = nums[i];\\n            int bit = 0;\\n            while(num>0){\\n                if((int)(num&1) == 1){\\n                    indexs[bit].push_back(i);\\n                }\\n                bit++;\\n                num = num >> 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int mx = i;\\n            int num = nums[i];\\n            for(int j=0;j<31;j++){\\n                // binary search in indexs[j] and find first iterator equal or greater than i\\n                auto t = lower_bound(indexs[j].begin(), indexs[j].end(), i);\\n                if(t!=indexs[j].end()){\\n                    mx = max(*t, mx);\\n                }\\n            }\\n            res[i] = mx-i+1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2598460,
                "title": "java-spend-4-hours-on-learning-bit-manuplation-basic",
                "content": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        \\n        int[] ans = new int[nums.length];\\n        int[] bits = new int[32];\\n        \\n        for(int i = nums.length-1; i >= 0; i--){\\n            ans[i] = 1;\\n            for(int j = 0; j < 32; j++){\\n                \\n                if((nums[i] & (1 << j)) > 0){\\n                    bits[j] = i;\\n                }\\n                ans[i] = Math.max(ans[i],bits[j]-i+1);\\n            }\\n        \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        \\n        int[] ans = new int[nums.length];\\n        int[] bits = new int[32];\\n        \\n        for(int i = nums.length-1; i >= 0; i--){\\n            ans[i] = 1;\\n            for(int j = 0; j < 32; j++){\\n                \\n                if((nums[i] & (1 << j)) > 0){\\n                    bits[j] = i;\\n                }\\n                ans[i] = Math.max(ans[i],bits[j]-i+1);\\n            }\\n        \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598007,
                "title": "java-binary-search-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n     int max_or=0;\\n        for(int i=0;i<nums.length;i++){\\n            max_or|=nums[i];\\n        }\\n    ArrayList<Integer> []arr=new ArrayList[32];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=new ArrayList<Integer>();\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<32;j++){\\n                if((nums[i]&(1<<j))>0){\\n                    arr[j].add(i);\\n                }\\n            }\\n        }\\n        //which bits are to be set\\n        ArrayList<Integer> to_set=new ArrayList<>();\\n        for(int i=0;i<32;i++){\\n            if((max_or&(1<<i))>0){\\n                to_set.add(i);\\n            }\\n        }\\n        int []ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int max_index=i;\\n            for(int set_bit:to_set){\\n                max_index=Math.max(max_index,BinarySearch(arr[set_bit],i));\\n            }\\n            ans[i]=max_index-i+1;\\n        }\\n        return ans;\\n        \\n    }\\n    public int BinarySearch(ArrayList<Integer> list,int start){\\n        int low=0;\\n        int high=list.size()-1;\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(list.get(mid)>=start){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans==-1?start:list.get(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n     int max_or=0;\\n        for(int i=0;i<nums.length;i++){\\n            max_or|=nums[i];\\n        }\\n    ArrayList<Integer> []arr=new ArrayList[32];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=new ArrayList<Integer>();\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<32;j++){\\n                if((nums[i]&(1<<j))>0){\\n                    arr[j].add(i);\\n                }\\n            }\\n        }\\n        //which bits are to be set\\n        ArrayList<Integer> to_set=new ArrayList<>();\\n        for(int i=0;i<32;i++){\\n            if((max_or&(1<<i))>0){\\n                to_set.add(i);\\n            }\\n        }\\n        int []ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int max_index=i;\\n            for(int set_bit:to_set){\\n                max_index=Math.max(max_index,BinarySearch(arr[set_bit],i));\\n            }\\n            ans[i]=max_index-i+1;\\n        }\\n        return ans;\\n        \\n    }\\n    public int BinarySearch(ArrayList<Integer> list,int start){\\n        int low=0;\\n        int high=list.size()-1;\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(list.get(mid)>=start){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else low=mid+1;\\n        }\\n        return ans==-1?start:list.get(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597683,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        \\n        \\n        int result [] = new int[nums.length];\\n        \\n        int bits [] = new int[32];\\n        Arrays.fill(bits,-1);\\n        \\n        for(int i = nums.length-1;i>=0;i--){\\n            \\n            int n = nums[i];\\n            for(int j=0;j<32;j++){\\n                if((n&1)==1){\\n                    bits[j]=i;\\n                }\\n                n>>>=1;\\n            }\\n            \\n            int max = Integer.MIN_VALUE;\\n            for(int j:bits)\\n                max = Math.max(max,j);\\n            if(max!=-1)\\n            result[i]= max-i+1;\\n            else\\n                result[i]=1;\\n                \\n            \\n        }\\n        return result;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        \\n        \\n        int result [] = new int[nums.length];\\n        \\n        int bits [] = new int[32];\\n        Arrays.fill(bits,-1);\\n        \\n        for(int i = nums.length-1;i>=0;i--){\\n            \\n            int n = nums[i];\\n            for(int j=0;j<32;j++){\\n                if((n&1)==1){\\n                    bits[j]=i;\\n                }\\n                n>>>=1;\\n            }\\n            \\n            int max = Integer.MIN_VALUE;\\n            for(int j:bits)\\n                max = Math.max(max,j);\\n            if(max!=-1)\\n            result[i]= max-i+1;\\n            else\\n                result[i]=1;\\n                \\n            \\n        }\\n        return result;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597417,
                "title": "java-binary-search-bit-operation",
                "content": "\\n```\\nclass Solution {\\n\\n    public int[] smallestSubarrays(int[] nums) {\\n        int i,j,left,right,mid,pos,current;\\n        int[] res = new int[nums.length];\\n        ArrayList<Integer>[] bitArray = new ArrayList[32];\\n        \\n        for(i=0;i<32;i++){\\n            bitArray[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(i=0;i<nums.length;i++){\\n            for(j=0;j<31;j++){\\n                if( (nums[i]&(1<<j)) >0){\\n                    bitArray[j].add(i);\\n                }\\n            }\\n        }\\n        \\n        for(i=0;i<nums.length;i++){\\n            current=i;\\n            for(j=0;j<31;j++){\\n                pos=i;\\n                left=0;\\n                right=bitArray[j].size()-1;\\n                while(left<=right){\\n                    mid = left+(right-left)/2;\\n                    if(bitArray[j].get(mid)<i){\\n                        left=mid+1;\\n                    }\\n                    else{\\n                        pos=bitArray[j].get(mid);\\n                        right=mid-1;\\n                    }\\n                }\\n                current = Math.max(current,pos);\\n            }\\n            res[i]=current-i+1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] smallestSubarrays(int[] nums) {\\n        int i,j,left,right,mid,pos,current;\\n        int[] res = new int[nums.length];\\n        ArrayList<Integer>[] bitArray = new ArrayList[32];\\n        \\n        for(i=0;i<32;i++){\\n            bitArray[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(i=0;i<nums.length;i++){\\n            for(j=0;j<31;j++){\\n                if( (nums[i]&(1<<j)) >0){\\n                    bitArray[j].add(i);\\n                }\\n            }\\n        }\\n        \\n        for(i=0;i<nums.length;i++){\\n            current=i;\\n            for(j=0;j<31;j++){\\n                pos=i;\\n                left=0;\\n                right=bitArray[j].size()-1;\\n                while(left<=right){\\n                    mid = left+(right-left)/2;\\n                    if(bitArray[j].get(mid)<i){\\n                        left=mid+1;\\n                    }\\n                    else{\\n                        pos=bitArray[j].get(mid);\\n                        right=mid-1;\\n                    }\\n                }\\n                current = Math.max(current,pos);\\n            }\\n            res[i]=current-i+1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596974,
                "title": "segment-tree-approach-c",
                "content": "```\\nclass SegTree {\\nprivate:\\n    vector<int> tree;\\npublic:\\n    SegTree(int _n) {\\n        tree.resize(4*_n);\\n    }\\n    void update(int l, int r, int node, int idx, int val) {\\n        if(l == r) {\\n            tree[node] = val;\\n            return;\\n        }\\n        int m = l + ((r-l) >> 1);\\n        if(idx <= m)\\n            update(l, m, 2*node+1, idx, val);\\n        else\\n            update(m+1, r, 2*node+2, idx, val);\\n        tree[node] = tree[2*node+1] | tree[2*node+2];\\n    }\\n    int query(int l, int r, int node, int gl, int gr) {\\n        if(r < gl || l > gr)\\n            return 0;\\n        if(l >= gl && r <= gr)\\n            return tree[node];\\n        int m = l + ((r-l) >> 1);\\n        return query(l, m, 2*node+1, gl, gr) | query(m+1, r, 2*node+2, gl, gr);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        SegTree sgt(n);\\n        for(int i=n-1; i>=0; i--) {\\n            sgt.update(0, n-1, 0, i, nums[i]);\\n            int mxOr = sgt.query(0, n-1, 0, i, n-1);\\n            int L = i, H = n-1, j=n-1;\\n            while(L <= H) {\\n                int m = L + ((H-L) >> 1);\\n                if(sgt.query(0, n-1, 0, i, m) == mxOr) {\\n                    j = m;\\n                    H = m-1;\\n                } else {\\n                    L = m+1;\\n                }\\n            }\\n            ans[i] = j-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass SegTree {\\nprivate:\\n    vector<int> tree;\\npublic:\\n    SegTree(int _n) {\\n        tree.resize(4*_n);\\n    }\\n    void update(int l, int r, int node, int idx, int val) {\\n        if(l == r) {\\n            tree[node] = val;\\n            return;\\n        }\\n        int m = l + ((r-l) >> 1);\\n        if(idx <= m)\\n            update(l, m, 2*node+1, idx, val);\\n        else\\n            update(m+1, r, 2*node+2, idx, val);\\n        tree[node] = tree[2*node+1] | tree[2*node+2];\\n    }\\n    int query(int l, int r, int node, int gl, int gr) {\\n        if(r < gl || l > gr)\\n            return 0;\\n        if(l >= gl && r <= gr)\\n            return tree[node];\\n        int m = l + ((r-l) >> 1);\\n        return query(l, m, 2*node+1, gl, gr) | query(m+1, r, 2*node+2, gl, gr);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        SegTree sgt(n);\\n        for(int i=n-1; i>=0; i--) {\\n            sgt.update(0, n-1, 0, i, nums[i]);\\n            int mxOr = sgt.query(0, n-1, 0, i, n-1);\\n            int L = i, H = n-1, j=n-1;\\n            while(L <= H) {\\n                int m = L + ((H-L) >> 1);\\n                if(sgt.query(0, n-1, 0, i, m) == mxOr) {\\n                    j = m;\\n                    H = m-1;\\n                } else {\\n                    L = m+1;\\n                }\\n            }\\n            ans[i] = j-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596885,
                "title": "c-2-solutions",
                "content": "1. Array of queue\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = size(nums);\\n        vector<int> ans(n);\\n        queue<int> q[32];\\n        for (int i = 0; i < n; i++) {\\n            int j = 0, cur = nums[i];\\n            while (cur) {\\n                if (cur & 1) q[j].push(i);\\n                cur >>= 1, j++;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int k = i;\\n            for (int j = 0; j < 32; j++) {\\n                if (q[j].empty()) continue;\\n                if (q[j].front() == i) q[j].pop();\\n                else k = max(k, q[j].front());\\n            }\\n            ans[i] = k - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n2. Just a array\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = size(nums), last[30] = {};\\n        vector<int> ans(n);\\n        for (int i = n-1; i >= 0; i--) {\\n            int cur = nums[i], j = 0;\\n            while (cur) {\\n                if (cur & 1) last[j] = i;\\n                cur >>= 1, j++;\\n            }\\n            ans[i] = max(1, *max_element(last, last+30)-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = size(nums);\\n        vector<int> ans(n);\\n        queue<int> q[32];\\n        for (int i = 0; i < n; i++) {\\n            int j = 0, cur = nums[i];\\n            while (cur) {\\n                if (cur & 1) q[j].push(i);\\n                cur >>= 1, j++;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            int k = i;\\n            for (int j = 0; j < 32; j++) {\\n                if (q[j].empty()) continue;\\n                if (q[j].front() == i) q[j].pop();\\n                else k = max(k, q[j].front());\\n            }\\n            ans[i] = k - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = size(nums), last[30] = {};\\n        vector<int> ans(n);\\n        for (int i = n-1; i >= 0; i--) {\\n            int cur = nums[i], j = 0;\\n            while (cur) {\\n                if (cur & 1) last[j] = i;\\n                cur >>= 1, j++;\\n            }\\n            ans[i] = max(1, *max_element(last, last+30)-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596431,
                "title": "clear-implementation-of-binary-search-and-suffix-or",
                "content": "```\\nThink about suffix of OR of the array will be you maximum OR of subarray i.e. [i....n-1] will be max OR of  that subarray which you have achive .\\n\\nclass Solution {\\npublic:\\n    \\n    typedef  int ll;\\n    void setbit(map<ll,ll>&mp,ll x )\\n    {\\n    \\n        for(ll i=0;i<32;i++)\\n        {\\n            if(x&((ll)1<<i))\\n                mp[i]++;\\n        }\\n    }\\n    ll check(ll mid,vector<vector<ll>>&v,ll p,ll t)\\n    {\\n        \\n      \\n        ll n=v.size();\\n        for(ll i=0;i<32;i++)\\n        {\\n            ll f=(p&(ll)1<<i)?1:0;\\n            ll s=(v[t][i]-v[mid][i])?1:0;\\n            \\n        \\n            if(f==s )\\n                continue;\\n            else\\n                return false;\\n            \\n        }\\n        return true;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        ll n=nums.size();\\n    \\n        vector<ll>suffix(n,0);\\n        ll x=0;\\n        \\n        vector<vector<ll>>v(n,vector<ll>(32,0));\\n        map<ll,ll>mp;\\n        for(ll i=n-1;i>=0;i--)\\n        {\\n            x=x | nums[i];\\n            suffix[i]=x;\\n        \\n            \\n            setbit(mp,nums[i]);\\n            \\n            for(ll j=0;j<32;j++)\\n            {\\n                v[i][j]=mp[j];\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        \\n        \\n        vector<int>ans;\\n        for(ll i=0;i<n;i++)\\n        {\\n            \\n            ll mx=suffix[i];\\n            \\n    \\n            ll start=i,end=n-1;\\n            ll t=n;\\n            while(start<=end)\\n            {\\n                ll mid=(start+(end-start)/2);\\n                if(check(mid,v,mx,i))\\n                {\\n                \\n                    t=mid;\\n                    end=mid-1;\\n                }\\n                else\\n                {\\n                    start=mid+1;\\n                }\\n            }\\n            \\n        \\n            ans.push_back(max(t-i,(ll)1));\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Suffix Array",
                    "Binary Tree"
                ],
                "code": "```\\nThink about suffix of OR of the array will be you maximum OR of subarray i.e. [i....n-1] will be max OR of  that subarray which you have achive .\\n\\nclass Solution {\\npublic:\\n    \\n    typedef  int ll;\\n    void setbit(map<ll,ll>&mp,ll x )\\n    {\\n    \\n        for(ll i=0;i<32;i++)\\n        {\\n            if(x&((ll)1<<i))\\n                mp[i]++;\\n        }\\n    }\\n    ll check(ll mid,vector<vector<ll>>&v,ll p,ll t)\\n    {\\n        \\n      \\n        ll n=v.size();\\n        for(ll i=0;i<32;i++)\\n        {\\n            ll f=(p&(ll)1<<i)?1:0;\\n            ll s=(v[t][i]-v[mid][i])?1:0;\\n            \\n        \\n            if(f==s )\\n                continue;\\n            else\\n                return false;\\n            \\n        }\\n        return true;\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        ll n=nums.size();\\n    \\n        vector<ll>suffix(n,0);\\n        ll x=0;\\n        \\n        vector<vector<ll>>v(n,vector<ll>(32,0));\\n        map<ll,ll>mp;\\n        for(ll i=n-1;i>=0;i--)\\n        {\\n            x=x | nums[i];\\n            suffix[i]=x;\\n        \\n            \\n            setbit(mp,nums[i]);\\n            \\n            for(ll j=0;j<32;j++)\\n            {\\n                v[i][j]=mp[j];\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        \\n        \\n        vector<int>ans;\\n        for(ll i=0;i<n;i++)\\n        {\\n            \\n            ll mx=suffix[i];\\n            \\n    \\n            ll start=i,end=n-1;\\n            ll t=n;\\n            while(start<=end)\\n            {\\n                ll mid=(start+(end-start)/2);\\n                if(check(mid,v,mx,i))\\n                {\\n                \\n                    t=mid;\\n                    end=mid-1;\\n                }\\n                else\\n                {\\n                    start=mid+1;\\n                }\\n            }\\n            \\n        \\n            ans.push_back(max(t-i,(ll)1));\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595997,
                "title": "easy-to-understand-c-bit-position",
                "content": "```\\n\\nSimpler approach :\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int power = log2(1e9) + 1;\\n        vector<int> farthestBitSet(power,0);\\n        vector<int> result(n,1);\\n        \\n        // iterate from behind, as oring of full array from any position\\n        // is going to be maximumm from particular point\\n        // maintain the position of each bit set till now, farthest the bit\\n        // subarray ends there for the size\\n        for (int i = n-1; i >= 0; i--) {\\n            int num = nums[i];\\n            int pos = 0;\\n            // Iterate over all bits set for a given number\\n            // and set the current number position for the same\\n            while(num) {\\n                if (num & 1) {\\n                    farthestBitSet[pos] = i;\\n                }\\n                num = num >> 1;\\n                pos++;\\n            }\\n            int maxBitPos = *max_element(farthestBitSet.begin(),farthestBitSet.end());\\n            result[i] = max(1,(maxBitPos-i)+1);\\n        }\\n        return result;\\n    }\\n\\t\\nclass Solution {\\npublic:\\n    // set the index of number to all bits set\\n    void setPosition(int num, vector<vector<int>> &bitArray, int idx) {\\n        int pos = 0;\\n        while(num) {\\n            if (num & 1) {\\n                bitArray[pos].push_back(idx);\\n            }\\n            pos++;\\n            num = num>>1;\\n        }\\n        return;\\n    }\\n    \\n    // search for max position among all bits set\\n    int getMaxPosition(int num, vector<vector<int>> &bitArray, int idx) {\\n        int result = 0;\\n        int pos = 0;\\n        while(num) {\\n            if (num & 1) {\\n                auto it = lower_bound(bitArray[pos].begin(),bitArray[pos].end(),idx);\\n                int curPos = *it ;\\n                result = max(result,curPos);\\n            }\\n            num = num >> 1;\\n            pos++;\\n        }\\n        return result;\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector rightOrArray(n,0);\\n        \\n        //pre compute all the rightmost array\\n        // as each number can know what max it can get\\n        rightOrArray[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            rightOrArray[i] = (rightOrArray[i+1] | nums[i]);\\n        }\\n        \\n        \\n        int power = log2(1e9) + 1;\\n        vector<vector<int>> bitArray(power);\\n        for (int i = 0; i < n; i++) {\\n            setPosition(nums[i],bitArray,i);\\n        }\\n        \\n        // default value is 1 as it is the minimumm subset\\n        vector<int> result(n,1);\\n        for (int i = 0; i < n; i++) {\\n            int maxIdx = getMaxPosition(rightOrArray[i],bitArray,i);\\n            result[i] = max(result[i],(maxIdx-i)+1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSimpler approach :\\nvector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int power = log2(1e9) + 1;\\n        vector<int> farthestBitSet(power,0);\\n        vector<int> result(n,1);\\n        \\n        // iterate from behind, as oring of full array from any position\\n        // is going to be maximumm from particular point\\n        // maintain the position of each bit set till now, farthest the bit\\n        // subarray ends there for the size\\n        for (int i = n-1; i >= 0; i--) {\\n            int num = nums[i];\\n            int pos = 0;\\n            // Iterate over all bits set for a given number\\n            // and set the current number position for the same\\n            while(num) {\\n                if (num & 1) {\\n                    farthestBitSet[pos] = i;\\n                }\\n                num = num >> 1;\\n                pos++;\\n            }\\n            int maxBitPos = *max_element(farthestBitSet.begin(),farthestBitSet.end());\\n            result[i] = max(1,(maxBitPos-i)+1);\\n        }\\n        return result;\\n    }\\n\\t\\nclass Solution {\\npublic:\\n    // set the index of number to all bits set\\n    void setPosition(int num, vector<vector<int>> &bitArray, int idx) {\\n        int pos = 0;\\n        while(num) {\\n            if (num & 1) {\\n                bitArray[pos].push_back(idx);\\n            }\\n            pos++;\\n            num = num>>1;\\n        }\\n        return;\\n    }\\n    \\n    // search for max position among all bits set\\n    int getMaxPosition(int num, vector<vector<int>> &bitArray, int idx) {\\n        int result = 0;\\n        int pos = 0;\\n        while(num) {\\n            if (num & 1) {\\n                auto it = lower_bound(bitArray[pos].begin(),bitArray[pos].end(),idx);\\n                int curPos = *it ;\\n                result = max(result,curPos);\\n            }\\n            num = num >> 1;\\n            pos++;\\n        }\\n        return result;\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector rightOrArray(n,0);\\n        \\n        //pre compute all the rightmost array\\n        // as each number can know what max it can get\\n        rightOrArray[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) {\\n            rightOrArray[i] = (rightOrArray[i+1] | nums[i]);\\n        }\\n        \\n        \\n        int power = log2(1e9) + 1;\\n        vector<vector<int>> bitArray(power);\\n        for (int i = 0; i < n; i++) {\\n            setPosition(nums[i],bitArray,i);\\n        }\\n        \\n        // default value is 1 as it is the minimumm subset\\n        vector<int> result(n,1);\\n        for (int i = 0; i < n; i++) {\\n            int maxIdx = getMaxPosition(rightOrArray[i],bitArray,i);\\n            result[i] = max(result[i],(maxIdx-i)+1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595203,
                "title": "c-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        vector<int> bits(32, -1);\\n        vector<vector<bool> > dp(n+1, vector<bool>(30, false));\\n        for(int i = n-1; i >= 0; i--) {\\n            for(int j = 0; j < 30; j++) {\\n                dp[i][j] = dp[i+1][j];\\n                if(((1<<j)&nums[i]) != 0) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        for(int i = n-1; i >= 0; i--) {\\n            int maxidx = i;\\n            for(int j = 0; j < 30; j++) {\\n                if((nums[i]&(1<<j))) {\\n                    bits[j] = i;\\n                }\\n            }\\n            for(int j = 0; j < 30; j++) {\\n                if(dp[i][j]) {\\n                    maxidx = max(maxidx, bits[j]);\\n                }\\n            }\\n            res.push_back(maxidx-i+1);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        vector<int> bits(32, -1);\\n        vector<vector<bool> > dp(n+1, vector<bool>(30, false));\\n        for(int i = n-1; i >= 0; i--) {\\n            for(int j = 0; j < 30; j++) {\\n                dp[i][j] = dp[i+1][j];\\n                if(((1<<j)&nums[i]) != 0) {\\n                    dp[i][j] = true;\\n                }\\n            }\\n        }\\n        for(int i = n-1; i >= 0; i--) {\\n            int maxidx = i;\\n            for(int j = 0; j < 30; j++) {\\n                if((nums[i]&(1<<j))) {\\n                    bits[j] = i;\\n                }\\n            }\\n            for(int j = 0; j < 30; j++) {\\n                if(dp[i][j]) {\\n                    maxidx = max(maxidx, bits[j]);\\n                }\\n            }\\n            res.push_back(maxidx-i+1);\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594888,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallestSubarrays = function (nums) {\\n  const n = nums.length;\\n  const ans = new Array(n).fill(1);\\n  const last = new Array(30).fill(0);\\n\\n  for (let start = n - 1; start >= 0; start--) {\\n    for (let shift = 0; shift < 30; shift++) {\\n      if ((nums[start] & (1 << shift)) !== 0) {\\n        // update current one bit with latest index\\n        last[shift] = start;\\n      }\\n\\n      ans[start] = Math.max(ans[start], last[shift] - start + 1);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallestSubarrays = function (nums) {\\n  const n = nums.length;\\n  const ans = new Array(n).fill(1);\\n  const last = new Array(30).fill(0);\\n\\n  for (let start = n - 1; start >= 0; start--) {\\n    for (let shift = 0; shift < 30; shift++) {\\n      if ((nums[start] & (1 << shift)) !== 0) {\\n        // update current one bit with latest index\\n        last[shift] = start;\\n      }\\n\\n      ans[start] = Math.max(ans[start], last[shift] - start + 1);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594693,
                "title": "easy-understanding-100",
                "content": "```\\nclass Solution {\\n    void set_map(unordered_map<int,int> &mp,int n,int ind)\\n    {\\n        int i=0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                mp[i] = ind;\\n            }\\n            i++;\\n            n = n>>1;\\n        }\\n    }\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int num = nums[i];\\n            set_map(mp,num,i);\\n            int mx = i;\\n            for(int j=31;j>=0;j--)\\n            {\\n                if(mp.find(j) != mp.end())\\n                {\\n                    mx = max(mx,mp[j]);\\n                }\\n            } \\n            ans[i] = mx - i + 1;\\n            \\n        }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void set_map(unordered_map<int,int> &mp,int n,int ind)\\n    {\\n        int i=0;\\n        while(n)\\n        {\\n            if(n&1)\\n            {\\n                mp[i] = ind;\\n            }\\n            i++;\\n            n = n>>1;\\n        }\\n    }\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int num = nums[i];\\n            set_map(mp,num,i);\\n            int mx = i;\\n            for(int j=31;j>=0;j--)\\n            {\\n                if(mp.find(j) != mp.end())\\n                {\\n                    mx = max(mx,mp[j]);\\n                }\\n            } \\n            ans[i] = mx - i + 1;\\n            \\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594668,
                "title": "python3-queues-w-appearances-of-each-bit-o-n",
                "content": "```python\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        bits = defaultdict(deque)\\n        for j, x in enumerate(nums):\\n            i = 0\\n            while x:\\n                if x % 2:\\n                    bits[i].append(j)\\n                x //= 2\\n                i += 1\\n                    \\n        ans = []\\n        for i in range(len(nums)):\\n            m = i\\n            clear = []\\n            for bp, bl in bits.items():\\n                if bl[0] < i:\\n                    bl.popleft()\\n                if bl:\\n                    m = max(m, bl[0])\\n                else:\\n                    clear.append(bp)\\n            for bp in clear:\\n                del bits[bp]\\n            ans.append(m-i+1)\\n            \\n        return ans\\n ```\\n\\nWith bin instead of math (seems a bit faster):\\n```python\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        bits = defaultdict(deque)\\n        for j, x in enumerate(nums):\\n            for i, b in enumerate(bin(x)[2:][::-1]):\\n                if b == \"1\":\\n                    bits[i].append(j)\\n                    \\n        ans = []\\n        for i in range(len(nums)):\\n            m = i\\n            clear = []\\n            for bp, bl in bits.items():\\n                if bl[0] < i:\\n                    bl.popleft()\\n                if bl:\\n                    m = max(m, bl[0])\\n                else:\\n                    clear.append(bp)\\n            for bp in clear:\\n                del bits[bp]\\n            ans.append(m-i+1)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        bits = defaultdict(deque)\\n        for j, x in enumerate(nums):\\n            i = 0\\n            while x:\\n                if x % 2:\\n                    bits[i].append(j)\\n                x //= 2\\n                i += 1\\n                    \\n        ans = []\\n        for i in range(len(nums)):\\n            m = i\\n            clear = []\\n            for bp, bl in bits.items():\\n                if bl[0] < i:\\n                    bl.popleft()\\n                if bl:\\n                    m = max(m, bl[0])\\n                else:\\n                    clear.append(bp)\\n            for bp in clear:\\n                del bits[bp]\\n            ans.append(m-i+1)\\n            \\n        return ans\\n ```\n```python\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        bits = defaultdict(deque)\\n        for j, x in enumerate(nums):\\n            for i, b in enumerate(bin(x)[2:][::-1]):\\n                if b == \"1\":\\n                    bits[i].append(j)\\n                    \\n        ans = []\\n        for i in range(len(nums)):\\n            m = i\\n            clear = []\\n            for bp, bl in bits.items():\\n                if bl[0] < i:\\n                    bl.popleft()\\n                if bl:\\n                    m = max(m, bl[0])\\n                else:\\n                    clear.append(bp)\\n            for bp in clear:\\n                del bits[bp]\\n            ans.append(m-i+1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594492,
                "title": "c-sliding-window",
                "content": "The idea is to iterate backwards and include the leftmost element as the start of the subarray. We keep removing elements from the right end of the subarray if removing that particular element does not make the count of set bits at that position to 0. We use a sliding window approach backwards to implement this linearly.\\n```\\nclass Solution {\\npublic:\\n    void set(vector<int> &bits, int n){\\n        for(int i=0; i<32; i++){\\n            int val=(n>>i)&1;\\n            bits[i]+=val;\\n        }\\n    }\\n    \\n    void unset(vector<int> &bits, int n){\\n        for(int i=0; i<32; i++){\\n            int val=(n>>i)&1;\\n            bits[i]-=val;\\n        }\\n    }\\n    \\n    bool safe(vector<int> &bits, int n){\\n        for(int i=0; i<32; i++){\\n            if(pow(2,i)>n){\\n                break;\\n            }\\n            int val=(n>>i)&1;\\n            if(bits[i]!=0 && bits[i]-val<=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n), bits(32,0);\\n        for(int left=n-1, right=n-1; left>=0; left--){\\n            set(bits,nums[left]);\\n            while(left<right && safe(bits,nums[right])){\\n                unset(bits,nums[right]);\\n                right--;\\n            }\\n            int len=right-left+1;\\n            ans[left]=len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void set(vector<int> &bits, int n){\\n        for(int i=0; i<32; i++){\\n            int val=(n>>i)&1;\\n            bits[i]+=val;\\n        }\\n    }\\n    \\n    void unset(vector<int> &bits, int n){\\n        for(int i=0; i<32; i++){\\n            int val=(n>>i)&1;\\n            bits[i]-=val;\\n        }\\n    }\\n    \\n    bool safe(vector<int> &bits, int n){\\n        for(int i=0; i<32; i++){\\n            if(pow(2,i)>n){\\n                break;\\n            }\\n            int val=(n>>i)&1;\\n            if(bits[i]!=0 && bits[i]-val<=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n), bits(32,0);\\n        for(int left=n-1, right=n-1; left>=0; left--){\\n            set(bits,nums[left]);\\n            while(left<right && safe(bits,nums[right])){\\n                unset(bits,nums[right]);\\n                right--;\\n            }\\n            int len=right-left+1;\\n            ans[left]=len;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594039,
                "title": "faster-than-100-c-bitmasking",
                "content": "We just build the ans from right to left while keeping track of the furthest index required\\n```\\nclass Solution {\\npublic:\\n    const int N = 32;\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> v(N);\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            for(int k = 0;k<N;k++)\\n            {\\n                if(nums[i]&(1<<k))\\n                    v[k] = i;\\n            }\\n            int ma = *max_element(v.begin(),v.end());\\n            ma = max(ma,i);\\n            ans[i] = ma-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int N = 32;\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> v(N);\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            for(int k = 0;k<N;k++)\\n            {\\n                if(nums[i]&(1<<k))\\n                    v[k] = i;\\n            }\\n            int ma = *max_element(v.begin(),v.end());\\n            ma = max(ma,i);\\n            ans[i] = ma-i+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593717,
                "title": "simple-o-n-approach-using-position-of-bits",
                "content": "For any subarray that starts at index i the maximum Bitwise-OR that can be obtained is given as bitwise-OR of all elements a[i, i+1, i+2, ...., n-1].\\n\\nIn the array pos, we store the smallest index of the array greater than current index s.t the current bit is set. i.e **pos[j] stores the smallest index >= i s.t jth bit is 1 at pos[j] if no such element has jth bit as set then pos[j]=n+2**\\n\\nSo for every index we go through all the bits which have pos[j] < n as these are the bits which are actually set in some of the elements of array. Out of all the valid bits we choose the max position and the ans for the subarray starting at ith index is given as **mx-i+1**.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& a) {\\n        int n=a.size();\\n        vector<int> p2(31,1),pos(31,n+2),ans(n);\\n        for(int j=1;j<31;j++)\\n            p2[j]=p2[j-1]<<1;\\n        for(int i=n-1;i>=0;i--){\\n            int mx=i;\\n            for(int j=0;j<31;j++){\\n                if(a[i]&p2[j])\\n                    pos[j]=i;\\n                if(pos[j]<n)\\n                    mx=max(mx,pos[j]);\\n            }\\n            ans[i]=1+mx-i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& a) {\\n        int n=a.size();\\n        vector<int> p2(31,1),pos(31,n+2),ans(n);\\n        for(int j=1;j<31;j++)\\n            p2[j]=p2[j-1]<<1;\\n        for(int i=n-1;i>=0;i--){\\n            int mx=i;\\n            for(int j=0;j<31;j++){\\n                if(a[i]&p2[j])\\n                    pos[j]=i;\\n                if(pos[j]<n)\\n                    mx=max(mx,pos[j]);\\n            }\\n            ans[i]=1+mx-i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593392,
                "title": "sliding-window-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void add(vector<int>&bits,int x)\\n    {\\n        for(int i=0;i<32;i++)\\n        {\\n            if((x>>i)&1)\\n                bits[i]++;\\n        }\\n    }\\n    bool more_on_right(vector<int>&bits,int right)\\n    {\\n        for(int i=0;i<32;i++)\\n        {\\n            if(((right>>i)&1)&&!bits[i])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    void remove(vector<int>&bits,int x)\\n    {\\n        for(int i=0;i<32;i++)\\n        {\\n            if((x>>i)&1)\\n                bits[i]--;\\n        }\\n    }    \\n    vector<int> smallestSubarrays(vector<int>&a) {\\n        vector<int>limits(a.size(),0),ans;\\n        int OR=0;\\n        vector<int>bits(32,0);\\n        for(int i=(int)a.size()-1;i>=0;i--)\\n        {\\n            OR|=a[i];\\n            limits[i]=OR;\\n        }\\n        int r=0;\\n        for(int l=0;l<a.size();l++)\\n        {\\n            \\n            while(r<a.size()&&more_on_right(bits,limits[r]))\\n                add(bits,a[r++]);\\n            remove(bits,a[l]);\\n            ans.push_back(max(r-l,1));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void add(vector<int>&bits,int x)\\n    {\\n        for(int i=0;i<32;i++)\\n        {\\n            if((x>>i)&1)\\n                bits[i]++;\\n        }\\n    }\\n    bool more_on_right(vector<int>&bits,int right)\\n    {\\n        for(int i=0;i<32;i++)\\n        {\\n            if(((right>>i)&1)&&!bits[i])\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    void remove(vector<int>&bits,int x)\\n    {\\n        for(int i=0;i<32;i++)\\n        {\\n            if((x>>i)&1)\\n                bits[i]--;\\n        }\\n    }    \\n    vector<int> smallestSubarrays(vector<int>&a) {\\n        vector<int>limits(a.size(),0),ans;\\n        int OR=0;\\n        vector<int>bits(32,0);\\n        for(int i=(int)a.size()-1;i>=0;i--)\\n        {\\n            OR|=a[i];\\n            limits[i]=OR;\\n        }\\n        int r=0;\\n        for(int l=0;l<a.size();l++)\\n        {\\n            \\n            while(r<a.size()&&more_on_right(bits,limits[r]))\\n                add(bits,a[r++]);\\n            remove(bits,a[l]);\\n            ans.push_back(max(r-l,1));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592576,
                "title": "go-100-faster",
                "content": "```\\nfunc n2a(n int) [33]int {\\n\\ti := 0\\n\\ta := [33]int{}\\n\\tfor n > 0 {\\n\\t\\tif n&1 == 1 {\\n\\t\\t\\ta[i] = 1\\n\\t\\t}\\n\\t\\ti++\\n\\t\\tn = n >> 1\\n\\t}\\n\\treturn a\\n}\\n\\nfunc sum(a1, a2 [33]int) [33]int {\\n\\tr := [33]int{}\\n\\tfor i := range a1 {\\n\\t\\tr[i] = a1[i] + a2[i]\\n\\t}\\n\\treturn r\\n}\\n\\nfunc min(a1, a2 [33]int) ([33]int, bool) {\\n\\tr := [33]int{}\\n\\tf := false\\n\\tfor i := range a1 {\\n\\t\\tr[i] = a1[i] - a2[i]\\n\\t\\tif a1[i] > 0 && r[i] == 0 {\\n\\t\\t\\tf = true\\n\\t\\t}\\n\\n\\t}\\n\\treturn r, f\\n}\\n\\nfunc smallestSubarrays(nums []int) []int {\\n\\tr := make([]int, len(nums))\\n\\tr[len(r)-1] = 1\\n\\tri := len(r) - 1\\n\\tor := n2a(nums[len(r)-1])\\n\\tfor i := len(r) - 2; i >= 0; i-- {\\n\\t\\tor = sum(or, n2a(nums[i]))\\n\\t\\tfor ri > i {\\n\\t\\t\\tnor, f := min(or, n2a(nums[ri]))\\n\\t\\t\\tif !f {\\n\\t\\t\\t\\tor = nor\\n\\t\\t\\t\\tri--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n\\t\\tr[i] = (ri - i) + 1\\n\\t}\\n\\treturn r\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc n2a(n int) [33]int {\\n\\ti := 0\\n\\ta := [33]int{}\\n\\tfor n > 0 {\\n\\t\\tif n&1 == 1 {\\n\\t\\t\\ta[i] = 1\\n\\t\\t}\\n\\t\\ti++\\n\\t\\tn = n >> 1\\n\\t}\\n\\treturn a\\n}\\n\\nfunc sum(a1, a2 [33]int) [33]int {\\n\\tr := [33]int{}\\n\\tfor i := range a1 {\\n\\t\\tr[i] = a1[i] + a2[i]\\n\\t}\\n\\treturn r\\n}\\n\\nfunc min(a1, a2 [33]int) ([33]int, bool) {\\n\\tr := [33]int{}\\n\\tf := false\\n\\tfor i := range a1 {\\n\\t\\tr[i] = a1[i] - a2[i]\\n\\t\\tif a1[i] > 0 && r[i] == 0 {\\n\\t\\t\\tf = true\\n\\t\\t}\\n\\n\\t}\\n\\treturn r, f\\n}\\n\\nfunc smallestSubarrays(nums []int) []int {\\n\\tr := make([]int, len(nums))\\n\\tr[len(r)-1] = 1\\n\\tri := len(r) - 1\\n\\tor := n2a(nums[len(r)-1])\\n\\tfor i := len(r) - 2; i >= 0; i-- {\\n\\t\\tor = sum(or, n2a(nums[i]))\\n\\t\\tfor ri > i {\\n\\t\\t\\tnor, f := min(or, n2a(nums[ri]))\\n\\t\\t\\tif !f {\\n\\t\\t\\t\\tor = nor\\n\\t\\t\\t\\tri--\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n    \\n\\t\\tr[i] = (ri - i) + 1\\n\\t}\\n\\treturn r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592557,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> A(nums.size(),0);\\n      int answer = 0;\\n      \\n      for (int i = nums.size()-1; i >= 0; i--)\\n      {\\n        answer  = (answer | nums[i]);\\n        A[i] = answer;\\n        \\n      }\\n      \\n      vector<int> B(nums.size(),0);\\n      vector<int> Bit(32,0);\\n      \\n      int i = 0;\\n      int temp = 0;\\n      int j = 0;\\n      while (i < nums.size())\\n      {\\n        \\n        while (temp != A[i] && j < nums.size())\\n        {\\n          int tempo = nums[j];\\n          temp = (temp | tempo);\\n          int bi = 31;\\n          while (bi >= 0 && tempo)\\n          {\\n            if (tempo % 2)\\n              Bit[bi]++;\\n            bi--;\\n            tempo = (tempo >> 1);\\n          }\\n          j++;\\n        }\\n        \\n        while (j <= i)\\n        {\\n          int tempo = nums[j];\\n          temp = (temp | tempo);\\n          int bi = 31;\\n          while (bi >= 0 && tempo)\\n          {\\n            if (tempo % 2)\\n              Bit[bi]++;\\n            bi--;\\n            tempo = (tempo >> 1);\\n          }\\n          j++;\\n        }\\n        B[i] = ((j-i)) ? (j-i) : 1;\\n        int tempo = nums[i];\\n        int bi = 31;\\n        while (bi >= 0 && tempo)\\n        {\\n          if (tempo % 2)\\n          {\\n            Bit[bi]--;\\n            \\n            if (!Bit[bi])\\n            {\\n              int k = 32- bi;\\n              temp = (temp & ~(1 << (k - 1)));\\n            }\\n          }\\n            bi--;\\n            tempo = (tempo >> 1);\\n        }\\n         // cout << \"Here\" << endl;\\n        i++;\\n      }\\n      return B;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> A(nums.size(),0);\\n      int answer = 0;\\n      \\n      for (int i = nums.size()-1; i >= 0; i--)\\n      {\\n        answer  = (answer | nums[i]);\\n        A[i] = answer;\\n        \\n      }\\n      \\n      vector<int> B(nums.size(),0);\\n      vector<int> Bit(32,0);\\n      \\n      int i = 0;\\n      int temp = 0;\\n      int j = 0;\\n      while (i < nums.size())\\n      {\\n        \\n        while (temp != A[i] && j < nums.size())\\n        {\\n          int tempo = nums[j];\\n          temp = (temp | tempo);\\n          int bi = 31;\\n          while (bi >= 0 && tempo)\\n          {\\n            if (tempo % 2)\\n              Bit[bi]++;\\n            bi--;\\n            tempo = (tempo >> 1);\\n          }\\n          j++;\\n        }\\n        \\n        while (j <= i)\\n        {\\n          int tempo = nums[j];\\n          temp = (temp | tempo);\\n          int bi = 31;\\n          while (bi >= 0 && tempo)\\n          {\\n            if (tempo % 2)\\n              Bit[bi]++;\\n            bi--;\\n            tempo = (tempo >> 1);\\n          }\\n          j++;\\n        }\\n        B[i] = ((j-i)) ? (j-i) : 1;\\n        int tempo = nums[i];\\n        int bi = 31;\\n        while (bi >= 0 && tempo)\\n        {\\n          if (tempo % 2)\\n          {\\n            Bit[bi]--;\\n            \\n            if (!Bit[bi])\\n            {\\n              int k = 32- bi;\\n              temp = (temp & ~(1 << (k - 1)));\\n            }\\n          }\\n            bi--;\\n            tempo = (tempo >> 1);\\n        }\\n         // cout << \"Here\" << endl;\\n        i++;\\n      }\\n      return B;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2592430,
                "title": "unique-solution-constant-space-o-n-time-complexity-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n    int ans=1;\\n    vector<int> result(nums.size(),1);\\n    unordered_map<int,int> mp; // key is bit, value is position\\n    for (int i=0;i<32;i++)\\n    {\\n        int currentbit=(nums.back()&(1<<i));\\n        if (currentbit>0)\\n        {\\n            mp[i]=nums.size()-1;\\n        }\\n    }\\n        \\n        for (int i=nums.size()-2;i>=0;i--)\\n        {\\n            int maxiindex=i;\\n            for (int j=0;j<32;j++)\\n            {\\n                if ((nums[i]&(1<<j))>0)\\n                {\\n                    mp[j]=i;\\n                }\\n                else\\n                {\\n                   if (mp.find(j)!=mp.end())\\n                   {\\n                       maxiindex=max(maxiindex,mp[j]);\\n                   }       \\n                }\\n            }\\n            result[i]=(maxiindex-i+1);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n    int ans=1;\\n    vector<int> result(nums.size(),1);\\n    unordered_map<int,int> mp; // key is bit, value is position\\n    for (int i=0;i<32;i++)\\n    {\\n        int currentbit=(nums.back()&(1<<i));\\n        if (currentbit>0)\\n        {\\n            mp[i]=nums.size()-1;\\n        }\\n    }\\n        \\n        for (int i=nums.size()-2;i>=0;i--)\\n        {\\n            int maxiindex=i;\\n            for (int j=0;j<32;j++)\\n            {\\n                if ((nums[i]&(1<<j))>0)\\n                {\\n                    mp[j]=i;\\n                }\\n                else\\n                {\\n                   if (mp.find(j)!=mp.end())\\n                   {\\n                       maxiindex=max(maxiindex,mp[j]);\\n                   }       \\n                }\\n            }\\n            result[i]=(maxiindex-i+1);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591897,
                "title": "python-modified-sliding-window-time-space-o-n",
                "content": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        \\n        # Step 1: find local max for each index\\n        localMax = [0] * N\\n        total = 0\\n        for i in reversed(range(N)):\\n            total |= nums[i]\\n            localMax[i] = total\\n        \\n        # Step 2: perform sliding window for each index until it reaches local max\\n        res = [0] * N\\n        currBin = {}\\n        j = 0\\n        for i in range(N):\\n            currInt = self.processNum(currBin, nums[i], 1)\\n            while j <= i and currInt == localMax[j]:\\n                res[j] = i-j+1\\n                currInt = self.processNum(currBin, nums[j], -1)\\n                j += 1\\n        \\n        return res\\n   \\n    def processNum(self, currBin, num, sign):\\n        i = 31\\n        while num:\\n            val = num & 1\\n            if val == 1:\\n                currBin[i] = currBin.get(i, 0) + sign\\n            if i in currBin and not currBin[i]:\\n                del currBin[i]\\n            num >>= 1\\n            i -= 1\\n        return self.convertToInt(currBin)\\n    \\n    def convertToInt(self, currBin):\\n        strNum = [\"0\"] * 32\\n        for k in currBin.keys():\\n            strNum[k] = \"1\"\\n        return int(\"\".join(strNum), 2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        \\n        # Step 1: find local max for each index\\n        localMax = [0] * N\\n        total = 0\\n        for i in reversed(range(N)):\\n            total |= nums[i]\\n            localMax[i] = total\\n        \\n        # Step 2: perform sliding window for each index until it reaches local max\\n        res = [0] * N\\n        currBin = {}\\n        j = 0\\n        for i in range(N):\\n            currInt = self.processNum(currBin, nums[i], 1)\\n            while j <= i and currInt == localMax[j]:\\n                res[j] = i-j+1\\n                currInt = self.processNum(currBin, nums[j], -1)\\n                j += 1\\n        \\n        return res\\n   \\n    def processNum(self, currBin, num, sign):\\n        i = 31\\n        while num:\\n            val = num & 1\\n            if val == 1:\\n                currBin[i] = currBin.get(i, 0) + sign\\n            if i in currBin and not currBin[i]:\\n                del currBin[i]\\n            num >>= 1\\n            i -= 1\\n        return self.convertToInt(currBin)\\n    \\n    def convertToInt(self, currBin):\\n        strNum = [\"0\"] * 32\\n        for k in currBin.keys():\\n            strNum[k] = \"1\"\\n        return int(\"\".join(strNum), 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591481,
                "title": "next-set-bit-position-similar-to-next-greater-element",
                "content": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[32];\\n        for(int i = 0; i < 31; ++i)\\n            arr[i] = -1;\\n        \\n        int[] ans = new int[n];\\n        \\n        for(int i = n - 1; i >= 0; --i) {\\n            int max = i;\\n            for(int j = 0; j < 31; ++j) {\\n                if((nums[i] & 1<<j) > 0) {\\n                    arr[j] = i;\\n                }else {\\n                    arr[j] = arr[j];\\n                }\\n                max = Math.max(max, arr[j]);\\n            }\\n            ans[i] = max - i + 1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[32];\\n        for(int i = 0; i < 31; ++i)\\n            arr[i] = -1;\\n        \\n        int[] ans = new int[n];\\n        \\n        for(int i = n - 1; i >= 0; --i) {\\n            int max = i;\\n            for(int j = 0; j < 31; ++j) {\\n                if((nums[i] & 1<<j) > 0) {\\n                    arr[j] = i;\\n                }else {\\n                    arr[j] = arr[j];\\n                }\\n                max = Math.max(max, arr[j]);\\n            }\\n            ans[i] = max - i + 1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591464,
                "title": "simple-c-two-solutions",
                "content": "**Segment TreeSolution**\\n```\\nclass segmentTree{\\n  private:\\n    int *arr;\\n    int n;\\n  public:\\n    segmentTree(vector<int>&nums){\\n        n = nums.size();\\n        arr= new int[4*n];\\n        build(1,0,n-1,nums);\\n    }\\n    int build(int pos, int tl,int tr,vector<int>&nums){\\n        if(tl>tr)\\n            return 0;\\n        if(tl==tr)\\n            return arr[pos]=nums[tl];\\n        int mid = tl+(tr-tl)/2;\\n        return arr[pos] = (build(2*pos,tl,mid,nums)|build(2*pos+1,mid+1,tr,nums));\\n    }\\n    int query(int pos, int tl , int tr, int l,int r){\\n        // case 1, no overlap\\n        if(tl>r or tr<l)\\n            return 0;\\n        // case 2 full overlap\\n        if(l<=tl and r>=tr)\\n            return arr[pos];\\n        int mid = tl+(tr-tl)/2;\\n        return query(2*pos,tl,mid,l,r)| query(2*pos+1,mid+1,tr,l,r);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        segmentTree seg(nums);\\n        vector<int>ans(n,1);\\n        int j=0;\\n        \\n        // cout<<seg.query(1,0,n-1,0,0)<<\"  and  \"<<j<<endl;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int maximum = seg.query(1,0,n-1,i,n-1);\\n            if(maximum==0)\\n            {\\n                ans[i]=1;\\n                continue;\\n            }\\n            // cout<<i<<\" \"<<maximum<<endl;\\n            // cout<<seg.query(1,0,n-1,i,j)<<\"  and  \"<<j<<endl;\\n            while(j<n and seg.query(1,0,n-1,i,j)<maximum){\\n                // cout<<seg.query(1,0,n-1,i,j)<<\"  and  \"<<j<<endl;\\n                j++;\\n            }\\n            // cout<<j<<endl;\\n            ans[i]=(j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTC N*log(N)\\n\\n**Tricky sliding window solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>bits(31,0);\\n        vector<int>ans(n,1);\\n        for(int j=n-1;j>=0;j--){\\n            for(int i=0;i<31;i++){\\n            if((1<<i)&(nums[j]))\\n                bits[i]=j;\\n            ans[j] = max(ans[j],bits[i]-j+1);\\n                \\n        }\\n        }\\n        return ans;\\n    } \\n};\\n```\\n\\nTC 30*n\\n",
                "solutionTags": [],
                "code": "```\\nclass segmentTree{\\n  private:\\n    int *arr;\\n    int n;\\n  public:\\n    segmentTree(vector<int>&nums){\\n        n = nums.size();\\n        arr= new int[4*n];\\n        build(1,0,n-1,nums);\\n    }\\n    int build(int pos, int tl,int tr,vector<int>&nums){\\n        if(tl>tr)\\n            return 0;\\n        if(tl==tr)\\n            return arr[pos]=nums[tl];\\n        int mid = tl+(tr-tl)/2;\\n        return arr[pos] = (build(2*pos,tl,mid,nums)|build(2*pos+1,mid+1,tr,nums));\\n    }\\n    int query(int pos, int tl , int tr, int l,int r){\\n        // case 1, no overlap\\n        if(tl>r or tr<l)\\n            return 0;\\n        // case 2 full overlap\\n        if(l<=tl and r>=tr)\\n            return arr[pos];\\n        int mid = tl+(tr-tl)/2;\\n        return query(2*pos,tl,mid,l,r)| query(2*pos+1,mid+1,tr,l,r);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        segmentTree seg(nums);\\n        vector<int>ans(n,1);\\n        int j=0;\\n        \\n        // cout<<seg.query(1,0,n-1,0,0)<<\"  and  \"<<j<<endl;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int maximum = seg.query(1,0,n-1,i,n-1);\\n            if(maximum==0)\\n            {\\n                ans[i]=1;\\n                continue;\\n            }\\n            // cout<<i<<\" \"<<maximum<<endl;\\n            // cout<<seg.query(1,0,n-1,i,j)<<\"  and  \"<<j<<endl;\\n            while(j<n and seg.query(1,0,n-1,i,j)<maximum){\\n                // cout<<seg.query(1,0,n-1,i,j)<<\"  and  \"<<j<<endl;\\n                j++;\\n            }\\n            // cout<<j<<endl;\\n            ans[i]=(j-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>bits(31,0);\\n        vector<int>ans(n,1);\\n        for(int j=n-1;j>=0;j--){\\n            for(int i=0;i<31;i++){\\n            if((1<<i)&(nums[j]))\\n                bits[i]=j;\\n            ans[j] = max(ans[j],bits[i]-j+1);\\n                \\n        }\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2591198,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> bits(33, 0);\\n        \\n        auto setBit = [&](int num) {\\n            int ind = 0;\\n            while(num) {\\n                bits[ind++] += num % 2;\\n                num /= 2;\\n            }\\n        };\\n        \\n        auto check = [&]() {\\n            long long num = 0, base = 1;\\n            for(int i = 0; i <= 32; i++) {\\n                if(bits[i] > 0) num += base;\\n                base *= 2;\\n            }\\n            return (int)num;\\n        };\\n        \\n        auto remove = [&](int num) {\\n            int ind = 0;\\n            while(num) {\\n                bits[ind++] -= num % 2;\\n                num /= 2;\\n            }\\n        };\\n        \\n        int n = nums.size();\\n        vector<int> postReq(n, 0);\\n        vector<int> ans;\\n        \\n        for(int i = n - 1; i >= 0; i--) postReq[i] = (i + 1 == n ? 0 : postReq[i + 1]) | nums[i];\\n        \\n        int ind = 0;\\n        for(int i = 0; i < n; i++) {\\n            while(ind <= i) setBit(nums[ind++]);\\n            \\n            while(check() < postReq[i]) setBit(nums[ind++]);\\n            ans.push_back(ind - i);\\n            remove(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> bits(33, 0);\\n        \\n        auto setBit = [&](int num) {\\n            int ind = 0;\\n            while(num) {\\n                bits[ind++] += num % 2;\\n                num /= 2;\\n            }\\n        };\\n        \\n        auto check = [&]() {\\n            long long num = 0, base = 1;\\n            for(int i = 0; i <= 32; i++) {\\n                if(bits[i] > 0) num += base;\\n                base *= 2;\\n            }\\n            return (int)num;\\n        };\\n        \\n        auto remove = [&](int num) {\\n            int ind = 0;\\n            while(num) {\\n                bits[ind++] -= num % 2;\\n                num /= 2;\\n            }\\n        };\\n        \\n        int n = nums.size();\\n        vector<int> postReq(n, 0);\\n        vector<int> ans;\\n        \\n        for(int i = n - 1; i >= 0; i--) postReq[i] = (i + 1 == n ? 0 : postReq[i + 1]) | nums[i];\\n        \\n        int ind = 0;\\n        for(int i = 0; i < n; i++) {\\n            while(ind <= i) setBit(nums[ind++]);\\n            \\n            while(check() < postReq[i]) setBit(nums[ind++]);\\n            ans.push_back(ind - i);\\n            remove(nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590986,
                "title": "simple-solution-c-15-lines-100-time-and-100-space-efficient",
                "content": "**Logic:**\\n* Please refer to the question hints.\\n* I have tried to make it more efficient by taking into account the max number of bits we actually have to iterate to instead of all 32.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t//Finding maximum bits to check for. Instead of this you can just use all 32\\n        int maxor = 0;\\n        for(auto x : nums)\\n            maxor |= x;\\n        int d = (maxor == 0) ? 1 : int(log2(maxor)) + 1;\\n\\t\\t\\n        vector<int> b(d,-1);\\n        vector<int> ans(n);\\n        int maxval;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            maxval = -1;\\n            for(int j = 0; j < d; j++){\\n                if(nums[i]&(1<<j))\\n                    b[j] = i;   \\n                maxval = max(maxval,b[j]);\\n            }\\n            maxval = maxval - i + 1;\\n            ans[i] = (maxval <= 0) ? 1 : maxval;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n\\t\\t//Finding maximum bits to check for. Instead of this you can just use all 32\\n        int maxor = 0;\\n        for(auto x : nums)\\n            maxor |= x;\\n        int d = (maxor == 0) ? 1 : int(log2(maxor)) + 1;\\n\\t\\t\\n        vector<int> b(d,-1);\\n        vector<int> ans(n);\\n        int maxval;\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            maxval = -1;\\n            for(int j = 0; j < d; j++){\\n                if(nums[i]&(1<<j))\\n                    b[j] = i;   \\n                maxval = max(maxval,b[j]);\\n            }\\n            maxval = maxval - i + 1;\\n            ans[i] = (maxval <= 0) ? 1 : maxval;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590872,
                "title": "super-short-solution",
                "content": "```\\n    vector<int> smallestSubarrays(vector<int>& a) {\\n        vector<int> res(a.size()), bit(32, a.size()-1);\\n        for(int i = a.size()-1; i >= 0; i--) {\\n            for(int j = 0; j < 32; j++) if((a[i] & (1 << j)) || !(a[bit[j]]& (1 << j))) bit[j] = i;\\n            res[i] = *max_element(begin(bit), end(bit)) - i +1;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> smallestSubarrays(vector<int>& a) {\\n        vector<int> res(a.size()), bit(32, a.size()-1);\\n        for(int i = a.size()-1; i >= 0; i--) {\\n            for(int j = 0; j < 32; j++) if((a[i] & (1 << j)) || !(a[bit[j]]& (1 << j))) bit[j] = i;\\n            res[i] = *max_element(begin(bit), end(bit)) - i +1;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2590755,
                "title": "two-pointer-segment-tree-100-time-100-space-commented-c",
                "content": "Segment tree\\n```\\n\\nclass Solution {\\npublic:\\n    // solution using segment tree\\n    vector<int> seg;\\n    void build(int n){\\n        seg.resize(4*n,0);\\n    }\\n    void update(int index,int l,int r,int i,int val){\\n        if(l==r){\\n            seg[index]=val;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        if(i<=mid){\\n            update(2*index+1,l,mid,i,val);    \\n        }\\n        else{\\n            update(2*index+2,mid+1,r,i,val);\\n        }\\n        seg[index]=(seg[2*index+1]|seg[2*index+2]);\\n        return ;\\n    }\\n    int query(int index,int l,int r,int left,int right){\\n        if(left<=l && r<=right){\\n            return seg[index];\\n        }\\n        if(r<left || right<l){\\n            return 0;\\n        }\\n        int mid=(l+r)/2;\\n        \\n        int or_l=query(2*index+1,l,mid,left,right);\\n        int or_r=query(2*index+2,mid+1,r,left,right);\\n        return (or_l|or_r);\\n    }\\n    vector<int> smallestSubarrays(vector<int>& A) {\\n        int n=A.size();\\n        build(n);\\n        for(int i=0;i<n;i++){\\n            update(0,0,n-1,i,A[i]);\\n        }\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;i++){\\n            int max_or=query(0,0,n-1,i,n-1);\\n            // cout<<max_or<<\"\\\\n\";\\n            int s=i,e=n-1;\\n            while(s<=e){\\n                int m=(s+e)/2;\\n                if(query(0,0,n-1,i,m)==max_or){\\n                    ans[i]=m-i+1;\\n                    e=m-1;\\n                }\\n                else s=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/b947a71b-0d07-469b-853a-37d8043e60e0_1663475986.633856.png)\\n\\nTwo Pointer\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& A) {\\n        int n=A.size();\\n        int max_or=0;\\n        vector<int> bits(30,0);\\n        for(int i=0;i<n;i++){\\n            // store the count of every bits\\n            for(int j=0;j<30;j++){\\n                if(A[i]&(1<<j)){\\n                    bits[j]++;\\n                }\\n            }\\n            max_or=(max_or|A[i]);\\n        }\\n        vector<int> ans(n,0);\\n        int j=0,i=0;\\n        pair<int,int> cur_or={0,0};\\n        vector<int> curbits(30,0);\\n        while(j<n){\\n            // check it current or is equal to current max_or and length should be equal to zero\\n            if(max_or==cur_or.first &&cur_or.second!=0){\\n               \\n                ans[j]=cur_or.second; // assign length to j index\\n                \\n                // remove bits of A[j] value from cur_or and max_or\\n                for(int k=0;k<30;k++){\\n                    if(A[j]&(1<<k)){\\n                        bits[k]--;\\n                        if(bits[k]==0){\\n                            max_or=(max_or^(1<<k));\\n                        }\\n                        curbits[k]--;\\n                        if(curbits[k]==0){\\n                            cur_or.first=((cur_or.first)^(1<<k));\\n                        }\\n                    }\\n                }\\n                j++;\\n                // assign length of cur_or\\n                cur_or.second=i-j;\\n            }  \\n            else {\\n                // add bits to current OR bits array when we add A[i];\\n                for(int k=0;k<30;k++){\\n                    if(A[i]&(1<<k)){\\n                        curbits[k]++;\\n                    }\\n                }\\n                cur_or.first=((cur_or.first)|A[i]);\\n                // assign length of cur_or\\n                cur_or.second=i-j+1;\\n                i++;\\n            \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    // solution using segment tree\\n    vector<int> seg;\\n    void build(int n){\\n        seg.resize(4*n,0);\\n    }\\n    void update(int index,int l,int r,int i,int val){\\n        if(l==r){\\n            seg[index]=val;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        if(i<=mid){\\n            update(2*index+1,l,mid,i,val);    \\n        }\\n        else{\\n            update(2*index+2,mid+1,r,i,val);\\n        }\\n        seg[index]=(seg[2*index+1]|seg[2*index+2]);\\n        return ;\\n    }\\n    int query(int index,int l,int r,int left,int right){\\n        if(left<=l && r<=right){\\n            return seg[index];\\n        }\\n        if(r<left || right<l){\\n            return 0;\\n        }\\n        int mid=(l+r)/2;\\n        \\n        int or_l=query(2*index+1,l,mid,left,right);\\n        int or_r=query(2*index+2,mid+1,r,left,right);\\n        return (or_l|or_r);\\n    }\\n    vector<int> smallestSubarrays(vector<int>& A) {\\n        int n=A.size();\\n        build(n);\\n        for(int i=0;i<n;i++){\\n            update(0,0,n-1,i,A[i]);\\n        }\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;i++){\\n            int max_or=query(0,0,n-1,i,n-1);\\n            // cout<<max_or<<\"\\\\n\";\\n            int s=i,e=n-1;\\n            while(s<=e){\\n                int m=(s+e)/2;\\n                if(query(0,0,n-1,i,m)==max_or){\\n                    ans[i]=m-i+1;\\n                    e=m-1;\\n                }\\n                else s=m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& A) {\\n        int n=A.size();\\n        int max_or=0;\\n        vector<int> bits(30,0);\\n        for(int i=0;i<n;i++){\\n            // store the count of every bits\\n            for(int j=0;j<30;j++){\\n                if(A[i]&(1<<j)){\\n                    bits[j]++;\\n                }\\n            }\\n            max_or=(max_or|A[i]);\\n        }\\n        vector<int> ans(n,0);\\n        int j=0,i=0;\\n        pair<int,int> cur_or={0,0};\\n        vector<int> curbits(30,0);\\n        while(j<n){\\n            // check it current or is equal to current max_or and length should be equal to zero\\n            if(max_or==cur_or.first &&cur_or.second!=0){\\n               \\n                ans[j]=cur_or.second; // assign length to j index\\n                \\n                // remove bits of A[j] value from cur_or and max_or\\n                for(int k=0;k<30;k++){\\n                    if(A[j]&(1<<k)){\\n                        bits[k]--;\\n                        if(bits[k]==0){\\n                            max_or=(max_or^(1<<k));\\n                        }\\n                        curbits[k]--;\\n                        if(curbits[k]==0){\\n                            cur_or.first=((cur_or.first)^(1<<k));\\n                        }\\n                    }\\n                }\\n                j++;\\n                // assign length of cur_or\\n                cur_or.second=i-j;\\n            }  \\n            else {\\n                // add bits to current OR bits array when we add A[i];\\n                for(int k=0;k<30;k++){\\n                    if(A[i]&(1<<k)){\\n                        curbits[k]++;\\n                    }\\n                }\\n                cur_or.first=((cur_or.first)|A[i]);\\n                // assign length of cur_or\\n                cur_or.second=i-j+1;\\n                i++;\\n            \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2589991,
                "title": "simple-c-solution-runtime-150ms",
                "content": "**If it helped you, Please Upvote!**\\n\\nExecutable Code :\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> result;\\n        int a = nums.size();\\n        vector<int> nearest(32, -1);\\n        for (int b = a -1; b >= 0; b--){\\n            for (int c = 0; c < 32; c++){\\n                if (nums[b] & (1 << c))\\n                    nearest[c] = b;\\n            }\\n            int last_set = b;\\n            for (int c = 0; c < 32; c++)\\n                last_set = max(last_set, nearest[c]);\\n                result.push_back(last_set - b + 1);\\n        }\\n            reverse(result.begin(), result.end());\\n            return result;\\n    }\\n};\\n```\\n\\n**If it helped you, Please Upvote!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> result;\\n        int a = nums.size();\\n        vector<int> nearest(32, -1);\\n        for (int b = a -1; b >= 0; b--){\\n            for (int c = 0; c < 32; c++){\\n                if (nums[b] & (1 << c))\\n                    nearest[c] = b;\\n            }\\n            int last_set = b;\\n            for (int c = 0; c < 32; c++)\\n                last_set = max(last_set, nearest[c]);\\n                result.push_back(last_set - b + 1);\\n        }\\n            reverse(result.begin(), result.end());\\n            return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589728,
                "title": "two-pointers-with-bit-counting",
                "content": "```cpp\\nint n = nums.size();\\nvector<int> ret(n);\\nvector<int> bit(32);\\nint j = n - 1;\\nlong long mask = 0;\\n\\nfor (int i = n - 1; i >= 0; --i)\\n{\\n\\t// include nums[i]\\n\\tmask = 1;\\n\\tfor (int b = 0; b < 32; ++b, mask <<= 1)\\n\\t\\tif (nums[i] & mask)\\n\\t\\t\\t++ bit[b];\\n\\t\\n\\t// check if nums[j] has been covered by some elements between i and j.\\n\\tbool covered = true;\\n\\t\\n\\twhile (covered && j > i)\\n\\t{\\n\\t\\tmask = 1;\\n\\t\\tfor (int b = 0; b < 32 && covered; ++b, mask <<= 1)\\n\\t\\t{\\n\\t\\t\\t// if there is not enought b-th bit in the running sum, then\\n\\t\\t\\t// the nums[j] are not entirly covered by other elements between i and j.\\n\\t\\t\\t// since the only b-th bit must come from nums[j].\\n\\t\\t\\tif ((nums[j] & mask) != 0 && bit[b] <= 1)\\n\\t\\t\\t\\tcovered = false;\\n\\t\\t}\\n\\n\\t\\t// if yes, the nums[j] has been covered by some elements between i and j.\\n\\t\\t// then we don\\'t need nums[j], exclude it.\\n\\t\\tif (covered)\\n\\t\\t{\\n\\t\\t\\tmask = 1;\\n\\t\\t\\tfor (int b = 0; b < 32; ++b, mask <<= 1)\\n\\t\\t\\t\\tif (nums[j] & mask)\\n\\t\\t\\t\\t\\t-- bit[b];\\n\\n\\t\\t\\t-- j;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tret[i] = j - i + 1;\\n}\\n\\nreturn ret;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nint n = nums.size();\\nvector<int> ret(n);\\nvector<int> bit(32);\\nint j = n - 1;\\nlong long mask = 0;\\n\\nfor (int i = n - 1; i >= 0; --i)\\n{\\n\\t// include nums[i]\\n\\tmask = 1;\\n\\tfor (int b = 0; b < 32; ++b, mask <<= 1)\\n\\t\\tif (nums[i] & mask)\\n\\t\\t\\t++ bit[b];\\n\\t\\n\\t// check if nums[j] has been covered by some elements between i and j.\\n\\tbool covered = true;\\n\\t\\n\\twhile (covered && j > i)\\n\\t{\\n\\t\\tmask = 1;\\n\\t\\tfor (int b = 0; b < 32 && covered; ++b, mask <<= 1)\\n\\t\\t{\\n\\t\\t\\t// if there is not enought b-th bit in the running sum, then\\n\\t\\t\\t// the nums[j] are not entirly covered by other elements between i and j.\\n\\t\\t\\t// since the only b-th bit must come from nums[j].\\n\\t\\t\\tif ((nums[j] & mask) != 0 && bit[b] <= 1)\\n\\t\\t\\t\\tcovered = false;\\n\\t\\t}\\n\\n\\t\\t// if yes, the nums[j] has been covered by some elements between i and j.\\n\\t\\t// then we don\\'t need nums[j], exclude it.\\n\\t\\tif (covered)\\n\\t\\t{\\n\\t\\t\\tmask = 1;\\n\\t\\t\\tfor (int b = 0; b < 32; ++b, mask <<= 1)\\n\\t\\t\\t\\tif (nums[j] & mask)\\n\\t\\t\\t\\t\\t-- bit[b];\\n\\n\\t\\t\\t-- j;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tret[i] = j - i + 1;\\n}\\n\\nreturn ret;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589713,
                "title": "o-n-c-explanation-with-figures",
                "content": "Idea:\\n- record each occurance of each bit in `nums` into a queue, and there will be at most 32 queues\\n- the front of each queue forms a wave (see figure)\\n- let\\'s denote the minimal element of the wave to be `s`, and the maximum element to be `e` \\n- for all the element between `i` and `s`, the length of the minimum sized subarray starts at `i` equals to `e - i + 1`\\n\\n![image](https://assets.leetcode.com/users/images/e70ba464-d82f-44ab-ac18-a012cf758d3d_1663460920.2431562.png)\\n\\nAlgorithm:\\n- put the index of each occurance of each bit in `nums` into a queue `wave[bit]`\\n- start with the first element in `nums`: `i`, find the first `wave` (`front` of all the queues in `wave[bit]` if the queue is not empty)\\n- fill `answer[i .. s]` with `e - i + 1`\\n- increment `i` to `s + 1`, drop all the wave front that is smaller than `i`, and search for the next wave.\\n\\nComplexity:\\n- time: O(n), scan the input array twice, and for each time access a constant number of queues (at most 32).\\n- space: O(n), the total queue size is at most (32 * n).\\n\\nCode:\\n```c++\\nclass Solution\\n{\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums)\\n    {\\n        int                n = nums.size();\\n        vector<queue<int>> wave(32);\\n        vector<int>        res(n);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            bitset<32> x = nums[i];\\n            for (int bit = 0; bit < 32; bit++)\\n            {\\n                if (x[bit])\\n                {\\n                    wave[bit].push(i);\\n                }\\n            }\\n        }\\n\\n        int i = 0;\\n        while (i < n)\\n        {\\n            int s = n, e = -1;\\n            for (auto& q : wave)\\n            {\\n                if (q.empty())\\n                {\\n                    continue;\\n                }\\n\\n                if (q.front() < i)\\n                {\\n                    q.pop();\\n                    if (q.empty())\\n                    {\\n                        continue;\\n                    }\\n                }\\n\\n                int o = q.front();\\n                s     = min(s, o);\\n                e     = max(e, o);\\n            }\\n            if (e == -1)\\n            {\\n                break;\\n            }\\n\\n            for (int j = i; j <= s; j++)\\n            {\\n                res[j] = e - j + 1;\\n            }\\n\\n            i = s + 1;\\n        }\\n\\n        while (i < n)\\n        {\\n            res[i] = 1;\\n            i++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution\\n{\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums)\\n    {\\n        int                n = nums.size();\\n        vector<queue<int>> wave(32);\\n        vector<int>        res(n);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            bitset<32> x = nums[i];\\n            for (int bit = 0; bit < 32; bit++)\\n            {\\n                if (x[bit])\\n                {\\n                    wave[bit].push(i);\\n                }\\n            }\\n        }\\n\\n        int i = 0;\\n        while (i < n)\\n        {\\n            int s = n, e = -1;\\n            for (auto& q : wave)\\n            {\\n                if (q.empty())\\n                {\\n                    continue;\\n                }\\n\\n                if (q.front() < i)\\n                {\\n                    q.pop();\\n                    if (q.empty())\\n                    {\\n                        continue;\\n                    }\\n                }\\n\\n                int o = q.front();\\n                s     = min(s, o);\\n                e     = max(e, o);\\n            }\\n            if (e == -1)\\n            {\\n                break;\\n            }\\n\\n            for (int j = i; j <= s; j++)\\n            {\\n                res[j] = e - j + 1;\\n            }\\n\\n            i = s + 1;\\n        }\\n\\n        while (i < n)\\n        {\\n            res[i] = 1;\\n            i++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589636,
                "title": "python3-2-pointers-sliding-window",
                "content": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ret = [0] * n\\n        i, j = n - 1, n - 1\\n        bitCount = [0] * 32\\n        \\n        # add bits of k to bitCount\\n        def addCount(k):\\n            cnt = 0\\n            while k > 0:\\n                bitCount[cnt] += k & 1\\n                k >>= 1\\n                cnt += 1\\n        \\n        # check if removing bits of k from bitCount decreases the current bitwise OR of numbers between i and j\\n        def checkCount(k):\\n            cnt = 0\\n            while k > 0:\\n                if k & 1 == 1 and bitCount[cnt] == 1:\\n                    return False\\n                k >>= 1\\n                cnt += 1\\n            return True\\n        \\n        # remove bits of k from bitCount\\n        def removeCount(k):\\n            cnt = 0\\n            while k > 0:\\n                bitCount[cnt] -= (k & 1)\\n                k >>= 1\\n                cnt += 1\\n        \\n        while i > -1:\\n            addCount(nums[i])\\n            while checkCount(nums[j]) and i < j:\\n                removeCount(nums[j])\\n                j -= 1\\n            i -= 1\\n            ret[i+1] = j - i\\n        \\n        return ret\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ret = [0] * n\\n        i, j = n - 1, n - 1\\n        bitCount = [0] * 32\\n        \\n        # add bits of k to bitCount\\n        def addCount(k):\\n            cnt = 0\\n            while k > 0:\\n                bitCount[cnt] += k & 1\\n                k >>= 1\\n                cnt += 1\\n        \\n        # check if removing bits of k from bitCount decreases the current bitwise OR of numbers between i and j\\n        def checkCount(k):\\n            cnt = 0\\n            while k > 0:\\n                if k & 1 == 1 and bitCount[cnt] == 1:\\n                    return False\\n                k >>= 1\\n                cnt += 1\\n            return True\\n        \\n        # remove bits of k from bitCount\\n        def removeCount(k):\\n            cnt = 0\\n            while k > 0:\\n                bitCount[cnt] -= (k & 1)\\n                k >>= 1\\n                cnt += 1\\n        \\n        while i > -1:\\n            addCount(nums[i])\\n            while checkCount(nums[j]) and i < j:\\n                removeCount(nums[j])\\n                j -= 1\\n            i -= 1\\n            ret[i+1] = j - i\\n        \\n        return ret\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589585,
                "title": "python-follow-the-hints",
                "content": "```\\nclass Solution:\\n    def smallestSubarrays(self, A: List[int]) -> List[int]:        \\n        N = len(A)\\n        result, last = [None] * N, dict()        \\n        for i in range(N - 1, -1,  -1):               \\n            pos = i\\n            for bit in range(31):\\n                if A[i] & (1 << bit): last[bit] = i\\n                else:\\n                    if bit in last: pos = max(pos, last[bit])                \\n            result[i] = pos-i+1                  \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, A: List[int]) -> List[int]:        \\n        N = len(A)\\n        result, last = [None] * N, dict()        \\n        for i in range(N - 1, -1,  -1):               \\n            pos = i\\n            for bit in range(31):\\n                if A[i] & (1 << bit): last[bit] = i\\n                else:\\n                    if bit in last: pos = max(pos, last[bit])                \\n            result[i] = pos-i+1                  \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589434,
                "title": "c-clean-concise-efficient-o-n-time",
                "content": "Traverse from right to left and keep track of the bits set untill now along with the index where each bit was last modified.\\n\\n```\\nvector<int>ans;\\nvector<int>bitset(32);\\nint n= nums.size();\\nfor(int i=n-1;i>=0;i--)\\n{\\n\\tfor(int j=0;j<32;j++)\\n\\t{\\n\\t\\tif(1<<j & nums[i])\\n\\t\\t\\tbitset[31-j] = i;\\n\\t}\\n\\tans.push_back(max(1,*max_element(bitset.begin(),bitset.end())-i+1));\\n}\\nreverse(ans.begin(),ans.end());\\nreturn ans;\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nvector<int>ans;\\nvector<int>bitset(32);\\nint n= nums.size();\\nfor(int i=n-1;i>=0;i--)\\n{\\n\\tfor(int j=0;j<32;j++)\\n\\t{\\n\\t\\tif(1<<j & nums[i])\\n\\t\\t\\tbitset[31-j] = i;\\n\\t}\\n\\tans.push_back(max(1,*max_element(bitset.begin(),bitset.end())-i+1));\\n}\\nreverse(ans.begin(),ans.end());\\nreturn ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589396,
                "title": "rust-dp",
                "content": "~~~\\nimpl Solution {\\n    pub fn smallest_subarrays(nums: Vec<i32>) -> Vec<i32> {\\n        let n = nums.len();\\n        let mut dp = vec![n; 30];\\n        let mut ret = vec![0; n];\\n        \\n        for i in (0..n).rev() {\\n            let mut t = i;\\n            for j in 0..30 {\\n                let temp = nums[i] >> (j as i32);\\n                if temp & 1 > 0 { dp[j] = i; }\\n                else if dp[j] < n { t = t.max(dp[j]); }\\n            }\\n            ret[i] = (t - i + 1) as i32;\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn smallest_subarrays(nums: Vec<i32>) -> Vec<i32> {\\n        let n = nums.len();\\n        let mut dp = vec![n; 30];\\n        let mut ret = vec![0; n];\\n        \\n        for i in (0..n).rev() {\\n            let mut t = i;\\n            for j in 0..30 {\\n                let temp = nums[i] >> (j as i32);\\n                if temp & 1 > 0 { dp[j] = i; }\\n                else if dp[j] < n { t = t.max(dp[j]); }\\n            }\\n            ret[i] = (t - i + 1) as i32;\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2589376,
                "title": "golang-77-ms-8-3-mb-solution",
                "content": "```\\nfunc max(a, b int32) int32 {\\n    if a >= b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc smallestSubarrays(nums []int) []int {\\n\\tminBitIdx := [30]int32{}\\n    maxJ := int32(0)\\n\\tfor i := int32(len(nums) - 1); i >= 0; i-- {\\n        j := int32(0)\\n\\t\\tfor num := nums[i]; num != 0; num, j = num>>1, j+1 {\\n\\t\\t\\tif num%2 == 1 {\\n\\t\\t\\t\\tminBitIdx[j] = i\\n\\t\\t\\t}\\n\\t\\t}\\n        maxJ = max(maxJ, j)\\n\\n\\t\\tmaxBitIdx := i\\n\\t\\tfor j = 0; j < maxJ; j++ {\\n\\t\\t\\tmaxBitIdx = max(maxBitIdx, minBitIdx[j])\\n\\t\\t}\\n\\t\\tnums[i] = int(maxBitIdx - i + 1)\\n\\t}\\n\\n\\treturn nums\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(a, b int32) int32 {\\n    if a >= b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc smallestSubarrays(nums []int) []int {\\n\\tminBitIdx := [30]int32{}\\n    maxJ := int32(0)\\n\\tfor i := int32(len(nums) - 1); i >= 0; i-- {\\n        j := int32(0)\\n\\t\\tfor num := nums[i]; num != 0; num, j = num>>1, j+1 {\\n\\t\\t\\tif num%2 == 1 {\\n\\t\\t\\t\\tminBitIdx[j] = i\\n\\t\\t\\t}\\n\\t\\t}\\n        maxJ = max(maxJ, j)\\n\\n\\t\\tmaxBitIdx := i\\n\\t\\tfor j = 0; j < maxJ; j++ {\\n\\t\\t\\tmaxBitIdx = max(maxBitIdx, minBitIdx[j])\\n\\t\\t}\\n\\t\\tnums[i] = int(maxBitIdx - i + 1)\\n\\t}\\n\\n\\treturn nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589365,
                "title": "c-prefix-sums-binary-search",
                "content": ">Note: I originally went with this approach using Python during the contest and it led to TLE - I reimplemented it in C++ and it got accepted. I am not sure if future test cases will invalidate this solution.\\n\\n# Complexity\\n**Time:**  `O(nlog(n))` where `n` is the size of `nums`.\\n**Space:**  `O(n)` where `n` is the size of `nums`.\\n\\n# Intuition\\n\\nThere are two things to note:\\n1. `nums[i] | nums[j]` is monotonically increasing for `i < j`.\\n2. The upper bound of an array element is `10e9`, which is 34 bits at max.\\n\\nFor a number `nums[i]`, if OR\\'ed with another `nums[j]` such that `nums[i] | nums[j]` leads to a larger value, implies that `nums[i]` has some bit unset (zero) but `nums[j]` has that bit set (one). It means that for every bit of `nums[i]`, if it is unset (zero), we can search if there exists a `nums[j]` (`j>i`) of which the bit is set (one).\\n\\nWe can compute the prefix sums for every bit, in a `m x n` matrix where `m` is the maximum number of bits and `n` is the size of `nums`. \\n\\nWe iterate over `nums`, for every unset bit of each `nums[i]`, we look for the first `nums[j]` which has that bit set using binary search.\\n\\n# Code\\n\\n```c++\\n#include <math.h> \\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxnum = -1;\\n        vector<int>ans(n,1);\\n        for (int i = 0; i < n; ++i) maxnum = max(nums[i],maxnum);\\n        \\n        // Handle the edge case of nums == [0]\\n        if (maxnum == 0) return ans;\\n        \\n        // The maximum number is 10e9 => the highest number of bits = log2(10e9)+1 = 34\\n        int maxbits = (int)log2(maxnum) + 1;\\n        \\n        /*\\n        A maxbits * n matrix to store the sum of each set bit.\\n        \\n        E.x., nums = [1,0,2,1,3], maxbits = log2(3)+1 = 2 bits\\n        freqs is a 2x5 matrix that looks like: [[1,1,1,2,3], [0,0,1,1,2]]\\n        \\n        Think of freqs[j] as the prefix sum of the jth bit for the entire array.\\n        freqs[j][i] => How many times the jth bit has been set until nums[i].\\n        */\\n        vector<vector<int>>freqs(maxbits, vector<int>(n,0));\\n        for (int i = 0; i < n;++i){\\n            for (int j = 0; j < maxbits; ++j) { \\n                if (i>0) freqs[j][i] = freqs[j][i-1];\\n                if ((nums[i]>>j)&1) freqs[j][i]++;\\n            }\\n        }\\n        \\n        int maxbit,val;\\n        for (int i = 0; i < n-1; ++i) {\\n            val = nums[i];\\n            maxbit = i;\\n            /*\\n                The only way to get a higher bitwise or value for nums[i]:\\n                - For every zero bit of nums[i], say the kth bit, we can find nums[j] where j > i whose kth bit is one;\\n                - We can use binary search within the prefix sum array, freqs[i] (i.e., the prefix sums of the jth bit)\\n                \\n                E.x.,, for nums[0] = 1, or (01) in binary, its 1st bit is zero - the only way to have a larger bitwise-or\\'ed value\\n                is to find a number where the 1st bit is set (one).\\n                \\n                Hence, we want to find the next first number where the first bit is set: \\n                use binary search within freqs[1], search for freqs[1][0]+1.\\n            */\\n            for (int b = 0; b < maxbits; ++b) {\\n                if (!((val>>b)&1)) {\\n                    int bit_count = freqs[b][i];\\n                    \\n                    int nxt_count = bit_count+1;\\n                    \\n                    // freqs[b].begin()+i+1 because we want to search starting from the next element.\\n                    auto iter = lower_bound(freqs[b].begin()+i+1,freqs[b].end(),nxt_count); \\n                    \\n                    // nxt_idx is the idx of the number that can be OR\\'ed with nums[i] to get a larger value.\\n                    // Handle out-of-bound case\\n                    int nxt_idx = iter== freqs[b].end() ? -1 : iter-freqs[b].begin(); \\n                    \\n                    // We keep the maximum index because any bit that is not set on nums[i] but is set on a nums[j] where j>i\\n                    // can contribute to a larger OR\\'ed value. We need to include them all.\\n                    maxbit = max(maxbit, nxt_idx);\\n                }\\n            }\\n            ans[i] = maxbit - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```c++\\n#include <math.h> \\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxnum = -1;\\n        vector<int>ans(n,1);\\n        for (int i = 0; i < n; ++i) maxnum = max(nums[i],maxnum);\\n        \\n        // Handle the edge case of nums == [0]\\n        if (maxnum == 0) return ans;\\n        \\n        // The maximum number is 10e9 => the highest number of bits = log2(10e9)+1 = 34\\n        int maxbits = (int)log2(maxnum) + 1;\\n        \\n        /*\\n        A maxbits * n matrix to store the sum of each set bit.\\n        \\n        E.x., nums = [1,0,2,1,3], maxbits = log2(3)+1 = 2 bits\\n        freqs is a 2x5 matrix that looks like: [[1,1,1,2,3], [0,0,1,1,2]]\\n        \\n        Think of freqs[j] as the prefix sum of the jth bit for the entire array.\\n        freqs[j][i] => How many times the jth bit has been set until nums[i].\\n        */\\n        vector<vector<int>>freqs(maxbits, vector<int>(n,0));\\n        for (int i = 0; i < n;++i){\\n            for (int j = 0; j < maxbits; ++j) { \\n                if (i>0) freqs[j][i] = freqs[j][i-1];\\n                if ((nums[i]>>j)&1) freqs[j][i]++;\\n            }\\n        }\\n        \\n        int maxbit,val;\\n        for (int i = 0; i < n-1; ++i) {\\n            val = nums[i];\\n            maxbit = i;\\n            /*\\n                The only way to get a higher bitwise or value for nums[i]:\\n                - For every zero bit of nums[i], say the kth bit, we can find nums[j] where j > i whose kth bit is one;\\n                - We can use binary search within the prefix sum array, freqs[i] (i.e., the prefix sums of the jth bit)\\n                \\n                E.x.,, for nums[0] = 1, or (01) in binary, its 1st bit is zero - the only way to have a larger bitwise-or\\'ed value\\n                is to find a number where the 1st bit is set (one).\\n                \\n                Hence, we want to find the next first number where the first bit is set: \\n                use binary search within freqs[1], search for freqs[1][0]+1.\\n            */\\n            for (int b = 0; b < maxbits; ++b) {\\n                if (!((val>>b)&1)) {\\n                    int bit_count = freqs[b][i];\\n                    \\n                    int nxt_count = bit_count+1;\\n                    \\n                    // freqs[b].begin()+i+1 because we want to search starting from the next element.\\n                    auto iter = lower_bound(freqs[b].begin()+i+1,freqs[b].end(),nxt_count); \\n                    \\n                    // nxt_idx is the idx of the number that can be OR\\'ed with nums[i] to get a larger value.\\n                    // Handle out-of-bound case\\n                    int nxt_idx = iter== freqs[b].end() ? -1 : iter-freqs[b].begin(); \\n                    \\n                    // We keep the maximum index because any bit that is not set on nums[i] but is set on a nums[j] where j>i\\n                    // can contribute to a larger OR\\'ed value. We need to include them all.\\n                    maxbit = max(maxbit, nxt_idx);\\n                }\\n            }\\n            ans[i] = maxbit - i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2589357,
                "title": "sparse-tree-with-binary-search",
                "content": "**\\nlearn the concept of sparse table from here :https://www.youtube.com/watch?v=iaRvydtqLV4&t=813s**\\n\\n\\n# Reference: The provided code demonstrates the usage of binary search in a monotonic increasing function. To understand this concept further, it is recommended to solve the \"AGGRESSIVE COWS\" problem on SPOJ.\\n\\nProblem: \"AGGRESSIVE COWS\" is a problem on SPOJ (Sphere Online Judge) that involves placing cows in stalls in such a way that the minimum distance between any two cows is maximized. The goal is to find the largest minimum distance possible.\\n\\nApproach: The problem can be solved using binary search on a monotonic increasing function.\\n\\nExplanation: The binary search approach works as follows:\\n\\n1. Initialize the lower bound as 0 and the upper bound as the maximum possible distance (which is the length of the longest stall).\\n2. Perform binary search iterations until the lower bound is less than or equal to the upper bound.\\n3. In each iteration, calculate the mid distance as the average of the lower and upper bounds.\\n4. Check if it is possible to place the cows with a minimum distance of mid.\\n5. If it is possible, update the lower bound to mid + 1, as the minimum distance can be increased.\\n6. If it is not possible, update the upper bound to mid - 1, as the minimum distance needs to be decreased.\\n7. Repeat steps 3-6 until the lower bound becomes greater than the upper bound.\\n8. The final value of the upper bound will be the largest minimum distance that satisfies the problem\\'s condition.\\n\\nBy solving the \"AGGRESSIVE COWS\" problem on SPOJ, you will gain a practical understanding of how binary search can be applied to find the optimal solution for a monotonic increasing function.\\n``````\\n// The given code solves the problem of finding the smallest subarray size starting at each index with the maximum possible bitwise OR value. It utilizes the concept of sparse table for efficient range OR queries and binary search to find the smallest subarray.\\n\\n**Solution\\n**\\nThe code implements the smallestSubarrays function that takes an input array arr. It utilizes a sparse table data structure to efficiently perform range OR queries and employs binary search algorithm to find the smallest subarray starting at each index with the maximum bitwise OR.\\n\\nThe build_log function is responsible for constructing logarithmic values used for efficient creation of the sparse table. The build function constructs the sparse table by iteratively computing the OR values for different subarray lengths. The query function performs a range OR query using the sparse table.\\n\\nIn the smallestSubarrays function, a suffix array suff is utilized to calculate the maximum OR value starting from each index. Then, for each index i, a binary search is performed to find the smallest subarray with a maximum OR equal to the current suffix value.\\n\\nThe main function demonstrates an example usage of the smallestSubarrays function and provides a reference to a video explaining the concept of sparse table. Additionally, it suggests solving the \"AGGRESSIVE COWS\" problem on SPOJ to gain a better understanding of binary search in a monotonic increasing function.\\n\\nReference: The code provided is inspired by the concept of sparse table and binary search algorithms. For a detailed understanding of sparse table, you can refer to the video tutorial: Sparse Table Tutorial. To explore the use of binary search in a monotonic increasing function, you can solve the \"AGGRESSIVE COWS\" problem on SPOJ.\\n\\n---\\n\\n\\n#include <iostream>\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int sparse_table[100005][30];\\n    int log_arr[100005];\\n\\n    /**\\n     * This function builds logarithmic values for efficient sparse table creation.\\n     * @param n The maximum input size\\n     */\\n    void build_log(int n) {\\n        log_arr[1] = 0;\\n        for (int i = 2; i <= n; i++) {\\n            log_arr[i] = 1 + log_arr[i / 2];\\n        }\\n    }\\n\\n    /**\\n     * This function builds the sparse table for efficient range OR queries.\\n     * @param arr The input array\\n     * @param n The size of the input array\\n     */\\n    void build(vector<int>& arr, int n) {\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 0; j < 25; j++) {\\n                int w = i + (1 << j) - 1;\\n                if (w >= n)\\n                    break;\\n                if (j == 0)\\n                    sparse_table[i][j] = arr[i];\\n                else\\n                    sparse_table[i][j] = sparse_table[i][j - 1] | sparse_table[i + (1 << (j - 1))][j - 1];\\n            }\\n        }\\n    }\\n\\n    /**\\n     * This function performs a range OR query using the sparse table.\\n     * @param l The left index of the range\\n     * @param r The right index of the range\\n     * @return The bitwise OR of the range\\n     */\\n    int query(int l, int r) {\\n        int w = r - l + 1;\\n        int power = log_arr[w];\\n        return (sparse_table[l][power] | sparse_table[r - (1 << power) + 1][power]);\\n    }\\n\\n    /**\\n     * This function finds the smallest subarray starting at each index with the maximum bitwise OR.\\n     * @param arr The input array\\n     * @return The vector containing the smallest subarray sizes\\n     */\\n    vector<int> smallestSubarrays(vector<int>& arr) {\\n        int n = arr.size();\\n        build_log(n);\\n        build(arr, n);\\n        vector<int> ans;\\n        int s = 0;\\n        vector<int> suff;\\n\\n        // Calculate the maximum OR value starting from each index using a suffix array\\n        for (int i = arr.size() - 1; i >= 0; i--) {\\n            s = s | arr[i];\\n            suff.push_back(s);\\n        }\\n        reverse(suff.begin(), suff.end());\\n\\n        // Iterate through each index and find the smallest subarray with maximum OR using binary search\\n        for (int i = 0; i < arr.size(); i++) {\\n            int temp = INT_MAX;\\n            int curr = suff[i];\\n            int left = i;\\n            int right = n;\\n            while (left <= right) {\\n                int mid = (left + right) / 2;\\n                int k = query(i, mid);\\n                if (k >= curr) {\\n                    temp = min(temp, mid - i + 1);\\n                    right = mid - 1;\\n                }\\n                else\\n                    left = mid + 1;\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n\\nint main() {\\n    // Example usage\\n    vector<int> nums = { 3, 1, 2, 4 };\\n    Solution s;\\n    vector<int> result = s.smallestSubarrays(nums);\\n\\n    // Display the result\\n    for (int i = 0; i < result.size(); i++) {\\n        cout << \"Smallest subarray size starting at index \" << i << \": \" << result[i] << endl;\\n    }\\n    \\n    return 0;\\n}\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "``````",
                "codeTag": "Unknown"
            },
            {
                "id": 2588984,
                "title": "sparse-table-with-binary-search-o-nlog-n",
                "content": "for ith index from left maximum or subarray is or of all number right to that index\\nfor this i use **curr** variable which store bitwise or of all elements from i+1 to n-1 now at ith index maximum or subarray is  **nums[i]**|**curr** and we simply perform binary search to get smallest length.\\n\\nfor better understanding refer to my c++ accepted code:\\n\\n```\\nint K=log2(1e5+1);vector<vector<int>>st;\\n    int Log2[100010];\\n    void cal(){\\n        Log2[1]=0;\\n        for(int i=2;i<100010;++i)Log2[i]=Log2[i/2]+1;\\n    }\\n    int f(int l,int mid){\\n        int r=(l+mid),j=Log2[mid+1];\\n        return st[l][j]|st[r-(1<<j)+1][j];\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        cal();\\n        int n=nums.size(); K=Log2[n+1];\\n        st.resize(n,vector<int>(K+1));\\n        for(int i=0;i<n;++i)st[i][0]=nums[i];\\n       \\n        for(int k=1;k<=K;++k ){\\n            for(int i=0;i+(1<<k)<=n;++i){\\n                st[i][k]=st[i][k-1]|st[i+(1<<(k-1))][k-1];\\n            }\\n        }\\n    vector<int>res(n,0);\\n        int curr=nums[n-1];res[n-1]=1;\\n        for(int i=n-2;i>=0;--i){\\n            int l=0,h=n-1-i,mid,ans;\\n            curr|=nums[i];\\n            while(l<=h){\\n                mid=(l+h)/2;\\n                if(f(i,mid)>=curr)ans=mid,h=mid-1;\\n                else l=mid+1;\\n            }\\n            res[i]=ans+1;\\n        }\\n        return res;\\n        \\n    }\\n```\\nif you find it helpful please **upvote**",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nint K=log2(1e5+1);vector<vector<int>>st;\\n    int Log2[100010];\\n    void cal(){\\n        Log2[1]=0;\\n        for(int i=2;i<100010;++i)Log2[i]=Log2[i/2]+1;\\n    }\\n    int f(int l,int mid){\\n        int r=(l+mid),j=Log2[mid+1];\\n        return st[l][j]|st[r-(1<<j)+1][j];\\n    }\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        cal();\\n        int n=nums.size(); K=Log2[n+1];\\n        st.resize(n,vector<int>(K+1));\\n        for(int i=0;i<n;++i)st[i][0]=nums[i];\\n       \\n        for(int k=1;k<=K;++k ){\\n            for(int i=0;i+(1<<k)<=n;++i){\\n                st[i][k]=st[i][k-1]|st[i+(1<<(k-1))][k-1];\\n            }\\n        }\\n    vector<int>res(n,0);\\n        int curr=nums[n-1];res[n-1]=1;\\n        for(int i=n-2;i>=0;--i){\\n            int l=0,h=n-1-i,mid,ans;\\n            curr|=nums[i];\\n            while(l<=h){\\n                mid=(l+h)/2;\\n                if(f(i,mid)>=curr)ans=mid,h=mid-1;\\n                else l=mid+1;\\n            }\\n            res[i]=ans+1;\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588973,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& a) {\\n        int x= 0 ;int ans=0; \\n        int n = a.size() ; \\n        vector<int>res(n) ; \\n        vector<int>maxxor(n) ; \\n        for(int i = n-1 ; i >=0 ; i--){\\n            x  = x |  a[i] ; \\n            ans = max(ans , x) ;\\n            maxxor[i] = ans ; \\n        }\\n        \\n       vector<vector<int>>mp(31) ; \\n        \\n        for(int i = 0 ; i < n ; i++){\\n           for(int j = 31 ; j >= 0 ; j-- ){\\n               int bit = ((a[i] >> j) & 1) ; \\n               if(bit){\\n                   mp[j].push_back(i);\\n               }\\n           }   \\n        }\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int len = 1 ; \\n            for(int j = 0 ; j <= 31 ; j++){\\n                \\n                int bit = (maxxor[i] >> j) & 1 ; \\n                \\n                if(bit){\\n             auto it = lower_bound(mp[j].begin(),mp[j].end() , i );\\n              int length = (*it) - i + 1;\\n              len = max( length , len );\\n                }\\n            }\\n            res[i] = len ; \\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& a) {\\n        int x= 0 ;int ans=0; \\n        int n = a.size() ; \\n        vector<int>res(n) ; \\n        vector<int>maxxor(n) ; \\n        for(int i = n-1 ; i >=0 ; i--){\\n            x  = x |  a[i] ; \\n            ans = max(ans , x) ;\\n            maxxor[i] = ans ; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2588972,
                "title": "java-bit-operation-slide-window",
                "content": "```\\n\\t//Runtime: 61 ms, faster than 60.00% of Java online submissions for Smallest Subarrays With Maximum Bitwise OR.\\n    //Memory Usage: 90.2 MB, less than 40.00% of Java online submissions for Smallest Subarrays With Maximum Bitwise OR.\\n    //Slide window + bit opertaion\\n    //Time:O(N); Space:O(N)\\n    //n is the nums.length\\n    public int[] smallestSubarrays(int[] nums) {\\n        int[] res = new int[nums.length];\\n        res[nums.length - 1] = 1;\\n\\n        //Time:O(N); Space:O(N)\\n        int[] maxNums = new int[nums.length];\\n        maxNums[nums.length - 1] = nums[nums.length - 1];\\n        for (int i = nums.length - 2; i >= 0; i--)\\n            maxNums[i] = nums[i] | maxNums[i + 1];\\n\\n        //Time:O(N); Space:O(32)\\n        int[] bitArr = new int[32 + 1];\\n        int x = 0, left = 0, right = 0;\\n        int maxC = Integer.bitCount(maxNums[0]);\\n        while (right < nums.length){\\n            int number = nums[right];\\n            x |= number;\\n            setOnes(bitArr, number, right + 1);\\n            while (left <= right && Integer.bitCount(x) >= maxC){\\n                res[left] = right - left + 1;\\n                //remove leftmost from x\\n                x = removeOnes(bitArr, ++left);\\n                if (left < nums.length - 1)\\n                    maxC = Integer.bitCount(maxNums[left]);\\n            }\\n            right++;\\n        }\\n        return res;\\n    }\\n\\n    //Time: O(32)\\n    private int removeOnes(int[] bitArr, int idx){\\n        int total = 0;\\n        for (int i = bitArr.length - 1; i > 0; i--){\\n            total = total << 1;\\n            if (bitArr[i] <= idx) bitArr[i] = 0;\\n            else total += 1;\\n        }\\n        return total;\\n    }\\n\\n    //Time: worst case: O(32 * 32)\\n    private void setOnes(int[] bitArr, int number, int idx){\\n        while (number != 0) {\\n            int lb = number & -number; //lowest one bit\\n            number = number ^ lb; //set 0\\n\\n            int k = 1;\\n            while ((lb = lb >> 1) != 0) k++;\\n\\n            bitArr[k] = idx;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n\\t//Runtime: 61 ms, faster than 60.00% of Java online submissions for Smallest Subarrays With Maximum Bitwise OR.\\n    //Memory Usage: 90.2 MB, less than 40.00% of Java online submissions for Smallest Subarrays With Maximum Bitwise OR.\\n    //Slide window + bit opertaion\\n    //Time:O(N); Space:O(N)\\n    //n is the nums.length\\n    public int[] smallestSubarrays(int[] nums) {\\n        int[] res = new int[nums.length];\\n        res[nums.length - 1] = 1;\\n\\n        //Time:O(N); Space:O(N)\\n        int[] maxNums = new int[nums.length];\\n        maxNums[nums.length - 1] = nums[nums.length - 1];\\n        for (int i = nums.length - 2; i >= 0; i--)\\n            maxNums[i] = nums[i] | maxNums[i + 1];\\n\\n        //Time:O(N); Space:O(32)\\n        int[] bitArr = new int[32 + 1];\\n        int x = 0, left = 0, right = 0;\\n        int maxC = Integer.bitCount(maxNums[0]);\\n        while (right < nums.length){\\n            int number = nums[right];\\n            x |= number;\\n            setOnes(bitArr, number, right + 1);\\n            while (left <= right && Integer.bitCount(x) >= maxC){\\n                res[left] = right - left + 1;\\n                //remove leftmost from x\\n                x = removeOnes(bitArr, ++left);\\n                if (left < nums.length - 1)\\n                    maxC = Integer.bitCount(maxNums[left]);\\n            }\\n            right++;\\n        }\\n        return res;\\n    }\\n\\n    //Time: O(32)\\n    private int removeOnes(int[] bitArr, int idx){\\n        int total = 0;\\n        for (int i = bitArr.length - 1; i > 0; i--){\\n            total = total << 1;\\n            if (bitArr[i] <= idx) bitArr[i] = 0;\\n            else total += 1;\\n        }\\n        return total;\\n    }\\n\\n    //Time: worst case: O(32 * 32)\\n    private void setOnes(int[] bitArr, int number, int idx){\\n        while (number != 0) {\\n            int lb = number & -number; //lowest one bit\\n            number = number ^ lb; //set 0\\n\\n            int k = 1;\\n            while ((lb = lb >> 1) != 0) k++;\\n\\n            bitArr[k] = idx;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588925,
                "title": "python-3-sliding-window-hash-map",
                "content": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        # store digits with 1 bit\\n        digits = defaultdict(lambda: defaultdict(int))\\n\\n        for num in set(nums):\\n            if not num: continue\\n            d = bin(num)[2:]\\n            for i, x in enumerate(d[::-1]):\\n                if x == \\'1\\':\\n                    digits[num][i] += 1\\n\\n        \\n        n = len(nums)\\n        r = n - 1\\n        ans = [0] * n\\n        tmp = defaultdict(int)\\n        for l in reversed(range(n)):\\n            for x in digits[nums[l]]:\\n                tmp[x] += 1\\n            \\n            # to be removed number will not cause current digits to have zero count after removal\\n            while r > l and all(tmp[x] > 1 for x in digits[nums[r]]):\\n                for x in digits[nums[r]]:\\n                    tmp[x] -= 1\\n                r -= 1\\n\\n            ans[l] =  r - l + 1\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        # store digits with 1 bit\\n        digits = defaultdict(lambda: defaultdict(int))\\n\\n        for num in set(nums):\\n            if not num: continue\\n            d = bin(num)[2:]\\n            for i, x in enumerate(d[::-1]):\\n                if x == \\'1\\':\\n                    digits[num][i] += 1\\n\\n        \\n        n = len(nums)\\n        r = n - 1\\n        ans = [0] * n\\n        tmp = defaultdict(int)\\n        for l in reversed(range(n)):\\n            for x in digits[nums[l]]:\\n                tmp[x] += 1\\n            \\n            # to be removed number will not cause current digits to have zero count after removal\\n            while r > l and all(tmp[x] > 1 for x in digits[nums[r]]):\\n                for x in digits[nums[r]]:\\n                    tmp[x] -= 1\\n                r -= 1\\n\\n            ans[l] =  r - l + 1\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2588904,
                "title": "c-solution-o-n-time-o-n-space-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    static vector<int> smallestSubarrays(const vector<int>& nums) {\\n        const int n = size(nums);\\n        vector<int> mp(31, -1);\\n        vector<int> ret(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = 0, a = 1; j <= 30; ++j, a <<= 1)\\n                if (a & nums[i])\\n                    mp[j] = i;\\n            int res = -1;\\n            for (auto x : mp)\\n                res = max(res, x);\\n            if (res != -1)\\n                ret[i] = res - i + 1;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static vector<int> smallestSubarrays(const vector<int>& nums) {\\n        const int n = size(nums);\\n        vector<int> mp(31, -1);\\n        vector<int> ret(n, 1);\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = 0, a = 1; j <= 30; ++j, a <<= 1)\\n                if (a & nums[i])\\n                    mp[j] = i;\\n            int res = -1;\\n            for (auto x : mp)\\n                res = max(res, x);\\n            if (res != -1)\\n                ret[i] = res - i + 1;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588891,
                "title": "c-easy-clean-and-concise-solution-for-beginners",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> smallestSubarrays(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tunordered_map<int,int> m;\\n\\n\\t\\t\\tvector<int> ans(n, 1);\\n\\n\\t\\t\\tfor(int i = n - 1; i >= 0; i--){\\n\\n\\t\\t\\t\\tint len = 1;\\n\\n\\t\\t\\t\\tfor(int bit = 0; bit <= 31; bit++){\\n\\t\\t\\t\\t\\tif(nums[i]>>bit & 1){\\n\\t\\t\\t\\t\\t\\tm[bit] = i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(m.find(bit) != m.end()){\\n\\t\\t\\t\\t\\t\\t\\tlen = max(len, m[bit] - i + 1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = len;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> smallestSubarrays(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tunordered_map<int,int> m;\\n\\n\\t\\t\\tvector<int> ans(n, 1);\\n\\n\\t\\t\\tfor(int i = n - 1; i >= 0; i--){\\n\\n\\t\\t\\t\\tint len = 1;\\n\\n\\t\\t\\t\\tfor(int bit = 0; bit <= 31; bit++){\\n\\t\\t\\t\\t\\tif(nums[i]>>bit & 1){\\n\\t\\t\\t\\t\\t\\tm[bit] = i;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2588890,
                "title": "c-easy-bit-manipulation",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> smallestSubarrays(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int,int>m;\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tint size = nums.size();\\n\\t\\t\\tfor(int j=size-1;j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint minn = 1;\\n\\t\\t\\t\\tfor(int i=0;i<32;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif((nums[j])&(1<<i))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[1<<i]=j;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(m.find(1<<i) != m.end())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tminn = max(minn,m[1<<i]-j+1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tv.push_back(minn);\\n\\t\\t\\t}\\n\\t\\t\\treverse(v.begin(),v.end());\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> smallestSubarrays(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int,int>m;\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tint size = nums.size();\\n\\t\\t\\tfor(int j=size-1;j>=0;j--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint minn = 1;\\n\\t\\t\\t\\tfor(int i=0;i<32;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif((nums[j])&(1<<i))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tm[1<<i]=j;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2588861,
                "title": "simple-af-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int> bs(32), ans(n);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int maxi = 1;\\n            for(int j=0;j<32;j++){\\n                if(!(arr[i] & 1<<j)) maxi = max(maxi,bs[j]-i+1);\\n                else bs[j] = i;\\n            }\\n            ans[i] = maxi;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int> bs(32), ans(n);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int maxi = 1;\\n            for(int j=0;j<32;j++){\\n                if(!(arr[i] & 1<<j)) maxi = max(maxi,bs[j]-i+1);\\n                else bs[j] = i;\\n            }\\n            ans[i] = maxi;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588826,
                "title": "c-bits-solution",
                "content": "```\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans(n,0);\\n        vector<int>dp(32,0);\\n\\n        for(int i = n - 1 ; i >= 0 ; i++){\\n            for(int j = 0 ; j < 33 ; j++){\\n                if(nums[i]&(i<<j)){\\n                    dp[j] = 1 ; \\n                }\\n                else{\\n                    if(dp[j] != 0 ){\\n                          dp[j] += 1 ; \\n                    }\\n                }\\n            }\\n\\n            int mx = *max_element(dp.begin(),dp.end());\\n            ans[i] = mx ; \\n        }\\n\\n        return ans ; \\n    }\\n\\t```\\n\\t\\n",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans(n,0);\\n        vector<int>dp(32,0);\\n\\n        for(int i = n - 1 ; i >= 0 ; i++){\\n            for(int j = 0 ; j < 33 ; j++){\\n                if(nums[i]&(i<<j)){\\n                    dp[j] = 1 ; \\n                }\\n                else{\\n                    if(dp[j] != 0 ){\\n                          dp[j] += 1 ; \\n                    }\\n                }\\n            }\\n\\n            int mx = *max_element(dp.begin(),dp.end());\\n            ans[i] = mx ; \\n        }\\n\\n        return ans ; \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588807,
                "title": "easy-understandable-code-c-nakshatra",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int temp = 0, n = nums.size();\\n        vector<int> mx(n);\\n        \\n        for(int i=n-1; i>=0; i--)\\n        {\\n            temp = temp | nums[i];\\n            mx[i] = temp;\\n        }\\n        \\n        map<int, int> mp;\\n        int i=0, j=0, xr=0, flag=1;\\n        vector<int> ans;\\n        while(i!=n)\\n        {\\n            int num, a;\\n            if(flag)\\n            {\\n                xr = xr | nums[j];\\n                num = nums[j];\\n                a=0;\\n                while(num!=0)\\n                {\\n                    if(num%2)\\n                        mp[a]++;\\n\\n                    num = num >> 1;\\n                    a++;\\n                }\\n            }\\n            \\n            if(xr==mx[i])\\n            {\\n                ans.push_back(j-i+1);\\n                num = nums[i];\\n                a=0;\\n                while(num!=0)\\n                {\\n                    if(num%2)\\n                    {\\n                        mp[a]--;\\n                        if(mp[a]==0)\\n                        {\\n                            int q = (1 << a);\\n                            xr = xr ^ q;\\n                            mp.erase(a);\\n                        }\\n                    }\\n                    \\n                    num = num >> 1;\\n                    a++;\\n                }\\n                i++;\\n                flag=0;\\n                if(j<i)\\n                {\\n                    flag=1;\\n                    j = i;\\n                }\\n            }\\n            else\\n            {\\n                j++;\\n                flag=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int temp = 0, n = nums.size();\\n        vector<int> mx(n);\\n        \\n        for(int i=n-1; i>=0; i--)\\n        {\\n            temp = temp | nums[i];\\n            mx[i] = temp;\\n        }\\n        \\n        map<int, int> mp;\\n        int i=0, j=0, xr=0, flag=1;\\n        vector<int> ans;\\n        while(i!=n)\\n        {\\n            int num, a;\\n            if(flag)\\n            {\\n                xr = xr | nums[j];\\n                num = nums[j];\\n                a=0;\\n                while(num!=0)\\n                {\\n                    if(num%2)\\n                        mp[a]++;\\n\\n                    num = num >> 1;\\n                    a++;\\n                }\\n            }\\n            \\n            if(xr==mx[i])\\n            {\\n                ans.push_back(j-i+1);\\n                num = nums[i];\\n                a=0;\\n                while(num!=0)\\n                {\\n                    if(num%2)\\n                    {\\n                        mp[a]--;\\n                        if(mp[a]==0)\\n                        {\\n                            int q = (1 << a);\\n                            xr = xr ^ q;\\n                            mp.erase(a);\\n                        }\\n                    }\\n                    \\n                    num = num >> 1;\\n                    a++;\\n                }\\n                i++;\\n                flag=0;\\n                if(j<i)\\n                {\\n                    flag=1;\\n                    j = i;\\n                }\\n            }\\n            else\\n            {\\n                j++;\\n                flag=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588777,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> smallestSubarrays(const vector<int> &nums) {\\n    constexpr int max_offset = 30;\\n    const int n = static_cast<int>(nums.size());\\n    int last_bit_index[max_offset]{};\\n    vector<int> ret(n, 1);\\n    for (int i = n - 1; i > -1; --i) {\\n      for (int offset = 0; offset < max_offset; ++offset) {\\n        if (((nums[i] >> offset) & 0b1) == 0b1) {\\n          last_bit_index[offset] = i;\\n        }\\n        if (last_bit_index[offset] > 0) {\\n          ret[i] = max(ret[i], last_bit_index[offset] - i + 1);\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<int> smallestSubarrays(const vector<int> &nums) {\\n    constexpr int max_offset = 30;\\n    const int n = static_cast<int>(nums.size());\\n    int last_bit_index[max_offset]{};\\n    vector<int> ret(n, 1);\\n    for (int i = n - 1; i > -1; --i) {\\n      for (int offset = 0; offset < max_offset; ++offset) {\\n        if (((nums[i] >> offset) & 0b1) == 0b1) {\\n          last_bit_index[offset] = i;\\n        }\\n        if (last_bit_index[offset] > 0) {\\n          ret[i] = max(ret[i], last_bit_index[offset] - i + 1);\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588759,
                "title": "c-bit-easy-solution-count-set-bits",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int  n = nums.size();\\n        vector<int> ans;\\n        vector<int> bt(32,-1);\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<30;j++){\\n                if(nums[i] & 1<<j){\\n                    bt[j]=i;\\n                }\\n            }\\n            int mx = 1;\\n            for(auto it:bt){\\n                mx = max(mx,it-i+1);\\n            }\\n            ans.push_back(mx);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        int  n = nums.size();\\n        vector<int> ans;\\n        vector<int> bt(32,-1);\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<30;j++){\\n                if(nums[i] & 1<<j){\\n                    bt[j]=i;\\n                }\\n            }\\n            int mx = 1;\\n            for(auto it:bt){\\n                mx = max(mx,it-i+1);\\n            }\\n            ans.push_back(mx);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588752,
                "title": "python-o-n-bit-manipulation",
                "content": "We start from the end of the array and keep the smallest index for each bit set.\\n\\n\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        bits, answer = {}, [0]*len(nums)\\n\\n        for i in range(len(nums)-1,-1,-1):\\n            n,k,j = nums[i], i, 0\\n            while n:\\n                if n&1: bits[j] = i\\n                n >>= 1\\n                j += 1\\n            answer[i] = max(bits.values())-i+1 if bits else 1\\n\\n        return answer",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "We start from the end of the array and keep the smallest index for each bit set.\\n\\n\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        bits, answer = {}, [0]*len(nums)\\n\\n        for i in range(len(nums)-1,-1,-1):\\n            n,k,j = nums[i], i, 0\\n            while n:\\n                if n&1: bits[j] = i\\n                n >>= 1\\n                j += 1\\n            answer[i] = max(bits.values())-i+1 if bits else 1\\n\\n        return answer",
                "codeTag": "Python3"
            },
            {
                "id": 2588710,
                "title": "explained-greedy-bit-manipulation",
                "content": "\\n    \\n    Observation : \\n    => \"starting at i\" then think from last index\\n    => for last index  max size will be 1 i.e that ele itself\\n    => \"size\" of the \"minimum\" sized non-empty subarray\\n    => what is size actually if I start at an index i ? \\n    => It will be end index - i + 1 (bcoz inclusive)\\n    => Therefore we need to find the end index.\\n    => Also for minimum size what can be the end index? \\n    => it is the nearest index  towards right of i \\n    => So if I am at index i, I need to find nearest index towards right\\n    => If I traverse from last the previous index itself is the nearest \\n    => When do I get maximum possible bitwise OR? \\n    => when all the bit is set in the number \\n    => So I need the nearest index where a  bit is set\\n    => this end index will be the farthest index where i can find a set bit\\n    => I go as far as i can to find a set bit bcoz i made my mind to get max OR\\n\\t=> so take max(farthest , mp[k]) ,for all 0<=k<=31 positions\\n    => Therefore I can maintain a map[kth bit is set]  at which index\\n    => Then just push the length and reverse since we pushed from last\\n\\t\\n  ```\\n  vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        vector<int> mp(64,-1);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int farthest  = i;\\n            \\n            for(int k=0;k<32;k++){\\n                if(nums[i] & (1LL << k)) mp[k] = i;\\n            }\\n            \\n            \\n            for(int k=0;k<32;k++){\\n                if(mp[k]!=-1) farthest = max(farthest , mp[k]);\\n            }\\n            \\n            ans.push_back(farthest - i + 1);\\n        }\\n        \\n        reverse(ans.begin() , ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<int> smallestSubarrays(vector<int>& nums) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        vector<int> mp(64,-1);\\n        \\n        for(int i=n-1;i>=0;i--){\\n            int farthest  = i;\\n            \\n            for(int k=0;k<32;k++){\\n                if(nums[i] & (1LL << k)) mp[k] = i;\\n            }\\n            \\n            \\n            for(int k=0;k<32;k++){\\n                if(mp[k]!=-1) farthest = max(farthest , mp[k]);\\n            }\\n            \\n            ans.push_back(farthest - i + 1);\\n        }\\n        \\n        reverse(ans.begin() , ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588693,
                "title": "my-bits-counting-javascript-solution",
                "content": "```\\nvar smallestSubarrays = function(nums) {\\n    const bits = new Array(30); // (1e9).toString(2).length\\n    const result = new Array(nums.length);\\n    let max;\\n    \\n    for (let i = nums.length - 1; 0 <= i; --i) {\\n        max = i;\\n        for (let j = 0; j < bits.length; ++j) {\\n            if (nums[i] & (1 << j)) {\\n               bits[j] = i;\\n            }\\n            \\n            if (bits[j] > max) { // undefined will just return false here\\n                max = bits[j];\\n            }\\n        }\\n        \\n        result[i] = max - i + 1;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar smallestSubarrays = function(nums) {\\n    const bits = new Array(30); // (1e9).toString(2).length\\n    const result = new Array(nums.length);\\n    let max;\\n    \\n    for (let i = nums.length - 1; 0 <= i; --i) {\\n        max = i;\\n        for (let j = 0; j < bits.length; ++j) {\\n            if (nums[i] & (1 << j)) {\\n               bits[j] = i;\\n            }\\n            \\n            if (bits[j] > max) { // undefined will just return false here\\n                max = bits[j];\\n            }\\n        }\\n        \\n        result[i] = max - i + 1;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588692,
                "title": "o-n-30-2-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ck(int a,int maxi,vector<int>&bit){\\n        \\n     for(int i=0;i<=30;++i){\\n        //if unsetting is causing problem return false\\n         if(a&(1<<i)){\\n               if(bit[i]-1<=0)return false;\\n            }\\n      }\\n        \\n        //dosen\\'t cause any problem unset all the bits which index j contributed to decrease the size\\n      for(int i=0;i<=30;++i){\\n            if(a&(1<<i) ){\\n            --bit[i]; \\n            }\\n      }  \\n        \\n    return true;    \\n    }\\n    \\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n      \\n        int maxi=0,tempmaxi;\\n      //find the max or possible \\n        for(auto it:nums){\\n             maxi|=it;\\n        }\\n        tempmaxi=maxi;\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        vector<int>bit(32,0);\\n      //set all the bits of last num can be done in the below loop as well\\n        for(int i=0;i<=30;++i){\\n            if(nums[n-1]&(1<<i)){\\n               bit[i]++;\\n            }\\n        }\\n        \\n        ans[n-1]=1;\\n        int j=n-1;\\n        maxi=nums[n-1];\\n        for(int i=n-2;i>=0;--i){\\n         for(int j=0;j<=30;++j){\\n            if(nums[i]&(1<<j)){\\n               bit[j]++;\\n             }\\n           }\\n          \\n            \\n            if(nums[i]==tempmaxi){\\n                ans[i]=1;  \\n             }\\n            else {\\n                //check if unsetting the bits from the jth index will affect my answer or not if not reduce the size \\n                while(j>i && ck(nums[j],tempmaxi,bit)){\\n                    --j;\\n                }\\n                ans[i]=((j-i)+1);\\n            }\\n            \\n        }\\n        \\n       return ans;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ck(int a,int maxi,vector<int>&bit){\\n        \\n     for(int i=0;i<=30;++i){\\n        //if unsetting is causing problem return false\\n         if(a&(1<<i)){\\n               if(bit[i]-1<=0)return false;\\n            }\\n      }\\n        \\n        //dosen\\'t cause any problem unset all the bits which index j contributed to decrease the size\\n      for(int i=0;i<=30;++i){\\n            if(a&(1<<i) ){\\n            --bit[i]; \\n            }\\n      }  \\n        \\n    return true;    \\n    }\\n    \\n    \\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n      \\n        int maxi=0,tempmaxi;\\n      //find the max or possible \\n        for(auto it:nums){\\n             maxi|=it;\\n        }\\n        tempmaxi=maxi;\\n        int n=nums.size();\\n        vector<int>ans(n);\\n        vector<int>bit(32,0);\\n      //set all the bits of last num can be done in the below loop as well\\n        for(int i=0;i<=30;++i){\\n            if(nums[n-1]&(1<<i)){\\n               bit[i]++;\\n            }\\n        }\\n        \\n        ans[n-1]=1;\\n        int j=n-1;\\n        maxi=nums[n-1];\\n        for(int i=n-2;i>=0;--i){\\n         for(int j=0;j<=30;++j){\\n            if(nums[i]&(1<<j)){\\n               bit[j]++;\\n             }\\n           }\\n          \\n            \\n            if(nums[i]==tempmaxi){\\n                ans[i]=1;  \\n             }\\n            else {\\n                //check if unsetting the bits from the jth index will affect my answer or not if not reduce the size \\n                while(j>i && ck(nums[j],tempmaxi,bit)){\\n                    --j;\\n                }\\n                ans[i]=((j-i)+1);\\n            }\\n            \\n        }\\n        \\n       return ans;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588690,
                "title": "java-binary-lifting-binary-search-code",
                "content": "Spend quiet sometime during the context to figure out a bug :(\\nFinally could figure out and accepted :D\\n\\n```java\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        BinaryLift binaryLift = new BinaryLift(nums);\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            res[i] = binarySearch(i, nums.length - 1, binaryLift);\\n        }\\n        return res;\\n    }\\n\\n    private int binarySearch(int l, int h, final BinaryLift binaryLift) {\\n        int ans = h;\\n        int left = l;\\n        int target = binaryLift.query(l, h);\\n        while (l <= h) {\\n            int m = (l + h) / 2;\\n            if (binaryLift.query(left, m) < target) l = m + 1;\\n            else {\\n                ans = m;\\n                h = m - 1;\\n            }\\n        }\\n        return ans - left + 1;\\n    }\\n\\n    class BinaryLift {\\n        int[][] store;\\n\\n        BinaryLift(int[] nums) {\\n            this.store = new int[nums.length + 1][20];\\n            for (int i = 0; i < nums.length; i++) store[i][0] = nums[i];\\n            for (int b = 1; b < 20; b++) {\\n                for (int i = 0; i + (1 << (b - 1)) < nums.length; i++) {\\n                    store[i][b] = (store[i][b - 1] | store[i + (1 << (b - 1))][b - 1]);\\n                }\\n            }\\n        }\\n\\n        int query(int a, int b) {\\n            int x = 0;\\n            while ((a + (1 << (x + 1))) <= b) x++;\\n            return (store[a][x] | store[(b - (1 << x)) + 1][x]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] smallestSubarrays(int[] nums) {\\n        BinaryLift binaryLift = new BinaryLift(nums);\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            res[i] = binarySearch(i, nums.length - 1, binaryLift);\\n        }\\n        return res;\\n    }\\n\\n    private int binarySearch(int l, int h, final BinaryLift binaryLift) {\\n        int ans = h;\\n        int left = l;\\n        int target = binaryLift.query(l, h);\\n        while (l <= h) {\\n            int m = (l + h) / 2;\\n            if (binaryLift.query(left, m) < target) l = m + 1;\\n            else {\\n                ans = m;\\n                h = m - 1;\\n            }\\n        }\\n        return ans - left + 1;\\n    }\\n\\n    class BinaryLift {\\n        int[][] store;\\n\\n        BinaryLift(int[] nums) {\\n            this.store = new int[nums.length + 1][20];\\n            for (int i = 0; i < nums.length; i++) store[i][0] = nums[i];\\n            for (int b = 1; b < 20; b++) {\\n                for (int i = 0; i + (1 << (b - 1)) < nums.length; i++) {\\n                    store[i][b] = (store[i][b - 1] | store[i + (1 << (b - 1))][b - 1]);\\n                }\\n            }\\n        }\\n\\n        int query(int a, int b) {\\n            int x = 0;\\n            while ((a + (1 << (x + 1))) <= b) x++;\\n            return (store[a][x] | store[(b - (1 << x)) + 1][x]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588614,
                "title": "o-n-heuristic-with-maximum-position-of-bit-1-on-every-bit-position-example-solution",
                "content": "**Main Idea**:\\n+ Building array **h** where **h[k]** contains position of elements in array **nums** existing **bit 1 at bit k**\\n+ Processing from i = [0, 1, ..., n - 1] where n = len(nums)\\n  + **Removing h[k][j] where h[k][j]<i**\\n  + Finding right border r with **r = Max{ Min{h[k][...]}, len(h[k])>0} or i** if not existing\\n  + Min size at position i is **r - i + 1**\\n\\nOther method is based on **binary search on quickly calculating total bits** from every position i to n-1. But it met time-limited-error.\\n\\n\\n**Examples**:\\n```\\nExample 1: [1, 0, 2, 1, 3]\\nh: {0: [0, 3, 4], 1: [2, 4]}\\n+  0 2 size: 3 h: [[0, 3, 4], [2, 4]]\\n+  1 3 size: 3 h: [[3, 4], [2, 4]]\\n+  2 3 size: 2 h: [[3, 4], [2, 4]]\\n+  3 4 size: 2 h: [[3, 4], [4]]\\n+  4 4 size: 1 h: [[4], [4]]\\nans: [3, 3, 2, 2, 1]\\n==================== \\n\\nExample 2: [1, 2]\\nh: {0: [0], 1: [1]}\\n+  0 1 size: 2 h: [[0], [1]]\\n+  1 1 size: 1 h: [[], [1]]\\nans: [2, 1]\\n==================== \\n```\\n\\n**Code**:\\n+ Bit Solutions using the positions of  bit 1\\n```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        def bins(k):\\n            ret = []\\n            while k>0:\\n                ret.append(k%2)\\n                k = k // 2\\n            return ret\\n        \\n        n = len(nums)\\n        h = [[] for _ in range(32)]\\n        for i in range(n):\\n            bi = bins(nums[i])\\n            for j in range(len(bi)):\\n                if bi[j]==1:\\n                    h[j].append(i)\\n                    \\n        print(nums)\\n        print(\"h:\", {i:h[i] for i in range(len(h)) if len(h[i])>0})\\n        \\n        vt = [0 for _ in range(32)]\\n        lh = [len(h[i]) for i in range(32)] \\n        ans = []\\n        for i in range(n):\\n            r = i\\n            for k in range(32):\\n                if vt[k]<lh[k] and h[k][vt[k]]<i:\\n                    vt[k] += 1\\n                if vt[k]<lh[k]:\\n                    r = max(r, h[k][vt[k]])\\n            \\n            print(\"+ \", i, r, \"size:\", r - i + 1, \"h:\", [h[i][vt[i]:] for i in range(len(h)) if len(h[i])>0])\\n            ans.append(r - i + 1)\\n        print(\"ans:\", ans)\\n        print(\"=\"*20, \"\\\\n\")\\n        return ans\\n\\t\\t\\nprint = lambda *a, **aa: ()\\n```\\n\\n+ BInary Search (Time Limited Error)\\n```\\nclass Solution:            \\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        TLE with BinSearch\\n        \"\"\"\\n        def bins(k):\\n            ret = []\\n            while k>0:\\n                ret.append(k%2)\\n                k = k // 2\\n            return ret\\n        \\n        n = len(nums)\\n        \\n        h = [{}]\\n        for i in range(n):\\n            bi = bins(nums[i])\\n            hi = {i:1 for i in range(len(bi)) if bi[i]==1}\\n            # print(nums[i], hi)\\n            ti = {k:v for k, v in h[i].items()}\\n            # print(\"-->\", ti)\\n            for k in hi:\\n                ti[k] = ti.get(k, 0) + 1\\n            h.append(ti)\\n            # print(\"-->\", ti, h)\\n        # print(h)\\n        \\n\\n        ans = []\\n        for i in range(n):\\n            x = 0\\n            for k in h[n]:\\n                if h[n].get(k, 0) - h[i].get(k, 0)>0:\\n                    x += 1\\n            \\n            l, r = i, n-1\\n            while l<r:\\n                mid = (l + r) // 2\\n                \\n                xmid = 0\\n                for k in h[mid+1]:\\n                    if h[mid+1].get(k, 0) - h[i].get(k, 0)>0:\\n                        xmid += 1\\n                \\n                if xmid!=x:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n                    \\n            # print(\"-->\", r, r - i + 1)\\n            size = r - i + 1\\n            ans.append(size)\\n        \\n        # print(\"=\"*20)\\n        return ans\\n    \\nprint = lambda *a, **aa: ()\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nExample 1: [1, 0, 2, 1, 3]\\nh: {0: [0, 3, 4], 1: [2, 4]}\\n+  0 2 size: 3 h: [[0, 3, 4], [2, 4]]\\n+  1 3 size: 3 h: [[3, 4], [2, 4]]\\n+  2 3 size: 2 h: [[3, 4], [2, 4]]\\n+  3 4 size: 2 h: [[3, 4], [4]]\\n+  4 4 size: 1 h: [[4], [4]]\\nans: [3, 3, 2, 2, 1]\\n==================== \\n\\nExample 2: [1, 2]\\nh: {0: [0], 1: [1]}\\n+  0 1 size: 2 h: [[0], [1]]\\n+  1 1 size: 1 h: [[], [1]]\\nans: [2, 1]\\n==================== \\n```\n```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        def bins(k):\\n            ret = []\\n            while k>0:\\n                ret.append(k%2)\\n                k = k // 2\\n            return ret\\n        \\n        n = len(nums)\\n        h = [[] for _ in range(32)]\\n        for i in range(n):\\n            bi = bins(nums[i])\\n            for j in range(len(bi)):\\n                if bi[j]==1:\\n                    h[j].append(i)\\n                    \\n        print(nums)\\n        print(\"h:\", {i:h[i] for i in range(len(h)) if len(h[i])>0})\\n        \\n        vt = [0 for _ in range(32)]\\n        lh = [len(h[i]) for i in range(32)] \\n        ans = []\\n        for i in range(n):\\n            r = i\\n            for k in range(32):\\n                if vt[k]<lh[k] and h[k][vt[k]]<i:\\n                    vt[k] += 1\\n                if vt[k]<lh[k]:\\n                    r = max(r, h[k][vt[k]])\\n            \\n            print(\"+ \", i, r, \"size:\", r - i + 1, \"h:\", [h[i][vt[i]:] for i in range(len(h)) if len(h[i])>0])\\n            ans.append(r - i + 1)\\n        print(\"ans:\", ans)\\n        print(\"=\"*20, \"\\\\n\")\\n        return ans\\n\\t\\t\\nprint = lambda *a, **aa: ()\\n```\n```\\nclass Solution:            \\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        TLE with BinSearch\\n        \"\"\"\\n        def bins(k):\\n            ret = []\\n            while k>0:\\n                ret.append(k%2)\\n                k = k // 2\\n            return ret\\n        \\n        n = len(nums)\\n        \\n        h = [{}]\\n        for i in range(n):\\n            bi = bins(nums[i])\\n            hi = {i:1 for i in range(len(bi)) if bi[i]==1}\\n            # print(nums[i], hi)\\n            ti = {k:v for k, v in h[i].items()}\\n            # print(\"-->\", ti)\\n            for k in hi:\\n                ti[k] = ti.get(k, 0) + 1\\n            h.append(ti)\\n            # print(\"-->\", ti, h)\\n        # print(h)\\n        \\n\\n        ans = []\\n        for i in range(n):\\n            x = 0\\n            for k in h[n]:\\n                if h[n].get(k, 0) - h[i].get(k, 0)>0:\\n                    x += 1\\n            \\n            l, r = i, n-1\\n            while l<r:\\n                mid = (l + r) // 2\\n                \\n                xmid = 0\\n                for k in h[mid+1]:\\n                    if h[mid+1].get(k, 0) - h[i].get(k, 0)>0:\\n                        xmid += 1\\n                \\n                if xmid!=x:\\n                    l = mid + 1\\n                else:\\n                    r = mid\\n                    \\n            # print(\"-->\", r, r - i + 1)\\n            size = r - i + 1\\n            ans.append(size)\\n        \\n        # print(\"=\"*20)\\n        return ans\\n    \\nprint = lambda *a, **aa: ()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588613,
                "title": "python3-all-about-bits",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6a0ecd6849b23f4b7ac9cf2a51afa017995e6c23) for solutions of biweekly 87. \\n\\nLearned this wonderful implementation from @lee215\\n```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        ans = [0]*len(nums)\\n        seen = [0]*30 \\n        for i in range(len(nums)-1, -1, -1): \\n            for j in range(30): \\n                if nums[i] & 1<<j: seen[j] = i \\n            ans[i] = max(1, max(seen)-i+1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestSubarrays(self, nums: List[int]) -> List[int]:\\n        ans = [0]*len(nums)\\n        seen = [0]*30 \\n        for i in range(len(nums)-1, -1, -1): \\n            for j in range(30): \\n                if nums[i] & 1<<j: seen[j] = i \\n            ans[i] = max(1, max(seen)-i+1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588577,
                "title": "o-n-cpp-bit-manipulation",
                "content": "store the index of i-th bit which contribute in the BITWISE OR. and for each index calculate the last index for which we get all the bit. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& arr) {\\n        vector<set<int>> bit(32);\\n        int num = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            for(int j = 0; j<32; j++){\\n                if(arr[i]&(1<<j)){\\n                    bit[j].insert(i);\\n                    num|=(1<<j);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i<arr.size(); i++){\\n            \\n            int m = i;\\n            \\n            for(int j = 0; j<32; j++){\\n                if(bit[j].size()){\\n                    int a = *bit[j].begin();\\n                    m = max(m, a);\\n                    if(a==i){\\n                        bit[j].erase(a);\\n                    }\\n                }\\n            }\\n            \\n            ans.push_back(m-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHappy coding :):):)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& arr) {\\n        vector<set<int>> bit(32);\\n        int num = 0;\\n        for(int i = 0; i<arr.size(); i++){\\n            for(int j = 0; j<32; j++){\\n                if(arr[i]&(1<<j)){\\n                    bit[j].insert(i);\\n                    num|=(1<<j);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i<arr.size(); i++){\\n            \\n            int m = i;\\n            \\n            for(int j = 0; j<32; j++){\\n                if(bit[j].size()){\\n                    int a = *bit[j].begin();\\n                    m = max(m, a);\\n                    if(a==i){\\n                        bit[j].erase(a);\\n                    }\\n                }\\n            }\\n            \\n            ans.push_back(m-i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2069245,
                "content": [
                    {
                        "username": "kumarabhinav14122",
                        "content": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        map<int,queue<int>> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=31;j++)\\n            {\\n                if(nums[i]&(1<<j))\\n                {\\n                    mp[j].push(i);\\n                }\\n            }\\n        }\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int mx=-1;\\n            for(auto it:mp)\\n            {\\n               mx=max(mx,it.second.front());\\n            }\\n            for(auto it:mp)\\n            {\\n               if(it.second.front()==i) \\n               {\\n                   it.second.pop();\\n               }                \\n            }\\n            cout<<mx<<endl;\\n            if(mx==-1) res[i]=1;\\n            else\\n               res[i]=(mx-i+1);\\n        }\\n        return res;\\n    }\\n};\\n\\nPlease anyone check , what\\'s wrong with this code."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The testcases are weak. My ~O(n^2) python solution beats 100%..."
                    },
                    {
                        "username": "vipul0092",
                        "content": "This is definitely feels like a hard problem to me, because there are so many ways to approach it.\nAnd if you don't know the exact correct way to approach it, implementing it is not that straightforward."
                    },
                    {
                        "username": "gashst950510",
                        "content": "With test case being [8,10,8]\nShould the answer not be [3,1,1]?\n\nThe expected answer is [2,1,1] instead.\n\nFor the first element in the answer, below are all the possible subarray:\n[8], 8 = 8\n[8, 10], 8 ^ 10 = 2\n[8, 10, 8], 8 ^ 10 ^ 8 = 10 --> max XOR value with subarray size 3\n\n----------------------------------------------------\n\nUpdate: The question says OR instead of XOR. I am dumb."
                    }
                ]
            },
            {
                "id": 2064965,
                "content": [
                    {
                        "username": "kumarabhinav14122",
                        "content": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        map<int,queue<int>> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=31;j++)\\n            {\\n                if(nums[i]&(1<<j))\\n                {\\n                    mp[j].push(i);\\n                }\\n            }\\n        }\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int mx=-1;\\n            for(auto it:mp)\\n            {\\n               mx=max(mx,it.second.front());\\n            }\\n            for(auto it:mp)\\n            {\\n               if(it.second.front()==i) \\n               {\\n                   it.second.pop();\\n               }                \\n            }\\n            cout<<mx<<endl;\\n            if(mx==-1) res[i]=1;\\n            else\\n               res[i]=(mx-i+1);\\n        }\\n        return res;\\n    }\\n};\\n\\nPlease anyone check , what\\'s wrong with this code."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The testcases are weak. My ~O(n^2) python solution beats 100%..."
                    },
                    {
                        "username": "vipul0092",
                        "content": "This is definitely feels like a hard problem to me, because there are so many ways to approach it.\nAnd if you don't know the exact correct way to approach it, implementing it is not that straightforward."
                    },
                    {
                        "username": "gashst950510",
                        "content": "With test case being [8,10,8]\nShould the answer not be [3,1,1]?\n\nThe expected answer is [2,1,1] instead.\n\nFor the first element in the answer, below are all the possible subarray:\n[8], 8 = 8\n[8, 10], 8 ^ 10 = 2\n[8, 10, 8], 8 ^ 10 ^ 8 = 10 --> max XOR value with subarray size 3\n\n----------------------------------------------------\n\nUpdate: The question says OR instead of XOR. I am dumb."
                    }
                ]
            },
            {
                "id": 2004125,
                "content": [
                    {
                        "username": "kumarabhinav14122",
                        "content": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        map<int,queue<int>> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=31;j++)\\n            {\\n                if(nums[i]&(1<<j))\\n                {\\n                    mp[j].push(i);\\n                }\\n            }\\n        }\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int mx=-1;\\n            for(auto it:mp)\\n            {\\n               mx=max(mx,it.second.front());\\n            }\\n            for(auto it:mp)\\n            {\\n               if(it.second.front()==i) \\n               {\\n                   it.second.pop();\\n               }                \\n            }\\n            cout<<mx<<endl;\\n            if(mx==-1) res[i]=1;\\n            else\\n               res[i]=(mx-i+1);\\n        }\\n        return res;\\n    }\\n};\\n\\nPlease anyone check , what\\'s wrong with this code."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The testcases are weak. My ~O(n^2) python solution beats 100%..."
                    },
                    {
                        "username": "vipul0092",
                        "content": "This is definitely feels like a hard problem to me, because there are so many ways to approach it.\nAnd if you don't know the exact correct way to approach it, implementing it is not that straightforward."
                    },
                    {
                        "username": "gashst950510",
                        "content": "With test case being [8,10,8]\nShould the answer not be [3,1,1]?\n\nThe expected answer is [2,1,1] instead.\n\nFor the first element in the answer, below are all the possible subarray:\n[8], 8 = 8\n[8, 10], 8 ^ 10 = 2\n[8, 10, 8], 8 ^ 10 ^ 8 = 10 --> max XOR value with subarray size 3\n\n----------------------------------------------------\n\nUpdate: The question says OR instead of XOR. I am dumb."
                    }
                ]
            },
            {
                "id": 1918495,
                "content": [
                    {
                        "username": "kumarabhinav14122",
                        "content": "class Solution {\\npublic:\\n    vector<int> smallestSubarrays(vector<int>& nums) {\\n        map<int,queue<int>> mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=31;j++)\\n            {\\n                if(nums[i]&(1<<j))\\n                {\\n                    mp[j].push(i);\\n                }\\n            }\\n        }\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int mx=-1;\\n            for(auto it:mp)\\n            {\\n               mx=max(mx,it.second.front());\\n            }\\n            for(auto it:mp)\\n            {\\n               if(it.second.front()==i) \\n               {\\n                   it.second.pop();\\n               }                \\n            }\\n            cout<<mx<<endl;\\n            if(mx==-1) res[i]=1;\\n            else\\n               res[i]=(mx-i+1);\\n        }\\n        return res;\\n    }\\n};\\n\\nPlease anyone check , what\\'s wrong with this code."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The testcases are weak. My ~O(n^2) python solution beats 100%..."
                    },
                    {
                        "username": "vipul0092",
                        "content": "This is definitely feels like a hard problem to me, because there are so many ways to approach it.\nAnd if you don't know the exact correct way to approach it, implementing it is not that straightforward."
                    },
                    {
                        "username": "gashst950510",
                        "content": "With test case being [8,10,8]\nShould the answer not be [3,1,1]?\n\nThe expected answer is [2,1,1] instead.\n\nFor the first element in the answer, below are all the possible subarray:\n[8], 8 = 8\n[8, 10], 8 ^ 10 = 2\n[8, 10, 8], 8 ^ 10 ^ 8 = 10 --> max XOR value with subarray size 3\n\n----------------------------------------------------\n\nUpdate: The question says OR instead of XOR. I am dumb."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Money Required Before Transactions",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code><font face=\"monospace\">transactions</font></code>, where <code>transactions[i] = [cost<sub>i</sub>, cashback<sub>i</sub>]</code>.</p>\n\n<p>The array describes transactions, where each transaction must be completed exactly once in <strong>some order</strong>. At any given moment, you have a certain amount of <code>money</code>. In order to complete transaction <code>i</code>, <code>money &gt;= cost<sub>i</sub></code> must hold true. After performing a transaction, <code>money</code> becomes <code>money - cost<sub>i</sub> + cashback<sub>i</sub></code>.</p>\n\n<p>Return<em> the minimum amount of </em><code>money</code><em> required before any transaction so that all of the transactions can be completed <strong>regardless of the order</strong> of the transactions.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> transactions = [[2,1],[5,0],[4,2]]\n<strong>Output:</strong> 10\n<strong>Explanation:\n</strong>Starting with money = 10, the transactions can be performed in any order.\nIt can be shown that starting with money &lt; 10 will fail to complete all transactions in some order.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> transactions = [[3,0],[0,3]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\n- If transactions are in the order [[3,0],[0,3]], the minimum money required to complete the transactions is 3.\n- If transactions are in the order [[0,3],[3,0]], the minimum money required to complete the transactions is 0.\nThus, starting with money = 3, the transactions can be performed in any order.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= transactions.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>transactions[i].length == 2</code></li>\n\t<li><code>0 &lt;= cost<sub>i</sub>, cashback<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2588034,
                "title": "java-c-python-easy-and-coincise",
                "content": "# **Intuition**\\nThe worst case is losing all money first,\\nthen we earn money later.\\n<br>\\n\\n# **Explanation**\\nFirst we calculate the sum of all money we can lose.\\nThat is the sum of lost money is\\n`sum_lose = sum(max(0, cost[i] - cashback[i]))`\\n\\nAssume before the last transaction thet lose money,\\nwe have `money = cost[i]`,\\nwe spent all money as cost for this transaction,\\nwe have no money left.\\nAfter transaction, we have `money = cashback[i]`.\\n\\nSo the initial money is at least `sum_lose + cashback[i]`\\nand after all losing money,\\nwe need at least `max(cost[i])`,\\nwhere `cost[i]` is the cost for all earning money transaction.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long minimumMoney(int[][] A) {\\n        long res = 0; int v = 0;\\n        for (int[] a : A) {\\n            v = Math.max(v, Math.min(a[0], a[1]));\\n            res += Math.max(a[0] - a[1], 0);\\n        }\\n        return res + v;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long minimumMoney(vector<vector<int>>& A) {\\n        long long res = 0; int v = 0;\\n        for (auto& a : A) {\\n            v = max(v, min(a[0], a[1]));\\n            res += max(a[0] - a[1], 0);\\n        }\\n        return res + v;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minimumMoney(self, A):\\n        res = v = 0\\n        for i,j in A:\\n            res += max(0, i - j)\\n            v = max(v, min(i, j))\\n        return res + v\\n```\\n**Python 1-line**\\n```py\\n    def minimumMoney(self, A):\\n        return sum(max(0, i - j) for i, j in A) + max(map(min, A))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long minimumMoney(int[][] A) {\\n        long res = 0; int v = 0;\\n        for (int[] a : A) {\\n            v = Math.max(v, Math.min(a[0], a[1]));\\n            res += Math.max(a[0] - a[1], 0);\\n        }\\n        return res + v;\\n    }\\n```\n```cpp\\n    long long minimumMoney(vector<vector<int>>& A) {\\n        long long res = 0; int v = 0;\\n        for (auto& a : A) {\\n            v = max(v, min(a[0], a[1]));\\n            res += max(a[0] - a[1], 0);\\n        }\\n        return res + v;\\n    }\\n```\n```py\\n    def minimumMoney(self, A):\\n        res = v = 0\\n        for i,j in A:\\n            res += max(0, i - j)\\n            v = max(v, min(i, j))\\n        return res + v\\n```\n```py\\n    def minimumMoney(self, A):\\n        return sum(max(0, i - j) for i, j in A) + max(map(min, A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2587905,
                "title": "python-explanation-with-pictures-greedy",
                "content": "### Sorting is not needed, please see [Lee\\'s solution](https://leetcode.com/problems/minimum-money-required-before-transactions/discuss/2588034/JavaC%2B%2BPython-Easy-and-Coincise).\\n\\n\\n<br>\\n<br>\\n\\n\\n\\nLet\\'s focus on the first half, the `n` transcations that `cost > cashback`.\\n\\n![image](https://assets.leetcode.com/users/images/e969e8c8-c43f-45eb-9fd2-1ecb1fc77ecb_1663430455.5225406.png)\\n\\nSince we will finish all the `loss` transactions anyway with a specific starting budget.\\nSuppose we have had an order with the maximum budget, regardless of the order of the first `n - 1` transactions, which transaction we shall do **last**? The one with the largest cashback.\\n\\n![image](https://assets.leetcode.com/users/images/2b19e330-0241-46dd-ab03-e71fd9ec1598_1663430461.0073833.png)\\n\\nOnce we finished the last transaction, we go for the **second last** one. Similarly, regardless of the order of the first `n - 2` transactions, we finish the one with the highest cashback last. \\n\\nSo on so forth, until we finish the order of all transactions.\\n\\nFor earning transactions, since the budget will monotonically increasing, we put the one with the maximum cost first. After finishing all `loss` transactions, our budget should be no less than the maximum cost.\\n\\n![image](https://assets.leetcode.com/users/images/0f2b2954-211e-4b65-b77f-87c464192f29_1663430467.404248.png)\\n\\n\\n**python**\\n\\n```\\ndef minimumMoney(self, A: List[List[int]]) -> int:\\n        # Splist transcations into two groups and sort according to the order.\\n        L, E = [a for a in A if a[0] > a[1]], [a for a in A if a[0] <= a[1]]\\n        L.sort(key = lambda x:  x[1])\\n        \\n        # budget: minimum budget we have met.\\n        # curr: current budget we have.\\n        budget, curr = 0, 0\\n        \\n        for a, b in L:\\n            curr -= a\\n            budget = min(budget, curr)\\n            curr += b\\n        \\n        if E:\\n            curr -= max(e[0] for e in E)\\n            budget = min(budget, curr)\\n\\n        return -budget\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef minimumMoney(self, A: List[List[int]]) -> int:\\n        # Splist transcations into two groups and sort according to the order.\\n        L, E = [a for a in A if a[0] > a[1]], [a for a in A if a[0] <= a[1]]\\n        L.sort(key = lambda x:  x[1])\\n        \\n        # budget: minimum budget we have met.\\n        # curr: current budget we have.\\n        budget, curr = 0, 0\\n        \\n        for a, b in L:\\n            curr -= a\\n            budget = min(budget, curr)\\n            curr += b\\n        \\n        if E:\\n            curr -= max(e[0] for e in E)\\n            budget = min(budget, curr)\\n\\n        return -budget\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2591571,
                "title": "dip-explained-with-pictures-c-code-easy-to-understand",
                "content": "A short question summary:\\n\\nWe are given some **transaction as [cost, cashback]**.\\nWe need to have **atleast cost amount of money** to proceed with the transaction after which our **new money is old_money - cost + cashback**.\\n\\nWe need to return min money required such that no matter how the transactions are arranged, we can complete all transactions.\\n\\n**Intuition:**\\n\\nIf we can somehow get the worst possible permuation of the transactions then we can get our answer easily either by just traversing the permutation or by doing binary search over answer.\\n\\n**Let\\'s Understand Dip now**\\n\\nAssume I have a perumation of orders as:\\n[6,4] \\u2014> [10,2] \\u2014> [1,6] \\u2014> [5,11] \\u2014> [3,1]\\nwhere first element is cost and second element is cashback.\\n\\nNow let\\'s assume we have currMoney as 0.\\n\\nSo if we proceed with first transaction our currMoney will be -6.\\n(Just don\\'t think about the condition that we will need atleast cost money, you will understand it later)\\n\\nAnd if we go to second transation firt we add cashback of last transaction to i.e. +4 and then I incur the cost of next transaction i.e. -10.\\n\\nSo if we plot a graph of currMoney over all transactions, it will be like this:\\n![image](https://assets.leetcode.com/users/images/491154ee-45fa-4ac1-b2b6-fa3a3aa04df5_1663485485.5813172.png)\\nWhat\\'s the most negative value we have in this graph?\\nIts -12\\nand That is minimum dip.\\nAnd also 12 is the min amount required if we want to complete all transaction.\\n(Now think about that condition which I said don\\'t think about :) )\\n\\nTake 12 and do the transaction on the permuations given above, you will understand better.\\n\\nNow I hope the concept of dip is clear\\n\\n**But how it is useful?**\\n\\nIt is useful in sorting the array, so that we can get the worst permuation.\\n\\nSo basically we have to arrange transactions in such a way that we get the least Min Dip possible across all of it\\'s permuatations.\\n\\nConsider only 2 transactions:\\n[6,7] and [5,11]\\n\\nNow either our arrange can be [6,7] \\u2014> [5,11] or it can be [5,11] \\u2014> [6,7].\\n\\nNow see their graph:\\n![image](https://assets.leetcode.com/users/images/ed06f8b2-0d5b-4361-aa4d-c363105010f6_1663486118.816935.png)\\nAs you can see that [6,7] --> [5,11] is giving us a better min dip of -6 instead of -5 of another option.\\n\\nThat\\'s how we have to sort the array.\\n\\nIn our comparator or Lambda function, wichever you used for sorting, we have two transactions.\\n\\nLet\\'s say transaction a and b.\\n\\nWe have to check whether a-->b is giving a better min dip or b-->a and then according to that we have to return true or false.\\n\\nHow to calculate dip?\\n\\nFor transaction of a-->b, there will be two dips:\\nFirst dip = -a[cost]\\nSecond dip = -a[cost] + a[cashback] - b[cost]\\n\\n(If you didn\\'t get this then think how lines are flowing in the graph where two permuations were compared. It first goes down, then goes up and then again down. We are calculating those two down points)\\n\\nIf both have same dip, then prefer the transaction which have higher cost.\\n\\nFor **Code explanation** you can checkout the video I attached at the bottom of this post.\\n\\nC++ Code for Binary Search over answer:\\n```\\nclass Solution {\\npublic:\\n\\n\\tbool isPossible(long long currMoney, vector<vector<int>>& transactions)\\n\\t{\\n\\t\\tfor (vector<int>& t : transactions)\\n\\t\\t{\\n\\t\\t\\tif (currMoney < t[0])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tcurrMoney += -t[0] + t[1];\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlong long minimumMoney(vector<vector<int>>& transactions) {\\n\\t\\tint opt1,opt2;\\n        sort(begin(transactions), end(transactions),\\n\\t\\t     [&](vector<int>& a, vector<int>& b)\\n\\t\\t{\\n\\t\\t\\topt1 = min(-a[0], -a[0] + a[1] - b[0]); //a->b\\n\\t\\t\\topt2 = min(-b[0], -b[0] + b[1] - a[0]); //b->a\\n\\t\\t\\tif (opt1 != opt2)\\n\\t\\t\\t\\treturn opt1 < opt2;\\n\\t\\t\\treturn a[0] > b[0];\\n\\t\\t});\\n\\t\\tlong long left = 0;\\n\\t\\tlong long right = LLONG_MAX;\\n\\t\\tlong long ans, mid;\\n\\t\\twhile (left <= right)\\n\\t\\t{\\n\\t\\t\\tmid = left + (right - left) / 2;\\n\\t\\t\\tif (isPossible(mid, transactions))\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\nC++ Code for optimised approach(Just get Min dip and return absolute of it):\\n```\\nclass Solution {\\npublic:\\n\\tlong long minimumMoney(vector<vector<int>>& transactions) {\\n\\t\\tint opt1, opt2;\\n\\t\\tsort(begin(transactions), end(transactions),\\n\\t\\t     [&](vector<int>& a, vector<int>& b)\\n\\t\\t{\\n\\t\\t\\topt1 = min(-a[0], -a[0] + a[1] - b[0]); //a->b\\n\\t\\t\\topt2 = min(-b[0], -b[0] + b[1] - a[0]); //b->a\\n\\t\\t\\tif (opt1 != opt2)\\n\\t\\t\\t\\treturn opt1 < opt2;\\n\\t\\t\\treturn a[0] > b[0];\\n\\t\\t});\\n\\t\\tlong long currMoney = 0;\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (vector<int>& currTaransaction : transactions)\\n\\t\\t{\\n\\t\\t\\tcurrMoney -= currTaransaction[0];\\n\\t\\t\\tans = min(ans, currMoney);\\n\\t\\t\\tcurrMoney += currTaransaction[1];\\n\\t\\t}\\n\\t\\treturn abs(ans);\\n\\t}\\n};\\n```\\nTime Complexity - O(nlogn) (sorting)\\nSpace Comlexity - O(1)\\n\\nFor Code Explanation check this video:\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/nXAVgtjvkfc?start=939\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n**If you liked the post then please upvote, it will motivate me to write more of such posts for hard problems.**",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\tbool isPossible(long long currMoney, vector<vector<int>>& transactions)\\n\\t{\\n\\t\\tfor (vector<int>& t : transactions)\\n\\t\\t{\\n\\t\\t\\tif (currMoney < t[0])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tcurrMoney += -t[0] + t[1];\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\n\\tlong long minimumMoney(vector<vector<int>>& transactions) {\\n\\t\\tint opt1,opt2;\\n        sort(begin(transactions), end(transactions),\\n\\t\\t     [&](vector<int>& a, vector<int>& b)\\n\\t\\t{\\n\\t\\t\\topt1 = min(-a[0], -a[0] + a[1] - b[0]); //a->b\\n\\t\\t\\topt2 = min(-b[0], -b[0] + b[1] - a[0]); //b->a\\n\\t\\t\\tif (opt1 != opt2)\\n\\t\\t\\t\\treturn opt1 < opt2;\\n\\t\\t\\treturn a[0] > b[0];\\n\\t\\t});\\n\\t\\tlong long left = 0;\\n\\t\\tlong long right = LLONG_MAX;\\n\\t\\tlong long ans, mid;\\n\\t\\twhile (left <= right)\\n\\t\\t{\\n\\t\\t\\tmid = left + (right - left) / 2;\\n\\t\\t\\tif (isPossible(mid, transactions))\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tlong long minimumMoney(vector<vector<int>>& transactions) {\\n\\t\\tint opt1, opt2;\\n\\t\\tsort(begin(transactions), end(transactions),\\n\\t\\t     [&](vector<int>& a, vector<int>& b)\\n\\t\\t{\\n\\t\\t\\topt1 = min(-a[0], -a[0] + a[1] - b[0]); //a->b\\n\\t\\t\\topt2 = min(-b[0], -b[0] + b[1] - a[0]); //b->a\\n\\t\\t\\tif (opt1 != opt2)\\n\\t\\t\\t\\treturn opt1 < opt2;\\n\\t\\t\\treturn a[0] > b[0];\\n\\t\\t});\\n\\t\\tlong long currMoney = 0;\\n\\t\\tlong long ans = 0;\\n\\t\\tfor (vector<int>& currTaransaction : transactions)\\n\\t\\t{\\n\\t\\t\\tcurrMoney -= currTaransaction[0];\\n\\t\\t\\tans = min(ans, currMoney);\\n\\t\\t\\tcurrMoney += currTaransaction[1];\\n\\t\\t}\\n\\t\\treturn abs(ans);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590024,
                "title": "two-cases",
                "content": "Based on the [lee215](https://leetcode.com/problems/minimum-money-required-before-transactions/discuss/2588034/JavaC%2B%2BPython-Easy-and-Coincise) solution.\\n\\nWe need to compute how much money we must `spend`, which is `sum(cost_i - cachback_i)`.\\n\\nNote that we do not care about the profit - as we can execute those transactions at the very end. We just assume that we need to spend zero on those transactions.\\n\\nThere is also an overhead on top of what we need to `spend`. We have two cases here:\\n- For `negative` transactions, the cashback from the very last transaction cannot be utilized, so we need to add it to `spend`. \\n\\t- We track the maximum `cashback` for those transactions.\\n- For `neutral` transactions, we need an upfront cost to make the first transaction.\\n\\t- We track the maximum `cost` for such transactions.\\n\\nIn the end, we need at least `spend` + `max(cachback, cost)` money to execute all transactions in any order.\\n\\n**C++**\\n```cpp\\nlong long minimumMoney(vector<vector<int>>& ts) {\\n    long long spend = 0, cashback = 0, cost = 0;\\n    for (auto &t : ts) {\\n        if (t[0] > t[1]) {\\n            spend += t[0] - t[1];\\n            cashback = max(cashback, (long long)t[1]);\\n        } else\\n            cost = max(cost, (long long)t[0]);\\n    }\\n    return spend + max(cashback, cost);\\n}  \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long minimumMoney(vector<vector<int>>& ts) {\\n    long long spend = 0, cashback = 0, cost = 0;\\n    for (auto &t : ts) {\\n        if (t[0] > t[1]) {\\n            spend += t[0] - t[1];\\n            cashback = max(cashback, (long long)t[1]);\\n        } else\\n            cost = max(cost, (long long)t[0]);\\n    }\\n    return spend + max(cashback, cost);\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588404,
                "title": "c-binary-search-with-comparator",
                "content": "This code is for those who tried to apply binary search and failed because of comparator :( \\n\\nBasically in this comparator, we are just checking whether A -> B gives more negative money or B -> A gives more negative money.\\n\\n```\\nbool compare1(vector<int>&A, vector<int>&B)\\n{\\n    int opt1 = min(-A[0], -A[0] + A[1] -B[0]) ;\\n    int opt2 = min(-B[0], -B[0]+B[1]-A[0]) ;\\n    \\n    if(opt1 < opt2) return true ;\\n    if(opt1 > opt2) return false ;\\n    \\n    return A[0] > B[0] ;\\n}\\n    \\n\\nclass Solution {\\npublic:\\n    \\n    bool canSolve(vector<vector<int>>&A, long long mid)\\n    {        \\n        for(int i=0; i<A.size(); i++)\\n        {\\n            if(mid < A[i][0]) return false ;\\n            \\n            mid = mid - (long)A[i][0] + (long)A[i][1] ; \\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n\\n    long long Solve(vector<vector<int>>&A)\\n    {\\n        long long start = 0 , end = LONG_MAX ;\\n        \\n        while(start < end)\\n        {\\n            if(end-start==1) break; \\n            \\n            long long mid = start + (end-start)/2 ;\\n            \\n            if(canSolve(A,mid)) {\\n                end = mid ;\\n            }\\n            else{\\n                start = mid;\\n            }\\n        }\\n        \\n        if(canSolve(A,start)) return start ;\\n        \\n        return end;         \\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& A) {\\n     \\n        long long Ans = -1e9 ;        \\n        sort(A.begin(),A.end(), compare1) ; \\n        Ans = max(Ans,Solve(A)) ;\\n        return Ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nbool compare1(vector<int>&A, vector<int>&B)\\n{\\n    int opt1 = min(-A[0], -A[0] + A[1] -B[0]) ;\\n    int opt2 = min(-B[0], -B[0]+B[1]-A[0]) ;\\n    \\n    if(opt1 < opt2) return true ;\\n    if(opt1 > opt2) return false ;\\n    \\n    return A[0] > B[0] ;\\n}\\n    \\n\\nclass Solution {\\npublic:\\n    \\n    bool canSolve(vector<vector<int>>&A, long long mid)\\n    {        \\n        for(int i=0; i<A.size(); i++)\\n        {\\n            if(mid < A[i][0]) return false ;\\n            \\n            mid = mid - (long)A[i][0] + (long)A[i][1] ; \\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n\\n    long long Solve(vector<vector<int>>&A)\\n    {\\n        long long start = 0 , end = LONG_MAX ;\\n        \\n        while(start < end)\\n        {\\n            if(end-start==1) break; \\n            \\n            long long mid = start + (end-start)/2 ;\\n            \\n            if(canSolve(A,mid)) {\\n                end = mid ;\\n            }\\n            else{\\n                start = mid;\\n            }\\n        }\\n        \\n        if(canSolve(A,start)) return start ;\\n        \\n        return end;         \\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& A) {\\n     \\n        long long Ans = -1e9 ;        \\n        sort(A.begin(),A.end(), compare1) ; \\n        Ans = max(Ans,Solve(A)) ;\\n        return Ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587984,
                "title": "easiest-hard-tag-question-brute-force-to-optimal",
                "content": "\\n**Approach 1**\\n\\n**Explanation** \\n\\nwe have to sort the transactions array based on the increasing value of the cashback, of transactions\\n\\nnow you should notice one thing we have to take all the transactions whose cost>cashback\\nsee this test case, \\n[[7,2],[0,10],[5,0],[4,1],[5,8],[5,9]]\\n\\nat the end , when we completely iterate our transactions array and our \\nmax store value13 and ans store 15\\n\\nbut still there is one way by which we can increase our ans, \\nif we add the maximum cost of transaction which we have not included yet\\n\\nmeans we can add maximum cost from [[0,10],[5,8],[5,9]],  \\nthat is we can still add, 5 to our max and this may be the maximum ans\\nand then update our ans as ans=Math.max(ans,max+ab);\\n\\n**TIME COMPLEXITY - Nlog(N)\\nSPACE COMPLEXITY - O(1)**\\n```\\npublic long minimumMoney(int[][] transactions) {\\n        Arrays.sort(transactions,(int a[],int b[])->(a[1]-b[1]));\\n\\n        long max=0,ans=0,ab=0;\\n        for(int a[]:transactions){\\n            if(a[0]>a[1]){\\n                max+=a[0];\\n                ans=Math.max(ans,max);\\n                max-=a[1];\\n            }\\n            else ab=Math.max(ab,a[0]);\\n        }\\n        ans=Math.max(ans,max+ab);\\n        return ans;\\n    }\\n```\\n\\t\\n**Approach 2**\\n\\nExplanation\\n\\nIdea behind this approach is also the same,\\n\\nFor 2nd iteration i am just finding the sum of the differnce between the transactions where\\ncost > cashback, because we have to consider that transactions.\\n\\nFor the first iteration our transaction array,  i am finding the last transaction that i should consider\\nto create maximum ans possible,\\n\\nNow here we have a case \\nThere is no transaction in which cost < cashback ,\\nfor example [[5,1],[5,2]]\\nfor this case our re will store 2, means i have to consider [5,2] transaction at last, \\n\\n\\nTIME COMPLEXITY -O(N)\\nSPACE COMPLEXITY - O(1)\\n```\\npublic long minimumMoney(int[][] transactions) {\\n        \\n        long res=0;\\n        for(int arr[]:transactions){\\n            res=Math.max(res, Math.min(arr[0],arr[1]));\\n        }\\n        for(int arr[]:transactions){\\n            res+=Math.max(arr[0]-arr[1],0);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Approach 3**\\n\\nTIME COMPLEXITY -O(N)\\nSPACE COMPLEXITY - O(1)\\n```\\npublic long minimumMoney(int[][] transactions) {\\n        \\n        long res = 0, temp = 0;\\n        for (int[] arr : transactions) {\\n            temp = Math.max(temp, Math.min(arr[0], arr[1]));\\n            res += Math.max(arr[0] - arr[1], 0);\\n        }\\n        return res + temp;\\n    }\\n```\\n\\t\\n**Please Upvote the Post**",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\npublic long minimumMoney(int[][] transactions) {\\n        Arrays.sort(transactions,(int a[],int b[])->(a[1]-b[1]));\\n\\n        long max=0,ans=0,ab=0;\\n        for(int a[]:transactions){\\n            if(a[0]>a[1]){\\n                max+=a[0];\\n                ans=Math.max(ans,max);\\n                max-=a[1];\\n            }\\n            else ab=Math.max(ab,a[0]);\\n        }\\n        ans=Math.max(ans,max+ab);\\n        return ans;\\n    }\\n```\n```\\npublic long minimumMoney(int[][] transactions) {\\n        \\n        long res=0;\\n        for(int arr[]:transactions){\\n            res=Math.max(res, Math.min(arr[0],arr[1]));\\n        }\\n        for(int arr[]:transactions){\\n            res+=Math.max(arr[0]-arr[1],0);\\n        }\\n        return res;\\n    }\\n```\n```\\npublic long minimumMoney(int[][] transactions) {\\n        \\n        long res = 0, temp = 0;\\n        for (int[] arr : transactions) {\\n            temp = Math.max(temp, Math.min(arr[0], arr[1]));\\n            res += Math.max(arr[0] - arr[1], 0);\\n        }\\n        return res + temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587878,
                "title": "python3-list-comprehension-2-lines-o-n",
                "content": "Pick a transaction to be the very last one you perform. \\n\\nBefore you perform this transaction, you want to perform every transaction that raises your cost, ie, every transaction where the cost is more than the cash back. Then add the cost of your chosen transaction and take the max over all possible final transactions.\\n\\nFirst we compute the sum of every transaction where the cost is greater than the cash back.\\n\\nIf we choose our final transaction to be one where the cost is greater than the cash back, we\\'ve already added the cost, so we just undo the subtraction of the cash back.\\n\\nOtherwise, we just add the cost.\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        s = sum([cost - cashback for cost, cashback in transactions if cost > cashback])\\n        return max([cashback + s if cost > cashback else s + cost for cost, cashback in transactions])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        s = sum([cost - cashback for cost, cashback in transactions if cost > cashback])\\n        return max([cashback + s if cost > cashback else s + cost for cost, cashback in transactions])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587889,
                "title": "sort-with-custom-comparator-with-detailed-explanations",
                "content": "Observation 1: If we pick some permutaion and go through the transactions in that order, the amount of money we need at the start = - the lowest our money dipped at any point. Same logic as https://leetcode.com/problems/dungeon-game/\\neg if the permutation is [5, 0] [4, 2] [2, 1], then the amount of money at each point in time will be -5, -5, -9, -7, -9, -8\\nLowest = -9, so amount of money needed at the start = 9.\\n\\nSo we have to find the permutation where the money dips the lowest. (ie the worst permutation)\\n\\nHow do we find the worst permutaton ? One way is to try and establish an ordering between the transactions such that we end up with the worst permuation. Some orderings that come to mind are ordering by the difference between cahsback and cost, ratio between them, etc, but each of those have simple counter examples. \\n\\nInstead of assigning some value to a transaction like t[1] - t[0] or t[1] / t[0] and sorting by that, we can look at 2 transactions t1 and t2 together and see whether t1 then t2 or t2 then t1 is worse. This can easily be done. Just simulate t1 then t2 and t2 then t1 and see in which one the money dips lower.\\nSo given two transactions a and b, we can tell whether a < b or b < a. For our comparator to be valid, a<b and b<c should imply a<c. This can also easily be verified. Also whether we do t1 then t2 or t2 then t1, the balance remains the same in the end. \\n\\nNow we simply sort by this comparator and simulate the the transactions in the worst permutation and find the answer.\\n\\nJava code (a bit messy):\\n```\\nclass Solution {\\n    private static class Transaction implements Comparable<Transaction> {\\n        int minus;\\n        int plus;\\n        Pair(int minus, int plus) {\\n            this.minus = minus;\\n            this.plus = plus;\\n        }\\n        \\n        @Override\\n        public int compareTo(Transaction other) {\\n            // this then other\\n            int option1 = Math.min(-this.minus, -this.minus + this.plus - other.minus);\\n            \\n            // other then this\\n            int option2 = Math.min(-other.minus, -other.minus + other.plus - this.minus);\\n            \\n            if(option1 < option2) {\\n                return -1;\\n            }\\n            if(option1 > option2) {\\n                return 1;\\n            }\\n\\t\\t\\t// in case of a tie, order by cost / cashback\\n            if(this.minus < other.minus) {\\n                return -1;\\n            }\\n            if(this.minus > other.minus) {\\n                return 1;\\n            }\\n            return this.plus - other.plus;\\n        }\\n        \\n    }\\n    \\n    public long minimumMoney(int[][] transactions) {\\n        List<Transaction> list = new ArrayList<>();\\n        \\n        for(int[] row : transactions) {\\n            list.add(new Transaction(row[0], row[1]));\\n        }\\n        \\n        Collections.sort(list);\\n        \\n        long res = Integer.MAX_VALUE;\\n        long money = 0;\\n        for(Transaction t : list) {\\n            money -= t.minus;\\n            res = Math.min(res, money);\\n            money += t.plus;\\n        }\\n        \\n        return -res;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    private static class Transaction implements Comparable<Transaction> {\\n        int minus;\\n        int plus;\\n        Pair(int minus, int plus) {\\n            this.minus = minus;\\n            this.plus = plus;\\n        }\\n        \\n        @Override\\n        public int compareTo(Transaction other) {\\n            // this then other\\n            int option1 = Math.min(-this.minus, -this.minus + this.plus - other.minus);\\n            \\n            // other then this\\n            int option2 = Math.min(-other.minus, -other.minus + other.plus - this.minus);\\n            \\n            if(option1 < option2) {\\n                return -1;\\n            }\\n            if(option1 > option2) {\\n                return 1;\\n            }\\n\\t\\t\\t// in case of a tie, order by cost / cashback\\n            if(this.minus < other.minus) {\\n                return -1;\\n            }\\n            if(this.minus > other.minus) {\\n                return 1;\\n            }\\n            return this.plus - other.plus;\\n        }\\n        \\n    }\\n    \\n    public long minimumMoney(int[][] transactions) {\\n        List<Transaction> list = new ArrayList<>();\\n        \\n        for(int[] row : transactions) {\\n            list.add(new Transaction(row[0], row[1]));\\n        }\\n        \\n        Collections.sort(list);\\n        \\n        long res = Integer.MAX_VALUE;\\n        long money = 0;\\n        for(Transaction t : list) {\\n            money -= t.minus;\\n            res = Math.min(res, money);\\n            money += t.plus;\\n        }\\n        \\n        return -res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588022,
                "title": "greedy",
                "content": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        re = 0\\n        m = 0\\n        for i in transactions:\\n            if i[0] - i[1] > 0: \\n                re += i[0] - i[1]\\n                m = max(m, i[1])\\n            else:\\n                m = max(m, i[0])\\n        return re + m\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        re = 0\\n        m = 0\\n        for i in transactions:\\n            if i[0] - i[1] > 0: \\n                re += i[0] - i[1]\\n                m = max(m, i[1])\\n            else:\\n                m = max(m, i[0])\\n        return re + m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588010,
                "title": "c-o-n-short-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& a) {\\n        long long total = 0, ans = 0;\\n        for (auto x : a) if (x[1] < x[0]) total += x[0] - x[1];\\n        for (auto x : a) ans = max(ans, x[0] + total - max(0, x[0] - x[1]));\\n        return ans;\\n    }\\n};\\n```\\n\\nThe core point of this solution is to loop through exactly which transaction will be the bar to set the initial money.\\n\\nTo calculate that, we pre-calculate `total =  all possibly money owed` after running the transactions.\\nThen we loop through the critical transaction `x` where `x` will be the last bar.\\nIn this case `x` will happen after all transactions that is losing money.\\n\\nSince `total` may also include the money owed from `x`, so we undo it by `total - max(0, x[0] - x[1])` Thus the answer for `x` will be `x[0] + total - max(0, x[0] - x[1])`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& a) {\\n        long long total = 0, ans = 0;\\n        for (auto x : a) if (x[1] < x[0]) total += x[0] - x[1];\\n        for (auto x : a) ans = max(ans, x[0] + total - max(0, x[0] - x[1]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587886,
                "title": "binary-search",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    \\n    bool check(ll m, vector<vector<int>>&transactions)\\n    {\\n        ll d = 0;\\n        for(int i=0; i<transactions.size(); i++)\\n        {\\n            if(transactions[i][0] >= transactions[i][1])\\n                d += transactions[i][0] - transactions[i][1];\\n        }\\n        for(int i = 0; i<transactions.size(); i++)\\n        {\\n            if(transactions[i][0] >= transactions[i][1])\\n            {\\n                ll d1 = transactions[i][0] - transactions[i][1];\\n                if(m - (d - d1) < transactions[i][0])\\n                    return false;\\n            }\\n            else\\n            {\\n                if(m - d < transactions[i][0])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        ll lo = 0, hi = 1e18, ans = 1e18;\\n        while(lo <= hi)\\n        {\\n            ll mid = lo + (hi - lo)/2;\\n            if(check(mid, transactions))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    \\n    bool check(ll m, vector<vector<int>>&transactions)\\n    {\\n        ll d = 0;\\n        for(int i=0; i<transactions.size(); i++)\\n        {\\n            if(transactions[i][0] >= transactions[i][1])\\n                d += transactions[i][0] - transactions[i][1];\\n        }\\n        for(int i = 0; i<transactions.size(); i++)\\n        {\\n            if(transactions[i][0] >= transactions[i][1])\\n            {\\n                ll d1 = transactions[i][0] - transactions[i][1];\\n                if(m - (d - d1) < transactions[i][0])\\n                    return false;\\n            }\\n            else\\n            {\\n                if(m - d < transactions[i][0])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        ll lo = 0, hi = 1e18, ans = 1e18;\\n        while(lo <= hi)\\n        {\\n            ll mid = lo + (hi - lo)/2;\\n            if(check(mid, transactions))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589010,
                "title": "c-greedy-explanation",
                "content": "**Approach:**\\n\\n* first find out the total money that we can lose.\\n* i.e the sum of lost money is\\n* ```sum_lose = sum(max(0, cost[i] - cashback[i]))```\\n* let the last transaction be at i\\n* now, the money we would have lost before the last transaction would be\\n\\t* ``` total_loss - loss at i```\\n* in order to perform the last transaction we want ```money>=cost[i]```\\n* so money should be atleast \\n\\t* ```money = total_loss - loss at i + cost[i]```\\n* now, ```loss at i = min(0,cost[i]-cashback[i])```\\n* consider the below equations to understand better\\n\\t* ![image](https://assets.leetcode.com/users/images/07fd25d1-d7e8-4f85-b338-674694688ad6_1663440603.2570097.jpeg)\\n* from the above equations we can say that \\n\\t* ```k = min(cost[i],cashback[i])```\\n* we will consider the worst case so take maximum value of k\\n* ```k =max(k, min(v[0], v[1]));```\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    long long minimumMoney(vector<vector<int>> &transactions)\\n    {\\n        long long total_loss = 0;\\n        int k = 0;\\n        for (auto &v : transactions)\\n        {\\n            k = max(k, min(v[0], v[1])); // v[0] = cost[i], v[1] = cashback[i]\\n            total_loss += max(v[0] - v[1], 0);\\n        }\\n        return total_loss + k;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```sum_lose = sum(max(0, cost[i] - cashback[i]))```\n``` total_loss - loss at i```\n```money>=cost[i]```\n```money = total_loss - loss at i + cost[i]```\n```loss at i = min(0,cost[i]-cashback[i])```\n```k = min(cost[i],cashback[i])```\n```k =max(k, min(v[0], v[1]));```\n```\\nclass Solution\\n{\\npublic:\\n    long long minimumMoney(vector<vector<int>> &transactions)\\n    {\\n        long long total_loss = 0;\\n        int k = 0;\\n        for (auto &v : transactions)\\n        {\\n            k = max(k, min(v[0], v[1])); // v[0] = cost[i], v[1] = cashback[i]\\n            total_loss += max(v[0] - v[1], 0);\\n        }\\n        return total_loss + k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588519,
                "title": "c-sorting-binary-search-on-answer",
                "content": "```\\nStep-1: We need an order that will cost maximum amount of money to complete all transactions. Then find the minimum amount using binary search.\\nStep-2: How to find that particular order? \"Take less cashback and spend more money \".\\nSplit transactions into two part:\\na: cashback less than cost.\\nb: cashback greater or equal to cost\\n\\ncase a: Sort them in ascending order of \"cashback\". (Take less cashback)\\ncase b: Sort them in descending order of \"cost\". (Spend more money, because all of them are giving cashback >= cost)\\n\\n\\n\\nclass Solution {\\n    static bool cmp1(vector<int> &a, vector<int> &b) {\\n        if(a[1] == b[1])\\n            return a[0] > b[0];\\n        return a[1] < b[1];\\n    }\\n    \\n    static bool cmp2(vector<int> &a, vector<int> &b) {\\n        return a[0] > b[0];\\n    }\\n    \\n    bool possible(vector<vector<int>>& v1, vector<vector<int>>& v2, long long ans) {\\n        for(int i = 0; i < v1.size(); i++) {\\n            if(ans >= v1[i][0]) \\n                ans = (ans - v1[i][0] + v1[i][1]);\\n            else \\n                return false;\\n        }\\n        \\n        for(int i = 0; i < v2.size(); i++) {\\n            if(ans >= v2[i][0]) \\n                ans = (ans - v2[i][0] + v2[i][1]);\\n            else \\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n\\npublic:\\n    long long minimumMoney(vector<vector<int>>& tr) {\\n        vector<vector<int>> v1, v2;\\n        for(int i = 0; i < tr.size(); i++) {\\n            if(tr[i][1] >= tr[i][0])\\n                v2.push_back({tr[i][0], tr[i][1]});\\n            else \\n                v1.push_back({tr[i][0], tr[i][1]});\\n        }\\n        \\n        sort(v1.begin(), v1.end(), cmp1);\\n        sort(v2.begin(), v2.end(), cmp2);\\n        \\n        long long ans = 0;\\n        long long low = 0, high = 1e16;\\n        while(low <= high) {\\n            long long mid = (low + high) / 2;\\n            if(possible(v1, v2, mid)) {\\n                ans = mid;\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nStep-1: We need an order that will cost maximum amount of money to complete all transactions. Then find the minimum amount using binary search.\\nStep-2: How to find that particular order? \"Take less cashback and spend more money \".\\nSplit transactions into two part:\\na: cashback less than cost.\\nb: cashback greater or equal to cost\\n\\ncase a: Sort them in ascending order of \"cashback\". (Take less cashback)\\ncase b: Sort them in descending order of \"cost\". (Spend more money, because all of them are giving cashback >= cost)\\n\\n\\n\\nclass Solution {\\n    static bool cmp1(vector<int> &a, vector<int> &b) {\\n        if(a[1] == b[1])\\n            return a[0] > b[0];\\n        return a[1] < b[1];\\n    }\\n    \\n    static bool cmp2(vector<int> &a, vector<int> &b) {\\n        return a[0] > b[0];\\n    }\\n    \\n    bool possible(vector<vector<int>>& v1, vector<vector<int>>& v2, long long ans) {\\n        for(int i = 0; i < v1.size(); i++) {\\n            if(ans >= v1[i][0]) \\n                ans = (ans - v1[i][0] + v1[i][1]);\\n            else \\n                return false;\\n        }\\n        \\n        for(int i = 0; i < v2.size(); i++) {\\n            if(ans >= v2[i][0]) \\n                ans = (ans - v2[i][0] + v2[i][1]);\\n            else \\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n\\npublic:\\n    long long minimumMoney(vector<vector<int>>& tr) {\\n        vector<vector<int>> v1, v2;\\n        for(int i = 0; i < tr.size(); i++) {\\n            if(tr[i][1] >= tr[i][0])\\n                v2.push_back({tr[i][0], tr[i][1]});\\n            else \\n                v1.push_back({tr[i][0], tr[i][1]});\\n        }\\n        \\n        sort(v1.begin(), v1.end(), cmp1);\\n        sort(v2.begin(), v2.end(), cmp2);\\n        \\n        long long ans = 0;\\n        long long low = 0, high = 1e16;\\n        while(low <= high) {\\n            long long mid = (low + high) / 2;\\n            if(possible(v1, v2, mid)) {\\n                ans = mid;\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588464,
                "title": "if-you-still-struggled-to-understand-after-reading-lee215-and-bakerston-s-posts",
                "content": "Read lee215 and Balerston\\'s posts first.\\n\\nCode optimized for easy understanding:\\n\\n```\\nclass Solution {\\n    public long minimumMoney(int[][] txs) {\\n        long netLosingCost = 0;\\n        int maxCashBack = 0;\\n        int maxCost = 0;\\n        for (int[] t : txs) {\\n            if (t[0] > t[1]) { // losing transactions\\n                netLosingCost += t[0] - t[1];\\n                maxCashBack = Math.max(maxCashBack, t[1]);\\n            } else { // earning transactions\\n                maxCost = Math.max(maxCost, t[0]);\\n            }\\n        }\\n        return netLosingCost + Math.max(maxCashBack, maxCost);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] txs) {\\n        long netLosingCost = 0;\\n        int maxCashBack = 0;\\n        int maxCost = 0;\\n        for (int[] t : txs) {\\n            if (t[0] > t[1]) { // losing transactions\\n                netLosingCost += t[0] - t[1];\\n                maxCashBack = Math.max(maxCashBack, t[1]);\\n            } else { // earning transactions\\n                maxCost = Math.max(maxCost, t[0]);\\n            }\\n        }\\n        return netLosingCost + Math.max(maxCashBack, maxCost);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588714,
                "title": "math-solution-o-n-time-o-1-space-100-time-memory",
                "content": "The task can be represented as follows:\\nWe have to find the maximum value of the sequence `cost_i1` - `cashback_i1` + `cost_j2` - `cashback_i2` + ... + `cost_j`:\\n<img src=\"https://latex.codecogs.com/svg.image?result=max_{t_i,j}{\\\\left&space;(\\\\sum_{t_i&space;\\\\neq&space;j}(cost_{t_i}-cashback_{t_i})&plus;cost_j\\\\right&space;)}\">\\n\\n\\nIt will take O(2^N) time to calculate all the options, so this solution is unacceptable. \\nBut we can notice that we needed to sum only that differences `cost_i - cashback_i` where `cost_i` is greater than `cashback_i`:\\n<img src=\"https://latex.codecogs.com/svg.image?max_{t_i,j}{\\\\left&space;(\\\\sum_{t_i&space;\\\\neq&space;j}(cost_{t_i}-cashback_{})&plus;cost_j\\\\right&space;)}\\\\leqslant&space;max_j{\\\\left&space;(\\\\sum_{i&space;\\\\neq&space;j,&space;cost_i>cashback_i}(cost_i-cashback_i)&plus;cost_j\\\\right&space;)}\">\\n\\n\\nSo we can extract the sum from under the maximum operation: \\n<img src=\"https://latex.codecogs.com/svg.image?max_j{\\\\left&space;(\\\\sum_{i&space;\\\\neq&space;j,&space;cost_i>cashback_i}(cost_i-cashback_i)&plus;cost_j\\\\right&space;)}&space;=&space;\\\\\\\\\\\\\\\\\\\\\\\\\\\\sum_{cost_i>cashback_i}(cost_i-cashback_i)&plus;max_j(cost_j-(cost_j-cashback_j)\\\\cdot&space;\\\\left&space;[&space;cost_j&space;>&space;cashback_j&space;\\\\right&space;])&space;=&space;\\\\\\\\\\\\\\\\\\\\sum_{cost_i>cashback_i}(cost_i-cashback_i)&plus;max_j(cashback_j&space;\\\\;\\\\;if\\\\;(cost_j&space;>&space;cashback_j)&space;\\\\;else&space;\\\\;\\\\;&space;cost_j)&space;\">\\n\\nSo we can solve the task just in one pass:\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        sum_diff = 0\\n        max_term = 0\\n        \\n        for cost, cashback in transactions:\\n            if cost > cashback:\\n                sum_diff += cost - cashback\\n                max_term = max(max_term, cashback)\\n            else:\\n                max_term = max(max_term, cost)\\n\\n        return sum_diff + max_term\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        sum_diff = 0\\n        max_term = 0\\n        \\n        for cost, cashback in transactions:\\n            if cost > cashback:\\n                sum_diff += cost - cashback\\n                max_term = max(max_term, cashback)\\n            else:\\n                max_term = max(max_term, cost)\\n\\n        return sum_diff + max_term\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588064,
                "title": "simple-python-solution-with-explanation-just-5-lines-of-code-o-n-time-complexity",
                "content": "Basic idea:\\n===========\\n1.  You need to ensure that you have enough money to pay for the ```cost``` at every transaction.\\n\\n2.  At the last transaction, you need to ensure you have at least ```cost``` for last transaction in cash. \\n\\tAt all other earlier transactions, you need to ensure you have at least ```sum(cost - cashback)``` for earlier transactions.\\n\\n3.  You can derive this by:\\n\\t- running through an interation with all possible combinations of last transaction\\n\\t\\t- in each case, add the minimum ```sum(cost - cashback)``` for earlier transactions.\\n\\t- compute the maximum value - this is the result. \\n\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        diff = [max(cost - cashback, 0) for cost, cashback in transactions]\\n        max_amt, sumdiff = 0, sum(diff)\\n        for i in range(len(transactions)):\\n            max_amt = max(max_amt, sumdiff - diff[i] + transactions[i][0])\\n            \\n        return max_amt\\n```",
                "solutionTags": [],
                "code": "```cost```\n```cost```\n```sum(cost - cashback)```\n```sum(cost - cashback)```\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        diff = [max(cost - cashback, 0) for cost, cashback in transactions]\\n        max_amt, sumdiff = 0, sum(diff)\\n        for i in range(len(transactions)):\\n            max_amt = max(max_amt, sumdiff - diff[i] + transactions[i][0])\\n            \\n        return max_amt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604001,
                "title": "the-easiest-possible-explanation-you-are-looking-for",
                "content": "It took me a while to get this through my head. So take your time but make sure you understand this.\\n\\n**Alse note that this is not the perfect O(N) solution. You can see Lee215 soln for that. This is O(NlogN) solution but this is what was easier for me to understand**\\n\\n**Now lets start**\\n\\n1. First, know that there are 2 kinds of transaction, one where you earn more than you spend (good transactions), and one where you earn less than you spend (bad transactions).\\n2.  In the worst case, you will need to perform all the bad transactions at first. What would be even worse? You will have to perform the worst bad transaction first. What does that mean? It means, the transaction, that gives you the least cashback among all bad transactions.\\n3.  Now that the bad transactions are over, now we will perform the good transactions. Now what can be the worst case here? It can be that you need to perform the costliest transaction among the good transactions first. But once you have done the costliest transaction, you no longer need to check the further transactions. Why so? Because this is a good transaction. If you  spend say 10$, you are guaranteed to receive a cashback of 10$ or more. And since this was the costliest transaction among the good transaction, you will now have money for the rest of them anyway, so no need to consider them.\\n\\n**Lets take an example to understand even better**\\n\\nwe are given this transaction array :`[[7,2],[0,10],[5,0],[4,1],[5,8],[5,9]]`\\nLets separate the good and bad transactions.\\n\\n**good transactions** :`[[0,10],[5,8],[5,9]]`\\n**bad transactions** :`[[7,2],[5,0],[4,1]]`\\n\\nNow cosider the **bad transactions**:\\n\\tWhich one among `[[7,2],[5,0],[4,1]]` is the worst transaction you might have to make? The answer to that is `[5,0]`. **Why?** because you are spending 5$ and getting nothing in return. What will be the next worst transaction? It will be `[4,1]` for the same reason. Do you see the **pattern**?\\n\\t\\nWe do the transaction with the least amount of cashback first. Because there we need to have our own money and can\\'t rely on cashback. So if we follow this,\\n**First transaction:** `cur += 5` = 5; `need = max(need,cur)` = 5; `cur -= 0` = 5\\n**Second transaction:** `cur += 4` = 9; `need = max(need,cur)` = 9; `cur -= 1` = 8  ( **NOTE** the need will first become 9, because we get a cashback only after paying the cost first. So in order to make the first and the second transaction, you need minimum of 9$)\\n**Third transaction:** `cur += 7` = 15;  `need = max(need,cur)` = 15; `cur -= 2` = 13\\n\\n**Okay so at this point all the bad transactions are over and everything bad that could have happened has happened... Except one\\uD83D\\uDE05**\\nEven though we only have good transactions now, we need to pay the cost for them to recieve the cashback. This is simpler though. We only need to figure out which is the costliest good transaction. **Why?** because once we pay that amount, we know since its a good transaction, we will get atleast the same amount back if not more.\\n\\nSo the ***worst*** **good transaction** is `[5,8] or [5,9]`. `cur += 5` = 18; `need = max(need,cur)` = 18\\n\\nAnd we got our answer. We need a minimum of 18$ in order to complete all transaction in any order!\\n\\n**Let\\'s finally have a look at the code to solidify what I just explained**\\n\\n```\\ndef minimumMoney(self, transactions: List[List[int]]) -> int:\\n        \\n\\tgoodTransactions = [txn for txn in transactions if txn[0] <= txn[1]]\\n\\tbadTransactions = [txn for txn in transactions if txn[0] > txn[1]]\\n\\n\\tbadTransactions.sort(key=lambda x: x[1])\\n\\n\\tneed = 0\\n\\tcur_amount = 0\\n\\n\\tfor cost,cashback in badTransactions:\\n\\t\\tcur_amount += cost\\n\\t\\tneed = max(need,cur_amount)\\n\\t\\tcur_amount -= cashback\\n\\n\\tif goodTransactions:\\n\\t\\tcostliest_good_transaction = max(goodTransactions, key=lambda x: x[0])\\n\\t\\tcur_amount += costliest_good_transaction[0]  \\n\\t\\tneed = max(need, cur_amount)\\n\\n\\treturn need\\n```\\t\\t\\n\\n***If this post was helpful at all, pls do upvote : )***",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\ndef minimumMoney(self, transactions: List[List[int]]) -> int:\\n        \\n\\tgoodTransactions = [txn for txn in transactions if txn[0] <= txn[1]]\\n\\tbadTransactions = [txn for txn in transactions if txn[0] > txn[1]]\\n\\n\\tbadTransactions.sort(key=lambda x: x[1])\\n\\n\\tneed = 0\\n\\tcur_amount = 0\\n\\n\\tfor cost,cashback in badTransactions:\\n\\t\\tcur_amount += cost\\n\\t\\tneed = max(need,cur_amount)\\n\\t\\tcur_amount -= cashback\\n\\n\\tif goodTransactions:\\n\\t\\tcostliest_good_transaction = max(goodTransactions, key=lambda x: x[0])\\n\\t\\tcur_amount += costliest_good_transaction[0]  \\n\\t\\tneed = max(need, cur_amount)\\n\\n\\treturn need\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2588487,
                "title": "easy-crisp-and-concise",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>> &transactions) {\\n        int mx = 0;\\n        for (auto &v : transactions) mx = max(mx, min(v[0], v[1]));\\n        long long res = mx;\\n        for (auto &v : transactions) res += max(0, v[0] - v[1]);\\n        return res;\\n    }\\n};\\n```\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>> &transactions) {\\n        int mx = 0;\\n        long long res = 0;\\n        for (auto &v : transactions) {\\n            mx = max(mx, min(v[0], v[1]));\\n            res += max(0, v[0] - v[1]);\\n        }\\n        res += mx;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>> &transactions) {\\n        int mx = 0;\\n        for (auto &v : transactions) mx = max(mx, min(v[0], v[1]));\\n        long long res = mx;\\n        for (auto &v : transactions) res += max(0, v[0] - v[1]);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>> &transactions) {\\n        int mx = 0;\\n        long long res = 0;\\n        for (auto &v : transactions) {\\n            mx = max(mx, min(v[0], v[1]));\\n            res += max(0, v[0] - v[1]);\\n        }\\n        res += mx;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587968,
                "title": "python-3-8-lines-solution-with-intuition-and-steps",
                "content": "### Intuition:\\nWe need to find the order of transactions which leads to highest accumulative money consumption at a certain time. To achieve this, the first step we should do is to find out all transactions that introduce a loss (cost > cashback). \\n\\n### Step:\\n- Find all loss transactions and calculate `total_loss` (make this positive, absolute value of the loss)\\n- Find the maximum cost in all rest transactions without the loss `profit_transaction_max_cost`\\n- Calculate `total_loss + profit_transaction_max_cost`\\n- It is also possible that the cost of one of the loss transaction is very high and we achieve the highest accumulative money consumption without using the `profit_transaction_max_cost` from the rest transactions. In this case, say this loss transaction hass loss_i, cost_i and cash_back_i, the highest consumption should be `total_loss - loss_i + cost_i = total_loss - (cost_i - cash_back_i) + cost_i = total_loss + cash_back_i`, thus we only need to find the maximum of all `cach_back` in loss transactions\\n- Campare these two values to find the highest moeny consumption\\n\\n### Solution:\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        loss_transactions = [[j, j - i] for i, j in transactions if j - i < 0]\\n        total_loss = sum([-loss for _, loss in loss_transactions])\\n        profit_transaction_max_cost = max([i for i, j in transactions if j - i >= 0])\\n        res = total_loss + profit_transaction_max_cost\\n        if loss_transactions:\\n            res = max(res, total_loss + max(loss_transactions)[0])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        loss_transactions = [[j, j - i] for i, j in transactions if j - i < 0]\\n        total_loss = sum([-loss for _, loss in loss_transactions])\\n        profit_transaction_max_cost = max([i for i, j in transactions if j - i >= 0])\\n        res = total_loss + profit_transaction_max_cost\\n        if loss_transactions:\\n            res = max(res, total_loss + max(loss_transactions)[0])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738372,
                "title": "easy-and-simple-explanation-with-proper-comments-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    // Finding the worst sequence which will lead us to the maximum.\\n    long long minimumMoney(vector<vector<int>>& vp) {\\n        int n=vp.size();\\n        long long y=0,z=0;\\n        vector<pair<int,int>>v; // All the transactions which will lead us to the maximum money required.\\n        for(int i=0;i<n;i++){\\n            // transactions which needs more money and gives less cashback.\\n            if(vp[i][0]-vp[i][1]>0){\\n                v.push_back({vp[i][0],vp[i][1]});\\n                y+=vp[i][0]-vp[i][1];\\n                \\n            }\\n            // transactions which needs less money and gives more cashback in return.\\n            else{\\n                // Storing the maximum cost which a transaction needs.\\n                // This transaction could be the last transaction where the maximum will reach midway of the transaction.\\n                z=max(z,(long long)vp[i][0]);\\n            }\\n        }\\n        // 1st case: Maximum being all the transactions + the last we recieved from z.\\n        long long ans=max(ans,y+z);\\n        for(int i=0;i<v.size();i++){\\n            // 2nd case: If ith transactio is the last transaction where we reach the maximum.\\n            ans=max(ans,y+v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Finding the worst sequence which will lead us to the maximum.\\n    long long minimumMoney(vector<vector<int>>& vp) {\\n        int n=vp.size();\\n        long long y=0,z=0;\\n        vector<pair<int,int>>v; // All the transactions which will lead us to the maximum money required.\\n        for(int i=0;i<n;i++){\\n            // transactions which needs more money and gives less cashback.\\n            if(vp[i][0]-vp[i][1]>0){\\n                v.push_back({vp[i][0],vp[i][1]});\\n                y+=vp[i][0]-vp[i][1];\\n                \\n            }\\n            // transactions which needs less money and gives more cashback in return.\\n            else{\\n                // Storing the maximum cost which a transaction needs.\\n                // This transaction could be the last transaction where the maximum will reach midway of the transaction.\\n                z=max(z,(long long)vp[i][0]);\\n            }\\n        }\\n        // 1st case: Maximum being all the transactions + the last we recieved from z.\\n        long long ans=max(ans,y+z);\\n        for(int i=0;i<v.size();i++){\\n            // 2nd case: If ith transactio is the last transaction where we reach the maximum.\\n            ans=max(ans,y+v[i].second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625493,
                "title": "simple-code-greedy-logic-o-n",
                "content": "->for passing any permutation, the min value should pass the worst case scenario\\n->the transactions can be divided into two parts\\n1-> cost>cashback   \\n   In this case we have to pay cost[i]-cashback[i] for each transaction\\n   for the last transaction we have to pay the cost -cashback for all the previous transactions +cost for the last       cashback\\n   This means that max cost is  sum(cost -cashback) +max(cashback)\\n   2-> cost<cashback \\n     for the worst case we have to make transactioin with the max cost at the beginning\\n   3-> when both exist\\n\\t we have to make all positive(cost-cashback) transctions first\\n\\t Then the negative (cost- cashback)\\n\\t ALSO WE HAVE TO CHECK AT TRANSITION FROM POSITIVE TO NEGATIVE  \\n\\t sum(cost- cashback)-> this we calculate only for positive transactions \\n\\t it will be either sum(cost- cashback)+ max(positive transaction cashback) <-ie. till buying the last positive transaction\\n\\t or sum(cost- cashback)+ max(cost negative transactions)   <--ie. buying all positive transaction and then max cost transaction in the negative category\\n\\n```\\n long long minimumMoney(vector<vector<int>>& tr) {\\n        int n = tr.size();\\n        int maxpos=0;\\n        long long possum=0;\\n        int maxcostneg=0;\\n        for(int i= 0;i<n;i++){\\n            if(tr[i][0]>tr[i][1]){\\n                maxpos=max(tr[i][1],maxpos);\\n                possum+= tr[i][0]-tr[i][1];\\n            }\\n            else maxcostneg=max(maxcostneg,tr[i][0]);\\n        }\\n        return max(maxpos,maxcostneg)+possum;\\n        \\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n long long minimumMoney(vector<vector<int>>& tr) {\\n        int n = tr.size();\\n        int maxpos=0;\\n        long long possum=0;\\n        int maxcostneg=0;\\n        for(int i= 0;i<n;i++){\\n            if(tr[i][0]>tr[i][1]){\\n                maxpos=max(tr[i][1],maxpos);\\n                possum+= tr[i][0]-tr[i][1];\\n            }\\n            else maxcostneg=max(maxcostneg,tr[i][0]);\\n        }\\n        return max(maxpos,maxcostneg)+possum;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2609010,
                "title": "from-formula-not-intuition",
                "content": "Lots of people can\\'t understand the intuition. But it\\'s ok. We can always figure out the formula to get the ans.\\nAssume  diff_j = cost_j - cashback_j, x - sum(diff_j) >= cost_i always be true for all i. (j = 0, 1, 2 ... i-1)\\n=> we can get: x >= cost_i + sum(diff_i)\\n=> x >= max((cost_i) + sum(diff_i))\\n=> we transfer the problem to calculate the max(cost_i + sum(diff_i)) => max(cost_i) + max(sum(diff_j)) = res\\n\\nLet\\'s solve this max(cost_i + sum(diff_i)) case by case.\\ncase 1: max(cost_i) is from diff_i >= 0\\nres = sum of diffs (that all diff >= 0) - (cost_i - cashback_i) + cost_i\\nres = sum of diffs (that all diff >= 0) + cashback_i\\nwhich means we need to find the max cashback among all diffs that diff > 0.\\n\\ncase2: max(cost_i) is from diff_i < 0\\nres = sum of diffs (that all diff >= 0) + max(cost_i). (cost_i from the diff_i that diff_i < 0)\\n\\nfinal res = Math.max(case1, case2)\\n```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        int n = transactions.length;\\n        long maxCost = 0;\\n        long maxCashBack = 0;\\n        long sum = 0;\\n        for (int[] t: transactions) {\\n            int cost = t[0];\\n            int back = t[1];\\n            if (cost - back > 0) {\\n                sum += (long)(cost - back);\\n                maxCashBack = Math.max(maxCashBack, back);\\n            } else {\\n                maxCost = Math.max(cost, maxCost);\\n            }\\n        }\\n        return sum + Math.max(maxCashBack, maxCost);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        int n = transactions.length;\\n        long maxCost = 0;\\n        long maxCashBack = 0;\\n        long sum = 0;\\n        for (int[] t: transactions) {\\n            int cost = t[0];\\n            int back = t[1];\\n            if (cost - back > 0) {\\n                sum += (long)(cost - back);\\n                maxCashBack = Math.max(maxCashBack, back);\\n            } else {\\n                maxCost = Math.max(cost, maxCost);\\n            }\\n        }\\n        return sum + Math.max(maxCashBack, maxCost);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596516,
                "title": "c-explanation-with-proof",
                "content": "For simplicity, I\\'ll call cash as A, cashback as B\\nThe i-th transaction will be (A[i], B[i])\\nConsider some arbitrary order of transactions: (A[0], B[0]), (A[1], B[1]), ..., (A[n-1], B[n-1])\\nWhat are the constrains? \\n1. `Money >= A[0]`\\n2. `Money - A[0] + B[0] >= A[1]`\\n3. ....\\n\\nSo, the i-th constraint will be: \\n`Money - A[0] + B[0] - A[1] + B[1] - ... - A[i-1] + B[i - 1] >= A[i]`\\n`Money >= (A[0] - B[0]) + (A[1] - B[1]) + ... + (A[i-1] - B[i-1]) + A[i]`\\n\\nLets call `D[i] = A[i] - B[i]`\\n\\nSo, we have: `Money >= D[0] + .. + D[i-1] + A[i]` for all i.\\n\\nCombining all the constrains, we\\'d have: `Money >= max_i D[0] + ... + D[i-1] + A[i]`\\n\\nFor every `i`, we need to find the max. value of sum of D\\'s not including `i`. This can be done by picking all the D\\'s that are positive(of course, if the value of D[i] > 0, don\\'t forget to subtract it).\\n\\nHere\\'s the code:\\n```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        To complete [a_i, b_i], following needs to hold\\n        \\n        1. money >= a_0\\n        2. money - a_0 + b_0 >= a_1\\n        3. money - a_0 + b_0 - a_1 + b_1 >= a_2 ...\\n        \\n        money >= (a_0 + ... + a_i) - (b_0 + .. + b_(i-1)) = (a_0 - b_0) + ... + (a_(i-1) - b_(i-1)) + a_i\\n        \\n        money >= (d_0 + .. + d_(i-1)) + a_i\\n        \\n        Take max d differences and an a_i which is not in d_i\\n        \\n        b\\'s as small as possible, a\\'s as large possible\\n    */\\n    \\n    long long minimumMoney(vector<vector<int>>& tr) {\\n        int n = tr.size();\\n        using ll = long long;\\n        vector<ll> d(n);\\n        ll pos = 0, neg = 0; \\n            \\n        for (int i = 0; i < n; ++i) {\\n            d[i] = tr[i][0] - tr[i][1];\\n            if (d[i] > 0) pos += d[i];\\n        }\\n        \\n        ll ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            ll sum = pos;\\n            if (d[i] > 0) sum -= d[i];\\n            \\n            ans = max(ans, tr[i][0] + sum);\\n        }\\n        \\n        return ans;\\n        \\n        return 0;\\n    }\\n};\\n```\\n\\nComments/Suggestions are welcome\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        To complete [a_i, b_i], following needs to hold\\n        \\n        1. money >= a_0\\n        2. money - a_0 + b_0 >= a_1\\n        3. money - a_0 + b_0 - a_1 + b_1 >= a_2 ...\\n        \\n        money >= (a_0 + ... + a_i) - (b_0 + .. + b_(i-1)) = (a_0 - b_0) + ... + (a_(i-1) - b_(i-1)) + a_i\\n        \\n        money >= (d_0 + .. + d_(i-1)) + a_i\\n        \\n        Take max d differences and an a_i which is not in d_i\\n        \\n        b\\'s as small as possible, a\\'s as large possible\\n    */\\n    \\n    long long minimumMoney(vector<vector<int>>& tr) {\\n        int n = tr.size();\\n        using ll = long long;\\n        vector<ll> d(n);\\n        ll pos = 0, neg = 0; \\n            \\n        for (int i = 0; i < n; ++i) {\\n            d[i] = tr[i][0] - tr[i][1];\\n            if (d[i] > 0) pos += d[i];\\n        }\\n        \\n        ll ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            ll sum = pos;\\n            if (d[i] > 0) sum -= d[i];\\n            \\n            ans = max(ans, tr[i][0] + sum);\\n        }\\n        \\n        return ans;\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589433,
                "title": "o-n-rigorous-proof-by-induction",
                "content": "If you don\\'t understand why the [solution by @lee215](https://leetcode.com/problems/minimum-money-required-before-transactions/discuss/2588034/JavaC%2B%2BPython-Easy-and-Coincise) works. \\n\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        return sum([max(0, c - b) for c, b in transactions]) + max(map(min, transactions))\\n```\\n**Theorem** The minimum money required for any permutation of transactions is `sum({cost[i] - cashback[i]: cost[i] >= cashback[i]}) + max(max({cashback[i]: cost[i] >= cashback[i]}), max({cost[i]: cashback[i] > cost[i]}))`\\n***Proof***:\\nIt\\'s valid for any permutation of transactions by separating them into winning and losing streaks.\\n* It\\'s a valid start for any transcation, i.e., ` >= max(cost[i])`\\n* If the first streak is winning, the remaining money is no smaller than any cost of the remaining transactions. \\n* If the first streak is losing, the remaining money is still no smaller than any cost of the remaining transactions by Proposition 2. \\n\\n\\n**Proposition 1** If all transactions are winning, i.e., for all `i`, `cashback[i] > cost[i]`, the minimum money required before transactions for any permutation is `max(cost[i])`, and the remaining money **must be** greater than `0`.\\n***Proof***: \\n* Since each transaction will increase our money, it is valid for any permutation of the winnig transactions to go through. \\n* On the other hand, if the starting money is smaller than this, any permutation with the start of `max(cost[i])` will not be valid. \\n\\n\\n**Proposition 2** If all transactions are losing, i.e., all `i`, `cost[i] >= cashback[i]`, the minimum money required before transactions for any permutation is `sum(cost[i] - cashback[i]) + max(cashback[i])`, and the remaining money **must be** `max(cashback[i])`.\\n***Proof***:\\n1. It is apparent when `n = 1`.\\n2. Assume `P(k)` is true, let\\'s consider `P(k+1)`:\\nLet `m` denote the transaction with max cashback. \\n\\t* `sum({cost[i] - cashback[i]: i <= k+1}) + cashback[m]` is valid for any permutation of the `k+1` transactions:\\n\\tWithout loss of generality, assume the first transaction is `j`, the remaining money for the rest `k` transactions becomes \\n\\t`sum({cost[i] - cashback[i]: i <= k+1, i != j}) + cashback[m]`\\n\\t`>=` \\n\\t`sum({cost[i] - cashback[i]: i <= k+1, i != j}) + max({cashback[i]: i <= k+1, i != j})`, and it is enough by `P(k)`.\\n\\t* On the otherhand, the money cannot be lower than it because \\n\\t `sum({cost[i] - cashback[i]: i <= k+1}) + cashback[m]`  \\n\\t `=`\\n\\t `sum({cost[i] - cashback[i]: i <= k+1, i != m}) + cost[m] - cashback[m] + cashback[m]`\\n\\t `=`\\n\\t `sum({cost[i] - cashback[i]: i <= k+1, i != m}) + cost[m]`\\n\\t the first term can be `0`, and any value smaller than `cost[m]` won\\'t be valid for the `k+1`-permutation starting with transaction `m`.\\n\\n\\n\\n\\t \\n\\t \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        return sum([max(0, c - b) for c, b in transactions]) + max(map(min, transactions))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588474,
                "title": "greedy-o-n-solution-no-sorting",
                "content": "**Idea**:: The worst thing that can happen before each transaction is doing all money loosing transaction before the current one.\\nThe money loosing transaction is transaction in which cashback is less than cost\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& t) \\n    {\\n \\n        \\n        long long money=0;\\n        long long ans =0;\\n        vector<int>v;\\n        \\n        for(int i=0;i<t.size();i++)\\n        {\\n            ans = max(ans,1LL*t[i][0]);\\n         \\n        }\\n        \\n        int n = t.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n           if((t[i][1]-t[i][0])<=0)   // A money loosing transaction\\n           {\\n               money+=t[i][1]-t[i][0];\\n           }\\n            \\n            \\n        }\\n\\t\\tans = max(ans,abs(money));\\n        // money stores the money which I have to loose ultimatelty;\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t   \\n\\t\\t    // the worst thing that can happen before ith trancation is doing all money loosing transactions \\n\\t\\t\\t//  before ith one\\n\\t\\t\\t\\n            if((t[i][1]-t[i][0])<=0)  // if ith transaction is money loosing\\n            {\\n                money-=t[i][1]-t[i][0];  // remove contribution of ith transaction which is added in money \\n\\t\\t\\t\\t                                   // above\\n            }\\n            if((money-t[i][0])<0)\\n            {\\n                ans = max(ans,abs(money-t[i][0]));  // money required is max of ans and (cost of ith transaction) + loosing money \\n            } \\n          \\n             if((t[i][1]-t[i][0])<=0) \\n            {\\n                money+=t[i][1]-t[i][0]; // just undo the changes made for ith transaction\\n            }\\n\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& t) \\n    {\\n \\n        \\n        long long money=0;\\n        long long ans =0;\\n        vector<int>v;\\n        \\n        for(int i=0;i<t.size();i++)\\n        {\\n            ans = max(ans,1LL*t[i][0]);\\n         \\n        }\\n        \\n        int n = t.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n           if((t[i][1]-t[i][0])<=0)   // A money loosing transaction\\n           {\\n               money+=t[i][1]-t[i][0];\\n           }\\n            \\n            \\n        }\\n\\t\\tans = max(ans,abs(money));\\n        // money stores the money which I have to loose ultimatelty;\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t   \\n\\t\\t    // the worst thing that can happen before ith trancation is doing all money loosing transactions \\n\\t\\t\\t//  before ith one\\n\\t\\t\\t\\n            if((t[i][1]-t[i][0])<=0)  // if ith transaction is money loosing\\n            {\\n                money-=t[i][1]-t[i][0];  // remove contribution of ith transaction which is added in money \\n\\t\\t\\t\\t                                   // above\\n            }\\n            if((money-t[i][0])<0)\\n            {\\n                ans = max(ans,abs(money-t[i][0]));  // money required is max of ans and (cost of ith transaction) + loosing money \\n            } \\n          \\n             if((t[i][1]-t[i][0])<=0) \\n            {\\n                money+=t[i][1]-t[i][0]; // just undo the changes made for ith transaction\\n            }\\n\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588070,
                "title": "short-o-n-solution-c",
                "content": "The problem was quite straightforward.\\nJust imagine how many losses you can make before each \\'ith\\' Transaction. This will be the peak price to do the following transaction and then just find the maximum of all peak transaction amounts.\\n\\n**Please note some transaction themselves causes loss of money so while calculating the peak you need to remove their loss as loss occurs after the transaction.**\\n\\n**Loss = Transaction_Amount - Cashback**\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        long long negative_sums = 0;\\n        for(auto a : transactions) {\\n            negative_sums += max(0ll , (long long)(a[0] - a[1]));\\n        }\\n        long long ans = 0;\\n        for(auto a : transactions) {\\n            negative_sums -= max(0ll , (long long)(a[0] - a[1]));\\n            ans = max(ans , negative_sums + a[0]);\\n            negative_sums += max(0ll ,(long long)(a[0] - a[1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        long long negative_sums = 0;\\n        for(auto a : transactions) {\\n            negative_sums += max(0ll , (long long)(a[0] - a[1]));\\n        }\\n        long long ans = 0;\\n        for(auto a : transactions) {\\n            negative_sums -= max(0ll , (long long)(a[0] - a[1]));\\n            ans = max(ans , negative_sums + a[0]);\\n            negative_sums += max(0ll ,(long long)(a[0] - a[1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828985,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nbool compare1(vector<int>&A, vector<int>&B)\\n{\\n    int opt1 = min(-A[0], -A[0] + A[1] -B[0]) ;\\n    int opt2 = min(-B[0], -B[0]+B[1]-A[0]) ;\\n    \\n    if(opt1 < opt2) return true ;\\n    if(opt1 > opt2) return false ;\\n    \\n    return A[0] > B[0] ;\\n}\\n    \\n\\nclass Solution {\\npublic:\\n    \\n    bool canSolve(vector<vector<int>>&A, long long mid)\\n    {        \\n        for(int i=0; i<A.size(); i++)\\n        {\\n            if(mid < A[i][0]) return false ;\\n            \\n            mid = mid - (long)A[i][0] + (long)A[i][1] ; \\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n\\n    long long Solve(vector<vector<int>>&A)\\n    {\\n        long long start = 0 , end = LONG_MAX ;\\n        \\n        while(start < end)\\n        {\\n            if(end-start==1) break; \\n            \\n            long long mid = start + (end-start)/2 ;\\n            \\n            if(canSolve(A,mid)) {\\n                end = mid ;\\n            }\\n            else{\\n                start = mid;\\n            }\\n        }\\n        \\n        if(canSolve(A,start)) return start ;\\n        \\n        return end;         \\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& A) {\\n     \\n        long long Ans = -1e9 ;        \\n        sort(A.begin(),A.end(), compare1) ; \\n        Ans = max(Ans,Solve(A)) ;\\n        return Ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool compare1(vector<int>&A, vector<int>&B)\\n{\\n    int opt1 = min(-A[0], -A[0] + A[1] -B[0]) ;\\n    int opt2 = min(-B[0], -B[0]+B[1]-A[0]) ;\\n    \\n    if(opt1 < opt2) return true ;\\n    if(opt1 > opt2) return false ;\\n    \\n    return A[0] > B[0] ;\\n}\\n    \\n\\nclass Solution {\\npublic:\\n    \\n    bool canSolve(vector<vector<int>>&A, long long mid)\\n    {        \\n        for(int i=0; i<A.size(); i++)\\n        {\\n            if(mid < A[i][0]) return false ;\\n            \\n            mid = mid - (long)A[i][0] + (long)A[i][1] ; \\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n\\n    long long Solve(vector<vector<int>>&A)\\n    {\\n        long long start = 0 , end = LONG_MAX ;\\n        \\n        while(start < end)\\n        {\\n            if(end-start==1) break; \\n            \\n            long long mid = start + (end-start)/2 ;\\n            \\n            if(canSolve(A,mid)) {\\n                end = mid ;\\n            }\\n            else{\\n                start = mid;\\n            }\\n        }\\n        \\n        if(canSolve(A,start)) return start ;\\n        \\n        return end;         \\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& A) {\\n     \\n        long long Ans = -1e9 ;        \\n        sort(A.begin(),A.end(), compare1) ; \\n        Ans = max(Ans,Solve(A)) ;\\n        return Ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715774,
                "title": "c-greedy-o-n",
                "content": "```\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        // res - c1 + cb1 - c2 + cb2 +... -cn >=0\\n        // res >= (c1+c2+...+cn) - (cb1-cb2-...cbn) + cbn\\n        long long maxDelta, maxCostPos = 0, maxCbNag = 0;\\n        for(auto& v:transactions){\\n            if (v[0] < v[1])\\n                maxCostPos = max<int>(maxCostPos, v[0]);\\n            else {\\n                maxCbNag = max<int>(maxCbNag, v[1]);\\n                maxDelta += v[0] - v[1];\\n            }\\n        }\\n        return maxDelta + max(maxCostPos , maxCbNag);\\n    }",
                "solutionTags": [],
                "code": "```\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        // res - c1 + cb1 - c2 + cb2 +... -cn >=0\\n        // res >= (c1+c2+...+cn) - (cb1-cb2-...cbn) + cbn\\n        long long maxDelta, maxCostPos = 0, maxCbNag = 0;\\n        for(auto& v:transactions){\\n            if (v[0] < v[1])\\n                maxCostPos = max<int>(maxCostPos, v[0]);\\n            else {\\n                maxCbNag = max<int>(maxCbNag, v[1]);\\n                maxDelta += v[0] - v[1];\\n            }\\n        }\\n        return maxDelta + max(maxCostPos , maxCbNag);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2616400,
                "title": "incorrect-sample-case",
                "content": "Hi all,\\n\\nI am little confused about the first sample case which is `[[2,1],[5,0],[4,2]]`\\n\\nIf we start with money = `8`, and let\\' say we execute the transactions in the order `[[4,2],[2,1],[5,0]]`, \\nthen it will look like, \\n\\n* 8 - 4 + 2 = 6\\n* 6 - 2 + 1 = 5\\n* 5 - 5 + 0 = 0\\n\\nSo, this way, answer for this should be `8` and not `10`. Isn\\'t it?",
                "solutionTags": [],
                "code": "Hi all,\\n\\nI am little confused about the first sample case which is `[[2,1],[5,0],[4,2]]`\\n\\nIf we start with money = `8`, and let\\' say we execute the transactions in the order `[[4,2],[2,1],[5,0]]`, \\nthen it will look like, \\n\\n* 8 - 4 + 2 = 6\\n* 6 - 2 + 1 = 5\\n* 5 - 5 + 0 = 0\\n\\nSo, this way, answer for this should be `8` and not `10`. Isn\\'t it?",
                "codeTag": "Unknown"
            },
            {
                "id": 2615654,
                "title": "python-easy-solution-comparator-function",
                "content": "The idea is to sort the transactions in the order of the most dip in initial money. We can do that easily by writing a custom comparator.\\n\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        \\n        \\n        def compare(x, y):            \\n\\n            if min(-x[0],-x[0] + x[1] - y[0]) < min(-y[0],-y[0] + y[1] - x[0]):\\n                return -1\\n            if min(-x[0],-x[0] + x[1] - y[0]) == min(-y[0],-y[0] + y[1] - x[0]):\\n                if x[0] < y[0]:\\n                    return -1\\n                else:\\n                    return 1\\n            else:\\n                return 1\\n\\n        transactions.sort(key = cmp_to_key(compare))\\n\\t\\t\\n        temp = 0\\n        ans = float(\"inf\")\\n \\n        for x in transactions:\\n            temp = temp - x[0]\\n            ans = min(ans,temp)\\n            \\n            temp = temp + x[1]\\n            \\n            \\n        return -ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        \\n        \\n        def compare(x, y):            \\n\\n            if min(-x[0],-x[0] + x[1] - y[0]) < min(-y[0],-y[0] + y[1] - x[0]):\\n                return -1\\n            if min(-x[0],-x[0] + x[1] - y[0]) == min(-y[0],-y[0] + y[1] - x[0]):\\n                if x[0] < y[0]:\\n                    return -1\\n                else:\\n                    return 1\\n            else:\\n                return 1\\n\\n        transactions.sort(key = cmp_to_key(compare))\\n\\t\\t\\n        temp = 0\\n        ans = float(\"inf\")\\n \\n        for x in transactions:\\n            temp = temp - x[0]\\n            ans = min(ans,temp)\\n            \\n            temp = temp + x[1]\\n            \\n            \\n        return -ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605374,
                "title": "python-3-one-liner-o-n",
                "content": "It is super easy: \\n* the second (sum) part takes the sum of the total cost of the transaction (cost - cashback, if it makes sense to include this transaction, i.e. cost > cashback).\\n* The first term (max) searches for the most costly transacion to make as the last one (only cost operation, no cashback taken). To make the last transaction you need to either choose which `cost - back` from the second part of the equation will be cancelled and replaced with `cost - (cost - back) ` i.e. `back` only, or if it was not included in the sum part (i.e. `cost <= back`) then add `cost` for the last transaction. Whether you take `cost` or `back` is controlled by `min`.\\n```\\nreturn max([min(t) for t in transactions]) + sum([cost - back for cost, back in transactions if cost > back])\\n```",
                "solutionTags": [],
                "code": "```\\nreturn max([min(t) for t in transactions]) + sum([cost - back for cost, back in transactions if cost > back])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2605321,
                "title": "c-6-liner-o-n",
                "content": "```\\n    long long minimumMoney(vector<vector<int>>& txn)\\n    {\\n        long long sumDelta = 0, biggestGain = 0;\\n        for(vector<int>&v : txn)\\n        {\\n            long long delta = max(0, v[0] - v[1]);\\n            sumDelta += delta;  \\n            biggestGain = max(biggestGain, -delta + v[0]);\\n        }\\n        return biggestGain + sumDelta;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    long long minimumMoney(vector<vector<int>>& txn)\\n    {\\n        long long sumDelta = 0, biggestGain = 0;\\n        for(vector<int>&v : txn)\\n        {\\n            long long delta = max(0, v[0] - v[1]);\\n            sumDelta += delta;  \\n            biggestGain = max(biggestGain, -delta + v[0]);\\n        }\\n        return biggestGain + sumDelta;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2595771,
                "title": "python-sort-and-add",
                "content": "The order require the most initial money is that starting from low cashback to high cashback.\\nThen we just need to count one by one to the the how much is sufficient to cover the last one.\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        transactions.sort(key = lambda x: (-x[1], x[0]))\\n        v = 0\\n        v += transactions[0][0]\\n        for trans in transactions[1:]:\\n            v += max(0, trans[0] - trans[1], trans[0] - v)\\n        return v\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        transactions.sort(key = lambda x: (-x[1], x[0]))\\n        v = 0\\n        v += transactions[0][0]\\n        for trans in transactions[1:]:\\n            v += max(0, trans[0] - trans[1], trans[0] - v)\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594155,
                "title": "java-solution-linear-runtime-no-sorting",
                "content": "### **Please Upvote !!!**\\n```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        long spend = 0, cost = 0, cashback = 0;\\n\\n        for (int[] t : transactions) {\\n            if (t[0] > t[1]) {\\n                spend += t[0] - t[1];\\n                cashback = Math.max(cashback, t[1]);\\n            }\\n            else cost = Math.max(cost, t[0]);\\n        }\\n\\n        return spend + Math.max(cost, cashback);\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        long spend = 0, cost = 0, cashback = 0;\\n\\n        for (int[] t : transactions) {\\n            if (t[0] > t[1]) {\\n                spend += t[0] - t[1];\\n                cashback = Math.max(cashback, t[1]);\\n            }\\n            else cost = Math.max(cost, t[0]);\\n        }\\n\\n        return spend + Math.max(cost, cashback);\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592946,
                "title": "intution-explained",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n        \\n        long long costSpent=0;\\n        long long cost=0;\\n        long long cashBack=0;\\n\\n        for(int i=0;i<transactions.size();++i){\\n            \\n            if(transactions[i][0]>transactions[i][1]){\\n                costSpent+=(transactions[i][0]-transactions[i][1]);\\n                cashBack=max(cashBack,(long long)transactions[i][1]);\\n            }\\n            else{\\n                cost=max(cost,(long long)transactions[i][0]);\\n            }\\n        }\\n        return costSpent+max(cost,cashBack);\\n        \\n    }\\n};\\n```\\n Here we want minimum money to start with so that we can finish transactions in any order we like.\\n So we can consider two scenarios, first is when we will check for all the positive transactions ,i.e in which we need to spend more than what we get.\\n This is clear that this much money is the least that we must have . But wait,are we missing on something??\\nYes the second thing that we want to keep in account is that we must also include in our sum which can be either \\n1. max of cost in case of negative transactions\\n 2. max of cashbacks in case of  positive transactions .\\n and at the end we need to include max of both of previously calculated value\\n with the sum of positive transaction amount that we mentioned in line 1.\\n  return the sum at the end; \\n        \\n   for example consider this: [[3,9],[0,4],[7,10],[3,5],[0,9],[19,13],[7,4],[0,0],[3,3],[8,0]]\\n    here in this case we can see that costSpent=17;\\n    but one of the transactions requires more than 17 , i.e if this has to complete first then we will fell short of money.\\n so this is why we need to keep track of how much more money want despite of costSpent amount which is done by keeping track of max cashBack in case of positive transactions \\nand max Cost in case of negative transactions.\\nIf the idea is still not clear just revisit the post again and do a dry-run on some testcases.\\n**Time Complexity: O(N)\\n   Space Complexity: O(1)**\\n```\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n        \\n        long long costSpent=0;\\n        long long cost=0;\\n        long long cashBack=0;\\n\\n        for(int i=0;i<transactions.size();++i){\\n            \\n            if(transactions[i][0]>transactions[i][1]){\\n                costSpent+=(transactions[i][0]-transactions[i][1]);\\n                cashBack=max(cashBack,(long long)transactions[i][1]);\\n            }\\n            else{\\n                cost=max(cost,(long long)transactions[i][0]);\\n            }\\n        }\\n        return costSpent+max(cost,cashBack);\\n        \\n    }\\n};\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592395,
                "title": "easy-to-understand-solution-based-on-lee215",
                "content": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        ans = 0\\n        losing_cash_left = 0 # Cash left after losing transaction\\n        earning_starting_cash = 0 # Cash needed to start the highest earning transaction\\n        for transaction in transactions:\\n            cash = transaction[0]\\n            cash_back = transaction[1]\\n            ans += max(0, cash - cash_back)\\n            if cash - cash_back > 0:\\n                losing_cash_left = max(losing_cash_left, cash_back)\\n            if cash - cash_back <= 0:\\n                earning_starting_cash = max(earning_starting_cash, cash)\\n        return ans + losing_cash_left + max(0, earning_starting_cash - losing_cash_left)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        ans = 0\\n        losing_cash_left = 0 # Cash left after losing transaction\\n        earning_starting_cash = 0 # Cash needed to start the highest earning transaction\\n        for transaction in transactions:\\n            cash = transaction[0]\\n            cash_back = transaction[1]\\n            ans += max(0, cash - cash_back)\\n            if cash - cash_back > 0:\\n                losing_cash_left = max(losing_cash_left, cash_back)\\n            if cash - cash_back <= 0:\\n                earning_starting_cash = max(earning_starting_cash, cash)\\n        return ans + losing_cash_left + max(0, earning_starting_cash - losing_cash_left)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2592183,
                "title": "c-divide-into-increasing-decreasing-intervals",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& t) {\\n        long long cur = 0, result = 0;\\n        vector<vector<int>> inc, dec;\\n        for(auto& a: t){\\n            if(a[0] > a[1])\\n                dec.push_back(a);\\n            else\\n                inc.push_back(a);\\n        }\\n        sort(dec.begin(), dec.end(), [](vector<int>& a, vector<int>& b){\\n            return b[1] > a[1];\\n        });\\n        sort(inc.begin(), inc.end(), [](vector<int>& a, vector<int>& b){\\n            return a[0] > b[0];\\n        });\\n        for(auto& a: dec){\\n            cur -= a[0];\\n            result = min(result, cur);\\n            cur += a[1];\\n        }\\n        for(auto& a: inc){\\n            cur -= a[0];\\n            result = min(result, cur);\\n            cur += a[1];\\n        }\\n        return abs(result);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& t) {\\n        long long cur = 0, result = 0;\\n        vector<vector<int>> inc, dec;\\n        for(auto& a: t){\\n            if(a[0] > a[1])\\n                dec.push_back(a);\\n            else\\n                inc.push_back(a);\\n        }\\n        sort(dec.begin(), dec.end(), [](vector<int>& a, vector<int>& b){\\n            return b[1] > a[1];\\n        });\\n        sort(inc.begin(), inc.end(), [](vector<int>& a, vector<int>& b){\\n            return a[0] > b[0];\\n        });\\n        for(auto& a: dec){\\n            cur -= a[0];\\n            result = min(result, cur);\\n            cur += a[1];\\n        }\\n        for(auto& a: inc){\\n            cur -= a[0];\\n            result = min(result, cur);\\n            cur += a[1];\\n        }\\n        return abs(result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591601,
                "title": "javascript-simple-efficient-solution",
                "content": "```\\n/**\\n * @param {number[][]} transactions\\n * @return {number}\\n */\\nvar minimumMoney = function(transactions) {\\n    let lossProductMaxCashback=0;\\n    let profitProductMaxPrice=0;\\n    let cost=0;\\n    for(let i=0;i<transactions.length;i++){\\n        if(transactions[i][0]>transactions[i][1]){//loss product\\n            lossProductMaxCashback = Math.max(lossProductMaxCashback,transactions[i][1]);\\n            cost += transactions[i][1]-transactions[i][0];\\n        }else{\\n            profitProductMaxPrice = Math.max(profitProductMaxPrice,transactions[i][0]);\\n        }\\n    }\\n    let ans = -1*(cost  -1*lossProductMaxCashback);\\n    if(profitProductMaxPrice-lossProductMaxCashback>0){//After purchasing all loss products. If we need to purchase a profit product which can ask for more money\\n        ans += (profitProductMaxPrice-lossProductMaxCashback)\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} transactions\\n * @return {number}\\n */\\nvar minimumMoney = function(transactions) {\\n    let lossProductMaxCashback=0;\\n    let profitProductMaxPrice=0;\\n    let cost=0;\\n    for(let i=0;i<transactions.length;i++){\\n        if(transactions[i][0]>transactions[i][1]){//loss product\\n            lossProductMaxCashback = Math.max(lossProductMaxCashback,transactions[i][1]);\\n            cost += transactions[i][1]-transactions[i][0];\\n        }else{\\n            profitProductMaxPrice = Math.max(profitProductMaxPrice,transactions[i][0]);\\n        }\\n    }\\n    let ans = -1*(cost  -1*lossProductMaxCashback);\\n    if(profitProductMaxPrice-lossProductMaxCashback>0){//After purchasing all loss products. If we need to purchase a profit product which can ask for more money\\n        ans += (profitProductMaxPrice-lossProductMaxCashback)\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2591460,
                "title": "c-o-n-solution-without-sorting-or-binary-search",
                "content": "**Approach :**\\n  **Design Logic**\\n ```\\n  ans = total_spend + other_variable\\n   there is two case during transaction \\n   case 1: Profit:\\n   during profit we are reducing total_spend money but for reducing that money\\n   person should have greater pocket money that maximum cost during profit which is part ofother_variable\\n   case 2: loss\\n   during loss it might be possible that any transaction having huge cashback which reducing the total_spend money from pocket\\n   to happen that transaction person should have greater pocket money that that transaction\\'s cost but here we already added the loss    to our total_spend money from pocket so the maximum cashback which is reducing total_spend in huge amount that should be part of   other variabl\\n    \\n   so finally we have two thing in other variable\\n   1) maximum cost during profit\\n   2) maximum cashback during loss\\n   to begin in a safe zone we take maximum of above two as other_variable which being added to total_spend money to give our ans\\n```\\n   \\n **C++ Code:**\\n  \\n```\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long total_spend = 0,cashback=0,cost=0;\\n        int n = transactions.size();\\n        for(int i=0;i<n;i++){\\n           \\n            // case 1: Loss\\n            if(transactions[i][0]>transactions[i][1]){ \\n              total_spend += transactions[i][0]-transactions[i][1];\\n             cashback = max(cashback,(long long)transactions[i][1]);\\n            }\\n             // case 2: profit\\n            if(transactions[i][0]<=transactions[i][1]) \\n             cost = max(cost,(long long)transactions[i][0]);\\n        }\\n    return total_spend + max(cost,cashback);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  ans = total_spend + other_variable\\n   there is two case during transaction \\n   case 1: Profit:\\n   during profit we are reducing total_spend money but for reducing that money\\n   person should have greater pocket money that maximum cost during profit which is part ofother_variable\\n   case 2: loss\\n   during loss it might be possible that any transaction having huge cashback which reducing the total_spend money from pocket\\n   to happen that transaction person should have greater pocket money that that transaction\\'s cost but here we already added the loss    to our total_spend money from pocket so the maximum cashback which is reducing total_spend in huge amount that should be part of   other variabl\\n    \\n   so finally we have two thing in other variable\\n   1) maximum cost during profit\\n   2) maximum cashback during loss\\n   to begin in a safe zone we take maximum of above two as other_variable which being added to total_spend money to give our ans\\n```\n```\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long total_spend = 0,cashback=0,cost=0;\\n        int n = transactions.size();\\n        for(int i=0;i<n;i++){\\n           \\n            // case 1: Loss\\n            if(transactions[i][0]>transactions[i][1]){ \\n              total_spend += transactions[i][0]-transactions[i][1];\\n             cashback = max(cashback,(long long)transactions[i][1]);\\n            }\\n             // case 2: profit\\n            if(transactions[i][0]<=transactions[i][1]) \\n             cost = max(cost,(long long)transactions[i][0]);\\n        }\\n    return total_spend + max(cost,cashback);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589673,
                "title": "python-short-solution-and-detailed-explanation",
                "content": "1. Put the losing-money transactions infront and the earning-money back. This is because putting the earning transactions in front will gain money and reduce the amount we need.\\n2. Assume we have 4 transactions that lose money for simplicity: [c1,g1], [c2,g2], [c3,g3], [c4,g4]. c means cost and g means gain.\\n3. The total amount will be c1 + (c2-g1) + (c3-g2) + (c4-g3) = c1+...+c4 - (g1+...+g3) =**totalLoss + g4**. After the 4 transactions, we will gain g4 as cashback, which will be used later.\\n4. For the transactions that gain money, the minimum amount needed for the worst case will be the max of all cost (maxCostGaining). After getting the cashback of the max cost, we can finish the other transactions without any extra money.\\n5. The answer looks like **totalLoss + g4 + maxCostGaining - g4 = totalLoss + maxCostGaining**\\n6. However, it is possible that g4 is larger than maxCostGaining. In that case, maxCostGaining - g4 is a negative number. We can\\'t spend a negative amount. We spend zero in that case and the total amount needed is **totalLoss + g4**.\\n7. totalLoss + g4 could be larger than totalLoss + maxCostGaining. Once g4 is larger than maxCostEarning, we found a even larger amount that we need. We therefore get the max cashback in losing-money transactions. **If maxCashBackLosing > maxCostGaining, answer =  totalLoss + maxCashBackLosing**. \\n\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        totalLoss = 0\\n        maxCostGaining = float(\\'-inf\\')\\n        maxCashBackLosing = float(\\'-inf\\')\\n        for cost,cashBack in transactions:\\n            if cost < cashBack:\\n                maxCostGaining = max(maxCostGaining,cost)\\n            else:\\n                totalLoss += cost - cashBack\\n                maxCashBackLosing = max(maxCashBackLosing,cashBack)\\n        return totalLoss + max(maxCostGaining,maxCashBackLosing)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        totalLoss = 0\\n        maxCostGaining = float(\\'-inf\\')\\n        maxCashBackLosing = float(\\'-inf\\')\\n        for cost,cashBack in transactions:\\n            if cost < cashBack:\\n                maxCostGaining = max(maxCostGaining,cost)\\n            else:\\n                totalLoss += cost - cashBack\\n                maxCashBackLosing = max(maxCashBackLosing,cashBack)\\n        return totalLoss + max(maxCostGaining,maxCashBackLosing)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589530,
                "title": "simple-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        ll l=0,r=1e14;\\n        ll ans=1e18;\\n        ll sum=0;\\n        sort(begin(transactions),end(transactions));\\n        for(auto &x:transactions){\\n            x[1]=max(0ll,(ll)x[0]-x[1]);\\n            sum+=x[1];\\n        }\\n        if(sum==0){\\n            return transactions[transactions.size()-1][0];\\n        }\\n        while(l<=r){\\n            ll mid=(l+r)/2;\\n            bool check=false;\\n            ll cur=mid;\\n            for(auto p:transactions){\\n                if(mid-sum<p[0]-p[1]){\\n                    check=true;\\n                    break;\\n                }\\n            }\\n            if(check){\\n                l=cur+1;\\n            }\\n            else{\\n                r=cur-1;\\n            }\\n        }\\n        return r+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long int\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        ll l=0,r=1e14;\\n        ll ans=1e18;\\n        ll sum=0;\\n        sort(begin(transactions),end(transactions));\\n        for(auto &x:transactions){\\n            x[1]=max(0ll,(ll)x[0]-x[1]);\\n            sum+=x[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2589282,
                "title": "java-o-n-with-comments",
                "content": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        long res = 0;\\n        long maxCashBack = 0; // record maxCashBack when cost i > cashback i\\n        long maxCost = 0; // record maxCost when cost i < cashback i\\n        /* \\n        The worst arrange is we finish all transactions with cost i > cashback i\\n        then campare the money between :\\n        1. finish all transactions with cost i than pay the most cost with cost i < cashback i\\n        2. pay the last transactions with cost i > cashback i before get cashback\\n        */\\n        for (int[] trans : transactions) {\\n            if (trans[0] > trans[1]) {\\n                res += trans[0] - trans[1];\\n                maxCashBack = Math.max(maxCashBack, trans[1]);\\n            } else {\\n                maxCost = Math.max(maxCost, trans[0]);\\n            }\\n        }\\n        res += Math.max(maxCashBack, maxCost);\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        long res = 0;\\n        long maxCashBack = 0; // record maxCashBack when cost i > cashback i\\n        long maxCost = 0; // record maxCost when cost i < cashback i\\n        /* \\n        The worst arrange is we finish all transactions with cost i > cashback i\\n        then campare the money between :\\n        1. finish all transactions with cost i than pay the most cost with cost i < cashback i\\n        2. pay the last transactions with cost i > cashback i before get cashback\\n        */\\n        for (int[] trans : transactions) {\\n            if (trans[0] > trans[1]) {\\n                res += trans[0] - trans[1];\\n                maxCashBack = Math.max(maxCashBack, trans[1]);\\n            } else {\\n                maxCost = Math.max(maxCost, trans[0]);\\n            }\\n        }\\n        res += Math.max(maxCashBack, maxCost);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589257,
                "title": "100-tc-100-sc-understandable-python-code-explained",
                "content": "![image](https://assets.leetcode.com/users/images/9c359646-4da8-4229-aa7f-82725aa47028_1663447483.5845342.png)\\n\\nWe only calculate total loss from strictly loss making transactions.\\n**For the last transaction we can either have the biggest loss-making cashback transaction or the biggest cost of profiting transaction.**\\n\\n**Our objective is to make as much loss as possible. Remember: before getting CB, we have to bear the cost, hence the last transaction we make matters a lot.**\\n\\nUpvote if you understood the logic :)\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        totalLoss = maxCBLosing = maxCostProfiting = 0\\n        \\n        for cost, cb in transactions:\\n            #loss making transactions\\n            if cost > cb:\\n                totalLoss += cost - cb\\n                maxCBLosing = max(maxCBLosing, cb)\\n            else:\\n                maxCostProfiting = max(maxCostProfiting, cost)\\n        \\n        return totalLoss + max(maxCBLosing, maxCostProfiting)\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        totalLoss = maxCBLosing = maxCostProfiting = 0\\n        \\n        for cost, cb in transactions:\\n            #loss making transactions\\n            if cost > cb:\\n                totalLoss += cost - cb\\n                maxCBLosing = max(maxCBLosing, cb)\\n            else:\\n                maxCostProfiting = max(maxCostProfiting, cost)\\n        \\n        return totalLoss + max(maxCBLosing, maxCostProfiting)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588962,
                "title": "c-sort-for-the-worst-case-and-perform-binary-search",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long minimumMoney(vector<vector<int>>& a) {\\n\\t\\t\\tsort(a.begin(),a.end(),[&](vector<int>& x,vector<int>& y){\\n\\t\\t\\t\\tint trial1=min(-x[0],-x[0]+x[1]-y[0]);\\n\\t\\t\\t\\tint trial2=min(-y[0],-y[0]+y[1]-x[0]);\\n\\t\\t\\t\\tif(trial1<trial2) return true;\\n\\t\\t\\t\\telse if(trial1>trial2) return false;\\n\\t\\t\\t\\treturn x[0]>y[0];\\n\\t\\t\\t});\\n\\t\\t\\tlong long l=0,r=1e16;\\n\\t\\t\\twhile(l<r) {\\n\\t\\t\\t\\tlong long m=(l+r)/2;\\n\\t\\t\\t\\tlong long x=m;\\n\\t\\t\\t\\tfor(int i=0;i<a.size();i++){\\n\\t\\t\\t\\t\\tx=x-a[i][0];\\n\\t\\t\\t\\t\\tif(x<0) break;\\n\\t\\t\\t\\t\\tx+=a[i][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(x<0) l=m+1;\\n\\t\\t\\t\\telse r=m;\\n\\t\\t\\t}\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long minimumMoney(vector<vector<int>>& a) {\\n\\t\\t\\tsort(a.begin(),a.end(),[&](vector<int>& x,vector<int>& y){\\n\\t\\t\\t\\tint trial1=min(-x[0],-x[0]+x[1]-y[0]);\\n\\t\\t\\t\\tint trial2=min(-y[0],-y[0]+y[1]-x[0]);\\n\\t\\t\\t\\tif(trial1<trial2) return true;\\n\\t\\t\\t\\telse if(trial1>trial2) return false;\\n\\t\\t\\t\\treturn x[0]>y[0];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2588892,
                "title": "c-solution-o-n-tc-o-1-sc-8-lines-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    static int64_t minimumMoney(const vector<vector<int>>& transactions) {\\n        int best = 0;\\n        int64_t ret = 0;\\n        for (auto& tx: transactions) {\\n            best = max(best, min(tx[0], tx[1]));\\n            if (tx[1] < tx[0])\\n                ret += tx[0] - tx[1];\\n        }\\n        return ret + best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int64_t minimumMoney(const vector<vector<int>>& transactions) {\\n        int best = 0;\\n        int64_t ret = 0;\\n        for (auto& tx: transactions) {\\n            best = max(best, min(tx[0], tx[1]));\\n            if (tx[1] < tx[0])\\n                ret += tx[0] - tx[1];\\n        }\\n        return ret + best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588607,
                "title": "rust-concise-solution",
                "content": "~~~\\nimpl Solution {\\n    pub fn minimum_money(transactions: Vec<Vec<i32>>) -> i64 {\\n        let mut sum = 0; // net spending\\n        for t in &transactions { sum += i32::max(0, t[0] - t[1]) as i64; }\\n        \\n        let mut ret = sum;\\n\\t    // Performing current transaction at the end\\n        for t in transactions {   \\n            if t[0] <= t[1] { ret = ret.max(sum + t[0] as i64); }\\n            else { ret = ret.max(sum + t[1] as i64); }\\n        }\\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn minimum_money(transactions: Vec<Vec<i32>>) -> i64 {\\n        let mut sum = 0; // net spending\\n        for t in &transactions { sum += i32::max(0, t[0] - t[1]) as i64; }\\n        \\n        let mut ret = sum;\\n\\t    // Performing current transaction at the end\\n        for t in transactions {   \\n            if t[0] <= t[1] { ret = ret.max(sum + t[0] as i64); }\\n            else { ret = ret.max(sum + t[1] as i64); }\\n        }\\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2588374,
                "title": "c-sort-the-array-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& arr) {\\n        sort(arr.begin(),arr.end(),[&](const auto& p, const auto& q){\\n            int x = min(-p[0],-p[0]+p[1]-q[0]);\\n            int y = min(-q[0],-q[0]+q[1]-p[0]);\\n            return (x<y || (x==y && p[0]>q[0]));\\n        });\\n        long long ans=INT_MAX, t=0ll;\\n        for(int i=0;i<arr.size();++i){\\n            t -= (long long)arr[i][0];\\n            ans = min(ans,t);\\n            t += (long long)arr[i][1];\\n        }\\n        return -ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& arr) {\\n        sort(arr.begin(),arr.end(),[&](const auto& p, const auto& q){\\n            int x = min(-p[0],-p[0]+p[1]-q[0]);\\n            int y = min(-q[0],-q[0]+q[1]-p[0]);\\n            return (x<y || (x==y && p[0]>q[0]));\\n        });\\n        long long ans=INT_MAX, t=0ll;\\n        for(int i=0;i<arr.size();++i){\\n            t -= (long long)arr[i][0];\\n            ans = min(ans,t);\\n            t += (long long)arr[i][1];\\n        }\\n        return -ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588212,
                "title": "sorting-greedily-o-nlogn-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int>&a,vector<int>&b){\\n        return a[1]<b[1];\\n    }\\n    bool static cmp2(vector<int>&a,vector<int>&b){\\n        return a[0]>b[0];\\n    }\\n    long long minimumMoney(vector<vector<int>>&a) {\\n        //sort(a.begin(),a.end(),cmp);\\n        long long ans=0;\\n        long long prv=0;\\n        int n=a.size();\\n        vector<vector<int>>b,c;\\n        // for(auto i:a){\\n        //     cout<<i[0]<<\" \"<<i[1]<<\"\\\\n\";\\n        // }\\n        for(auto i:a){\\n            if(i[1]-i[0]<0){\\n                b.push_back(i);\\n            }else{\\n                c.push_back(i);\\n            }\\n        }\\n        sort(b.begin(),b.end(),cmp);\\n        sort(c.begin(),c.end(),cmp2);\\n        for(int i=0;i<b.size();i++){\\n            long long cur=b[i][0];\\n            long long cb=b[i][1];\\n            if(prv>=cur){\\n                prv=prv-cur+cb;\\n            }else{\\n                ans+=(cur-prv);\\n                prv=cb;\\n            }\\n        }\\n        for(int i=0;i<c.size();i++){\\n            long long cur=c[i][0];\\n            long long cb=c[i][1];\\n            if(prv>=cur){\\n                prv=prv-cur+cb;\\n            }else{\\n                ans+=(cur-prv);\\n                prv=cb;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    bool static cmp(vector<int>&a,vector<int>&b){\\n        return a[1]<b[1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2588087,
                "title": "c-greedy",
                "content": "**Approach**: We paying for **sum(cost-cashback)** and we are taking maximum cashback as initial money because if we for last transaction we have `money = cost[i] `then we will lost all the money so we taking intial money as cashback[i].\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long res = 0;\\n        for(auto ele: transactions){\\n            res  = max(res,min(ele[0],ele[1])*1LL);\\n        };\\n        for(auto ele:transactions){\\n            res+=max(ele[0]-ele[1],0);\\n        };\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long res = 0;\\n        for(auto ele: transactions){\\n            res  = max(res,min(ele[0],ele[1])*1LL);\\n        };\\n        for(auto ele:transactions){\\n            res+=max(ele[0]-ele[1],0);\\n        };\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992132,
                "title": "c-easy-clean-code-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    long long minimumMoney(vector<vector<int>>& t) {\\n        vector<vector<int>> a,b;\\n        long long int c=0,m=INT_MAX;\\n\\n        for(auto i : t)\\n         if(i[0]<=i[1]) a.push_back(i);\\n         else b.push_back(i);\\n\\n         sort(a.begin(),a.end(),greater<vector<int>> ());\\n         sort(b.begin(),b.end(),cmp);\\n\\n         for(int i=0;i<b.size();i++)\\n         {\\n             c-=b[i][0];\\n             m=min(m,c);\\n             c+=b[i][1];\\n         }\\n         for(int i=0;i<a.size();i++)\\n         {\\n             c-=a[i][0];\\n             m=min(m,c);\\n             c+=a[i][1];\\n         }\\n         return -1*m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    long long minimumMoney(vector<vector<int>>& t) {\\n        vector<vector<int>> a,b;\\n        long long int c=0,m=INT_MAX;\\n\\n        for(auto i : t)\\n         if(i[0]<=i[1]) a.push_back(i);\\n         else b.push_back(i);\\n\\n         sort(a.begin(),a.end(),greater<vector<int>> ());\\n         sort(b.begin(),b.end(),cmp);\\n\\n         for(int i=0;i<b.size();i++)\\n         {\\n             c-=b[i][0];\\n             m=min(m,c);\\n             c+=b[i][1];\\n         }\\n         for(int i=0;i<a.size();i++)\\n         {\\n             c-=a[i][0];\\n             m=min(m,c);\\n             c+=a[i][1];\\n         }\\n         return -1*m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905042,
                "title": "heap-priority-queue-greedy-c-solution-easy-approach-to-solve-hard-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif casback is more don\\'t take only take that at last moment i.e with maximum cost because you have to pay then only you are getting cashback other thing min heap\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n   long long int  max(long long int  a,long long int b){\\n       if(a>b){\\n           return a;\\n       }\\n       return b;\\n   }\\n\\n    long long minimumMoney(vector<vector<int>>& tr) {\\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>>pq;\\n   \\n        long long k = 0;\\n        for(int i = 0;i<tr.size();i++) {\\n            if(tr[i][1]<=tr[i][0]){\\n  pq.push({tr[i][1],tr[i][0]});\\n            }\\n          \\n            else {\\n                k = max(tr[i][0],k);\\n            } \\n        }\\n        \\n        long long int ans = 0;\\n        long long int maxi = 0;\\n       while(!pq.empty()) {\\n            maxi = max(maxi,ans+pq.top().second);\\n\\n            ans = ans+(pq.top().second-pq.top().first);\\n            pq.pop();\\n         \\n            \\n        }\\n        maxi = max(maxi,ans+k);\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n   long long int  max(long long int  a,long long int b){\\n       if(a>b){\\n           return a;\\n       }\\n       return b;\\n   }\\n\\n    long long minimumMoney(vector<vector<int>>& tr) {\\n        priority_queue<pair<long long int,long long int>,vector<pair<long long int,long long int>>,greater<pair<long long int,long long int>>>pq;\\n   \\n        long long k = 0;\\n        for(int i = 0;i<tr.size();i++) {\\n            if(tr[i][1]<=tr[i][0]){\\n  pq.push({tr[i][1],tr[i][0]});\\n            }\\n          \\n            else {\\n                k = max(tr[i][0],k);\\n            } \\n        }\\n        \\n        long long int ans = 0;\\n        long long int maxi = 0;\\n       while(!pq.empty()) {\\n            maxi = max(maxi,ans+pq.top().second);\\n\\n            ans = ans+(pq.top().second-pq.top().first);\\n            pq.pop();\\n         \\n            \\n        }\\n        maxi = max(maxi,ans+k);\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718548,
                "title": "greedy-java-explained-in-details",
                "content": "# Intuition\\nAll the transactions where cashback is bigger than cost can be ignored for starters, because once we start doing them our money deposit will increase, so until that point money will only decrease when we process transactions where cost > cashback. However, we only care about one transaction with cost < cashback, because before we received any cashback we need to have enough money to get around the cost of this transaction, that\\'s why we need to find maximum such cost to finally add it.\\n\\n# Approach\\nFinally there are 2 cases:\\nCase 1: All transactions with cost >= cashback, in this case we finally need to add up cashback before we made the final transaction and the cashback should as big as possible.\\nCase 2: There exists transaction where cost < cashback, in this case we actually only add the biggest cost from transactions array where cost < cashback to maximize result.\\nFinally it turns out that we end up to choosing the maximum of cashback from case 1 and cost from case 2. If you look at it closely you can either choose not getting a cashback and leave yourself with paid cost, or get a cashback and pay a cost from the other transaction from case 2.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public static long minimumMoney(int[][] transactions) {\\n        long sum = 0;\\n        int maxCashback = -1;\\n        int maxCost = -1;\\n        for (int[] transaction : transactions) {\\n            sum += Math.max(0, transaction[0] - transaction[1]);\\n            if (transaction[0] - transaction[1] >= 0) {\\n                maxCashback = Math.max(maxCashback, transaction[1]);\\n            }\\n            if (transaction[0] - transaction[1] < 0) {\\n                maxCost = Math.max(maxCost, transaction[0]);\\n            }\\n        }\\n        return sum + Math.max(maxCashback, maxCost);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public static long minimumMoney(int[][] transactions) {\\n        long sum = 0;\\n        int maxCashback = -1;\\n        int maxCost = -1;\\n        for (int[] transaction : transactions) {\\n            sum += Math.max(0, transaction[0] - transaction[1]);\\n            if (transaction[0] - transaction[1] >= 0) {\\n                maxCashback = Math.max(maxCashback, transaction[1]);\\n            }\\n            if (transaction[0] - transaction[1] < 0) {\\n                maxCost = Math.max(maxCost, transaction[0]);\\n            }\\n        }\\n        return sum + Math.max(maxCashback, maxCost);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579903,
                "title": "simple-just-find-the-loss-at-each-transaction-and-add-it-to-the-max-amount",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions)\\n    {\\n        long long loss=0;\\n        int ans=0;\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            if(transactions[i][0]>transactions[i][1])\\n            {\\n                loss+=transactions[i][0]-transactions[i][1];\\n                ans=max(ans,transactions[i][1]);\\n            }\\n            else\\n            {\\n                ans=max(ans,transactions[i][0]);\\n            }\\n        }\\n        return loss+(long long)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions)\\n    {\\n        long long loss=0;\\n        int ans=0;\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            if(transactions[i][0]>transactions[i][1])\\n            {\\n                loss+=transactions[i][0]-transactions[i][1];\\n                ans=max(ans,transactions[i][1]);\\n            }\\n            else\\n            {\\n                ans=max(ans,transactions[i][0]);\\n            }\\n        }\\n        return loss+(long long)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555236,
                "title": "simple-go-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minimumMoney(transactions [][]int) int64 {\\n    base, extra := 0, 0\\n    for _, t := range transactions {\\n        if t[0] > t[1] {\\n            base += t[0] - t[1]\\n            extra = max(extra, t[1])\\n        } else {\\n            extra = max(extra, t[0])\\n        }\\n    }\\n    return int64(base + extra)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumMoney(transactions [][]int) int64 {\\n    base, extra := 0, 0\\n    for _, t := range transactions {\\n        if t[0] > t[1] {\\n            base += t[0] - t[1]\\n            extra = max(extra, t[1])\\n        } else {\\n            extra = max(extra, t[0])\\n        }\\n    }\\n    return int64(base + extra)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3507136,
                "title": "java-beats-100-easy-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        int max = 0;\\n        int maxCashBack = 0;\\n        long sum = 0;\\n        for (int[] t : transactions) {\\n            int diff = t[0] - t[1];\\n            if (diff <= 0) {\\n                max = Math.max(max, t[0]);\\n            } else {\\n                sum += diff;\\n                maxCashBack = Math.max(maxCashBack, t[1]);\\n            }\\n        }\\n        return Math.max(sum+maxCashBack, sum+max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        int max = 0;\\n        int maxCashBack = 0;\\n        long sum = 0;\\n        for (int[] t : transactions) {\\n            int diff = t[0] - t[1];\\n            if (diff <= 0) {\\n                max = Math.max(max, t[0]);\\n            } else {\\n                sum += diff;\\n                maxCashBack = Math.max(maxCashBack, t[1]);\\n            }\\n        }\\n        return Math.max(sum+maxCashBack, sum+max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469768,
                "title": "lazy-but-crazy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} transactions\\n * @return {number}\\n */\\nvar minimumMoney = function(t) {\\n    let top=[], bottom=[]\\n    for (let i=0;i<t.length;i++){\\n        if (t[i][1]<t[i][0]) top.push(t[i])\\n        else bottom.push(t[i])   \\n    }\\n    top.sort((a,b)=>a[1]-b[1])\\n    bottom.sort((a,b)=>b[0]-a[0])\\n    let arr=[...top,...bottom]\\n    for (let i=arr.length-2;i>-1;i--){\\n        if (arr[i][0]-arr[i][1]>0 )\\n            if(arr[i][0]<arr[i+1][0]+arr[i][0]-arr[i][1]){\\n            arr[i][0]=arr[i+1][0]+arr[i][0]-arr[i][1]\\n            }\\n    }\\n    return arr[0][0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[][]} transactions\\n * @return {number}\\n */\\nvar minimumMoney = function(t) {\\n    let top=[], bottom=[]\\n    for (let i=0;i<t.length;i++){\\n        if (t[i][1]<t[i][0]) top.push(t[i])\\n        else bottom.push(t[i])   \\n    }\\n    top.sort((a,b)=>a[1]-b[1])\\n    bottom.sort((a,b)=>b[0]-a[0])\\n    let arr=[...top,...bottom]\\n    for (let i=arr.length-2;i>-1;i--){\\n        if (arr[i][0]-arr[i][1]>0 )\\n            if(arr[i][0]<arr[i+1][0]+arr[i][0]-arr[i][1]){\\n            arr[i][0]=arr[i+1][0]+arr[i][0]-arr[i][1]\\n            }\\n    }\\n    return arr[0][0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3295008,
                "title": "python-o-n-complexity-with-simple-explanation",
                "content": "# Intuition\\nThe transactions can be divided into two kinds:\\n1. transaction with positive profit.\\n2. transaction with non-positive profit.\\n\\nTo find the minimum money required before transactions, we only need to know how much money we can lose in the worst case. The worst case is just **first completing all transactions with non-positive profit and then completing the rest**. \\n\\nWe use `lost` to store the money we lose by completing all transactions with non-positive profit.\\n\\nBesides, among all those transactions with non-negative profit, we need to find the largest cashback, i.e., `large_gain`. A possible maximum of money lost is `lost` + `large_gain`.\\n\\nAmong all those transactions with positive profit, we need to find the largest cost, i.e., `large_cost`. The other possible maximum of money lost is `lost` + `large_cost`.\\n\\nHence, the money required is min(`lost` + `large_gain`, `lost` + `large_cost`).\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumMoney(self, transactions):\\n        \"\"\"\\n        :type transactions: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        large_gain = -1\\n        large_cost = -1\\n        lost = 0\\n\\n        for x in transactions:\\n            if x[0]>=x[1]: # non-postive profit\\n                lost += x[0] - x[1]\\n                large_gain = max(large_gain, x[1])\\n            else: # positive profit\\n                large_cost = max(large_cost, x[0])\\n        return max(lost + large_gain, lost + large_cost)\\n\\n\\n\\n            \\n        \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumMoney(self, transactions):\\n        \"\"\"\\n        :type transactions: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        large_gain = -1\\n        large_cost = -1\\n        lost = 0\\n\\n        for x in transactions:\\n            if x[0]>=x[1]: # non-postive profit\\n                lost += x[0] - x[1]\\n                large_gain = max(large_gain, x[1])\\n            else: # positive profit\\n                large_cost = max(large_cost, x[0])\\n        return max(lost + large_gain, lost + large_cost)\\n\\n\\n\\n            \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197746,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions):\\n        ans = [max(i-j,0) for i,j in transactions]\\n        n, max_val, total = len(transactions), 0, sum(ans)\\n\\n        for i in range(n):\\n            max_val = max(max_val,total-ans[i]+transactions[i][0])\\n\\n        return max_val\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions):\\n        ans = [max(i-j,0) for i,j in transactions]\\n        n, max_val, total = len(transactions), 0, sum(ans)\\n\\n        for i in range(n):\\n            max_val = max(max_val,total-ans[i]+transactions[i][0])\\n\\n        return max_val\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193347,
                "title": "proof-for-lee215-s-solution",
                "content": "# Intuition from lee215\\'s [solution](https://leetcode.com/problems/minimum-money-required-before-transactions/solutions/2588034/JavaC++Python-Easy-and-Coincise/)\\n1. Doing all the negative transactions before all the positive transaction will be the worst case.\\n2. The worst-case and hence the final answer depends only on the last negative transaction and the first positive transaction.\\n3. In the worst-case permutations:\\nLet `m` be the index of the negative transaction with maximum cashback and `l` be the index of the positive transaction with the highest cost.\\nTemplate of the worst-case permuation = `[...all negative transactions in any order..., transaction[m], transaction[l], ...all psoitive transactions in any order...]`\\n# To Prove\\n1. `Min. starting money needed = total negative loss + max(max cashback in all negative transactions, max cost in all positive transactions)`\\n`= (total negative loss) + max(B[m], A[l])`\\n\\n# Proof:\\nLet `money_m` be the money needed to complete transaction `m` in worst case, then `money_m >= (total negative loss) + B[m]`.\\n\\n For any intermediate negative transaction `i` in any permutation including the worst case scenario. \\n`(total negative loss) + (max cashback in all negative transactions)`\\n `= (negative loss for [0, i-1]) + A[i] + (negative loss for [i+1, m] + (B[m] - B[i])` \\n`>= A[i]` proving that the `money >= A[i]` invariant is satisfied for every negative transaction.\\n\\n\\nLet `money_n` be the money needed to complete transaction `n` in worst case, then `money_n - (total negative loss) >= A[l] `\\nimplies `money_n => (total negative loss) + A[l]`.\\n\\nJust like above we can prove that for any positive transaction i in any permutation, the invariant `money >= A[i]` will be satisfied.\\n\\nMin. money required = `max(money_n, money_m) = max((total negative loss) + B[m], (total negative loss) + A[l]) = (total negative loss) + max(B[m], A[l])`.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long ans = 0, totalLoss = 0, maxCashback = 0, maxCost = 0;\\n        for (auto &v: transactions) {\\n            if (v[0] > v[1]) {\\n                totalLoss += v[0] - v[1];\\n                maxCashback = max(maxCashback, (long)v[1]);\\n            } else {\\n                maxCost = max(maxCost, (long)v[0]);\\n            }\\n        }\\n        return totalLoss + max(maxCost, maxCashback);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long ans = 0, totalLoss = 0, maxCashback = 0, maxCost = 0;\\n        for (auto &v: transactions) {\\n            if (v[0] > v[1]) {\\n                totalLoss += v[0] - v[1];\\n                maxCashback = max(maxCashback, (long)v[1]);\\n            } else {\\n                maxCost = max(maxCost, (long)v[0]);\\n            }\\n        }\\n        return totalLoss + max(maxCost, maxCashback);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174903,
                "title": "sorting-elegant-c-binary-search",
                "content": "```cpp\\nusing ll = long long;\\n\\ntemplate <typename Predicate>\\nll binary_search(ll low, ll high, Predicate&& predicate) {\\n  if (low >= high) return low;\\n  auto const mid = low + (high - low) / 2;\\n  if (predicate(mid)) {\\n    return binary_search(mid + 1, high, predicate);\\n  } else {\\n    return binary_search(low, mid, predicate);\\n  }\\n}\\n\\nclass Solution {\\n public:\\n  long long minimumMoney(std::vector<std::vector<int>>& transactions) {\\n    std::sort(std::begin(transactions), std::end(transactions),\\n              [](auto const& a, auto const& b) {\\n                auto const a_dip = std::min(-a[0], a[1] - a[0] - b[0]);\\n                auto const b_dip = std::min(-b[0], b[1] - b[0] - a[0]);\\n                if (a_dip == b_dip) return a[0] > b[0];\\n                return a_dip < b_dip;\\n              });\\n    auto is_sufficient = [&](ll money) {\\n      for (auto const& t : transactions) {\\n        auto const cost = t[0];\\n        auto const cashback = t[1];\\n        if (money < cost) return false;\\n        money += (-cost + cashback);\\n      }\\n      return true;\\n    };\\n    return binary_search(0, 1e14, std::not_fn(is_sufficient));\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nusing ll = long long;\\n\\ntemplate <typename Predicate>\\nll binary_search(ll low, ll high, Predicate&& predicate) {\\n  if (low >= high) return low;\\n  auto const mid = low + (high - low) / 2;\\n  if (predicate(mid)) {\\n    return binary_search(mid + 1, high, predicate);\\n  } else {\\n    return binary_search(low, mid, predicate);\\n  }\\n}\\n\\nclass Solution {\\n public:\\n  long long minimumMoney(std::vector<std::vector<int>>& transactions) {\\n    std::sort(std::begin(transactions), std::end(transactions),\\n              [](auto const& a, auto const& b) {\\n                auto const a_dip = std::min(-a[0], a[1] - a[0] - b[0]);\\n                auto const b_dip = std::min(-b[0], b[1] - b[0] - a[0]);\\n                if (a_dip == b_dip) return a[0] > b[0];\\n                return a_dip < b_dip;\\n              });\\n    auto is_sufficient = [&](ll money) {\\n      for (auto const& t : transactions) {\\n        auto const cost = t[0];\\n        auto const cashback = t[1];\\n        if (money < cost) return false;\\n        money += (-cost + cashback);\\n      }\\n      return true;\\n    };\\n    return binary_search(0, 1e14, std::not_fn(is_sufficient));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035780,
                "title": "o-n-solution-python",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:o(n)\\n\\n# Code\\n```\\nfrom functools import cmp_to_key\\n\\nclass Solution:\\n\\n    def sortbyCond(self,a, b):\\n        if (a[1] != b[1]):\\n            return (a[1] - b[1])\\n        else:\\n            return a[0] - b[0]\\n\\n    def minimumMoney(self, t: List[List[int]]) -> int:\\n        maxi=0\\n        ans2=0\\n        ans=0\\n        l=[]\\n        n=len(t)\\n        for i in range(n):\\n            if(t[i][1]>=t[i][0]):\\n                maxi=max(maxi,t[i][0])\\n            elif(t[i][1]==0):\\n                ans2+=t[i][0]\\n            else:\\n                l.append(t[i])\\n        \\n        p=len(l)\\n        l.sort(key = cmp_to_key(self.sortbyCond))\\n        for i in range(p):\\n            ans+=(l[i][0]-l[i][1])\\n            if(i==p-1):\\n                ans+=l[i][1]\\n\\n        ans+=ans2\\n\\n        if(len(l)>0 and maxi>l[len(l)-1][1]):\\n            ans+=maxi-l[p-1][1]\\n        elif(len(l)==0 and maxi>0):\\n            ans+=maxi\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cmp_to_key\\n\\nclass Solution:\\n\\n    def sortbyCond(self,a, b):\\n        if (a[1] != b[1]):\\n            return (a[1] - b[1])\\n        else:\\n            return a[0] - b[0]\\n\\n    def minimumMoney(self, t: List[List[int]]) -> int:\\n        maxi=0\\n        ans2=0\\n        ans=0\\n        l=[]\\n        n=len(t)\\n        for i in range(n):\\n            if(t[i][1]>=t[i][0]):\\n                maxi=max(maxi,t[i][0])\\n            elif(t[i][1]==0):\\n                ans2+=t[i][0]\\n            else:\\n                l.append(t[i])\\n        \\n        p=len(l)\\n        l.sort(key = cmp_to_key(self.sortbyCond))\\n        for i in range(p):\\n            ans+=(l[i][0]-l[i][1])\\n            if(i==p-1):\\n                ans+=l[i][1]\\n\\n        ans+=ans2\\n\\n        if(len(l)>0 and maxi>l[len(l)-1][1]):\\n            ans+=maxi-l[p-1][1]\\n        elif(len(l)==0 and maxi>0):\\n            ans+=maxi\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994601,
                "title": "simple-python-solution-beats-100",
                "content": "Transactions that cost - cachback is positive for them will add to the total debt. For other transactions that have negative cost - cashback, the only needed field is the largest cost among them, as they will decrease the total debt.\\n```\\nclass Solution(object):\\n    def minimumMoney(self, transactions):\\n        \"\"\"\\n        :type transactions: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cur = maxCur = maxPositive = 0\\n\\n        transactions = sorted(transactions, key = lambda t: t[1])    \\n\\n        for tran in transactions:\\n            # If entire transaction adds to debt or equals zero:\\n            if tran[0] >= tran[1]:\\n                cur += tran[0]\\n                maxCur = max(cur, maxCur)\\n                cur -= tran[1]\\n            # Otherwise, keep the largest cost:    \\n            else:\\n                maxPositive = max(maxPositive, tran[0])\\n\\n\\n        return max(cur + maxPositive, maxCur)    \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumMoney(self, transactions):\\n        \"\"\"\\n        :type transactions: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        cur = maxCur = maxPositive = 0\\n\\n        transactions = sorted(transactions, key = lambda t: t[1])    \\n\\n        for tran in transactions:\\n            # If entire transaction adds to debt or equals zero:\\n            if tran[0] >= tran[1]:\\n                cur += tran[0]\\n                maxCur = max(cur, maxCur)\\n                cur -= tran[1]\\n            # Otherwise, keep the largest cost:    \\n            else:\\n                maxPositive = max(maxPositive, tran[0])\\n\\n\\n        return max(cur + maxPositive, maxCur)    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970914,
                "title": "java-two-approaches-with-sorting-greedy-binary-searching",
                "content": "**Approach** - \\n1. We must find the minimum money so that we can pass all the transactions performed in any order. So, with minimum money, we should be able to pass the worst case possible after rearranging the given array.\\n2. There can be two types of transactions possible.\\n    2.1. First type are when cashback is less than cost. So, there will be loss of money after this transaction. We can call them loss ones.\\n    2.2 Second type are when cashback is greater than or equal to cost, we will gain some money after this transaction. We can call them neutral ones.\\n3. To create the worst we can think of executing the loss transactions before the neutral ones.\\n4. Now, the question is what should be the order of loss and neutral ones.\\n    4.1. If we arrange loss transactions in increasing order of their cashbacks. Then, we can think of one answer as the cost required to be able to pass the last of loss transaction arranged in inceasing order of their cashback. Because at this point, we will be most negative before accepting its cashback.\\n    4.3. What if we arrange neutral ones in decreasing order of their cost. Then at the beginning of these type of transactions after completing all the loss transactions. We may need the most amount of starting money. Because after completing each of the neutral transaction, we will gain some money and the required starting money will decrease.\\n5. So, now we have two possible answers. Compare and return the maximum value.\\n6. We don\\'t need to separate and create different list of for both types of transactions. If we observe carefully, we can think of the solution in linear with 1 traversal only.\\n\\nT.C is O(N) and S.C is O(1)\\n```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        int maxCashBackForLoss = 0, maxCostForProfit = 0;\\n        long total = 0l;\\n        for(int i = 0; i<transactions.length; ++i){\\n            if(transactions[i][0] > transactions[i][1]){\\n                // Loss transaction\\n                total += (transactions[i][0] - transactions[i][1]);\\n                maxCashBackForLoss = (int)Math.max(maxCashBackForLoss, transactions[i][1]);\\n            }\\n            else{\\n                maxCostForProfit = Math.max(maxCostForProfit, transactions[i][0]);\\n            }\\n        }\\n        \\n        long maxValue = 0l;\\n        // maxValue = (long)Math.max(maxValue, total + maxCashBackForLoss);\\n        // maxValue = (long)Math.max(maxValue, total + maxCostForProfit);\\n        // return maxValue;\\n        // Above code can be simplied to below single statement\\n        return total + (long)Math.max(maxCashBackForLoss, maxCostForProfit);\\n    }\\n}\\n\\n```\\n\\n\\nBelow approach is based as above one but uses binary search. It is slow as compared to above one but more intutive.\\n\\n**Approach** - \\n1. Divide transactions into losses and gains with losses in increasing order of their cashback and gains in decreasing order of their cost. As discussed above.\\n2. Then do binarySearch from 0l to Long.MAX_VALUE and try to pass both losses and gains for each mid value and shift end and start points of binary search accordingly.\\n\\nT.C is O(N*logN) and S.C is O(N)\\n\\n```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        List<Integer> losses = new ArrayList<>(), gains = new ArrayList<>();\\n        for(int i = 0; i<transactions.length; ++i){\\n            if(transactions[i][0] > transactions[i][1]){\\n                losses.add(i);\\n            }\\n            else gains.add(i);\\n        }\\n        \\n        Collections.sort(losses, (i1,i2)->transactions[i1][1] - transactions[i2][1]);\\n        Collections.sort(gains, (i1,i2)->transactions[i2][0] - transactions[i1][0]);\\n        \\n        long start = 0l, end = Long.MAX_VALUE, mid, minValue = Long.MAX_VALUE;\\n        while(start <= end){\\n            mid = start + (end - start)/2;\\n            if(check(losses, gains, mid, transactions)){\\n                minValue = mid;\\n                end = mid - 1;\\n            }\\n            else start = mid + 1;\\n        }\\n        \\n        return minValue;\\n    }\\n    \\n    private boolean check(List<Integer> losses, List<Integer> gains, long money, int[][] transactions){\\n        for(int i : losses){\\n            if(money < transactions[i][0]){\\n                return false;\\n            }\\n            money = money - transactions[i][0] + transactions[i][1];\\n        }\\n        \\n        for(int i : gains){\\n            if(money < transactions[i][0]){\\n                return false;\\n            }\\n            money = money - transactions[i][0] + transactions[i][1];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        int maxCashBackForLoss = 0, maxCostForProfit = 0;\\n        long total = 0l;\\n        for(int i = 0; i<transactions.length; ++i){\\n            if(transactions[i][0] > transactions[i][1]){\\n                // Loss transaction\\n                total += (transactions[i][0] - transactions[i][1]);\\n                maxCashBackForLoss = (int)Math.max(maxCashBackForLoss, transactions[i][1]);\\n            }\\n            else{\\n                maxCostForProfit = Math.max(maxCostForProfit, transactions[i][0]);\\n            }\\n        }\\n        \\n        long maxValue = 0l;\\n        // maxValue = (long)Math.max(maxValue, total + maxCashBackForLoss);\\n        // maxValue = (long)Math.max(maxValue, total + maxCostForProfit);\\n        // return maxValue;\\n        // Above code can be simplied to below single statement\\n        return total + (long)Math.max(maxCashBackForLoss, maxCostForProfit);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        List<Integer> losses = new ArrayList<>(), gains = new ArrayList<>();\\n        for(int i = 0; i<transactions.length; ++i){\\n            if(transactions[i][0] > transactions[i][1]){\\n                losses.add(i);\\n            }\\n            else gains.add(i);\\n        }\\n        \\n        Collections.sort(losses, (i1,i2)->transactions[i1][1] - transactions[i2][1]);\\n        Collections.sort(gains, (i1,i2)->transactions[i2][0] - transactions[i1][0]);\\n        \\n        long start = 0l, end = Long.MAX_VALUE, mid, minValue = Long.MAX_VALUE;\\n        while(start <= end){\\n            mid = start + (end - start)/2;\\n            if(check(losses, gains, mid, transactions)){\\n                minValue = mid;\\n                end = mid - 1;\\n            }\\n            else start = mid + 1;\\n        }\\n        \\n        return minValue;\\n    }\\n    \\n    private boolean check(List<Integer> losses, List<Integer> gains, long money, int[][] transactions){\\n        for(int i : losses){\\n            if(money < transactions[i][0]){\\n                return false;\\n            }\\n            money = money - transactions[i][0] + transactions[i][1];\\n        }\\n        \\n        for(int i : gains){\\n            if(money < transactions[i][0]){\\n                return false;\\n            }\\n            money = money - transactions[i][0] + transactions[i][1];\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962095,
                "title": "binary-search-with-special-sort-77-90-faster-c-simple-short-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp1(vector<int>&v1,vector<int>&v2){\\n        if(v1[1]==v2[1]){\\n            return v1[0]>v2[0];\\n        }\\n        return v1[1]<v2[1];\\n    }\\n\\n    static bool cmp2(vector<int>&v1,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]<v2[1]; \\n        }\\n        return v1[0]>v2[0];\\n    }\\n\\n    bool check(vector<vector<int>>&cost,vector<vector<int>>&cashback,ll same,ll mid){\\n        ll current=mid,n=cost.size(),m=cashback.size();\\n        for(ll i=0;i<n;i++){\\n            if(current<cost[i][0]){\\n                return false;\\n            }\\n            current=(current-cost[i][0]+cost[i][1]);\\n        }\\n        if(current<same){\\n            return false;\\n        }\\n        for(ll i=0;i<m;i++){\\n            if(current<cashback[i][0]){\\n                return false;\\n            }\\n            current=(current-cashback[i][0]+cashback[i][1]);\\n        }\\n        return true;\\n    }\\n\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        ll n=transactions.size(),same=INT_MIN;\\n        vector<vector<int>>cost,cashback;\\n        for(auto &x:transactions){\\n            if(x[1]<x[0]){\\n                cost.push_back(x);\\n            }\\n            else if(x[1]>x[0]){\\n                cashback.push_back(x);\\n            }\\n            else{\\n                same=max(same,(ll)x[1]);\\n            }\\n        }\\n        sort(cost.begin(),cost.end(),cmp1);\\n        sort(cashback.begin(),cashback.end(),cmp2);\\n        ll low=0,high=1e17,answer,mid;\\n        while(low<=high){\\n            mid=(low+high)>>1;\\n            if(check(cost,cashback,same,mid)){\\n                answer=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp1(vector<int>&v1,vector<int>&v2){\\n        if(v1[1]==v2[1]){\\n            return v1[0]>v2[0];\\n        }\\n        return v1[1]<v2[1];\\n    }\\n\\n    static bool cmp2(vector<int>&v1,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]<v2[1]; \\n        }\\n        return v1[0]>v2[0];\\n    }\\n\\n    bool check(vector<vector<int>>&cost,vector<vector<int>>&cashback,ll same,ll mid){\\n        ll current=mid,n=cost.size(),m=cashback.size();\\n        for(ll i=0;i<n;i++){\\n            if(current<cost[i][0]){\\n                return false;\\n            }\\n            current=(current-cost[i][0]+cost[i][1]);\\n        }\\n        if(current<same){\\n            return false;\\n        }\\n        for(ll i=0;i<m;i++){\\n            if(current<cashback[i][0]){\\n                return false;\\n            }\\n            current=(current-cashback[i][0]+cashback[i][1]);\\n        }\\n        return true;\\n    }\\n\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        ll n=transactions.size(),same=INT_MIN;\\n        vector<vector<int>>cost,cashback;\\n        for(auto &x:transactions){\\n            if(x[1]<x[0]){\\n                cost.push_back(x);\\n            }\\n            else if(x[1]>x[0]){\\n                cashback.push_back(x);\\n            }\\n            else{\\n                same=max(same,(ll)x[1]);\\n            }\\n        }\\n        sort(cost.begin(),cost.end(),cmp1);\\n        sort(cashback.begin(),cashback.end(),cmp2);\\n        ll low=0,high=1e17,answer,mid;\\n        while(low<=high){\\n            mid=(low+high)>>1;\\n            if(check(cost,cashback,same,mid)){\\n                answer=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955750,
                "title": "go-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this function is to find the minimum amount of money that needs to be paid in order to make all transactions \"good\". A transaction is good if the amount received is greater than or equal to the amount spent.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken in this function is to first separate the transactions into two lists: \"good\" transactions and \"bad\" transactions. A \"good\" transaction is one where the amount received is greater than or equal to the amount spent, and a \"bad\" transaction is one where the amount received is less than the amount spent.\\n\\nOnce the transactions are separated, the function calculates the minimum amount of money needed to make the \"bad\" transactions good. This is done by adding up the difference between the amount received and the amount spent for each \"bad\" transaction, and also keeping track of the maximum amount spent in any \"bad\" transaction.\\n\\nFinally, the function looks at the \"good\" transactions and keeps track of the maximum amount received in any \"good\" transaction.\\n\\nThe minimum amount of money needed to make all transactions good is then calculated by adding the sum of the differences between the amounts received and spent for the \"bad\" transactions, and the maximum amount received or spent in either the \"good\" or \"bad\" transactions.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), where n is the number of transactions. This is because the function only needs to iterate through the transactions once in order to separate them into \"good\" and \"bad\" lists, and then again in order to calculate the minimum amount of money needed to make all transactions good.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is also O(n), as it creates two lists (one for \"good\" transactions and one for \"bad\" transactions) that have a size equal to the number of transactions.\\n# Code\\n```\\nfunc minimumMoney(transactions [][]int) int64 {\\n    good, bad := [][]int{}, [][]int{}\\n    for _, t := range transactions {\\n        c, g := t[0], t[1]\\n        if c > g {\\n            bad = append(bad, []int{c, g})\\n        } else {\\n            good = append(good, []int{c, g})\\n        }\\n    }\\n    base, extra := 0, 0\\n    for _, b := range bad {\\n        base += b[0] - b[1]\\n        extra = max(extra, b[1])\\n    }\\n    for _, g := range good {\\n        extra = max(extra, g[0])\\n    }\\n    return int64(base + extra)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumMoney(transactions [][]int) int64 {\\n    good, bad := [][]int{}, [][]int{}\\n    for _, t := range transactions {\\n        c, g := t[0], t[1]\\n        if c > g {\\n            bad = append(bad, []int{c, g})\\n        } else {\\n            good = append(good, []int{c, g})\\n        }\\n    }\\n    base, extra := 0, 0\\n    for _, b := range bad {\\n        base += b[0] - b[1]\\n        extra = max(extra, b[1])\\n    }\\n    for _, g := range good {\\n        extra = max(extra, g[0])\\n    }\\n    return int64(base + extra)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2829489,
                "title": "c-greedy-faster-than-85-o-n-easy-solution",
                "content": "```\\n#define in long long\\n\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        vector<vector<in>>v;\\n        in maxima = 0;\\n        for(auto vec:transactions)\\n        {\\n            in i = vec[0], j =vec[1];\\n            // IF CASHACK IS MORE THAN AMOUNT WE USED \\n            // DONT CHECK IT , JUST TAKE MAX OF ALL THIS COSTS\\n            // BECAUSE IN WORST CASE WE WILL USE THAT BEFORE OTHER\\n            // COSTi<=CASHBACKi\\n            \\n            if(i<=j)\\n            {\\n                maxima = max(i,maxima);\\n            }else{ \\n                v.push_back({j,i});  // PUSH {CASHBACKi,COSTi}\\n            }\\n        }\\n        // SORT BASED ON THE CAHSBACK\\n        sort(v.begin(),v.end());\\n        \\n        in money_used=0,money_left=0;\\n        \\n        // MONEY USED => MONEY WE HAVE TAKEN TO REACH UP TO CURRENT INDEX\\n        // MONEY LEFT => MONEY LEFT AFTER GETTING CURRENT INDEX CAHBACK\\n        for(auto vec:v)\\n        {\\n            \\n            in i = vec[0],j=vec[1];\\n            \\n            // IF WE NEED ANY MONEY TO DO CURRENT TRANSACTION\\n            in needed = money_left>=j ? 0 : j-money_left;\\n            \\n            money_used += needed;   // ADD TO MONEY USED\\n            money_left = i;         // MONEY LEFT = CASHBACK\\n        }\\n        // TO TAKE CURRENT ELEMENT THAT MAX ELEMENT OF CASHBACKi>=COSTi\\n        // WE NEED LEFT MONEY = COSTi \\n        if(money_left<maxima) money_used += (maxima-money_left);\\n        return money_used;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        vector<vector<in>>v;\\n        in maxima = 0;\\n        for(auto vec:transactions)\\n        {\\n            in i = vec[0], j =vec[1];\\n            // IF CASHACK IS MORE THAN AMOUNT WE USED \\n            // DONT CHECK IT , JUST TAKE MAX OF ALL THIS COSTS\\n            // BECAUSE IN WORST CASE WE WILL USE THAT BEFORE OTHER\\n            // COSTi<=CASHBACKi\\n            \\n            if(i<=j)\\n            {\\n                maxima = max(i,maxima);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2821461,
                "title": "easy-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        long ret = 0;\\n        int maxcost = INT_MIN;\\n        int maxback = INT_MIN;\\n        for (auto & t : transactions) {\\n            int delta = t[1] - t[0];\\n            if (delta < 0) {\\n                ret += delta;\\n                maxback = max(maxback, t[1]);\\n            }\\n            else {\\n                maxcost = max(maxcost, t[0]);\\n            }\\n        }\\n        return -min(ret - maxcost, ret - maxback);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        long ret = 0;\\n        int maxcost = INT_MIN;\\n        int maxback = INT_MIN;\\n        for (auto & t : transactions) {\\n            int delta = t[1] - t[0];\\n            if (delta < 0) {\\n                ret += delta;\\n                maxback = max(maxback, t[1]);\\n            }\\n            else {\\n                maxcost = max(maxcost, t[0]);\\n            }\\n        }\\n        return -min(ret - maxcost, ret - maxback);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745722,
                "title": "c-with-single-iteration-o-sizeof-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long loss = 0;\\n        int maxa = 0;\\n        for(int i = 0; i < transactions.size(); ++i)\\n        {\\n            if(transactions[i][0] > transactions[i][1])\\n            {\\n                loss += transactions[i][0]-transactions[i][1];\\n                maxa = max(maxa, transactions[i][1]);\\n            }\\n            else\\n                maxa = max(maxa, transactions[i][0]);\\n        }\\n        return loss + (long long)maxa;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long loss = 0;\\n        int maxa = 0;\\n        for(int i = 0; i < transactions.size(); ++i)\\n        {\\n            if(transactions[i][0] > transactions[i][1])\\n            {\\n                loss += transactions[i][0]-transactions[i][1];\\n                maxa = max(maxa, transactions[i][1]);\\n            }\\n            else\\n                maxa = max(maxa, transactions[i][0]);\\n        }\\n        return loss + (long long)maxa;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688969,
                "title": "c-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        //sum of total_loss + trans[i][0]\\n        long long sum = 0;\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            sum+=transactions[i][0];\\n        }\\n        long long total_loss =0;\\n        long long ans = 9223372036854775807;\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            if(transactions[i][1]<transactions[i][0])\\n            {\\n                total_loss+=(transactions[i][0]-transactions[i][1]);\\n            }\\n        }\\n        bool ll=false;\\n        if(total_loss==0)\\n        {\\n            ll=true;\\n            for(int i=0;i<transactions.size();i++)\\n            {\\n                total_loss+=(transactions[i][0]-transactions[i][1]);\\n            }\\n        }\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            long long u = total_loss;\\n            long long y =0;\\n            if(transactions[i][1]<transactions[i][0])\\n            {\\n                y=(transactions[i][0]-transactions[i][1]);\\n            }\\n            else if(ll==true)\\n            {\\n                y=(transactions[i][0]-transactions[i][1]);\\n            }\\n            long long pp = u - y;\\n            pp = sum-pp;\\n            ans = min(ans,pp-transactions[i][0]);\\n            ans = min(ans,sum-transactions[i][0]);\\n        }\\n        long long gg=sum-ans;\\n        return gg;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        //sum of total_loss + trans[i][0]\\n        long long sum = 0;\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            sum+=transactions[i][0];\\n        }\\n        long long total_loss =0;\\n        long long ans = 9223372036854775807;\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            if(transactions[i][1]<transactions[i][0])\\n            {\\n                total_loss+=(transactions[i][0]-transactions[i][1]);\\n            }\\n        }\\n        bool ll=false;\\n        if(total_loss==0)\\n        {\\n            ll=true;\\n            for(int i=0;i<transactions.size();i++)\\n            {\\n                total_loss+=(transactions[i][0]-transactions[i][1]);\\n            }\\n        }\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            long long u = total_loss;\\n            long long y =0;\\n            if(transactions[i][1]<transactions[i][0])\\n            {\\n                y=(transactions[i][0]-transactions[i][1]);\\n            }\\n            else if(ll==true)\\n            {\\n                y=(transactions[i][0]-transactions[i][1]);\\n            }\\n            long long pp = u - y;\\n            pp = sum-pp;\\n            ans = min(ans,pp-transactions[i][0]);\\n            ans = min(ans,sum-transactions[i][0]);\\n        }\\n        long long gg=sum-ans;\\n        return gg;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685835,
                "title": "two-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    long long ans = 0, current_cash = 0;\\n    void solve(vector<vector<int>> transactions){\\n        for(int i = 0; i < transactions.size(); i++){\\n              if(current_cash >= transactions[i][0]){\\n                  current_cash = (current_cash - transactions[i][0] + transactions[i][1]);\\n              }\\n              else{\\n                  ans += (transactions[i][0] - current_cash);\\n                  current_cash += (transactions[i][0] - current_cash);\\n                  current_cash = (current_cash - transactions[i][0] + transactions[i][1]);\\n              }\\n          }\\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        vector<vector<int>> pos, neg;\\n        \\n        for(int i = 0; i < transactions.size(); i++){\\n            if(transactions[i][1] - transactions[i][0] <= 0) \\n                neg.push_back({transactions[i][0], transactions[i][1]});\\n            else \\n                pos.push_back({transactions[i][0], transactions[i][1]});\\n        }\\n        \\n        sort(neg.begin(),\\n          neg.end(),\\n          [] (const vector<int> &a, const vector<int> &b)\\n          {\\n              return a[1] < b[1];\\n          });\\n        \\n        sort(pos.begin(),\\n          pos.end(),\\n          [] (const vector<int> &a, const vector<int> &b)\\n          {\\n              return a[0] > b[0];\\n          });\\n        \\n          solve(neg);\\n          solve(pos);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = 0, current_cash = 0;\\n    void solve(vector<vector<int>> transactions){\\n        for(int i = 0; i < transactions.size(); i++){\\n              if(current_cash >= transactions[i][0]){\\n                  current_cash = (current_cash - transactions[i][0] + transactions[i][1]);\\n              }\\n              else{\\n                  ans += (transactions[i][0] - current_cash);\\n                  current_cash += (transactions[i][0] - current_cash);\\n                  current_cash = (current_cash - transactions[i][0] + transactions[i][1]);\\n              }\\n          }\\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        vector<vector<int>> pos, neg;\\n        \\n        for(int i = 0; i < transactions.size(); i++){\\n            if(transactions[i][1] - transactions[i][0] <= 0) \\n                neg.push_back({transactions[i][0], transactions[i][1]});\\n            else \\n                pos.push_back({transactions[i][0], transactions[i][1]});\\n        }\\n        \\n        sort(neg.begin(),\\n          neg.end(),\\n          [] (const vector<int> &a, const vector<int> &b)\\n          {\\n              return a[1] < b[1];\\n          });\\n        \\n        sort(pos.begin(),\\n          pos.end(),\\n          [] (const vector<int> &a, const vector<int> &b)\\n          {\\n              return a[0] > b[0];\\n          });\\n        \\n          solve(neg);\\n          solve(pos);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640061,
                "title": "minimum-money-solution-90-faster",
                "content": "class Solution:\\n\\n    def minimumMoney(self, A):\\n        res = v = 0\\n        for i,j in A:\\n            res += max(0, i - j)\\n            v = max(v, min(i, j))\\n        return res + v",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def minimumMoney(self, A):\\n        res = v = 0\\n        for i,j in A:\\n            res += max(0, i - j)\\n            v = max(v, min(i, j))\\n        return res + v",
                "codeTag": "Java"
            },
            {
                "id": 2637455,
                "title": "c-solution",
                "content": "```\\nlong long minimumMoney(int** transactions, int transactionsSize, int* transactionsColSize){\\n    long long ans = 0;\\n    int mostback = 0;\\n    int makemoney = -1;\\n    for (int i = 0 ; i < transactionsSize ; i++){\\n        if (transactions[i][0] > transactions[i][1]){\\n            ans += transactions[i][0]-transactions[i][1];\\n            if (mostback < transactions[i][1]){\\n                mostback = transactions[i][1];\\n            }\\n        } else {\\n            if (makemoney < transactions[i][0]){\\n                makemoney = transactions[i][0];\\n            }\\n        }\\n    }\\n    \\n    if (mostback < makemoney){\\n        ans += makemoney;\\n    } else {\\n        ans += mostback;\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long minimumMoney(int** transactions, int transactionsSize, int* transactionsColSize){\\n    long long ans = 0;\\n    int mostback = 0;\\n    int makemoney = -1;\\n    for (int i = 0 ; i < transactionsSize ; i++){\\n        if (transactions[i][0] > transactions[i][1]){\\n            ans += transactions[i][0]-transactions[i][1];\\n            if (mostback < transactions[i][1]){\\n                mostback = transactions[i][1];\\n            }\\n        } else {\\n            if (makemoney < transactions[i][0]){\\n                makemoney = transactions[i][0];\\n            }\\n        }\\n    }\\n    \\n    if (mostback < makemoney){\\n        ans += makemoney;\\n    } else {\\n        ans += mostback;\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629243,
                "title": "simple-greedy-o-n-c",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& trans) {\\n       \\n        \\n        \\n        ll n=trans.size();\\n        \\n        vector<vector<ll>>act; // act[i][0]--> cost[i]-cashback[i]   act[i][0]--> cost[i]\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            act.push_back({trans[i][0]-trans[i][1],trans[i][0]});\\n        }\\n        \\n     \\n        ll l[n];   // l[i]---> maximum sum take we can form from elemnts from 0 to i\\n        ll r[n];  // r[i]---> maximum sum take we can form from elemnts from i+1 to n-1\\n        \\n        l[0]=max((ll)0,act[0][0]);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=(l[i-1]+max((ll)0,act[i][0]));\\n        }\\n        \\n        r[n-1]=max((ll)0,act[n-1][0]);\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=(r[i+1]+max((ll)0,act[i][0]));\\n        }\\n        \\n      \\n        ll ans=0;\\n        // solution is max of.  cost[i]+l[i-1]+r[i+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans,act[i][1]+(i==0?0:l[i-1])+(i==n-1?0:r[i+1]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& trans) {\\n       \\n        \\n        \\n        ll n=trans.size();\\n        \\n        vector<vector<ll>>act; // act[i][0]--> cost[i]-cashback[i]   act[i][0]--> cost[i]\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            act.push_back({trans[i][0]-trans[i][1],trans[i][0]});\\n        }\\n        \\n     \\n        ll l[n];   // l[i]---> maximum sum take we can form from elemnts from 0 to i\\n        ll r[n];  // r[i]---> maximum sum take we can form from elemnts from i+1 to n-1\\n        \\n        l[0]=max((ll)0,act[0][0]);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=(l[i-1]+max((ll)0,act[i][0]));\\n        }\\n        \\n        r[n-1]=max((ll)0,act[n-1][0]);\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=(r[i+1]+max((ll)0,act[i][0]));\\n        }\\n        \\n      \\n        ll ans=0;\\n        // solution is max of.  cost[i]+l[i-1]+r[i+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=max(ans,act[i][1]+(i==0?0:l[i-1])+(i==n-1?0:r[i+1]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611527,
                "title": "go-binary-search",
                "content": "```\\nunc minimumMoney(transactions [][]int) int64 {\\n    t := transactions\\n    \\n    top := 0\\n    diff := 0\\n    for _, v := range t {\\n        top += v[0]\\n        if v[0] > v[1] {\\n            diff += v[0] - v[1]\\n        }\\n    }\\n\\n    return int64(sort.Search(top + 1, func(i int) bool {\\n        for _, v := range t {\\n            a := diff\\n            if v[0] > v[1] {\\n                a -= v[0] - v[1]\\n            }\\n            if i - a < v[0] {\\n                return false\\n            }\\n        }\\n        return true\\n    }))    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nunc minimumMoney(transactions [][]int) int64 {\\n    t := transactions\\n    \\n    top := 0\\n    diff := 0\\n    for _, v := range t {\\n        top += v[0]\\n        if v[0] > v[1] {\\n            diff += v[0] - v[1]\\n        }\\n    }\\n\\n    return int64(sort.Search(top + 1, func(i int) bool {\\n        for _, v := range t {\\n            a := diff\\n            if v[0] > v[1] {\\n                a -= v[0] - v[1]\\n            }\\n            if i - a < v[0] {\\n                return false\\n            }\\n        }\\n        return true\\n    }))    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2611175,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        \\n        Arrays.sort(transactions,(a,b)->{\\n            int a_min = Math.min(-a[0],-a[0]+a[1]-b[0]);\\n            int b_min = Math.min(-b[0],-b[0]+b[1]-a[0]);\\n            if (a_min!=b_min) return a_min - b_min;\\n            else return b[0]-a[0];\\n            \\n        });\\n        \\n        long ans = 0;\\n        long cost = 0;\\n        for(int t[]:transactions){\\n            cost-= t[0];\\n            ans = Math.min(ans,cost);\\n            cost+=t[1];\\n        }\\n        \\n      return Math.abs(ans);  \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        \\n        Arrays.sort(transactions,(a,b)->{\\n            int a_min = Math.min(-a[0],-a[0]+a[1]-b[0]);\\n            int b_min = Math.min(-b[0],-b[0]+b[1]-a[0]);\\n            if (a_min!=b_min) return a_min - b_min;\\n            else return b[0]-a[0];\\n            \\n        });\\n        \\n        long ans = 0;\\n        long cost = 0;\\n        for(int t[]:transactions){\\n            cost-= t[0];\\n            ans = Math.min(ans,cost);\\n            cost+=t[1];\\n        }\\n        \\n      return Math.abs(ans);  \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610535,
                "title": "javascript-easy-solution-greedy",
                "content": "\\n```\\nvar minimumMoney = function(transactions) {\\n    let maxCost = 0;\\n    let maxCash = 0;\\n    let money = 0;\\n    \\n    for(let i = 0; i < transactions.length; i++){\\n        if(transactions[i][0] > transactions[i][1]){\\n            money += transactions[i][0] - transactions[i][1];\\n            maxCash = Math.max(maxCash, transactions[i][1]);\\n        } else{\\n            maxCost =  Math.max(maxCost, transactions[i][0]);\\n        }\\n    }\\n    return money + Math.max(maxCash, maxCost) ;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar minimumMoney = function(transactions) {\\n    let maxCost = 0;\\n    let maxCash = 0;\\n    let money = 0;\\n    \\n    for(let i = 0; i < transactions.length; i++){\\n        if(transactions[i][0] > transactions[i][1]){\\n            money += transactions[i][0] - transactions[i][1];\\n            maxCash = Math.max(maxCash, transactions[i][1]);\\n        } else{\\n            maxCost =  Math.max(maxCost, transactions[i][0]);\\n        }\\n    }\\n    return money + Math.max(maxCash, maxCost) ;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2610457,
                "title": "java-one-pass-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        int max = 0;\\n        long sum = 0;\\n        for (int[] transaction : transactions) {\\n            int diff = transaction[1]-transaction[0];\\n            if (diff < 0) {\\n                sum -= diff;\\n                transaction[0] += diff;\\n            }\\n            max = Math.max(max, transaction[0]);\\n        }\\n        return max+sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        int max = 0;\\n        long sum = 0;\\n        for (int[] transaction : transactions) {\\n            int diff = transaction[1]-transaction[0];\\n            if (diff < 0) {\\n                sum -= diff;\\n                transaction[0] += diff;\\n            }\\n            max = Math.max(max, transaction[0]);\\n        }\\n        return max+sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608463,
                "title": "c-easy",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) \\n    {\\n        ll total=0;\\n        for(auto &x:transactions)total+=max(0,x[0]-x[1]);\\n        ll ans=0;\\n        for(auto &x:transactions)ans=max(ans,1ll*x[0]);\\n        if(total==0)return ans;\\n        for(auto &x:transactions)\\n        {\\n            if(x[0]<=x[1])ans=max(total+x[0],ans);\\n            else ans=max(total-(x[0]-x[1])+x[0],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) \\n    {\\n        ll total=0;\\n        for(auto &x:transactions)total+=max(0,x[0]-x[1]);\\n        ll ans=0;\\n        for(auto &x:transactions)ans=max(ans,1ll*x[0]);\\n        if(total==0)return ans;\\n        for(auto &x:transactions)\\n        {\\n            if(x[0]<=x[1])ans=max(total+x[0],ans);\\n            else ans=max(total-(x[0]-x[1])+x[0],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604880,
                "title": "simple-2d-sorting",
                "content": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        Queue<int[]> maxHeap = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        int maxValueProfit = 0;\\n        for(int[] transaction: transactions){\\n            int cost = transaction[0];\\n            int cashBack = transaction[1];\\n            if(cost>cashBack) maxHeap.offer(new int[]{cost,cashBack});\\n            else maxValueProfit = Math.max(maxValueProfit,cost);\\n        }\\n        long answer = 0L, cur_money = 0L;\\n        while(!maxHeap.isEmpty()){\\n            int[] transaction = maxHeap.remove();\\n            int cost = transaction[0];\\n            int cashBack = transaction[1];\\n            if(cur_money<cost){\\n                answer += cost-cur_money;\\n                cur_money = cost;\\n            }\\n            cur_money -= cost;\\n            cur_money += cashBack;\\n        }\\n        if(cur_money<maxValueProfit) answer += (maxValueProfit-cur_money);\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        Queue<int[]> maxHeap = new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        int maxValueProfit = 0;\\n        for(int[] transaction: transactions){\\n            int cost = transaction[0];\\n            int cashBack = transaction[1];\\n            if(cost>cashBack) maxHeap.offer(new int[]{cost,cashBack});\\n            else maxValueProfit = Math.max(maxValueProfit,cost);\\n        }\\n        long answer = 0L, cur_money = 0L;\\n        while(!maxHeap.isEmpty()){\\n            int[] transaction = maxHeap.remove();\\n            int cost = transaction[0];\\n            int cashBack = transaction[1];\\n            if(cur_money<cost){\\n                answer += cost-cur_money;\\n                cur_money = cost;\\n            }\\n            cur_money -= cost;\\n            cur_money += cashBack;\\n        }\\n        if(cur_money<maxValueProfit) answer += (maxValueProfit-cur_money);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603126,
                "title": "sort-and-prefix-sum-worst-case-then-binary-search",
                "content": "Calculate the biggest negative value we can get.\\n\\n```\\n\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        # let us see at what point we go to highest loss\\n        totalLoss = 0\\n        for cost,cashback in transactions:\\n            if cost > cashback:\\n                totalLoss += cashback-cost\\n            \\n        def calc(money):\\n            # for a given money, let us figure out if we can hit the barrier \\n            for cost,cashback in transactions:\\n                loss = totalLoss\\n                if cost > cashback:\\n                    loss += cost-cashback\\n                \\n                if (money+loss) < cost:\\n                    return False\\n            return True\\n        costSum = sum(map(itemgetter(0),transactions))\\n        cashSum = sum(map(itemgetter(1),transactions))\\n        lo = max(0,costSum-cashSum)\\n        hi = costSum\\n        while lo < hi:\\n            mid = (lo+hi) >> 1\\n            if calc(mid):\\n                hi = mid\\n            else:\\n                lo = mid+1\\n        return lo\\n```\\n\\nNow try to figure out the money we need do binary search.\\n\\t- In each step of binary search, we go through all the individual costs\\n\\t\\t- For each of the individual cost, we check if we have enough money by considering the `biggest loss` we calculated above. \\n\\nTime complexity is `n log(n)`",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        # let us see at what point we go to highest loss\\n        totalLoss = 0\\n        for cost,cashback in transactions:\\n            if cost > cashback:\\n                totalLoss += cashback-cost\\n            \\n        def calc(money):\\n            # for a given money, let us figure out if we can hit the barrier \\n            for cost,cashback in transactions:\\n                loss = totalLoss\\n                if cost > cashback:\\n                    loss += cost-cashback\\n                \\n                if (money+loss) < cost:\\n                    return False\\n            return True\\n        costSum = sum(map(itemgetter(0),transactions))\\n        cashSum = sum(map(itemgetter(1),transactions))\\n        lo = max(0,costSum-cashSum)\\n        hi = costSum\\n        while lo < hi:\\n            mid = (lo+hi) >> 1\\n            if calc(mid):\\n                hi = mid\\n            else:\\n                lo = mid+1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599553,
                "title": "easy-python-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        good, bad = [], []\\n        for c, g in transactions:\\n            if c > g:\\n                bad.append([c, g])\\n            else:\\n                good.append([c, g])\\n        \\n        base = extra = 0\\n        for c, g in bad:\\n            base += c - g\\n            extra = max(extra, g)\\n        for c, g in good:\\n            extra = max(extra, c)\\n        return base + extra\\n    # Time: O(n) where n is the number of transactions\\n    # Space: O(n)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        good, bad = [], []\\n        for c, g in transactions:\\n            if c > g:\\n                bad.append([c, g])\\n            else:\\n                good.append([c, g])\\n        \\n        base = extra = 0\\n        for c, g in bad:\\n            base += c - g\\n            extra = max(extra, g)\\n        for c, g in good:\\n            extra = max(extra, c)\\n        return base + extra\\n    # Time: O(n) where n is the number of transactions\\n    # Space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599239,
                "title": "golang-no-sort",
                "content": "If we transform this problem to the X,Y coordinate; \\nThe peak point is the answer.\\n\\nGraph:\\n```\\n        cb\\n      c   b\\n    c      b\\n   c \\n c\\n \\n[5,-3]    \\n```\\n\\n\\nSo we do,\\n1. Sum( t1[0]-t1[1])  which t1  in  [ cost >= cashback ] and plus back the largest cashback t1[i] for the first peak point.\\n2. Because there is a potential second peak point when do a transaction t2 ,which t2 in [ cost < cashback] has largest cost. Therefore,  highest peak point = Max( first peak point,  Sum( t[0]-t[1]) + largest cashback of t2 )\\nwhich t1  in  [ cost >= cashback ]\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nNo Sort Version:\\n```\\nfunc minimumMoney(transactions [][]int) int64 {\\n\\tvar largestRewardT []int\\n\\ttopCost := 0\\n\\tlargestCachBackOfCostT := 0\\n\\tfor _, t := range transactions {\\n\\t\\tif 0 <= t[0]-t[1] {\\n\\t\\t\\ttopCost += t[0] - t[1]\\n\\t\\t\\tif largestCachBackOfCostT < t[1] {\\n\\t\\t\\t\\tlargestCachBackOfCostT = t[1]\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif largestRewardT == nil || largestRewardT[0] < t[0] {\\n\\t\\t\\t\\tlargestRewardT = t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\ttopCost += largestCachBackOfCostT\\n\\n\\tif largestRewardT != nil {\\n\\t\\ttopCost = Max(topCost, topCost+largestRewardT[0]-largestCachBackOfCostT)\\n\\t}\\n\\n\\treturn int64(topCost)\\n}\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nSort Version:\\n```\\nfunc minimumMoneySort(transactions [][]int) int64 {\\n\\tvar costT [][]int\\n\\tvar largestRewardT []int\\n\\tfor _, t := range transactions {\\n\\t\\tif 0 <= t[0]-t[1] {\\n\\t\\t\\tcostT = append(costT, t)\\n\\t\\t} else {\\n\\t\\t\\tif largestRewardT == nil || largestRewardT[0] < t[0] {\\n\\t\\t\\t\\tlargestRewardT = t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tsort.SliceStable(costT, func(i, j int) bool {\\n\\t\\treturn costT[i][1] < costT[j][1]\\n\\t})\\n\\t// last one with largest cost\\n\\tif largestRewardT != nil {\\n\\t\\tcostT = append(costT, largestRewardT)\\n\\t}\\n\\tres := 0\\n\\tsum := 0\\n\\tfor _, t := range costT {\\n\\t\\tsum = sum + t[0]\\n\\t\\tres = Max(res, sum)\\n\\t\\tsum = sum - t[1]\\n\\t}\\n\\n\\treturn int64(res)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n        cb\\n      c   b\\n    c      b\\n   c \\n c\\n \\n[5,-3]    \\n```\n```\\nfunc minimumMoney(transactions [][]int) int64 {\\n\\tvar largestRewardT []int\\n\\ttopCost := 0\\n\\tlargestCachBackOfCostT := 0\\n\\tfor _, t := range transactions {\\n\\t\\tif 0 <= t[0]-t[1] {\\n\\t\\t\\ttopCost += t[0] - t[1]\\n\\t\\t\\tif largestCachBackOfCostT < t[1] {\\n\\t\\t\\t\\tlargestCachBackOfCostT = t[1]\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif largestRewardT == nil || largestRewardT[0] < t[0] {\\n\\t\\t\\t\\tlargestRewardT = t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\ttopCost += largestCachBackOfCostT\\n\\n\\tif largestRewardT != nil {\\n\\t\\ttopCost = Max(topCost, topCost+largestRewardT[0]-largestCachBackOfCostT)\\n\\t}\\n\\n\\treturn int64(topCost)\\n}\\n```\n```\\nfunc minimumMoneySort(transactions [][]int) int64 {\\n\\tvar costT [][]int\\n\\tvar largestRewardT []int\\n\\tfor _, t := range transactions {\\n\\t\\tif 0 <= t[0]-t[1] {\\n\\t\\t\\tcostT = append(costT, t)\\n\\t\\t} else {\\n\\t\\t\\tif largestRewardT == nil || largestRewardT[0] < t[0] {\\n\\t\\t\\t\\tlargestRewardT = t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tsort.SliceStable(costT, func(i, j int) bool {\\n\\t\\treturn costT[i][1] < costT[j][1]\\n\\t})\\n\\t// last one with largest cost\\n\\tif largestRewardT != nil {\\n\\t\\tcostT = append(costT, largestRewardT)\\n\\t}\\n\\tres := 0\\n\\tsum := 0\\n\\tfor _, t := range costT {\\n\\t\\tsum = sum + t[0]\\n\\t\\tres = Max(res, sum)\\n\\t\\tsum = sum - t[1]\\n\\t}\\n\\n\\treturn int64(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2598841,
                "title": "java-two-solutions-sorting-versus-greedy",
                "content": "**sorting**\\nRuntime: 13 ms, faster than 48.66% of Java online submissions for Minimum Money Required Before Transactions.\\nMemory Usage: 75.7 MB, less than 99.81% of Java online submissions for Minimum Money Required Before Transactions.\\n```\\nclass Solution {\\n  public long minimumMoney(int[][] transactions) {\\n    ArrayList<int[]> list = new ArrayList<>(transactions.length);\\n    \\n    int maxi = 0;\\n    for(int[] t : transactions)\\n      if(t[0] <= t[1]) maxi = Math.max(maxi, t[0]);\\n      else list.add(t);  \\n   \\n    if(list.size() == 0) return maxi;\\n    Collections.sort(list, (int[] a, int[] b)-> \\n      a[1] - b[1] );\\n    \\n    long ans = 0, dif;\\n    for(int i = 0; i != list.size(); i++){\\n      ans += list.get(i)[0];\\n      if( i+1 == list.size()){\\n        if(list.size() == transactions.length) break;\\n        if(list.get(i)[1] < maxi) ans += maxi - list.get(i)[1]; \\n        break;\\n      } \\n      ans -= list.get(i)[1];  \\n    }\\n      \\n    return ans;\\n  }\\n}\\n```\\n\\n**greedy\\n(on second thought I understand that I can discard sorting all elements where [0] > [1] : I always use in my first solution only [1] the greatest number )**\\nRuntime: 3 ms, faster than 100.00% of Java online submissions for Minimum Money Required Before Transactions.\\nMemory Usage: 97.5 MB, less than 96.57% of Java online submissions for Minimum Money Required Before Transactions.\\n```\\nclass Solution {\\n  public long minimumMoney(int[][] transactions) {\\n    int maxi1 = 0, maxi2 = 0;\\n    long ans = 0;\\n    \\n    for(int[] t : transactions)\\n      if(t[0] <= t[1]) maxi1 = Math.max(maxi1, t[0]);\\n      else {ans += t[0] - t[1]; maxi2 = Math.max(maxi2, t[1]);}  \\n      \\n    return ans + (maxi1 > maxi2 ? maxi1 : maxi2);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long minimumMoney(int[][] transactions) {\\n    ArrayList<int[]> list = new ArrayList<>(transactions.length);\\n    \\n    int maxi = 0;\\n    for(int[] t : transactions)\\n      if(t[0] <= t[1]) maxi = Math.max(maxi, t[0]);\\n      else list.add(t);  \\n   \\n    if(list.size() == 0) return maxi;\\n    Collections.sort(list, (int[] a, int[] b)-> \\n      a[1] - b[1] );\\n    \\n    long ans = 0, dif;\\n    for(int i = 0; i != list.size(); i++){\\n      ans += list.get(i)[0];\\n      if( i+1 == list.size()){\\n        if(list.size() == transactions.length) break;\\n        if(list.get(i)[1] < maxi) ans += maxi - list.get(i)[1]; \\n        break;\\n      } \\n      ans -= list.get(i)[1];  \\n    }\\n      \\n    return ans;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public long minimumMoney(int[][] transactions) {\\n    int maxi1 = 0, maxi2 = 0;\\n    long ans = 0;\\n    \\n    for(int[] t : transactions)\\n      if(t[0] <= t[1]) maxi1 = Math.max(maxi1, t[0]);\\n      else {ans += t[0] - t[1]; maxi2 = Math.max(maxi2, t[1]);}  \\n      \\n    return ans + (maxi1 > maxi2 ? maxi1 : maxi2);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598578,
                "title": "scala-fairly-easy-to-understand",
                "content": "```scala\\ncase class Transaction(cost: Long, cashback: Long) {\\n  def netto: Long = cost - cashback\\n}\\n\\ndef minimumMoney(transactions: Array[Array[Int]]): Long = {\\n  val models = transactions.collect { case Array(cost, cashback) => Transaction(cost, cashback) }\\n  val (loss, others) = models.partition(_.netto > 0)\\n  if(loss.isEmpty) others.maxBy(_.cost).cost\\n  else {\\n    val totalLoss = loss.map(_.netto).sum\\n    val max1 = totalLoss + loss.maxBy(_.cashback).cashback\\n    others.maxByOption(_.cost).fold(max1)(o => math.max(max1, totalLoss + o.cost))\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ncase class Transaction(cost: Long, cashback: Long) {\\n  def netto: Long = cost - cashback\\n}\\n\\ndef minimumMoney(transactions: Array[Array[Int]]): Long = {\\n  val models = transactions.collect { case Array(cost, cashback) => Transaction(cost, cashback) }\\n  val (loss, others) = models.partition(_.netto > 0)\\n  if(loss.isEmpty) others.maxBy(_.cost).cost\\n  else {\\n    val totalLoss = loss.map(_.netto).sum\\n    val max1 = totalLoss + loss.maxBy(_.cashback).cashback\\n    others.maxByOption(_.cost).fold(max1)(o => math.max(max1, totalLoss + o.cost))\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597694,
                "title": "2-approaches-o-n-and-nlogn",
                "content": "// first approach is inspired by problem\\n// https://leetcode.com/problems/gas-station/\\n\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        ll deficit = 0;\\n        int maxCashback = 0;\\n        int maxCost = 0;\\n        \\n        \\n        \\n        for (auto &t : transactions) {\\n            if (t[0] > t[1]) {\\n                // Collect deficit across all costly transaction where\\n                // cost is lesser than the cashback\\n                // Collect the maxCashback, we would process it the last\\n                // to start the series with costly trades, we will need\\n                // atleast deficit and maxCashback upfront, this will ensure\\n                // that costly series can be processed fully\\n                deficit += (ll)(t[0]-t[1]);\\n                maxCashback = max(maxCashback,t[1]);\\n            } else {\\n                // in 2nd case we collect the maximumm Cost across all\\n                // profitable transactions, we would like to process maximumm cost first\\n                // as we will need to borrow max money for the same if we start with it.\\n                // Rest all can happen as smallest Cashback in profitable set will be lesser\\n                // than maxCost of the set\\n                maxCost = max(maxCost,t[0]);\\n            }\\n        }\\n        // result will sum of deficit and maximumm of casback and Cost\\n        // this will make sure that we have enough surplus to complete \\n        // all the transaction in worst case, with all costly transaction processed\\n        // first, with maxCashback obtained the last and of all profitable trades\\n        // picking up the maxCost first so that we need money upfront.\\n        return deficit + max(maxCashback,maxCost); \\n    }     \\n    long long minimumMoney1(vector<vector<int>>& transactions) {\\n        vector<vector<int>> costlyJobs;\\n        vector<vector<int>> profitJobs;\\n        ll result = 0;\\n        \\n        for (auto &p : transactions) {\\n            // pick up free money first\\n            if (p[0] <= p[1]) {\\n                profitJobs.push_back(p);\\n            } else {\\n                // push only those task which need money\\n                costlyJobs.push_back(p);\\n            }\\n        }\\n        \\n        // sort costly jobs with lesser cashback first, so that it will borrow max\\n        sort(costlyJobs.begin(),costlyJobs.end(),[](auto &a, auto &b) {return  a[1] < b[1] ; });\\n        \\n        // sort profitable jobs with higher cost first\\n        // as if heavy jobs don\\'t bring any cashback we will pick the heaviest job\\n        sort(profitJobs.begin(),profitJobs.end(),[](auto &a, auto &b) {return  a[0] == b[0] ? a[1] < b[1] : a[0] > b[0] ; });\\n     \\n        \\n        ll total = result;\\n        \\n        vector<vector<int>> allJobs;\\n        \\n        for (auto &p : costlyJobs) {\\n            allJobs.push_back(p);\\n        }\\n        for (auto &p : profitJobs) {\\n            allJobs.push_back(p);\\n        }\\n       \\n        \\n        \\n        for (int i = 0; i < allJobs.size(); i++) {\\n            int cost = allJobs[i][0];\\n            int cashback = allJobs[i][1];\\n            \\n            if (cost > total) {\\n                result = result + (cost-total);\\n                // keep collecting the cashback\\n                total = cashback;\\n            } else {\\n                // if can accomodate the job then collect the\\n                // cashback\\n                total = total-cost + cashback;\\n            }\\n        }\\n        \\n        return result;\\n  \\n    }\\n};\\n\\n\\nclass Solution1 {\\npublic:\\n    using ll = long long;\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        vector<pair<ll,ll>> jobs;\\n        vector<pair<ll,ll>> profitJobs;\\n        ll result = 0;\\n        \\n        for (auto &p : transactions) {\\n            // pick up free money first\\n            if (p[0] <= p[1]) {\\n                profitJobs.push_back({p[0],p[1]});\\n            } else {\\n                // push only those task which need money\\n                jobs.push_back({p[0],p[1]});\\n            }\\n        }\\n        sort(jobs.begin(),jobs.end(),[](auto &a, auto &b) {return   a.second < b.second ; });\\n        sort(profitJobs.begin(),profitJobs.end(),[](auto &a, auto &b) {return  a.first > b.first ; });\\n     \\n        \\n        ll total = result;\\n        \\n        vector<pair<ll,ll>> allJobs;\\n        \\n        for (auto &p : jobs) {\\n            allJobs.push_back(p);\\n        }\\n        for (auto &p : profitJobs) {\\n            allJobs.push_back(p);\\n        }\\n       \\n        \\n        \\n        for (int i = 0; i < allJobs.size(); i++) {\\n            auto [cost,cashback] = allJobs[i];\\n            \\n            if (cost > total) {\\n                result = result + (cost-total);\\n                // keep collecting the cashback\\n                total = cashback;\\n            } else {\\n                // if can accomodate the job then collect the\\n                // cashback\\n                total = total-cost + cashback;\\n            }\\n        }\\n        \\n        return result;\\n  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        ll deficit = 0;\\n        int maxCashback = 0;\\n        int maxCost = 0;\\n        \\n        \\n        \\n        for (auto &t : transactions) {\\n            if (t[0] > t[1]) {\\n                // Collect deficit across all costly transaction where\\n                // cost is lesser than the cashback\\n                // Collect the maxCashback, we would process it the last\\n                // to start the series with costly trades, we will need\\n                // atleast deficit and maxCashback upfront, this will ensure\\n                // that costly series can be processed fully\\n                deficit += (ll)(t[0]-t[1]);\\n                maxCashback = max(maxCashback,t[1]);\\n            } else {\\n                // in 2nd case we collect the maximumm Cost across all\\n                // profitable transactions, we would like to process maximumm cost first\\n                // as we will need to borrow max money for the same if we start with it.\\n                // Rest all can happen as smallest Cashback in profitable set will be lesser\\n                // than maxCost of the set\\n                maxCost = max(maxCost,t[0]);\\n            }\\n        }\\n        // result will sum of deficit and maximumm of casback and Cost\\n        // this will make sure that we have enough surplus to complete \\n        // all the transaction in worst case, with all costly transaction processed\\n        // first, with maxCashback obtained the last and of all profitable trades\\n        // picking up the maxCost first so that we need money upfront.\\n        return deficit + max(maxCashback,maxCost); \\n    }     \\n    long long minimumMoney1(vector<vector<int>>& transactions) {\\n        vector<vector<int>> costlyJobs;\\n        vector<vector<int>> profitJobs;\\n        ll result = 0;\\n        \\n        for (auto &p : transactions) {\\n            // pick up free money first\\n            if (p[0] <= p[1]) {\\n                profitJobs.push_back(p);\\n            } else {\\n                // push only those task which need money\\n                costlyJobs.push_back(p);\\n            }\\n        }\\n        \\n        // sort costly jobs with lesser cashback first, so that it will borrow max\\n        sort(costlyJobs.begin(),costlyJobs.end(),[](auto &a, auto &b) {return  a[1] < b[1] ; });\\n        \\n        // sort profitable jobs with higher cost first\\n        // as if heavy jobs don\\'t bring any cashback we will pick the heaviest job\\n        sort(profitJobs.begin(),profitJobs.end(),[](auto &a, auto &b) {return  a[0] == b[0] ? a[1] < b[1] : a[0] > b[0] ; });\\n     \\n        \\n        ll total = result;\\n        \\n        vector<vector<int>> allJobs;\\n        \\n        for (auto &p : costlyJobs) {\\n            allJobs.push_back(p);\\n        }\\n        for (auto &p : profitJobs) {\\n            allJobs.push_back(p);\\n        }\\n       \\n        \\n        \\n        for (int i = 0; i < allJobs.size(); i++) {\\n            int cost = allJobs[i][0];\\n            int cashback = allJobs[i][1];\\n            \\n            if (cost > total) {\\n                result = result + (cost-total);\\n                // keep collecting the cashback\\n                total = cashback;\\n            } else {\\n                // if can accomodate the job then collect the\\n                // cashback\\n                total = total-cost + cashback;\\n            }\\n        }\\n        \\n        return result;\\n  \\n    }\\n};\\n\\n\\nclass Solution1 {\\npublic:\\n    using ll = long long;\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        vector<pair<ll,ll>> jobs;\\n        vector<pair<ll,ll>> profitJobs;\\n        ll result = 0;\\n        \\n        for (auto &p : transactions) {\\n            // pick up free money first\\n            if (p[0] <= p[1]) {\\n                profitJobs.push_back({p[0],p[1]});\\n            } else {\\n                // push only those task which need money\\n                jobs.push_back({p[0],p[1]});\\n            }\\n        }\\n        sort(jobs.begin(),jobs.end(),[](auto &a, auto &b) {return   a.second < b.second ; });\\n        sort(profitJobs.begin(),profitJobs.end(),[](auto &a, auto &b) {return  a.first > b.first ; });\\n     \\n        \\n        ll total = result;\\n        \\n        vector<pair<ll,ll>> allJobs;\\n        \\n        for (auto &p : jobs) {\\n            allJobs.push_back(p);\\n        }\\n        for (auto &p : profitJobs) {\\n            allJobs.push_back(p);\\n        }\\n       \\n        \\n        \\n        for (int i = 0; i < allJobs.size(); i++) {\\n            auto [cost,cashback] = allJobs[i];\\n            \\n            if (cost > total) {\\n                result = result + (cost-total);\\n                // keep collecting the cashback\\n                total = cashback;\\n            } else {\\n                // if can accomodate the job then collect the\\n                // cashback\\n                total = total-cost + cashback;\\n            }\\n        }\\n        \\n        return result;\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597098,
                "title": "python-find-worst-ending",
                "content": "The idea is to calculate total loss, and then find worst last cost, remove diff from total cost and just add cost to make candidate.\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:                \\n        biggest_cost = 0                        \\n        total_loss = sum(max(0, c - b) for c, b in transactions)\\n        \\n        for c, b in transactions:\\n            biggest_cost = max(biggest_cost, total_loss - max(0, c-b) + c)\\n                        \\n        return biggest_cost\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:                \\n        biggest_cost = 0                        \\n        total_loss = sum(max(0, c - b) for c, b in transactions)\\n        \\n        for c, b in transactions:\\n            biggest_cost = max(biggest_cost, total_loss - max(0, c-b) + c)\\n                        \\n        return biggest_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596936,
                "title": "java-time-o-n-space-o-1",
                "content": "```\\n    //Runtime: 4 ms, faster than 100.00% of Java online submissions for Minimum Money Required Before Transactions.\\n    //Memory Usage: 97 MB, less than 100.00% of Java online submissions for Minimum Money Required Before Transactions.\\n    //Time: O(N); Space: O(1)\\n    public long minimumMoney(int[][] transactions) {\\n\\n        long totalFee = 0;\\n        int maxIncome = 0;\\n        for(int[] transaction : transactions) {\\n            maxIncome = Math.max(maxIncome, Math.min(transaction[0], transaction[1]));\\n            totalFee += Math.max(0, transaction[0] - transaction[1]);\\n        }\\n        return totalFee + maxIncome;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //Runtime: 4 ms, faster than 100.00% of Java online submissions for Minimum Money Required Before Transactions.\\n    //Memory Usage: 97 MB, less than 100.00% of Java online submissions for Minimum Money Required Before Transactions.\\n    //Time: O(N); Space: O(1)\\n    public long minimumMoney(int[][] transactions) {\\n\\n        long totalFee = 0;\\n        int maxIncome = 0;\\n        for(int[] transaction : transactions) {\\n            maxIncome = Math.max(maxIncome, Math.min(transaction[0], transaction[1]));\\n            totalFee += Math.max(0, transaction[0] - transaction[1]);\\n        }\\n        return totalFee + maxIncome;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2596059,
                "title": "my-o-n-solution-c",
                "content": "\\n\\n    long long minimumMoney(vector<vector<int>>& A) {\\n        long long max_loss = 0;\\n        int temp, a = 0; //a is the loss that it the last element(before the profits going up) contributes the max loss(ans to the question)\\n        for( auto &i : A ){\\n            temp = i[0] - i[1];\\n            if( temp > 0) {\\n                if( temp + a < i[0] ){ // this element is better to put in the last position(before the profits going up) than be in the front (currently)\\n                    max_loss += i[0] - a;\\n                    a = i[0] - temp;\\n                }\\n                else{                  // put it in the middle\\n                    max_loss += temp;\\n                }\\n            }\\n            else if( a < i[0] ){ // this element is better to put in the last element (before going up)\\n                max_loss += i[0] - a;\\n                a = i[0]; // push it to back(after the profits going up)\\n            }\\n        }\\n        return max_loss;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    long long minimumMoney(vector<vector<int>>& A) {\\n        long long max_loss = 0;\\n        int temp, a = 0; //a is the loss that it the last element(before the profits going up) contributes the max loss(ans to the question)\\n        for( auto &i : A ){\\n            temp = i[0] - i[1];\\n            if( temp > 0) {\\n                if( temp + a < i[0] ){ // this element is better to put in the last position(before the profits going up) than be in the front (currently)\\n                    max_loss += i[0] - a;\\n                    a = i[0] - temp;\\n                }\\n                else{                  // put it in the middle\\n                    max_loss += temp;\\n                }\\n            }\\n            else if( a < i[0] ){ // this element is better to put in the last element (before going up)\\n                max_loss += i[0] - a;\\n                a = i[0]; // push it to back(after the profits going up)\\n            }\\n        }\\n        return max_loss;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2595715,
                "title": "simple-sorting-and-greedy",
                "content": "we have to sort the array based on the observation that finaly we should get the worst permutation of the array and for that we calculate the minimum cost which is out final answer\\nfor the question\\n\\nin the custom comparator we check if  it is benificial to take first transaction  over other it yes return true \\nfor benificial i mean that which will leads to maximum required cost \\n\\nFor better understanding :- look at my submission\\n\\n```\\n static bool comp(vector<int>&a,vector<int>&b){\\n        int opt1=min(-a[0],-a[0]+a[1]-b[0]),opt2=min(-b[0],-b[0]+b[1]-a[0]);\\n        if(opt1!=opt2)return opt1<opt2;\\n        return a[0]>b[0];\\n    }\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n      sort(transactions.begin(),transactions.end(),comp);\\n     long long money=0,ans=0;\\n        for(int i=0;i<transactions.size();++i){\\n            long long need=0;\\n            if(money<=transactions[i][0]){\\n                need+=(transactions[i][0]-money);\\n                money=transactions[i][1];\\n            }\\n            else{\\n                money-=transactions[i][0];\\n                money+=transactions[i][1];\\n            }\\n            ans+=need;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n static bool comp(vector<int>&a,vector<int>&b){\\n        int opt1=min(-a[0],-a[0]+a[1]-b[0]),opt2=min(-b[0],-b[0]+b[1]-a[0]);\\n        if(opt1!=opt2)return opt1<opt2;\\n        return a[0]>b[0];\\n    }\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n      sort(transactions.begin(),transactions.end(),comp);\\n     long long money=0,ans=0;\\n        for(int i=0;i<transactions.size();++i){\\n            long long need=0;\\n            if(money<=transactions[i][0]){\\n                need+=(transactions[i][0]-money);\\n                money=transactions[i][1];\\n            }\\n            else{\\n                money-=transactions[i][0];\\n                money+=transactions[i][1];\\n            }\\n            ans+=need;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594988,
                "title": "python3-simple-one-line-solution-o-n-in-depth-explanation",
                "content": "# Code\\n```python\\nclass Solution:\\n    def minimumMoney(self, a: List[List[int]]) -> int:\\n        return max(cost - max(cost - cb, 0) for cost, cb in a) + sum(max(cost - cb, 0) for cost, cb in a)\\n```\\n\\n# Explanation\\nFirst, we define how much money a series of transaction requires. Determine that there will essentially be an upfront cost, and then each subsequent cost is offset by the cashback which came before it. One cashback will always be ignored because it will happen after executing the last transaction.\\n\\nTaking the maximum of each permutation at each iteration of this will yield a formula. Here\\'s that formula for three transactions:\\n```python\\nmax(cost1,  # T1\\n    cost2,  # T2\\n    cost3,  # T3\\n    cost1 + cost2 - cashback1,  # T1 -> T2\\n    cost1 + cost2 - cashback2,  # T2 -> T1\\n    cost1 + cost3 - cashback1,  # T1 -> T3\\n    cost1 + cost3 - cashback3,  # T3 -> T1\\n    cost2 + cost3 - cashback2,  # T2 -> T3\\n    cost2 + cost3 - cashback3,  # T3 -> T2\\n    cost1 + cost2 + cost3 - cashback1 - cashback2,  # T1 -> T2 -> T3 or T2 -> T1 -> T3\\n    cost1 + cost2 + cost3 - cashback1 - cashback3,  # T1 -> T3 -> T2 or T3 -> T1 -> T2\\n    cost1 + cost2 + cost3 - cashback2 - cashback3,  # T2 -> T3 -> T1 or T3 -> T2 -> T1\\n)\\n```\\n\\nLet\\'s simplify this by substituting in something we can compute in advance. How about the differences between each cost and cashback? That is to say, if a term adds costX and subtracts cashbackX, we substitute in their difference dX:\\n```python\\nmax(cost1,\\n    cost2,\\n    cost3,\\n    cost1 + d2,\\n    cost1 + d3,\\n    cost2 + d1,\\n    cost2 + d3,\\n    cost3 + d1,\\n    cost3 + d2,\\n    cost1 + d2 + d3,\\n    cost2 + d1 + d3,\\n    cost3 + d1 + d2)\\n```\\n\\nThis helps clarify things. The solution will be some cost, plus the sum of a combination of differences associated with any transaction that cost didn\\'t belong to.\\n\\nIf we filter out any negative differences, we don\\'t have to even worry about combinations. We can just take the sum of all positive differences `d` minus the difference for the current transaction and add it to the cost. Thus giving us...\\n\\n```python\\nmax(cost1 + d - d1,\\ncost2 + d - d2,\\ncost3 + d - d3)\\n```\\n\\nFinally, we can simplify by moving the d term outside\\n\\n```python\\nmax(cost1 - d1, cost2 - d2, cost3 - d3) + d\\n```\\n\\nThis approach is trivial to program and you can see my implementation above.\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumMoney(self, a: List[List[int]]) -> int:\\n        return max(cost - max(cost - cb, 0) for cost, cb in a) + sum(max(cost - cb, 0) for cost, cb in a)\\n```\n```python\\nmax(cost1,  # T1\\n    cost2,  # T2\\n    cost3,  # T3\\n    cost1 + cost2 - cashback1,  # T1 -> T2\\n    cost1 + cost2 - cashback2,  # T2 -> T1\\n    cost1 + cost3 - cashback1,  # T1 -> T3\\n    cost1 + cost3 - cashback3,  # T3 -> T1\\n    cost2 + cost3 - cashback2,  # T2 -> T3\\n    cost2 + cost3 - cashback3,  # T3 -> T2\\n    cost1 + cost2 + cost3 - cashback1 - cashback2,  # T1 -> T2 -> T3 or T2 -> T1 -> T3\\n    cost1 + cost2 + cost3 - cashback1 - cashback3,  # T1 -> T3 -> T2 or T3 -> T1 -> T2\\n    cost1 + cost2 + cost3 - cashback2 - cashback3,  # T2 -> T3 -> T1 or T3 -> T2 -> T1\\n)\\n```\n```python\\nmax(cost1,\\n    cost2,\\n    cost3,\\n    cost1 + d2,\\n    cost1 + d3,\\n    cost2 + d1,\\n    cost2 + d3,\\n    cost3 + d1,\\n    cost3 + d2,\\n    cost1 + d2 + d3,\\n    cost2 + d1 + d3,\\n    cost3 + d1 + d2)\\n```\n```python\\nmax(cost1 + d - d1,\\ncost2 + d - d2,\\ncost3 + d - d3)\\n```\n```python\\nmax(cost1 - d1, cost2 - d2, cost3 - d3) + d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594238,
                "title": "c-greedy-3-parts",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    long long minimumMoney(vector<vector<int>>& trans) {\\n        int n = trans.size();\\n        \\n        long long ans = 0, tmp=0;\\n        vector<int> cash0;\\n        vector<pair<int, int>> cash1;\\n        vector<pair<int, int>> cash2;\\n        for(auto i:trans)\\n        {\\n            if(i[1]==0)\\n            {\\n                cash0.push_back(i[0]);\\n            }else if(i[1]<=i[0])\\n            {\\n                cash1.push_back({i[0], i[1]});\\n            }else\\n            {\\n                cash2.push_back({i[0], i[1]});\\n            }\\n        }\\n        sort(cash1.begin(), cash1.end(), [&] (pair<int, int> a, pair<int, int> b){\\n            return a.second<b.second || (a.second == b.second && a.first>b.first);\\n        });\\n        sort(cash2.rbegin(), cash2.rend());\\n        \\n        for(auto i:cash0)\\n        {\\n            ans+=i;\\n            // tmp+=i;\\n        }\\n        for(auto i:cash1)\\n        {\\n            if(tmp<i.first)\\n            {\\n                ans += i.first - tmp;\\n                tmp=i.first;\\n            }\\n            \\n            tmp += -i.first + i.second;\\n        }\\n        int d = -1;\\n        for(auto i:cash2)\\n        {\\n            d = max(d, i.first);\\n        }\\n        if (d != -1) {\\n            ans = max(ans + (ll)d - tmp, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    long long minimumMoney(vector<vector<int>>& trans) {\\n        int n = trans.size();\\n        \\n        long long ans = 0, tmp=0;\\n        vector<int> cash0;\\n        vector<pair<int, int>> cash1;\\n        vector<pair<int, int>> cash2;\\n        for(auto i:trans)\\n        {\\n            if(i[1]==0)\\n            {\\n                cash0.push_back(i[0]);\\n            }else if(i[1]<=i[0])\\n            {\\n                cash1.push_back({i[0], i[1]});\\n            }else\\n            {\\n                cash2.push_back({i[0], i[1]});\\n            }\\n        }\\n        sort(cash1.begin(), cash1.end(), [&] (pair<int, int> a, pair<int, int> b){\\n            return a.second<b.second || (a.second == b.second && a.first>b.first);\\n        });\\n        sort(cash2.rbegin(), cash2.rend());\\n        \\n        for(auto i:cash0)\\n        {\\n            ans+=i;\\n            // tmp+=i;\\n        }\\n        for(auto i:cash1)\\n        {\\n            if(tmp<i.first)\\n            {\\n                ans += i.first - tmp;\\n                tmp=i.first;\\n            }\\n            \\n            tmp += -i.first + i.second;\\n        }\\n        int d = -1;\\n        for(auto i:cash2)\\n        {\\n            d = max(d, i.first);\\n        }\\n        if (d != -1) {\\n            ans = max(ans + (ll)d - tmp, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593329,
                "title": "python3-o-n-time-order-of-middle-transactions-doesn-t-matter",
                "content": "We want to find the maximum possible sum of required cash by changing the order of transactions.\\nSuppose we already have all transactions sorted in such optimal order. Then there must exists a transaction \"x\" somewhere in the middle that reaches the \"maximum\" cash requirement. We can take all transactions before transaction \"x\", and ignore all those afterward, the result will still be the same.\\nWe don\\'t know which transaction is \"x\", but we know that for all transactions before \"x\", their order doesn\\'t matter. Their contributions will always be \"cash - back\", and for all transactions after \"x\", their contributions must be negative, otherwise we can put them before \"x\" and make bigger cash requirement. \\nSo we can greedily take all transactions with positive contributions and add their contributions together, assuming all of them are before transaction \"x\". Then we can find transaction \"x\" from one of the following:\\n1. The one with biggest \"cash\" value from one of the \"negative\" contributions. Transactions of negative contributions are all ignored already, add its \"cash\" value back to the result.\\n2. The one with biggest \"back\" value from one of the \"positive\" contributions. Transactions of positive contributions are already added, remove its \"back\" value from the result. \\nWhichever makes the maximum final required cash.\\n\\nNo sort introduced, O(n) time.\\n\\n**Python3:**\\n```\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        cur = 0\\n        max_cash,max_back = 0,0\\n        for cash,back in transactions:\\n            if back>cash:\\n                max_cash = max(max_cash,cash)\\n            else:\\n                cur = cur-cash+back\\n                max_back = max(max_back,back)\\n        return -(cur-max(max_cash,max_back))\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        cur = 0\\n        max_cash,max_back = 0,0\\n        for cash,back in transactions:\\n            if back>cash:\\n                max_cash = max(max_cash,cash)\\n            else:\\n                cur = cur-cash+back\\n                max_back = max(max_back,back)\\n        return -(cur-max(max_cash,max_back))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2592962,
                "title": "minimum-money-required-before-transactions",
                "content": "I think approach mentioned in discussions section is wrong for this question  ...\\n\\nEg :\\n[[2,1],[5,0],[4,2]]\\n\\nAs per question, answer for this test case should be 10.\\n\\nHowever as pr me, answer should be 8.\\ncurr = 8;\\n\\n[4,2] -> curr - 4+2 = 6\\n[2,1] -> curr - 2+1 = 5\\n[5,0] -> curr - 5+0 = 0\\nso if we start with 8 rupee in hand, we can complete all transactions\\n\\nI followed greedy approach, by sorting the transaction on the basis of transaction which gives more cashback, then started with 0 rupee in hand and 0 required for completion of transaction \\n\\n\\n```\\nclass ArrayComparator implements Comparator<int[]> {\\n    @Override\\n    public int compare(int a[],int b[]){\\n        if(a[1]==b[1]) return a[0]-b[0];\\n        return b[1]-a[1];\\n    }\\n}\\nclass Solution {\\n    public long minimumMoney(int[][] arr) {\\n        Arrays.sort(arr,new ArrayComparator());\\n        \\n        int req=0,curr=0,n=arr.length;\\n        for(int i=0;i<n;i++){\\n            if(curr<=arr[i][0]){\\n                req +=arr[i][0]-curr;\\n                curr=arr[i][1];\\n            }else{\\n                curr-=arr[i][0]+arr[i][1];\\n            }\\n        }\\n        return req;\\n    }\\n}\\n```\\n\\n\\nHowever, this solution isn\\'t submitted because it fails in most test case, because of wrong setup..\\n\\nDo let me know if i am right...\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass ArrayComparator implements Comparator<int[]> {\\n    @Override\\n    public int compare(int a[],int b[]){\\n        if(a[1]==b[1]) return a[0]-b[0];\\n        return b[1]-a[1];\\n    }\\n}\\nclass Solution {\\n    public long minimumMoney(int[][] arr) {\\n        Arrays.sort(arr,new ArrayComparator());\\n        \\n        int req=0,curr=0,n=arr.length;\\n        for(int i=0;i<n;i++){\\n            if(curr<=arr[i][0]){\\n                req +=arr[i][0]-curr;\\n                curr=arr[i][1];\\n            }else{\\n                curr-=arr[i][0]+arr[i][1];\\n            }\\n        }\\n        return req;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592844,
                "title": "c-slow-but-clear-logic-of-greedy-approach",
                "content": "The intuition is to do the transactions *in worst order*.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        vector<vector<int>> earn, lose;\\n        for (const auto &t: transactions) {\\n            if (t[0] <= t[1])\\n                earn.push_back(t);\\n            else\\n                lose.push_back(t);\\n        }\\n        \\n        \\n        int earn_max_cost = 0;\\n        for (const auto &e: earn)\\n            earn_max_cost = max(earn_max_cost, e[0]);\\n        // sort earn in ascending\\n        sort(lose.begin(), lose.end(), [](vector<int> a, vector<int> b) {return a[1] < b[1];});\\n        \\n        // regardless of order means that we want to find the money required for the worst order of transactions\\n        long long answer = earn_max_cost;\\n        long long accu = earn_max_cost;\\n        // we do losing transcations frist\\n        if (lose.size()) {\\n            answer = lose.front()[0];\\n            accu = answer;\\n            // we always do the transactions with minimum cashback first\\n            for (const auto &l: lose) {\\n                if (accu < l[0]) {\\n                    answer += l[0] - accu;\\n                    accu = l[0];\\n                }\\n                accu += l[1] - l[0];\\n            }\\n        }\\n        // for the remaining earning transactions\\n        // we always do the one with largest cost\\n        // no considerations are requried other than the largest cost eraning transaction\\n        answer += accu >= earn_max_cost ? 0 : earn_max_cost - accu;\\n        \\n        return answer;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        vector<vector<int>> earn, lose;\\n        for (const auto &t: transactions) {\\n            if (t[0] <= t[1])\\n                earn.push_back(t);\\n            else\\n                lose.push_back(t);\\n        }\\n        \\n        \\n        int earn_max_cost = 0;\\n        for (const auto &e: earn)\\n            earn_max_cost = max(earn_max_cost, e[0]);\\n        // sort earn in ascending\\n        sort(lose.begin(), lose.end(), [](vector<int> a, vector<int> b) {return a[1] < b[1];});\\n        \\n        // regardless of order means that we want to find the money required for the worst order of transactions\\n        long long answer = earn_max_cost;\\n        long long accu = earn_max_cost;\\n        // we do losing transcations frist\\n        if (lose.size()) {\\n            answer = lose.front()[0];\\n            accu = answer;\\n            // we always do the transactions with minimum cashback first\\n            for (const auto &l: lose) {\\n                if (accu < l[0]) {\\n                    answer += l[0] - accu;\\n                    accu = l[0];\\n                }\\n                accu += l[1] - l[0];\\n            }\\n        }\\n        // for the remaining earning transactions\\n        // we always do the one with largest cost\\n        // no considerations are requried other than the largest cost eraning transaction\\n        answer += accu >= earn_max_cost ? 0 : earn_max_cost - accu;\\n        \\n        return answer;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592539,
                "title": "easy-o-n-solution",
                "content": "**Intution :**\\n* The intuition is to first store all the losses that we store all the losses i.e. `cost - cachback` if the term is >0 in the variable `money` .\\n* We also calculate the `mcback` from the txn that give a loss and assume it to be the last one , so , we can\\'t use that cashback and have to add that into our initial money that we want to take for transactions\\n* When we get cases where `cashback > cost` we have a gain and we only store the max cost in `mcost` in such cases as that would be the max amount we spend in such cases.\\n* We need to add `mcost - mcback` to our answer if that\\'s > 0.\\n\\n\\n**Code :**\\n\\n```\\nlong long minimumMoney(vector<vector<int>>& v) {\\n        long long money=0;\\n        int mcback=0,mcost;\\n        for(auto i:v){\\n            int t=i[0]-i[1];\\n            if(t>=0){\\n                money+=t;\\n                mcback=max(mcback,i[1]);//calc the max cback if sorted in desc order\\n            }\\n            else{\\n                mcost=max(mcost,i[0]);//calc the max cost borne in the other case\\n            }\\n            \\n        }\\n        //mcback is not used at beg so add it\\n        //and also add the cost incurred -mcback if that term is more than 0\\n        return money+mcback+max(0,mcost-mcback);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nlong long minimumMoney(vector<vector<int>>& v) {\\n        long long money=0;\\n        int mcback=0,mcost;\\n        for(auto i:v){\\n            int t=i[0]-i[1];\\n            if(t>=0){\\n                money+=t;\\n                mcback=max(mcback,i[1]);//calc the max cback if sorted in desc order\\n            }\\n            else{\\n                mcost=max(mcost,i[0]);//calc the max cost borne in the other case\\n            }\\n            \\n        }\\n        //mcback is not used at beg so add it\\n        //and also add the cost incurred -mcback if that term is more than 0\\n        return money+mcback+max(0,mcost-mcback);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2592401,
                "title": "what-is-happening-in-example-1",
                "content": "```\\nInput: transactions = [[2,1],[5,0],[4,2]]\\nOutput: 10\\nExplanation:\\nStarting with money = 10, the transactions can be performed in any order.\\nIt can be shown that starting with money < 10 will fail to complete all transactions in some order.\\n```\\n\\nI think 8 is the answer. How does 10 makes sense. Someone please explain.",
                "solutionTags": [],
                "code": "```\\nInput: transactions = [[2,1],[5,0],[4,2]]\\nOutput: 10\\nExplanation:\\nStarting with money = 10, the transactions can be performed in any order.\\nIt can be shown that starting with money < 10 will fail to complete all transactions in some order.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2591796,
                "title": "status-200-ok",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    static bool compare(vector<int> &a, vector<int> &b){\\n        int x = a[0] - a[1];\\n        int y = b[0] - b[1];\\n        if(x > 0 && y > 0) return a[1] < b[1];\\n        if(x <= 0 && y <= 0) return a[0] > b[0];\\n        if(x <= 0) return false;\\n        if(y <= 0) return true;\\n        return false;\\n    }\\n    long long minimumMoney(vector<vector<int>>& t) {\\n        sort(begin(t), end(t), compare);\\n        long long ans = 0, money = 0, n = t.size();\\n        for(int i = 0; i<n; ++i){\\n            money+=t[i][0];\\n            ans = max(ans, money);\\n            money-=t[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    static bool compare(vector<int> &a, vector<int> &b){\\n        int x = a[0] - a[1];\\n        int y = b[0] - b[1];\\n        if(x > 0 && y > 0) return a[1] < b[1];\\n        if(x <= 0 && y <= 0) return a[0] > b[0];\\n        if(x <= 0) return false;\\n        if(y <= 0) return true;\\n        return false;\\n    }\\n    long long minimumMoney(vector<vector<int>>& t) {\\n        sort(begin(t), end(t), compare);\\n        long long ans = 0, money = 0, n = t.size();\\n        for(int i = 0; i<n; ++i){\\n            money+=t[i][0];\\n            ans = max(ans, money);\\n            money-=t[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591741,
                "title": "java-fastest-easy-to-understand-5-ms",
                "content": "```\\n public long minimumMoney(int[][] transactions) {\\n        long sum = 0L;\\n        //step 1. compute sum for transactions where cost > cashback\\n        for(int[] t : transactions) {\\n            if(t[0] > t[1]) {\\n                sum += t[0] - t[1]; // add cost and remove cashback\\n            }\\n        }\\n        //step 2. if cost > cashback, add the cashBack again which we removed  in step 1.\\n        //else add max cost from remaining transactions\\n        long max = 0;\\n        for(int[] t : transactions) {\\n            max = t[0] > t[1]? Math.max(max, sum + t[1]): Math.max(max, sum + t[0]);\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public long minimumMoney(int[][] transactions) {\\n        long sum = 0L;\\n        //step 1. compute sum for transactions where cost > cashback\\n        for(int[] t : transactions) {\\n            if(t[0] > t[1]) {\\n                sum += t[0] - t[1]; // add cost and remove cashback\\n            }\\n        }\\n        //step 2. if cost > cashback, add the cashBack again which we removed  in step 1.\\n        //else add max cost from remaining transactions\\n        long max = 0;\\n        for(int[] t : transactions) {\\n            max = t[0] > t[1]? Math.max(max, sum + t[1]): Math.max(max, sum + t[0]);\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2591375,
                "title": "sort-greedy-c",
                "content": "```\\nbool comp(vector<int>&A, vector<int>&B)\\n{\\n    int opt1 = min(-A[0], -A[0] + A[1] -B[0]) ;\\n    int opt2 = min(-B[0], -B[0]+B[1]-A[0]) ;\\n\\n    if(opt1 < opt2) return true ;\\n    if(opt1 > opt2) return false ;\\n\\n    return A[0] > B[0] ;\\n}\\nclass Solution {\\npublic:\\n    \\n    long long minimumMoney(vector<vector<int>>& T) {\\n        sort(T.begin(),T.end(),comp);\\n        int n=T.size();\\n        long long sum=T[n-1][0];\\n        for(int i=n-2;i>=0;i--){\\n            sum=max(sum+T[i][0]-T[i][1],1LL*T[i][0]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nbool comp(vector<int>&A, vector<int>&B)\\n{\\n    int opt1 = min(-A[0], -A[0] + A[1] -B[0]) ;\\n    int opt2 = min(-B[0], -B[0]+B[1]-A[0]) ;\\n\\n    if(opt1 < opt2) return true ;\\n    if(opt1 > opt2) return false ;\\n\\n    return A[0] > B[0] ;\\n}\\nclass Solution {\\npublic:\\n    \\n    long long minimumMoney(vector<vector<int>>& T) {\\n        sort(T.begin(),T.end(),comp);\\n        int n=T.size();\\n        long long sum=T[n-1][0];\\n        for(int i=n-2;i>=0;i--){\\n            sum=max(sum+T[i][0]-T[i][1],1LL*T[i][0]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591267,
                "title": "python-worst-case-simulation-o-nlogn",
                "content": "Split transactions into two list L and R where L is the list of transactions in which cost is less than cashback and R is vice versa.\\nSort R in increasing order of cashback.\\nSimulate according to the order of R.\\nThen cosider max cost among elements in L.\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        L, R = [], []\\n        for cost, cashback in transactions:\\n            if cost < cashback:\\n                L.append((cost,cashback))\\n            else:\\n                R.append((cost,cashback))\\n        R.sort(key = lambda x: x[1])\\n        res = 0\\n        curcost = 0\\n        for cost, cashback in R:\\n            res += max(cost-curcost, 0)\\n            curcost += max(cost-curcost, 0)\\n            curcost -= cost\\n            curcost += cashback\\n        res += max((max(L)[0] if L else 0) - curcost, 0)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "Split transactions into two list L and R where L is the list of transactions in which cost is less than cashback and R is vice versa.\\nSort R in increasing order of cashback.\\nSimulate according to the order of R.\\nThen cosider max cost among elements in L.\\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        L, R = [], []\\n        for cost, cashback in transactions:\\n            if cost < cashback:\\n                L.append((cost,cashback))\\n            else:\\n                R.append((cost,cashback))\\n        R.sort(key = lambda x: x[1])\\n        res = 0\\n        curcost = 0\\n        for cost, cashback in R:\\n            res += max(cost-curcost, 0)\\n            curcost += max(cost-curcost, 0)\\n            curcost -= cost\\n            curcost += cashback\\n        res += max((max(L)[0] if L else 0) - curcost, 0)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2590625,
                "title": "o-n-concise-and-easy-c-solution",
                "content": "\\tlong long maxval(long long a, long long b)\\n    {\\n        return (a>b?a:b);\\n    }\\n    long long minval(long long a, long long b)\\n    {\\n        return (a<b?a:b);\\n    }\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long ans=0;\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            ans=maxval(ans,minval(transactions[i][0],transactions[i][1]));\\n        }\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            ans+=maxval(0,transactions[i][0]-transactions[i][1]);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tlong long maxval(long long a, long long b)\\n    {\\n        return (a>b?a:b);\\n    }\\n    long long minval(long long a, long long b)\\n    {\\n        return (a<b?a:b);\\n    }\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long ans=0;\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            ans=maxval(ans,minval(transactions[i][0],transactions[i][1]));\\n        }\\n        for(int i=0;i<transactions.size();i++)\\n        {\\n            ans+=maxval(0,transactions[i][0]-transactions[i][1]);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2590573,
                "title": "sorting-greedy-solution-2-methods-o-nlogn-time-complexity-o-1-space-complexity",
                "content": "```\\n//For original solution\\n//comparator for sorting transaction where we will get money\\nbool cmp1(const vector<int> &a,const vector<int> &b)\\n{\\n    return a[0]>b[0];\\n}\\n//comparator for sorting transaction where we will give money\\nbool cmp2(const vector<int> &a,const vector<int> &b)\\n{\\n    return a[1]<b[1];\\n}\\n\\n//For space optimised solution\\n//combining the comparator functions into one.\\nbool cmp3(const vector<int> &a,const vector<int> &b)\\n{\\n    if(a[0]-a[1]<=0&&b[0]-b[1]<=0)\\n    {\\n        return a[0]>b[0];\\n    }\\n    else if(a[0]-a[1]>0&&b[0]-b[1]>0)\\n    {\\n        return a[1]<b[1];\\n    }\\n    \\n    return a[0]-a[1]>b[0]-b[1];\\n}\\n\\n\\nclass Solution {\\npublic:\\n    long long original(vector<vector<int>>& transactions)\\n    {\\n        vector<vector<int>> more,less;       \\n        for(auto &i:transactions)\\n        {\\n            if(i[0]<=i[1])\\n            {\\n                more.push_back(i);\\n            }\\n            else\\n            {\\n                less.push_back(i);\\n            }\\n        }\\n        sort(more.begin(),more.end(),cmp1);\\n        sort(less.begin(),less.end(),cmp2);    \\n        long long prev=0,ans=0;     \\n        for(auto &i:less)\\n        {\\n            if(prev>=i[0])  //if we have enough money\\n            {\\n                prev=prev-i[0]+i[1];\\n            }\\n            else            //if we dont have enough money\\n            {\\n                ans+=(i[0]-prev);   \\n                prev=i[1];  //setting it to minimum money required\\n            }\\n        }      \\n            \\n        for(auto &i:more)      //same as above loop\\n        {\\n            if(prev>=i[0])\\n            {\\n                prev=prev-i[0]+i[1];\\n            }\\n            else\\n            {\\n                ans+=(i[0]-prev);\\n                prev=i[1];\\n            }\\n        }\\n        return ans;        \\n    }\\n    \\n    //sorting the original transaction vector itself to reduce memory\\n    long long optimised(vector<vector<int>>& transactions)\\n    {\\n        long long prev=0,ans=0;\\n        \\n        \\n        sort(transactions.begin(),transactions.end(),cmp3);\\n        \\n        for(auto &i:transactions)\\n        {\\n            if(prev>=i[0])\\n            {\\n                prev=prev-i[0]+i[1];\\n            }\\n            else\\n            {\\n                ans+=(i[0]-prev);\\n                prev=i[1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        \\n        //The Original sorting solution with O(N) space complexity ans NlogN time complexity.\\n        // return original(transactions);\\n        \\n        //The space optimised solution with O(1) space complexity and NlogN time complexity.\\n        return optimised(transactions);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n//For original solution\\n//comparator for sorting transaction where we will get money\\nbool cmp1(const vector<int> &a,const vector<int> &b)\\n{\\n    return a[0]>b[0];\\n}\\n//comparator for sorting transaction where we will give money\\nbool cmp2(const vector<int> &a,const vector<int> &b)\\n{\\n    return a[1]<b[1];\\n}\\n\\n//For space optimised solution\\n//combining the comparator functions into one.\\nbool cmp3(const vector<int> &a,const vector<int> &b)\\n{\\n    if(a[0]-a[1]<=0&&b[0]-b[1]<=0)\\n    {\\n        return a[0]>b[0];\\n    }\\n    else if(a[0]-a[1]>0&&b[0]-b[1]>0)\\n    {\\n        return a[1]<b[1];\\n    }\\n    \\n    return a[0]-a[1]>b[0]-b[1];\\n}\\n\\n\\nclass Solution {\\npublic:\\n    long long original(vector<vector<int>>& transactions)\\n    {\\n        vector<vector<int>> more,less;       \\n        for(auto &i:transactions)\\n        {\\n            if(i[0]<=i[1])\\n            {\\n                more.push_back(i);\\n            }\\n            else\\n            {\\n                less.push_back(i);\\n            }\\n        }\\n        sort(more.begin(),more.end(),cmp1);\\n        sort(less.begin(),less.end(),cmp2);    \\n        long long prev=0,ans=0;     \\n        for(auto &i:less)\\n        {\\n            if(prev>=i[0])  //if we have enough money\\n            {\\n                prev=prev-i[0]+i[1];\\n            }\\n            else            //if we dont have enough money\\n            {\\n                ans+=(i[0]-prev);   \\n                prev=i[1];  //setting it to minimum money required\\n            }\\n        }      \\n            \\n        for(auto &i:more)      //same as above loop\\n        {\\n            if(prev>=i[0])\\n            {\\n                prev=prev-i[0]+i[1];\\n            }\\n            else\\n            {\\n                ans+=(i[0]-prev);\\n                prev=i[1];\\n            }\\n        }\\n        return ans;        \\n    }\\n    \\n    //sorting the original transaction vector itself to reduce memory\\n    long long optimised(vector<vector<int>>& transactions)\\n    {\\n        long long prev=0,ans=0;\\n        \\n        \\n        sort(transactions.begin(),transactions.end(),cmp3);\\n        \\n        for(auto &i:transactions)\\n        {\\n            if(prev>=i[0])\\n            {\\n                prev=prev-i[0]+i[1];\\n            }\\n            else\\n            {\\n                ans+=(i[0]-prev);\\n                prev=i[1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        \\n        //The Original sorting solution with O(N) space complexity ans NlogN time complexity.\\n        // return original(transactions);\\n        \\n        //The space optimised solution with O(1) space complexity and NlogN time complexity.\\n        return optimised(transactions);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590006,
                "title": "short-simple-c-solution-runtime-1000ms",
                "content": "**If it helped you, Please Upvote!**\\n\\nExecutable Code :\\n\\n```\\nclass Solution \\n{\\n    public: \\n    long long max(long long p, long long q) \\n    {\\n        return (p>q?p:q);\\n    } \\n    long long min(long long p, long long q) \\n    {\\n        return (p<q?p:q);\\n    } \\n    long long minimumMoney (vector<vector <int>>& t) \\n    {\\n        long long r = 0; \\n        for(auto s : t) \\n            r = max(r, min(s[0], s[1])); \\n        for(auto s : t) \\n            r += max(0, s[0] - s[1]); \\n        return r;\\n    }\\n};\\n```\\n\\n**If it helped you, Please Upvote!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public: \\n    long long max(long long p, long long q) \\n    {\\n        return (p>q?p:q);\\n    } \\n    long long min(long long p, long long q) \\n    {\\n        return (p<q?p:q);\\n    } \\n    long long minimumMoney (vector<vector <int>>& t) \\n    {\\n        long long r = 0; \\n        for(auto s : t) \\n            r = max(r, min(s[0], s[1])); \\n        for(auto s : t) \\n            r += max(0, s[0] - s[1]); \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589513,
                "title": "javascript-grab-biggest-minimum-between-pairs-and-accumulate-differences",
                "content": "```\\nvar minimumMoney = function(transactions) {\\n    // Question asks about minimum money which allows to complete any transaction in any order\\n    // That\\'s very important and it actually simplifies a lot\\n    // It means we need now just two things\\n    let result = 0\\n    \\n    for(const [t1,t2] of transactions) {\\n        // 1. Get biggest minimum in pair  - because in worst case that\\'s we need to add it at the top of positive differences\\n        const min = Math.min(t1,t2)\\n        result= Math.max(result, min)\\n    }\\n\\n    // 2. Grab and add positive differences\\n    for(const [t1,t2] of transactions) {\\n        result+= Math.max(t1-t2, 0)\\n    }\\n    \\n    return result\\n};\\n\\n// Let\\'s say we have simplest input with just one transaction [[3,2]]\\n// Biggest minimum in pairs is 2\\n// Sum of positive differences is 1\\n// It means we need to start with 3\\n// If we choose more complex inputs let\\'s say [[0,3], [3,2]], we gonna see that the same holds true\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumMoney = function(transactions) {\\n    // Question asks about minimum money which allows to complete any transaction in any order\\n    // That\\'s very important and it actually simplifies a lot\\n    // It means we need now just two things\\n    let result = 0\\n    \\n    for(const [t1,t2] of transactions) {\\n        // 1. Get biggest minimum in pair  - because in worst case that\\'s we need to add it at the top of positive differences\\n        const min = Math.min(t1,t2)\\n        result= Math.max(result, min)\\n    }\\n\\n    // 2. Grab and add positive differences\\n    for(const [t1,t2] of transactions) {\\n        result+= Math.max(t1-t2, 0)\\n    }\\n    \\n    return result\\n};\\n\\n// Let\\'s say we have simplest input with just one transaction [[3,2]]\\n// Biggest minimum in pairs is 2\\n// Sum of positive differences is 1\\n// It means we need to start with 3\\n// If we choose more complex inputs let\\'s say [[0,3], [3,2]], we gonna see that the same holds true\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589352,
                "title": "well-explained-solution-begineers-c-binary-seach-greedy-tc-nlogn",
                "content": "Lets Get to the Logic why we need to separate the array into two parts:\\n1. transitions[i][1]>=transitions[i][0] -------> There is a Profit. \\n2. transitions[i][1]<transitions[i][0] --------->There is Loss.\\n\\n\\nSo the worst ordering of the indexes will be if we keep the Loss transactions first and then Profit transactions.\\n\\n1. Then How to Sort the Loss Transactions:\\n    \\n\\tLets take an example that we are a college student living in a hostel, so we need money to meet daily expenses, So our survival of each day depends how much money does our parents sent to us right . The day in which our parents send less money  its become more difficult . Now coming to the problem , daily expense is cost & parent money is cashback . so we will sort in increasing cahbackvalue, and if same cashback value then we will sort in decreasing cost;\\n\\t\\n2. How to sort the Profit section\\n\\n    In the profit array we will face the most difficulty when the cost of the one part is high.\\n\\tSo will sort it in decreasing cost;\\n\\t\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp2(vector<int> &a,vector<int> &b)\\n    {\\n       if (a[1]==b[1])\\n           return a[0]>b[0];\\n        \\n        return a[1]<b[1];\\n    }\\n    \\n    \\n     static bool cmp1(vector<int> &a,vector<int> &b)\\n    {\\n        return a[0]>b[0];\\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        long long low=0,high=0;\\n        for (auto x:transactions)\\n        {\\n          high+=x[0];\\n        }\\n        \\n        vector<vector<int>> profit,loss;\\n        \\n        for (auto x:transactions)\\n        {\\n            if (x[1]>=x[0])\\n              profit.push_back({x[0],x[1]});\\n            else\\n              loss.push_back({x[0],x[1]});  \\n        }\\n        \\n        \\n        sort(profit.begin(),profit.end(),cmp1);\\n        sort(loss.begin(),loss.end(),cmp2);\\n        \\n        \\n        \\n        long long ans;\\n        \\n        \\n        \\n        // for (auto x:transactions)\\n        // {\\n        //     cout<<x[0]<<\" \"<<x[1]<<endl;\\n        // }\\n        \\n        while (low<=high)\\n        {\\n            long long mid=high+(low-high)/2;\\n            \\n            if (isPossible(mid,profit,loss))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    bool isPossible(long long price,vector<vector<int>> &profit,vector<vector<int>> &loss)\\n    {\\n        for (int i=0;i<loss.size();++i)\\n        {\\n            if (price<loss[i][0])\\n                return false;\\n            \\n            price-=(loss[i][0]-loss[i][1]);\\n        }\\n        \\n        for (int i=0;i<profit.size();++i)\\n        {\\n            if (price<profit[i][0])\\n                return false;\\n            \\n            price-=(profit[i][0]-profit[i][1]);\\n        }\\n        \\n        return true;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp2(vector<int> &a,vector<int> &b)\\n    {\\n       if (a[1]==b[1])\\n           return a[0]>b[0];\\n        \\n        return a[1]<b[1];\\n    }\\n    \\n    \\n     static bool cmp1(vector<int> &a,vector<int> &b)\\n    {\\n        return a[0]>b[0];\\n    }\\n    \\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        \\n        long long low=0,high=0;\\n        for (auto x:transactions)\\n        {\\n          high+=x[0];\\n        }\\n        \\n        vector<vector<int>> profit,loss;\\n        \\n        for (auto x:transactions)\\n        {\\n            if (x[1]>=x[0])\\n              profit.push_back({x[0],x[1]});\\n            else\\n              loss.push_back({x[0],x[1]});  \\n        }\\n        \\n        \\n        sort(profit.begin(),profit.end(),cmp1);\\n        sort(loss.begin(),loss.end(),cmp2);\\n        \\n        \\n        \\n        long long ans;\\n        \\n        \\n        \\n        // for (auto x:transactions)\\n        // {\\n        //     cout<<x[0]<<\" \"<<x[1]<<endl;\\n        // }\\n        \\n        while (low<=high)\\n        {\\n            long long mid=high+(low-high)/2;\\n            \\n            if (isPossible(mid,profit,loss))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    bool isPossible(long long price,vector<vector<int>> &profit,vector<vector<int>> &loss)\\n    {\\n        for (int i=0;i<loss.size();++i)\\n        {\\n            if (price<loss[i][0])\\n                return false;\\n            \\n            price-=(loss[i][0]-loss[i][1]);\\n        }\\n        \\n        for (int i=0;i<profit.size();++i)\\n        {\\n            if (price<profit[i][0])\\n                return false;\\n            \\n            price-=(profit[i][0]-profit[i][1]);\\n        }\\n        \\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2589202,
                "title": "golang-214-ms-17-5-mb",
                "content": "```\\nfunc max(a, b int) int {\\n    if a >= b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc minimumMoney(transactions [][]int) int64 {\\n    positiveTransactionMaxCost := 0\\n\\n    j := 0\\n    for i := 0; i < len(transactions); i++ {\\n        transaction := transactions[i]\\n\\t\\tif transaction[0] > transaction[1] {\\n            if j != i {\\n                transactions[j] = transaction\\n            }\\n            j++\\n\\t\\t} else {\\n\\t\\t\\tpositiveTransactionMaxCost = max(positiveTransactionMaxCost, transaction[0])\\n\\t\\t}\\n\\t}\\n    transactions = transactions[:j]\\n\\n\\tsort.Slice(transactions, func(i, j int) bool {\\n\\t\\treturn transactions[i][1] < transactions[j][1]\\n\\t})\\n\\n    result := 0\\n\\tmoney := 0\\n\\tfor _, transaction := range transactions {\\n\\t\\tif money < transaction[0] {\\n\\t\\t\\tresult += transaction[0] - money\\n\\t\\t\\tmoney = transaction[1]\\n        } else {\\n            money += transaction[1] - transaction[0]\\n        }\\n\\t}\\n    if money < positiveTransactionMaxCost {\\n        result += positiveTransactionMaxCost - money\\n    }\\n\\n\\treturn int64(result)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(a, b int) int {\\n    if a >= b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc minimumMoney(transactions [][]int) int64 {\\n    positiveTransactionMaxCost := 0\\n\\n    j := 0\\n    for i := 0; i < len(transactions); i++ {\\n        transaction := transactions[i]\\n\\t\\tif transaction[0] > transaction[1] {\\n            if j != i {\\n                transactions[j] = transaction\\n            }\\n            j++\\n\\t\\t} else {\\n\\t\\t\\tpositiveTransactionMaxCost = max(positiveTransactionMaxCost, transaction[0])\\n\\t\\t}\\n\\t}\\n    transactions = transactions[:j]\\n\\n\\tsort.Slice(transactions, func(i, j int) bool {\\n\\t\\treturn transactions[i][1] < transactions[j][1]\\n\\t})\\n\\n    result := 0\\n\\tmoney := 0\\n\\tfor _, transaction := range transactions {\\n\\t\\tif money < transaction[0] {\\n\\t\\t\\tresult += transaction[0] - money\\n\\t\\t\\tmoney = transaction[1]\\n        } else {\\n            money += transaction[1] - transaction[0]\\n        }\\n\\t}\\n    if money < positiveTransactionMaxCost {\\n        result += positiveTransactionMaxCost - money\\n    }\\n\\n\\treturn int64(result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589094,
                "title": "java-math-explained-o-n",
                "content": "The idea is from [@yxc](https://leetcode.cn/u/acvv_cxy/). \\n\\n+ Firstly, we want to have this equation, `a` is `cost`, `b` is `cashback`\\n\\n![image](https://assets.leetcode.com/users/images/0e1c92c6-3b28-4c48-8e4c-b144abfc380c_1663441376.6647184.png)\\n\\n+ Organize it\\n\\n![image](https://assets.leetcode.com/users/images/7df825b0-b957-41fb-8d13-2ce9c349eca5_1663441565.3543165.png)\\n\\n+ Enum each `a` at the postition of `a_i`\\n\\n![image](https://assets.leetcode.com/users/images/1a5b40a7-33a6-4203-b2ca-a45f2c1b2daf_1663441741.3249135.png)\\n\\n---\\nAlgorithm:\\n+ Sum all `(a - b)` if `a > b`\\n+ Enum each `a`\\n\\t+ if `a - b > 0`, means it contributes to sum. The result is `sum - ( a - b ) + a`\\n\\t+ else, means no contributions to sum. The result is `sum + a`\\n+ return max of result\\n\\n### Code\\n```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        long sum = 0L;\\n        for(int[] p : transactions){\\n            int a = p[0];\\n            int b = p[1];\\n            \\n            if(a > b) sum += a - b;\\n        }\\n    \\n        long ret = 0L;\\n        \\n        for(int i = 0; i < transactions.length; i++){\\n            int a = transactions[i][0];\\n            int b = transactions[i][1];\\n            long s = sum;\\n            if(a > b){\\n                s -= a - b;\\n            }\\n            ret = Math.max(ret, s + a);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        long sum = 0L;\\n        for(int[] p : transactions){\\n            int a = p[0];\\n            int b = p[1];\\n            \\n            if(a > b) sum += a - b;\\n        }\\n    \\n        long ret = 0L;\\n        \\n        for(int i = 0; i < transactions.length; i++){\\n            int a = transactions[i][0];\\n            int b = transactions[i][1];\\n            long s = sum;\\n            if(a > b){\\n                s -= a - b;\\n            }\\n            ret = Math.max(ret, s + a);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589084,
                "title": "100-faster-in-runtime-and-memory-explanation-java-solution",
                "content": "I read almost every solution but didn\\'t find explanation with most of them, so finally here I am with Intution behind the solution. If you like it don\\'t forget to **UPVOTE**\\n![image](https://assets.leetcode.com/users/images/bc649ff3-55bd-4b78-ab9b-f9db09bf4ea2_1663441886.401988.png)\\n\\n\\n```\\nclass Solution {\\n    public long minimumMoney(int[][] trans) {\\n        // answer = total possible loss + last trans\\n        // last trans : maximum of two possibilties\\n        // // 1. for trans having profit : last trans will be trans with max cost\\n        // // 2. for trans having loss : last trans will be trans with max cashback\\n        // last trans will be the max of both the conditions\\n        \\n        long total_loss=0;\\n        // if trans is profitable we\\'ll add 0 \\n        for(int[] tran:trans) total_loss+=Math.max(0,tran[0]-tran[1]);\\n        int last_trans=0;\\n        for(int[] tran: trans){\\n            // loss\\n            // if(tran[0]>tran[1]) last_trans=Math.max(last_trans,tran[1]);\\n            // // profit\\n            // else last_trans=Math.max(last_trans,tran[0]);\\n            // optimized : 100% faster RunTime and Memory\\n            last_trans=Math.max(last_trans,Math.min(tran[0],tran[1]));\\n        }\\n        return total_loss+last_trans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] trans) {\\n        // answer = total possible loss + last trans\\n        // last trans : maximum of two possibilties\\n        // // 1. for trans having profit : last trans will be trans with max cost\\n        // // 2. for trans having loss : last trans will be trans with max cashback\\n        // last trans will be the max of both the conditions\\n        \\n        long total_loss=0;\\n        // if trans is profitable we\\'ll add 0 \\n        for(int[] tran:trans) total_loss+=Math.max(0,tran[0]-tran[1]);\\n        int last_trans=0;\\n        for(int[] tran: trans){\\n            // loss\\n            // if(tran[0]>tran[1]) last_trans=Math.max(last_trans,tran[1]);\\n            // // profit\\n            // else last_trans=Math.max(last_trans,tran[0]);\\n            // optimized : 100% faster RunTime and Memory\\n            last_trans=Math.max(last_trans,Math.min(tran[0],tran[1]));\\n        }\\n        return total_loss+last_trans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588957,
                "title": "c-solution",
                "content": "\\tlong long minimumMoney(vector<vector<int>>& t) {\\n        \\n        vector<vector<int>> arr1, arr2;\\n        for(auto it: t) {\\n            if(it[0] > it[1])\\n                arr1.push_back(it);\\n            else\\n                arr2.push_back(it);\\n        }\\n        \\n        sort(arr1.begin(), arr1.end(), [](vector<int> &a, vector<int> &b){\\n            return a[1] < b[1];\\n        });\\n        \\n        sort(arr2.begin(), arr2.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] > b[0];\\n        });\\n        \\n        long long ans = 0, m = 0;\\n        for(auto &it: arr1) {\\n           \\n            if(m < it[0]) {\\n                long long diff = it[0] - m;\\n                ans += diff;\\n                m = 0;\\n            }\\n            else \\n                m -= it[0];\\n            \\n            m += it[1];\\n        }\\n        \\n        for(auto &it: arr2) {\\n            \\n            if(m < it[0]) {\\n                long long diff = it[0] - m;\\n                ans += diff;\\n                m = 0;\\n            }\\n            else \\n                m -= it[0];\\n            \\n            m += it[1];\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "\\tlong long minimumMoney(vector<vector<int>>& t) {\\n        \\n        vector<vector<int>> arr1, arr2;\\n        for(auto it: t) {\\n            if(it[0] > it[1])\\n                arr1.push_back(it);\\n            else\\n                arr2.push_back(it);\\n        }\\n        \\n        sort(arr1.begin(), arr1.end(), [](vector<int> &a, vector<int> &b){\\n            return a[1] < b[1];\\n        });\\n        \\n        sort(arr2.begin(), arr2.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] > b[0];\\n        });\\n        \\n        long long ans = 0, m = 0;\\n        for(auto &it: arr1) {\\n           \\n            if(m < it[0]) {\\n                long long diff = it[0] - m;\\n                ans += diff;\\n                m = 0;\\n            }\\n            else \\n                m -= it[0];\\n            \\n            m += it[1];\\n        }\\n        \\n        for(auto &it: arr2) {\\n            \\n            if(m < it[0]) {\\n                long long diff = it[0] - m;\\n                ans += diff;\\n                m = 0;\\n            }\\n            else \\n                m -= it[0];\\n            \\n            m += it[1];\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2588816,
                "title": "my-solution",
                "content": "**Solution I**\\n```\\n/**\\n * divide the transactions into two groups,\\n * 1. executing the transaction can earn money, that is `cashback` > `cost`\\n * 2. executing the transaction cannot earn money, that is `cashback` <= `cost`\\n *\\n * the logic is as following,\\n * 1. calculate the sum of loss (`loss_sum`),\\n *    that is `cost` - `cashback`, of every transactions in the group `2`\\n * 2. iterate every transaction,\\n * 2.1 for the transaction in the group `1`,\\n *     the answer should be the maximum value of `loss_sum` + `cost`\\n * 2.2 for the transaction in the group `2`,\\n *     the answer should be the maximum value of `loss_sum` - (`cost` - `cashback`) + `cost`\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `transactions`\\n */\\nclass Solution {\\n public:\\n  long long minimumMoney(const vector<vector<int>> &transactions) {\\n    constexpr int cost_index = 0;\\n    constexpr int cashback_index = 1;\\n    long long loss_sum = 0LL;\\n    for (const vector<int> &transaction : transactions) {\\n      loss_sum += max(0, transaction[cost_index] - transaction[cashback_index]);\\n    }\\n    \\n    long long ret = 0LL;\\n    for (const vector<int> &transaction : transactions) {\\n      const int loss = transaction[cost_index] - transaction[cashback_index];\\n      if (loss > 0) {\\n        loss_sum -= loss;\\n      }\\n      ret = max(ret, loss_sum + transaction[cost_index]);\\n      if (loss > 0) {\\n        loss_sum += loss;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**Solution II**\\n```\\n/**\\n * divide the transactions into two groups,\\n * 1. executing the transaction can earn money, that is `cashback` > `cost`\\n * 2. executing the transaction cannot earn money, that is `cashback` <= `cost`\\n *\\n * the logic is as following,\\n * 1. calculate the sum of loss (`loss_sum`),\\n *    that is `cost` - `cashback`, of every transactions in the group `2`\\n * 2. iterate every transaction,\\n * 2.1 for the transaction in the group `1`,\\n *     the answer should be the maximum value of `loss_sum` + `cost`\\n * 2.2 for the transaction in the group `2`,\\n *     the answer should be the maximum value of `loss_sum` - (`cost` - `cashback`) + `cost`\\n *     that is `loss_sum` + `cashback`\\n * 2.3 for the transaction in the group `1`, `cost` = min(`cost`, `cashback`)\\n * 2.4 for the transaction in the group `2`, `cashback` = min(`cost`, `cashback`)\\n * 2.5 it can be concluded that for every transaction,\\n *     the answer should be the maximum value of `loss_sum` + min(`cost`, `cashback`)\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `transactions`\\n */\\nclass Solution {\\n public:\\n  long long minimumMoney(const vector<vector<int>> &transactions) {\\n    constexpr int cost_index = 0;\\n    constexpr int cashback_index = 1;\\n    long long loss_sum = 0LL;\\n    int extra = 0;\\n    for (const vector<int> &transaction : transactions) {\\n      loss_sum += max(0, transaction[cost_index] - transaction[cashback_index]);\\n      extra = max(extra, min(transaction[cost_index], transaction[cashback_index]));\\n    }\\n    return loss_sum + extra;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * divide the transactions into two groups,\\n * 1. executing the transaction can earn money, that is `cashback` > `cost`\\n * 2. executing the transaction cannot earn money, that is `cashback` <= `cost`\\n *\\n * the logic is as following,\\n * 1. calculate the sum of loss (`loss_sum`),\\n *    that is `cost` - `cashback`, of every transactions in the group `2`\\n * 2. iterate every transaction,\\n * 2.1 for the transaction in the group `1`,\\n *     the answer should be the maximum value of `loss_sum` + `cost`\\n * 2.2 for the transaction in the group `2`,\\n *     the answer should be the maximum value of `loss_sum` - (`cost` - `cashback`) + `cost`\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `transactions`\\n */\\nclass Solution {\\n public:\\n  long long minimumMoney(const vector<vector<int>> &transactions) {\\n    constexpr int cost_index = 0;\\n    constexpr int cashback_index = 1;\\n    long long loss_sum = 0LL;\\n    for (const vector<int> &transaction : transactions) {\\n      loss_sum += max(0, transaction[cost_index] - transaction[cashback_index]);\\n    }\\n    \\n    long long ret = 0LL;\\n    for (const vector<int> &transaction : transactions) {\\n      const int loss = transaction[cost_index] - transaction[cashback_index];\\n      if (loss > 0) {\\n        loss_sum -= loss;\\n      }\\n      ret = max(ret, loss_sum + transaction[cost_index]);\\n      if (loss > 0) {\\n        loss_sum += loss;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * divide the transactions into two groups,\\n * 1. executing the transaction can earn money, that is `cashback` > `cost`\\n * 2. executing the transaction cannot earn money, that is `cashback` <= `cost`\\n *\\n * the logic is as following,\\n * 1. calculate the sum of loss (`loss_sum`),\\n *    that is `cost` - `cashback`, of every transactions in the group `2`\\n * 2. iterate every transaction,\\n * 2.1 for the transaction in the group `1`,\\n *     the answer should be the maximum value of `loss_sum` + `cost`\\n * 2.2 for the transaction in the group `2`,\\n *     the answer should be the maximum value of `loss_sum` - (`cost` - `cashback`) + `cost`\\n *     that is `loss_sum` + `cashback`\\n * 2.3 for the transaction in the group `1`, `cost` = min(`cost`, `cashback`)\\n * 2.4 for the transaction in the group `2`, `cashback` = min(`cost`, `cashback`)\\n * 2.5 it can be concluded that for every transaction,\\n *     the answer should be the maximum value of `loss_sum` + min(`cost`, `cashback`)\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `transactions`\\n */\\nclass Solution {\\n public:\\n  long long minimumMoney(const vector<vector<int>> &transactions) {\\n    constexpr int cost_index = 0;\\n    constexpr int cashback_index = 1;\\n    long long loss_sum = 0LL;\\n    int extra = 0;\\n    for (const vector<int> &transaction : transactions) {\\n      loss_sum += max(0, transaction[cost_index] - transaction[cashback_index]);\\n      extra = max(extra, min(transaction[cost_index], transaction[cashback_index]));\\n    }\\n    return loss_sum + extra;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588788,
                "title": "python-3-lines",
                "content": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        transactions1 = [min(t[0],t[1]) for t in transactions]\\n        transactions2 = [max(0,t[0]-t[1]) for t in transactions]\\n        return sum(transactions2)+max(transactions1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        transactions1 = [min(t[0],t[1]) for t in transactions]\\n        transactions2 = [max(0,t[0]-t[1]) for t in transactions]\\n        return sum(transactions2)+max(transactions1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588648,
                "title": "0ms-java-solution",
                "content": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        long ans = 0L;\\n        long minVal  = 0L;\\n        for(int[] ar:transactions){\\n            minVal  = Math.min(ar[0],ar[1]);\\n            ans = Math.max(ans,minVal);\\n        }\\n        for(int[] ar:transactions)\\n            ans += Math.max(ar[0]-ar[1],0);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        long ans = 0L;\\n        long minVal  = 0L;\\n        for(int[] ar:transactions){\\n            minVal  = Math.min(ar[0],ar[1]);\\n            ans = Math.max(ans,minVal);\\n        }\\n        for(int[] ar:transactions)\\n            ans += Math.max(ar[0]-ar[1],0);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588620,
                "title": "python3-greedy",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6a0ecd6849b23f4b7ac9cf2a51afa017995e6c23) for solutions of biweekly 87. \\n\\nLearned this wonderful implementatoin from @lee215 \\n```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        ans = val = 0 \\n        for cost, cashback in transactions: \\n            ans += max(0, cost - cashback)\\n            val = max(val, min(cost, cashback))\\n        return ans + val \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoney(self, transactions: List[List[int]]) -> int:\\n        ans = val = 0 \\n        for cost, cashback in transactions: \\n            ans += max(0, cost - cashback)\\n            val = max(val, min(cost, cashback))\\n        return ans + val \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588589,
                "title": "c-sum-differences",
                "content": "```\\n    public long MinimumMoney(int[][] transactions)\\n    {\\n        long result = 0; int last = 0;\\n        foreach (int[] t in transactions)\\n        {\\n            if (t[0] < t[1])\\n            {\\n                last = Math.Max(last, t[0]);\\n            }\\n            else\\n            {\\n                last = Math.Max(last, t[1]);\\n                result += Math.Max(t[0] - t[1], 0);\\n            }\\n        }\\n        return result + last;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long MinimumMoney(int[][] transactions)\\n    {\\n        long result = 0; int last = 0;\\n        foreach (int[] t in transactions)\\n        {\\n            if (t[0] < t[1])\\n            {\\n                last = Math.Max(last, t[0]);\\n            }\\n            else\\n            {\\n                last = Math.Max(last, t[1]);\\n                result += Math.Max(t[0] - t[1], 0);\\n            }\\n        }\\n        return result + last;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588535,
                "title": "c-4-liner",
                "content": "First, see the sum of loss we can face and store the sum of losses in `negs`\\nTo know the maximum loss, we exclude the cashback component. For the transactions where we have loss (which are included in `negs`), we just exclude the cashback component to get the max value, whereas for the transactions which are not accounted yet, we add the cost component to get the maximum value.\\n```\\nlong long minimumMoney(vector<vector<int>>& ar) {\\n    long long ans=0,negs=0;\\n    for(auto it:ar) negs+=max(0,it[0]-it[1]);\\n    for(auto it:ar) ans=max(ans,negs+((it[0]>=it[1])?it[1]:it[0]));\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long minimumMoney(vector<vector<int>>& ar) {\\n    long long ans=0,negs=0;\\n    for(auto it:ar) negs+=max(0,it[0]-it[1]);\\n    for(auto it:ar) ans=max(ans,negs+((it[0]>=it[1])?it[1]:it[0]));\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2588509,
                "title": "o-n-easy-and-short-solution-c",
                "content": "class Solution {\\npublic:\\n\\n\\n\\n\\n    long long minimumMoney(vector<vector<int>>& trans) {\\n        long long total=0;\\n        int n=trans.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(trans[i][0]-trans[i][1]>0){\\n                total+=trans[i][0]-trans[i][1];\\n            }\\n        }\\n        \\n        long long ans=-1;\\n        for(int i=0;i<n;i++){\\n            long long diff=max(0,trans[i][0]-trans[i][1]);\\n             ans=max(ans,trans[i][0]+total-diff);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n\\n\\n    long long minimumMoney(vector<vector<int>>& trans) {\\n        long long total=0;\\n        int n=trans.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(trans[i][0]-trans[i][1]>0){\\n                total+=trans[i][0]-trans[i][1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2588356,
                "title": "find-the-largest-negative-value-first-and-then-verify-the-two-operations-on-those-values",
                "content": "\\n```\\nclass Solution {\\n    public long minimumMoney(int[][] t) {\\n\\t\\t//1. for elements for which cost[i] > cashback[i], find the largest negative value that can be achieved by the operation from sum(cost[i] - cashback[i]).\\n        long minusT = 0;\\n        ArrayList<int[]> minus = new ArrayList<>();\\n        ArrayList<int[]> other = new ArrayList<>();\\n        for(int[] v : t){\\n            int cost = v[0];\\n            int cashback = v[1];\\n            minusT += Math.max(0L,cost-cashback);\\n            if(cost-cashback > 0){\\n                minus.add(v);\\n            }else{\\n                other.add(v);\\n            }\\n        }\\n\\t\\t// for each operation, get max(minus value up to the previous operation + cost of the operation).\\n        long ans = 0;\\n        for(int[] v : minus){\\n            int cost = v[0];\\n            int cashback = v[1];\\n\\t\\t\\t//Since minusT contains its own element, the value of that element is excluded.\\n            ans = Math.max(ans,minusT+cost-(cost-cashback));\\n        }\\n        for(int[] v : other){\\n            int cost = v[0];\\n            ans = Math.max(ans,minusT+cost);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumMoney(int[][] t) {\\n\\t\\t//1. for elements for which cost[i] > cashback[i], find the largest negative value that can be achieved by the operation from sum(cost[i] - cashback[i]).\\n        long minusT = 0;\\n        ArrayList<int[]> minus = new ArrayList<>();\\n        ArrayList<int[]> other = new ArrayList<>();\\n        for(int[] v : t){\\n            int cost = v[0];\\n            int cashback = v[1];\\n            minusT += Math.max(0L,cost-cashback);\\n            if(cost-cashback > 0){\\n                minus.add(v);\\n            }else{\\n                other.add(v);\\n            }\\n        }\\n\\t\\t// for each operation, get max(minus value up to the previous operation + cost of the operation).\\n        long ans = 0;\\n        for(int[] v : minus){\\n            int cost = v[0];\\n            int cashback = v[1];\\n\\t\\t\\t//Since minusT contains its own element, the value of that element is excluded.\\n            ans = Math.max(ans,minusT+cost-(cost-cashback));\\n        }\\n        for(int[] v : other){\\n            int cost = v[0];\\n            ans = Math.max(ans,minusT+cost);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588355,
                "title": "python3-for-each-possible-transaction-consider-the-worst-preceding-scenario",
                "content": "For a given transaction, the worst scenario is a subset of transactions prior to the given transaction that maximizes the sum of budget changes (at the exclusion of the current transaction).\\n\\n```\\n\\tdef minimumMoney(self, transactions: List[List[int]]) -> int:\\n        changes = [max(0, cost-gain) for cost, gain in transactions]\\n        larger = sum(changes)\\n        m = 0\\n        for i in range(len(transactions)):\\n            cost, gain = transactions[i]\\n            worst = larger - changes[i]\\n            m = max(m, cost+worst)\\n        return m\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\tdef minimumMoney(self, transactions: List[List[int]]) -> int:\\n        changes = [max(0, cost-gain) for cost, gain in transactions]\\n        larger = sum(changes)\\n        m = 0\\n        for i in range(len(transactions)):\\n            cost, gain = transactions[i]\\n            worst = larger - changes[i]\\n            m = max(m, cost+worst)\\n        return m\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2588288,
                "title": "java-solution",
                "content": "class Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        \\n        /*lets assume example 1\\n        after 2 transaction money will be needed is 4 for the last transaction\\n            and after 3rd transaction we will have 2 as money\\n            so to perform all transaction we will need that total money as lost money as well as cashback */\\n        long lost =0;\\n        int cashback=0;\\n        for(int[] a:transactions){\\n            lost += Math.max(0,a[0]-a[1]);\\n            cashback = Math.max(cashback,Math.min(a[0],a[1]));\\n        }\\n        return cashback + lost;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long minimumMoney(int[][] transactions) {\\n        \\n        /*lets assume example 1\\n        after 2 transaction money will be needed is 4 for the last transaction\\n            and after 3rd transaction we will have 2 as money\\n            so to perform all transaction we will need that total money as lost money as well as cashback */\\n        long lost =0;\\n        int cashback=0;\\n        for(int[] a:transactions){\\n            lost += Math.max(0,a[0]-a[1]);\\n            cashback = Math.max(cashback,Math.min(a[0],a[1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2588229,
                "title": "c-time-cpmplexity-o-n-space-complexity-o-1",
                "content": "* **1-Just first calculate the minimum money or loss that you can achieve at every ith transaction\\n2-After that we just have to calculate the money after calculating the minimum loss that is =p+=max(0,it[0]-it[1]);**\\nclass Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long t,p=0;\\n        for(auto it:transactions){\\n           t=min(it[0],it[1]);\\n            p=max(p,t);\\n        }\\n        for(auto it:transactions)\\n            p+=max(0,it[0]-it[1]);\\n        return p;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long minimumMoney(vector<vector<int>>& transactions) {\\n        long long t,p=0;\\n        for(auto it:transactions){\\n           t=min(it[0],it[1]);\\n            p=max(p,t);\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": []
    }
]